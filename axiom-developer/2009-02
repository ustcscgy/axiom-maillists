From MAILER-DAEMON Sun Feb 01 02:09:25 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LTWSL-0002R0-4L
	for mharc-axiom-developer@gnu.org; Sun, 01 Feb 2009 02:09:25 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LTWSK-0002P5-2s
	for axiom-developer@nongnu.org; Sun, 01 Feb 2009 02:09:24 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LTWSI-0002LQ-Bd
	for axiom-developer@nongnu.org; Sun, 01 Feb 2009 02:09:23 -0500
Received: from [199.232.76.173] (port=57539 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LTWSI-0002L9-7M
	for axiom-developer@nongnu.org; Sun, 01 Feb 2009 02:09:22 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:59405
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LTWSH-00082x-SE
	for axiom-developer@nongnu.org; Sun, 01 Feb 2009 02:09:22 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1179Kug012948;
	Sun, 1 Feb 2009 01:09:20 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1179Kxc012945;
	Sun, 1 Feb 2009 01:09:20 -0600
Date: Sun, 1 Feb 2009 01:09:20 -0600
Message-Id: <200902010709.n1179Kxc012945@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090131.01.tpd.patch (help documentation fixes
	and packages)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 01 Feb 2009 07:09:24 -0000

The GroebnerPackage now has a help file, regression test, and
operation examples

More packages were moved to Book Volume 10.4: Packages

The patch is too large to post. See
http://axiom-developer.org/axiom-website/patches.html#latest

Tim



From MAILER-DAEMON Sun Feb 01 18:39:38 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LTluc-0004Nh-Qi
	for mharc-axiom-developer@gnu.org; Sun, 01 Feb 2009 18:39:38 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LTlua-0004NA-83
	for axiom-developer@nongnu.org; Sun, 01 Feb 2009 18:39:36 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LTluX-0004L8-CW
	for axiom-developer@nongnu.org; Sun, 01 Feb 2009 18:39:34 -0500
Received: from [199.232.76.173] (port=33530 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LTluX-0004Ko-4b
	for axiom-developer@nongnu.org; Sun, 01 Feb 2009 18:39:33 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:45597
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LTluW-0001Ah-OY
	for axiom-developer@nongnu.org; Sun, 01 Feb 2009 18:39:32 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n11NdUug023306;
	Sun, 1 Feb 2009 17:39:30 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n11NdS0i023299;
	Sun, 1 Feb 2009 17:39:28 -0600
Date: Sun, 1 Feb 2009 17:39:28 -0600
Message-Id: <200902012339.n11NdS0i023299@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090201.01.tpd.patch (bookvol10.4 add packages)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 01 Feb 2009 23:39:36 -0000

More packages were added.

The patch is too large to post. See
http://axiom-developer.org/axiom-website/patches.html#latest

Tim



From MAILER-DAEMON Fri Feb 06 09:09:00 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LVRO7-0006Vk-Pu
	for mharc-axiom-developer@gnu.org; Fri, 06 Feb 2009 09:08:59 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LVQRp-0006RD-07
	for axiom-developer@nongnu.org; Fri, 06 Feb 2009 08:08:45 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LVQRm-0006Qz-Eu
	for axiom-developer@nongnu.org; Fri, 06 Feb 2009 08:08:43 -0500
Received: from [199.232.76.173] (port=52899 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LVQRm-0006Qw-8Z
	for axiom-developer@nongnu.org; Fri, 06 Feb 2009 08:08:42 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:48260
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LVQRl-00015S-VY
	for axiom-developer@nongnu.org; Fri, 06 Feb 2009 08:08:42 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n16D8cug012629;
	Fri, 6 Feb 2009 07:08:39 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n16D8ZjT012619;
	Fri, 6 Feb 2009 07:08:35 -0600
Date: Fri, 6 Feb 2009 07:08:35 -0600
Message-Id: <200902061308.n16D8ZjT012619@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090203.01.tpd.patch (bookvol10.4 add packages)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 06 Feb 2009 13:08:45 -0000

More packages were moved to book volume 10.4

See:
http://axiom-developer.org/axiom-website/patches.html#latest

Tim



From MAILER-DAEMON Fri Feb 06 20:22:10 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LVbtZ-0007By-TG
	for mharc-axiom-developer@gnu.org; Fri, 06 Feb 2009 20:22:09 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LVbtY-0007Ap-FP
	for axiom-developer@nongnu.org; Fri, 06 Feb 2009 20:22:08 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LVbtX-0007Ad-4s
	for axiom-developer@nongnu.org; Fri, 06 Feb 2009 20:22:07 -0500
Received: from [199.232.76.173] (port=41890 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LVbtW-0007Aa-W1
	for axiom-developer@nongnu.org; Fri, 06 Feb 2009 20:22:07 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:54122
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LVbtW-0006RD-Hr
	for axiom-developer@nongnu.org; Fri, 06 Feb 2009 20:22:06 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n171M4ug012973;
	Fri, 6 Feb 2009 19:22:04 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n171M24v012966;
	Fri, 6 Feb 2009 19:22:02 -0600
Date: Fri, 6 Feb 2009 19:22:02 -0600
Message-Id: <200902070122.n171M24v012966@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090207.02.tpd.patch (bookvol10.4 add packages)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 07 Feb 2009 01:22:08 -0000

More packages were added to book volumne 10.4

See:
http://axiom-developer.org/axiom-website/patches.html#latest

Tim



From MAILER-DAEMON Sat Feb 07 15:13:21 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LVtYH-0005dC-71
	for mharc-axiom-developer@gnu.org; Sat, 07 Feb 2009 15:13:21 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LVtYF-0005cI-BI
	for axiom-developer@nongnu.org; Sat, 07 Feb 2009 15:13:19 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LVtYC-0005aL-BD
	for axiom-developer@nongnu.org; Sat, 07 Feb 2009 15:13:18 -0500
Received: from [199.232.76.173] (port=41058 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LVtYC-0005aG-4b
	for axiom-developer@nongnu.org; Sat, 07 Feb 2009 15:13:16 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:57987
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LVtYB-0003JA-PK
	for axiom-developer@nongnu.org; Sat, 07 Feb 2009 15:13:15 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n17KDBug023560;
	Sat, 7 Feb 2009 14:13:11 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n17KD7Xe023550;
	Sat, 7 Feb 2009 14:13:07 -0600
Date: Sat, 7 Feb 2009 14:13:07 -0600
Message-Id: <200902072013.n17KD7Xe023550@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080208.01.tpd.patch (bookvol10.4 add packages)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 07 Feb 2009 20:13:19 -0000

Add more packages to book volume 10.4

See:
http://axiom-developer.org/axiom-website/patches.html#latest

Tim



From MAILER-DAEMON Mon Feb 09 06:34:26 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LWUPC-0001yC-Ji
	for mharc-axiom-developer@gnu.org; Mon, 09 Feb 2009 06:34:26 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LWUP9-0001xM-W2
	for axiom-developer@nongnu.org; Mon, 09 Feb 2009 06:34:24 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LWUP9-0001x3-2T
	for axiom-developer@nongnu.org; Mon, 09 Feb 2009 06:34:23 -0500
Received: from [199.232.76.173] (port=52606 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LWUP8-0001ww-IS
	for axiom-developer@nongnu.org; Mon, 09 Feb 2009 06:34:22 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:36989
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LWUP7-0002GQ-Gc
	for axiom-developer@nongnu.org; Mon, 09 Feb 2009 06:34:22 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n19BYDug023651;
	Mon, 9 Feb 2009 05:34:13 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n19BYDAQ023643;
	Mon, 9 Feb 2009 05:34:13 -0600
Date: Mon, 9 Feb 2009 05:34:13 -0600
Message-Id: <200902091134.n19BYDAQ023643@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090209.01.tpd.patch (bookvol10.4 add packages)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 09 Feb 2009 11:34:24 -0000

More packages were added to book volume 10.4

See:
http://axiom-developer.org/axiom-website/patches.html#latest

Tim



From MAILER-DAEMON Tue Feb 10 06:42:21 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LWr0P-0005nb-GA
	for mharc-axiom-developer@gnu.org; Tue, 10 Feb 2009 06:42:21 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LWr0N-0005nW-Vt
	for axiom-developer@nongnu.org; Tue, 10 Feb 2009 06:42:20 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LWr0M-0005nK-8K
	for axiom-developer@nongnu.org; Tue, 10 Feb 2009 06:42:19 -0500
Received: from [199.232.76.173] (port=33367 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LWr0M-0005nH-1W
	for axiom-developer@nongnu.org; Tue, 10 Feb 2009 06:42:18 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:54574
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LWr0L-0004Aw-2N
	for axiom-developer@nongnu.org; Tue, 10 Feb 2009 06:42:17 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1ABgDug024232;
	Tue, 10 Feb 2009 05:42:13 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1ABgAS7024213;
	Tue, 10 Feb 2009 05:42:10 -0600
Date: Tue, 10 Feb 2009 05:42:10 -0600
Message-Id: <200902101142.n1ABgAS7024213@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090210.01.tpd.patch (bookvol10.4 add exports)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 10 Feb 2009 11:42:20 -0000

Add export information to each package.

========================================================================
diff --git a/books/bookvol10.4.pamphlet b/books/bookvol10.4.pamphlet
index 3cc4291..48a65ae 100644
--- a/books/bookvol10.4.pamphlet
+++ b/books/bookvol10.4.pamphlet
@@ -31,6 +31,15 @@
 \newcommand{\pagefrom}[2]{% e.g. \pagefrom{name}{abb}
 \ \\${\bf\Leftarrow{}}${``#1''} (#2) \ref{#1} on page~\pageref{#1}}
 %%
+
+%% cross will put the category and function in the index
+%% cross will leave the funcname so it can be put inline.
+%%
+\newcommand{\cross}[2]{% e.g. \pagefrom{cat}{funcname}
+\index{#1!#2}%
+\index{#2!#1}%
+#2}
+
 % special meanings for math characters
 \providecommand{\N}{\mbox{\bbold N}}
 \providecommand{\Natural}{\mbox{\bbold N}}
@@ -265,6 +274,15 @@ in the bootstrap set. Thus,
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{AF}{belong?} &
+\cross{AF}{droot} &
+\cross{AF}{definingPolynomial} &
+\cross{AF}{inrootof} &
+\cross{AF}{iroot} \\
+\cross{AF}{minPoly} &
+\cross{AF}{operator} &
+\cross{AF}{rootOf} &
+\cross{AF}{?**?} &
 \end{tabular}
 
 <<package AF AlgebraicFunction>>=
@@ -527,8 +545,7 @@ AlgebraicFunction(R, F): Exports == Implementation where
 \pagepic{ps/v104algebraichermiteintegration.ps}{INTHERAL}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{INTHERAL}{HermiteIntegrate}
 
 <<package INTHERAL AlgebraicHermiteIntegration>>=
 )abbrev package INTHERAL AlgebraicHermiteIntegration
@@ -616,7 +633,10 @@ AlgebraicHermiteIntegration(F,UP,UPUP,R):Exports == Implementation where
 \pagepic{ps/v104algebraicintegrate.ps}{INTALG}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{INTALG}{algintegrate} &
+\cross{INTALG}{palginfieldint} &
+\cross{INTALG}{palgintegrate} 
 \end{tabular}
 
 <<package INTALG AlgebraicIntegrate>>=
@@ -932,8 +952,7 @@ AlgebraicIntegrate(R0, F, UP, UPUP, R): Exports == Implementation where
 \pagepic{ps/v104algebraicintegration.ps}{INTAF}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{INTAF}{algint}
 
 <<package INTAF AlgebraicIntegration>>=
 )abbrev package INTAF AlgebraicIntegration
@@ -1024,7 +1043,14 @@ AlgebraicIntegration(R, F): Exports == Implementation where
 \pagepic{ps/v104algebraicmanipulations.ps}{ALGMANIP}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llll}
+\cross{ALGMANIP}{ratDenom} &
+\cross{ALGMANIP}{ratPoly} &
+\cross{ALGMANIP}{rootKerSimp} &
+\cross{ALGMANIP}{rootPower} \\
+\cross{ALGMANIP}{rootProduct} &
+\cross{ALGMANIP}{rootSimp} &
+\cross{ALGMANIP}{rootSplit} &
 \end{tabular}
 
 <<package ALGMANIP AlgebraicManipulations>>=
@@ -1244,8 +1270,7 @@ AlgebraicManipulations(R, F): Exports == Implementation where
 \pagepic{ps/v104algebraicmultfact.ps}{ALGMFACT}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{ALGMFACT}{factor}
 
 <<package ALGMFACT AlgebraicMultFact>>=
 )abbrev package ALGMFACT AlgebraicMultFact
@@ -1314,6 +1339,24 @@ AlgebraicMultFact(OV,E,P) : C == T
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{ALGPKG}{basis} &
+\cross{ALGPKG}{basisOfCenter} &
+\cross{ALGPKG}{basisOfCentroid} &
+\cross{ALGPKG}{basisOfCommutingElements} &
+\cross{ALGPKG}{basisOfLeftAnnihilator} \\
+\cross{ALGPKG}{basisOfLeftNucleus} &
+\cross{ALGPKG}{basisOfLeftNucloid} &
+\cross{ALGPKG}{basisOfMiddleNucleus} &
+\cross{ALGPKG}{basisOfNucleus} &
+\cross{ALGPKG}{basisOfRightAnnihilator} \\
+\cross{ALGPKG}{basisOfRightNucleus} &
+\cross{ALGPKG}{basisOfRightNucloid} &
+\cross{ALGPKG}{biRank} &
+\cross{ALGPKG}{doubleRank} &
+\cross{ALGPKG}{leftRank} \\
+\cross{ALGPKG}{radicalOfLeftTraceForm} &
+\cross{ALGPKG}{rightRank} &
+\cross{ALGPKG}{weakBiRank} &&
 \end{tabular}
 
 <<package ALGPKG AlgebraPackage>>=
@@ -1792,7 +1835,10 @@ AlgebraPackage(R:IntegralDomain, A: FramedNonAssociativeAlgebra(R)): _
 \pagepic{ps/v104algfactor.ps}{ALGFACT}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{ALGFACT}{doublyTransitive?} &
+\cross{ALGFACT}{factor} &
+\cross{ALGFACT}{split} 
 \end{tabular}
 
 <<package ALGFACT AlgFactor>>=
@@ -1910,7 +1956,9 @@ AlgFactor(UP): Exports == Implementation where
 \pagepic{ps/v104annanumericalintegrationpackage.ps}{INTPACK}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{INTPACK}{integrate} &
+\cross{INTPACK}{measure} 
 \end{tabular}
 
 <<package INTPACK AnnaNumericalIntegrationPackage>>=
@@ -2430,7 +2478,10 @@ AnnaNumericalIntegrationPackage(): with
 \pagepic{ps/v104annanumericaloptimizationpackage.ps}{OPTPACK}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{OPTPACK}{goodnessOfFit} &
+\cross{OPTPACK}{measure} &
+\cross{OPTPACK}{optimize} 
 \end{tabular}
 
 <<package OPTPACK AnnaNumericalOptimizationPackage>>=
@@ -2838,7 +2889,9 @@ AnnaNumericalOptimizationPackage(): with
 \pagepic{ps/v104annaordinarydifferentialequationpackage.ps}{ODEPACK}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{ODEPACK}{measure} &
+\cross{ODEPACK}{solve}
 \end{tabular}
 
 <<package ODEPACK AnnaOrdinaryDifferentialEquationPackage>>=
@@ -3255,7 +3308,9 @@ AnnaOrdinaryDifferentialEquationPackage(): with
 \pagepic{ps/v104annapartialdifferentialequationpackage.ps}{PDEPACK}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{PDEPACK}{measure} &
+\cross{PDEPACK}{solve}
 \end{tabular}
 
 <<package PDEPACK AnnaPartialDifferentialEquationPackage>>=
@@ -3522,7 +3577,11 @@ AnnaPartialDifferentialEquationPackage(): with
 \pagepic{ps/v104anyfunctions1.ps}{ANY1}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llll}
+\cross{ANY1}{coerce} &
+\cross{ANY1}{retract} &
+\cross{ANY1}{retractable?} &
+\cross{ANY1}{retractIfCan} 
 \end{tabular}
 
 <<package ANY1 AnyFunctions1>>=
@@ -3586,7 +3645,9 @@ AnyFunctions1(S:Type): with
 \pagepic{ps/v104applyrules.ps}{APPRULE}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{APPRULE}{applyRules} &
+\cross{APPRULE}{localUnquote}
 \end{tabular}
 
 <<package APPRULE ApplyRules>>=
@@ -3720,8 +3781,7 @@ ApplyRules(Base, R, F): Exports == Implementation where
 \pagepic{ps/v104applyunivariateskewpolynomial.ps}{APPLYORE}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{APPLYORE}{apply}
 
 <<package APPLYORE ApplyUnivariateSkewPolynomial>>=
 )abbrev package APPLYORE ApplyUnivariateSkewPolynomial
@@ -3759,7 +3819,10 @@ ApplyUnivariateSkewPolynomial(R:Ring, M: LeftModule R,
 \pagepic{ps/v104associatedequations.ps}{ASSOCEQ}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{ASSOCEQ}{associatedEquations} &
+\cross{ASSOCEQ}{associatedSystem} &
+\cross{ASSOCEQ}{uncouplingMatrices} 
 \end{tabular}
 
 <<package ASSOCEQ AssociatedEquations>>=
@@ -3882,8 +3945,7 @@ AssociatedEquations(R, L):Exports == Implementation where
 \pagepic{ps/v104attachpredicates.ps}{PMPRED}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{PMPRED}{suchThat}
 
 <<package PMPRED AttachPredicates>>=
 )abbrev package PMPRED AttachPredicates
@@ -3924,7 +3986,10 @@ AttachPredicates(D:Type): Exports == Implementation where
 \pagepic{ps/v104axiomserver.ps}{AXSERV}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{AXSERV}{multiServ} &
+\cross{ASSOCEQ}{axServer} &
+\cross{ASSOCEQ}{getDatabase} 
 \end{tabular}
 
 <<package AXSERV AxiomServer>>=
@@ -4626,8 +4691,7 @@ input.
 \pagepic{ps/v104balancedfactorisation.ps}{BALFACT}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{BALFACT}{balancedFactorisation}
 
 <<package BALFACT BalancedFactorisation>>=
 )abbrev package BALFACT BalancedFactorisation
@@ -4685,7 +4749,11 @@ BalancedFactorisation(R, UP): Exports == Implementation where
 \pagepic{ps/v104basicoperatorfunctions1.ps}{BOP1}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llll}
+\cross{BOP1}{constantOpIfCan} &
+\cross{BOP1}{constantOperator} &
+\cross{BOP1}{derivative} &
+\cross{BOP1}{evaluate} 
 \end{tabular}
 
 <<package BOP1 BasicOperatorFunctions1>>=
@@ -4819,7 +4887,11 @@ BasicOperatorFunctions1(A:SetCategory): Exports == Implementation where
 \pagepic{ps/v104bezoutmatrix.ps}{BEZOUT}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llll}
+\cross{BEZOUT}{bezoutDiscriminant} &
+\cross{BEZOUT}{bezoutMatrix} &
+\cross{BEZOUT}{bezoutResultant} &
+\cross{BEZOUT}{sylvesterMatrix} 
 \end{tabular}
 
 <<package BEZOUT BezoutMatrix>>=
@@ -4985,8 +5057,7 @@ BezoutMatrix(R,UP,M,Row,Col): Exports == Implementation where
 \pagepic{ps/v104boundintegerroots.ps}{BOUNDZRO}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{BOUNDZRO}{integerBound}
 
 <<package BOUNDZRO BoundIntegerRoots>>=
 )abbrev package BOUNDZRO BoundIntegerRoots
@@ -5083,7 +5154,10 @@ BoundIntegerRoots(F, UP): Exports == Implementation where
 \pagepic{ps/v104brillharttests.ps}{BRILL}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{BRILL}{noLinearFactor?} &
+\cross{BEZOUT}{brillhartIrreducible?} &
+\cross{BEZOUT}{brillhartTrials} 
 \end{tabular}
 
 <<package BRILL BrillhartTests>>=
@@ -5206,7 +5280,9 @@ BrillhartTests(UP): Exports == Implementation where
 \pagepic{ps/v104cartesiantensorfunctions2.ps}{CARTEN2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{CARTEN2}{map} &
+\cross{CARTEN2}{reshape}
 \end{tabular}
 
 <<package CARTEN2 CartesianTensorFunctions2>>=
@@ -5256,7 +5332,13 @@ CartesianTensorFunctions2(minix, dim, S, T): CTPcat == CTPdef where
 \pagepic{ps/v104changeofvariable.ps}{CHVAR}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llll}
+\cross{CHVAR}{chvar} &
+\cross{CHVAR}{eval} &
+\cross{CHVAR}{goodPoint} &
+\cross{CHVAR}{mkIntegral} \\
+\cross{CHVAR}{radPoly} &
+\cross{CHVAR}{rootPoly} &&
 \end{tabular}
 
 <<package CHVAR ChangeOfVariable>>=
@@ -5401,8 +5483,7 @@ ChangeOfVariable(F, UP, UPUP): Exports == Implementation where
 \pagepic{ps/v104characteristicpolynomialinmonogenicalalgebra.ps}{CPIMA}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{CPIMA}{characteristicPolynomial}
 
 <<package CPIMA CharacteristicPolynomialInMonogenicalAlgebra>>=
 )abbrev package CPIMA CharacteristicPolynomialInMonogenicalAlgebra
@@ -5452,8 +5533,7 @@ CharacteristicPolynomialInMonogenicalAlgebra(R : CommutativeRing,
 \pagepic{ps/v104characteristicpolynomialpackage.ps}{CHARPOL}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{CHARPOL}{characteristicPolynomial}
 
 <<package CHARPOL CharacteristicPolynomialPackage>>=
 )abbrev package CHARPOL CharacteristicPolynomialPackage
@@ -5504,7 +5584,10 @@ CharacteristicPolynomialPackage(R:CommutativeRing):C == T where
 \pagepic{ps/v104chineseremaindertoolsforintegralbases.ps}{IBACHIN}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{IBACHIN}{chineseRemainder} &
+\cross{IBACHIN}{factorList} &
+\cross{IBACHIN}{listConjugateBases} 
 \end{tabular}
 
 <<package IBACHIN ChineseRemainderToolsForIntegralBases>>=
@@ -5695,7 +5778,9 @@ ChineseRemainderToolsForIntegralBases(K,R,UP): Exports == Implementation where
 \pagepic{ps/v104coercevectormatrixpackage.ps}{CVMP}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{CVMP}{coerce} &
+\cross{CVMP}{coerceP}
 \end{tabular}
 
 <<package CVMP CoerceVectorMatrixPackage>>=
@@ -5765,6 +5850,24 @@ CoerceVectorMatrixPackage(R : CommutativeRing): public == private where
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{COMBF}{belong?} &
+\cross{COMBF}{binomial} &
+\cross{COMBF}{factorial} &
+\cross{COMBF}{factorials} &
+\cross{COMBF}{iibinom} \\
+\cross{COMBF}{iidprod} &
+\cross{COMBF}{iidsum} &
+\cross{COMBF}{iifact} &
+\cross{COMBF}{iiperm} &
+\cross{COMBF}{iipow} \\
+\cross{COMBF}{ipow} &
+\cross{COMBF}{permutation} &
+\cross{COMBF}{product} &
+\cross{COMBF}{summation} &
+\cross{COMBF}{operator} \\
+\cross{COMBF}{product} &
+\cross{COMBF}{summation} &
+\cross{COMBF}{?**?} &&
 \end{tabular}
 
 <<package COMBF CombinatorialFunction>>=
@@ -6405,7 +6508,10 @@ equality.
 \pagepic{ps/v104commondenominator.ps}{CDEN}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{CDEN}{clearDenominator} &
+\cross{COMBF}{commonDenominator} &
+\cross{COMBF}{splitDenominator} 
 \end{tabular}
 
 <<package CDEN CommonDenominator>>=
@@ -6465,8 +6571,7 @@ CommonDenominator(R, Q, A): Exports == Implementation where
 \pagepic{ps/v104commonoperators.ps}{COMMONOP}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{COMMONOP}{operator}
 
 <<package COMMONOP CommonOperators>>=
 )abbrev package COMMONOP CommonOperators
@@ -6663,8 +6768,7 @@ CommonOperators(): Exports == Implementation where
 \pagepic{ps/v104commuteunivariatepolynomialcategory.ps}{COMMUPC}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{COMMUPC}{swap}
 
 <<package COMMUPC CommuteUnivariatePolynomialCategory>>=
 )abbrev package COMMUPC CommuteUnivariatePolynomialCategory
@@ -6724,8 +6828,7 @@ CommuteUnivariatePolynomialCategory(R, UP, UPUP): Exports == Impl where
 \pagepic{ps/v104complexfactorization.ps}{COMPFACT}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{COMPFACT}{factor}
 
 <<package COMPFACT ComplexFactorization>>=
 )abbrev package COMPFACT ComplexFactorization
@@ -6827,8 +6930,7 @@ ComplexFactorization(RR,PR) : C == T where
 \pagepic{ps/v104complexfunctions2.ps}{COMPLEX2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{COMPLEX2}{map}
 
 <<package COMPLEX2 ComplexFunctions2>>=
 )abbrev package COMPLEX2 ComplexFunctions2
@@ -6863,8 +6965,7 @@ ComplexFunctions2(R:CommutativeRing, S:CommutativeRing): with
 \pagepic{ps/v104complexintegersolvelinearpolynomialequation.ps}{CINTSLPE}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{CINTSLPE}{solveLinearPolynomialEquation}
 
 <<package CINTSLPE ComplexIntegerSolveLinearPolynomialEquation>>=
 )abbrev package CINTSLPE ComplexIntegerSolveLinearPolynomialEquation
@@ -6928,8 +7029,7 @@ ComplexIntegerSolveLinearPolynomialEquation(R,CR): C == T
 \pagepic{ps/v104complexpattern.ps}{COMPLPAT}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{COMPLPAT}{convert}
 
 <<package COMPLPAT ComplexPattern>>=
 )abbrev package COMPLPAT ComplexPattern
@@ -6973,8 +7073,7 @@ ComplexPattern(R, S, CS) : C == T where
 \pagepic{ps/v104complexpatternmatch.ps}{CPMATCH}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{CPMATCH}{patternMatch}
 
 <<package CPMATCH ComplexPatternMatch>>=
 )abbrev package CPMATCH ComplexPatternMatch
@@ -7040,6 +7139,17 @@ ComplexPatternMatch(R, S, CS) : C == T where
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{CRFP}{complexZeros} &
+\cross{CRFP}{divisorCascade} &
+\cross{CRFP}{factor} &
+\cross{CRFP}{graeffe} &
+\cross{CRFP}{norm} \\
+\cross{CRFP}{pleskenSplit} &
+\cross{CRFP}{reciprocalPolynomial} &
+\cross{CRFP}{rootRadius} &
+\cross{CRFP}{schwerpunkt} &
+\cross{CRFP}{setErrorBound} \\
+\cross{CRFP}{startPolynomial} &&&&
 \end{tabular}
 
 <<package CRFP ComplexRootFindingPackage>>=
@@ -7642,8 +7752,7 @@ ComplexRootFindingPackage(R, UP): public == private where
 \pagepic{ps/v104complexrootpackage.ps}{CMPLXRT}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{CMPLXRT}{complexZeros}
 
 <<package CMPLXRT ComplexRootPackage>>=
 )abbrev package CMPLXRT ComplexRootPackage
@@ -7718,7 +7827,13 @@ ComplexRootPackage(UP,Par) : T == C where
 \pagepic{ps/v104complextrigonometricmanipulations.ps}{CTRIGMNP}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llll}
+\cross{CTRIGMNP}{complexElementary} &
+\cross{CTRIGMNP}{complexForm} &
+\cross{CTRIGMNP}{complexNormalize} &
+\cross{CTRIGMNP}{imag} \\
+\cross{CTRIGMNP}{real} &
+\cross{CTRIGMNP}{trigs} &&
 \end{tabular}
 
 <<package CTRIGMNP ComplexTrigonometricManipulations>>=
@@ -7841,8 +7956,7 @@ ComplexTrigonometricManipulations(R, F): Exports == Implementation where
 \pagepic{ps/v104constantlode.ps}{ODECONST}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{ODECONST}{constDsolve}
 
 <<package ODECONST ConstantLODE>>=
 )abbrev package ODECONST ConstantLODE
@@ -7938,6 +8052,21 @@ ConstantLODE(R, F, L): Exports == Implementation where
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{COORDSYS}{bipolar} &
+\cross{COORDSYS}{bipolarCylindrical} &
+\cross{COORDSYS}{cartesian} &
+\cross{COORDSYS}{conical} &
+\cross{COORDSYS}{cylindrical} \\
+\cross{COORDSYS}{elliptic} &
+\cross{COORDSYS}{ellipticCylindrical} &
+\cross{COORDSYS}{oblateSpheroidal} &
+\cross{COORDSYS}{parabolic} &
+\cross{COORDSYS}{parabolicCylindrical} \\
+\cross{COORDSYS}{paraboloidal} &
+\cross{COORDSYS}{polar} &
+\cross{COORDSYS}{prolateSpheroidal} &
+\cross{COORDSYS}{spherical} &
+\cross{COORDSYS}{toroidal} 
 \end{tabular}
 
 <<package COORDSYS CoordinateSystems>>=
@@ -8137,7 +8266,10 @@ CoordinateSystems(R): Exports == Implementation where
 \pagepic{ps/v104crapackage.ps}{CRAPACK}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{CRAPACK}{modTree} &
+\cross{CRAPACK}{chineseRemainder} &
+\cross{CRAPACK}{multiEuclideanTree} 
 \end{tabular}
 
 <<package CRAPACK CRApackage>>=
@@ -9136,6 +9268,19 @@ o )show CycleIndicators
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{CYCLES}{alternating} &
+\cross{CYCLES}{cap} &
+\cross{CYCLES}{complete} &
+\cross{CYCLES}{cup} &
+\cross{CYCLES}{cyclic} \\
+\cross{CYCLES}{dihedral} &
+\cross{CYCLES}{elementary} &
+\cross{CYCLES}{eval} &
+\cross{CYCLES}{graphs} &
+\cross{CYCLES}{powerSum} \\
+\cross{CYCLES}{SFunction} &
+\cross{CYCLES}{skewSFunction} &
+\cross{CYCLES}{wreath} &&
 \end{tabular}
 
 <<package CYCLES CycleIndicators>>=
@@ -9372,7 +9517,10 @@ CycleIndicators: Exports == Implementation where
 \pagepic{ps/v104cyclicstreamtools.ps}{CSTTOOLS}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{CSTTOOLS}{computeCycleEntry} &
+\cross{CSTTOOLS}{computeCycleLength} &
+\cross{CSTTOOLS}{cycleElt}
 \end{tabular}
 
 <<package CSTTOOLS CyclicStreamTools>>=
@@ -9454,7 +9602,10 @@ CyclicStreamTools(S,ST): Exports == Implementation where
 \pagepic{ps/v104cyclotomicpolynomialpackage.ps}{CYCLOTOM}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{CYCLOTOM}{cyclotomic} &
+\cross{CYCLOTOM}{cyclotomicDecomposition} &
+\cross{CYCLOTOM}{cyclotomicFactorization}
 \end{tabular}
 
 <<package CYCLOTOM CyclotomicPolynomialPackage>>=
@@ -9525,7 +9676,10 @@ CyclotomicPolynomialPackage: public == private where
 \pagepic{ps/v104definiteintegrationtools.ps}{DFINTTLS}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{DFINTTLS}{ignore?} &
+\cross{DFINTTLS}{checkForZero} &
+\cross{DFINTTLS}{computeInt} 
 \end{tabular}
 
 <<package DFINTTLS DefiniteIntegrationTools>>=
@@ -9789,7 +9943,9 @@ DefiniteIntegrationTools(R, F): Exports == Implementation where
 \pagepic{ps/v104degreereductionpackage.ps}{DEGRED}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{DEGRED}{expand} &
+\cross{DEGRED}{reduce}
 \end{tabular}
 
 <<package DEGRED DegreeReductionPackage>>=
@@ -9850,8 +10006,7 @@ DegreeReductionPackage(R1, R2): Cat == Capsule where
 \pagepic{ps/v104diophantinesolutionpackage.ps}{DIOSP}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{DIOSP}{dioSolve}
 
 <<package DIOSP DiophantineSolutionPackage>>=
 )abbrev package DIOSP DiophantineSolutionPackage
@@ -10042,7 +10197,10 @@ DiophantineSolutionPackage(): Cat == Capsule where
 \pagepic{ps/v104directproductfunctions2.ps}{DIRPROD2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{DIRPROD2}{map} &
+\cross{DIRPROD2}{reduce} &
+\cross{DIRPROD2}{scan}
 \end{tabular}
 
 <<package DIRPROD2 DirectProductFunctions2>>=
@@ -10105,8 +10263,7 @@ DirectProductFunctions2(dim, A, B): Exports == Implementation where
 \pagepic{ps/v104discretelogarithmpackage.ps}{DLP}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{DLP}{shanksDiscLogAlgorithm}
 
 <<package DLP DiscreteLogarithmPackage>>=
 )abbrev package DLP DiscreteLogarithmPackage
@@ -10201,7 +10358,13 @@ DiscreteLogarithmPackage(M): public == private where
 \pagepic{ps/v104displaypackage.ps}{DISPLAY}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llllll}
+\cross{DISPLAY}{bright} &
+\cross{DISPLAY}{center} &
+\cross{DISPLAY}{copies} &
+\cross{DISPLAY}{newLine} &
+\cross{DISPLAY}{say} &
+\cross{DISPLAY}{sayLength} 
 \end{tabular}
 
 <<package DISPLAY DisplayPackage>>=
@@ -10334,6 +10497,15 @@ DisplayPackage: public == private where
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{DDFACT}{distdfact} &
+\cross{DDFACT}{exptMod} &
+\cross{DDFACT}{factor} &
+\cross{DDFACT}{factorSquareFree} &
+\cross{DDFACT}{irreducible?} \\
+\cross{DDFACT}{separateDegrees} &
+\cross{DDFACT}{separateFactors} &
+\cross{DDFACT}{trace2PowMod} &
+\cross{DDFACT}{tracePowMod} &
 \end{tabular}
 
 <<package DDFACT DistinctDegreeFactorize>>=
@@ -10601,6 +10773,27 @@ DistinctDegreeFactorize(F,FP): C == T
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{DFSFUN}{airyAi} &
+\cross{DFSFUN}{airyBi} &
+\cross{DFSFUN}{besselI} &
+\cross{DFSFUN}{besselJ} &
+\cross{DFSFUN}{besselK} \\
+\cross{DFSFUN}{besselY} &
+\cross{DFSFUN}{Beta} &
+\cross{DFSFUN}{digamma} &
+\cross{DFSFUN}{E1} &
+\cross{DFSFUN}{Ei} \\
+\cross{DFSFUN}{Ei1} &
+\cross{DFSFUN}{Ei2} &
+\cross{DFSFUN}{Ei3} &
+\cross{DFSFUN}{Ei4} &
+\cross{DFSFUN}{Ei5} \\
+\cross{DFSFUN}{Ei6} &
+\cross{DFSFUN}{En} &
+\cross{DFSFUN}{Gamma} &
+\cross{DFSFUN}{hypergeometric0F1} &
+\cross{DFSFUN}{logGamma} \\
+\cross{DFSFUN}{polygamma} &&&&
 \end{tabular}
 
 <<package DFSFUN DoubleFloatSpecialFunctions>>=
@@ -12722,8 +12915,7 @@ $\infty$ & -1.000 & 0.100000000 0000000000 00000000001 E 01\\
 \pagepic{ps/v104doubleresultantpackage.ps}{DBLRESP}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{DBLRESP}{doubleResultant}
 
 <<package DBLRESP DoubleResultantPackage>>=
 )abbrev package DBLRESP DoubleResultantPackage
@@ -12790,6 +12982,11 @@ DoubleResultantPackage(F, UP, UPUP, R): Exports == Implementation where
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{DRAWCX}{setImagSteps} &
+\cross{DRAWCX}{setRealSteps} &
+\cross{DRAWCX}{drawComplex} &
+\cross{DRAWCX}{drawComplexVectorField} &
+\cross{DRAWCX}{setClipValue} 
 \end{tabular}
 
 <<package DRAWCX DrawComplex>>=
@@ -12978,8 +13175,7 @@ DrawComplex(): Exports == Implementation where
 \pagepic{ps/v104drawnumerichack.ps}{DRAWHACK}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{DRAWHACK}{coerce}
 
 <<package DRAWHACK DrawNumericHack>>=
 )abbrev package DRAWHACK DrawNumericHack
@@ -13023,6 +13219,22 @@ DrawNumericHack(R:Join(OrderedSet,IntegralDomain,ConvertibleTo Float)):
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{DROPT0}{adaptive} &
+\cross{DROPT0}{clipBoolean} &
+\cross{DROPT0}{coord} &
+\cross{DROPT0}{curveColorPalette} &
+\cross{DROPT0}{pointColorPalette} \\
+\cross{DROPT0}{ranges} &
+\cross{DROPT0}{space} &
+\cross{DROPT0}{style} &
+\cross{DROPT0}{title} &
+\cross{DROPT0}{toScale} \\
+\cross{DROPT0}{tubePoints} &
+\cross{DROPT0}{tubeRadius} &
+\cross{DROPT0}{units} &
+\cross{DROPT0}{var1Steps} &
+\cross{DROPT0}{var2Steps} \\
+\cross{DROPT0}{viewpoint} &
 \end{tabular}
 
 <<package DROPT0 DrawOptionFunctions0>>=
@@ -13204,8 +13416,7 @@ DrawOptionFunctions0(): Exports == Implementation where
 \pagepic{ps/v104drawoptionfunctions1.ps}{DROPT1}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{DROPT1}{option}
 
 <<package DROPT1 DrawOptionFunctions1>>=
 )abbrev package DROPT1 DrawOptionFunctions1
@@ -13244,6 +13455,18 @@ DrawOptionFunctions1(S:Type): Exports == Implementation where
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{D01AGNT}{changeName} &
+\cross{D01AGNT}{commaSeparate} &
+\cross{D01AGNT}{df2st} &
+\cross{D01AGNT}{functionIsContinuousAtEndPoints} &
+\cross{D01AGNT}{functionIsOscillatory} \\
+\cross{D01AGNT}{gethi} &
+\cross{D01AGNT}{getlo} &
+\cross{D01AGNT}{ldf2lst} &
+\cross{D01AGNT}{problemPoints} &
+\cross{D01AGNT}{rangeIsFinite} \\
+\cross{D01AGNT}{sdf2lst} &
+\cross{D01AGNT}{singularitiesOf} &&&
 \end{tabular}
 
 <<package D01AGNT d01AgentsPackage>>=
@@ -13535,7 +13758,10 @@ d01AgentsPackage(): E == I where
 \pagepic{ps/v104d01weightspackage.ps}{D01WGTS}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{D01WGTS}{exprHasAlgebraicWeight} &
+\cross{D01WGTS}{exprHasLogarithmicWeights} &
+\cross{D01WGTS}{exprHasWeightCosWXorSinWX} 
 \end{tabular}
 
 <<package D01WGTS d01WeightsPackage>>=
@@ -13807,6 +14033,16 @@ d01WeightsPackage(): E == I where
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{D02AGNT}{accuracyIF} &
+\cross{D02AGNT}{combineFeatureCompatibility} &
+\cross{D02AGNT}{eval} &
+\cross{D02AGNT}{expenseOfEvaluationIF} &
+\cross{D02AGNT}{intermediateResultsIF} \\
+\cross{D02AGNT}{jacobian} &
+\cross{D02AGNT}{sparsityIF} &
+\cross{D02AGNT}{stiffnessAndStabilityFactor} &
+\cross{D02AGNT}{stiffnessAndStabilityOfODEIF} &
+\cross{D02AGNT}{systemSizeIF} 
 \end{tabular}
 
 <<package D02AGNT d02AgentsPackage>>=
@@ -14110,7 +14346,11 @@ d02AgentsPackage(): E == I where
 \pagepic{ps/v104d03agentspackage.ps}{D03AGNT}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llll}
+\cross{D03AGNT}{central?} &
+\cross{D03AGNT}{elliptic?} &
+\cross{D03AGNT}{subscriptedVariables} &
+\cross{D03AGNT}{varList}
 \end{tabular}
 
 <<package D03AGNT d03AgentsPackage>>=
@@ -14219,7 +14459,13 @@ d03AgentsPackage(): E == I where
 \pagepic{ps/v104eigenpackage.ps}{EP}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llllll}
+\cross{EP}{characteristicPolynomial} &
+\cross{EP}{eigenvalues} &
+\cross{EP}{eigenvector} &
+\cross{EP}{eigenvectors} &
+\cross{EP}{generalizedEigenvector} &
+\cross{EP}{generalizedEigenvectors} 
 \end{tabular}
 
 <<package EP EigenPackage>>=
@@ -14481,6 +14727,65 @@ EigenPackage(R) : C == T
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{EF}{acos} &
+\cross{EF}{acosh} &
+\cross{EF}{acot} &
+\cross{EF}{acoth} &
+\cross{EF}{acsc} \\
+\cross{EF}{acsch} &
+\cross{EF}{asec} &
+\cross{EF}{asech} &
+\cross{EF}{asin} &
+\cross{EF}{asinh} \\
+\cross{EF}{atan} &
+\cross{EF}{atanh} &
+\cross{EF}{belong?} &
+\cross{EF}{cos} &
+\cross{EF}{cosh} \\
+\cross{EF}{cot} &
+\cross{EF}{coth} &
+\cross{EF}{csc} &
+\cross{EF}{csch} &
+\cross{EF}{exp} \\
+\cross{EF}{iiacos} &
+\cross{EF}{iiacosh} &
+\cross{EF}{iiacot} &
+\cross{EF}{iiacoth} &
+\cross{EF}{iiacsc} \\
+\cross{EF}{iiacsch} &
+\cross{EF}{iiasec} &
+\cross{EF}{iiasech} &
+\cross{EF}{iiasin} &
+\cross{EF}{iiasinh} \\
+\cross{EF}{iiatan} &
+\cross{EF}{iiatanh} &
+\cross{EF}{iicos} &
+\cross{EF}{iicosh} &
+\cross{EF}{iicot} \\
+\cross{EF}{iicoth} &
+\cross{EF}{iicsc} &
+\cross{EF}{iicsch} &
+\cross{EF}{iiexp} &
+\cross{EF}{iilog} \\
+\cross{EF}{iisec} &
+\cross{EF}{iisech} &
+\cross{EF}{iisin} &
+\cross{EF}{iisinh} &
+\cross{EF}{iisqrt2} \\
+\cross{EF}{iisqrt3} &
+\cross{EF}{iitan} &
+\cross{EF}{iitanh} &
+\cross{EF}{localReal?} &
+\cross{EF}{log} \\
+\cross{EF}{operator} &
+\cross{EF}{pi} &
+\cross{EF}{sec} &
+\cross{EF}{sech} &
+\cross{EF}{sin} \\
+\cross{EF}{sinh} &
+\cross{EF}{specialTrigs} &
+\cross{EF}{tan} &
+\cross{EF}{tanh} &
 \end{tabular}
 
 <<package EF ElementaryFunction>>=
@@ -15350,7 +15655,10 @@ ElementaryFunction(R, F): Exports == Implementation where
 \pagepic{ps/v104elementaryfunctiondefiniteintegration.ps}{DEFINTEF}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{DEFINTEF}{innerint} &
+\cross{DEFINTEF}{integrate} &
+\cross{DEFINTEF}{integrate} 
 \end{tabular}
 
 <<package DEFINTEF ElementaryFunctionDefiniteIntegration>>=
@@ -15577,8 +15885,7 @@ ElementaryFunctionDefiniteIntegration(R, F): Exports == Implementation where
 \pagepic{ps/v104elementaryfunctionlodesolver.ps}{LODEEF}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{LODEEF}{solve} 
 
 <<package LODEEF ElementaryFunctionLODESolver>>=
 )abbrev package LODEEF ElementaryFunctionLODESolver
@@ -15846,8 +16153,7 @@ ElementaryFunctionLODESolver(R, F, L): Exports == Implementation where
 \pagepic{ps/v104elementaryfunctionodesolver.ps}{ODEEF}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{ODEEF}{solve} 
 
 <<package ODEEF ElementaryFunctionODESolver>>=
 )abbrev package ODEEF ElementaryFunctionODESolver
@@ -16123,8 +16429,7 @@ ElementaryFunctionODESolver(R, F): Exports == Implementation where
 \pagepic{ps/v104elementaryfunctionsign.ps}{SIGNEF}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{SIGNEF}{sign} 
 
 <<package SIGNEF ElementaryFunctionSign>>=
 )abbrev package SIGNEF ElementaryFunctionSign
@@ -16328,7 +16633,13 @@ ElementaryFunctionSign(R,F): Exports == Implementation where
 \pagepic{ps/v104elementaryfunctionstructurepackage.ps}{EFSTRUC}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llllll}
+\cross{EFSTRUC}{normalize} &
+\cross{EFSTRUC}{realElementary} &
+\cross{EFSTRUC}{rootNormalize} &
+\cross{EFSTRUC}{rischNormalize} &
+\cross{EFSTRUC}{tanQ} &
+\cross{EFSTRUC}{validExponential} 
 \end{tabular}
 
 <<package EFSTRUC ElementaryFunctionStructurePackage>>=
@@ -16740,6 +17051,60 @@ ElementaryFunctionStructurePackage(R,F): Exports == Implementation where
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{EFULS}{acos} &
+\cross{EFULS}{acosIfCan} &
+\cross{EFULS}{acosh} &
+\cross{EFULS}{acoshIfCan} &
+\cross{EFULS}{acot} \\
+\cross{EFULS}{acotIfCan} &
+\cross{EFULS}{acoth} &
+\cross{EFULS}{acothIfCan} &
+\cross{EFULS}{acsc} &
+\cross{EFULS}{acscIfCan} \\
+\cross{EFULS}{acsch} &
+\cross{EFULS}{acschIfCan} &
+\cross{EFULS}{asec} &
+\cross{EFULS}{asecIfCan} &
+\cross{EFULS}{asech} \\
+\cross{EFULS}{asechIfCan} &
+\cross{EFULS}{asin} &
+\cross{EFULS}{asinIfCan} &
+\cross{EFULS}{asinh} &
+\cross{EFULS}{asinhIfCan} \\
+\cross{EFULS}{atan} &
+\cross{EFULS}{atanIfCan} &
+\cross{EFULS}{atanh} &
+\cross{EFULS}{atanhIfCan} &
+\cross{EFULS}{cos} \\
+\cross{EFULS}{cosIfCan} &
+\cross{EFULS}{cosh} &
+\cross{EFULS}{coshIfCan} &
+\cross{EFULS}{cot} &
+\cross{EFULS}{cotIfCan} \\
+\cross{EFULS}{coth} &
+\cross{EFULS}{cothIfCan} &
+\cross{EFULS}{csc} &
+\cross{EFULS}{cscIfCan} &
+\cross{EFULS}{csch} \\
+\cross{EFULS}{cschIfCan} &
+\cross{EFULS}{exp} &
+\cross{EFULS}{expIfCan} &
+\cross{EFULS}{log} &
+\cross{EFULS}{logIfCan} \\
+\cross{EFULS}{nthRootIfCan} &
+\cross{EFULS}{sec} &
+\cross{EFULS}{secIfCan} &
+\cross{EFULS}{sech} &
+\cross{EFULS}{sechIfCan} \\
+\cross{EFULS}{sin} &
+\cross{EFULS}{sinIfCan} &
+\cross{EFULS}{sinh} &
+\cross{EFULS}{sinhIfCan} &
+\cross{EFULS}{tan} \\
+\cross{EFULS}{tanIfCan} &
+\cross{EFULS}{tanh} &
+\cross{EFULS}{tanhIfCan} &
+\cross{EFULS}{?**?} &
 \end{tabular}
 
 <<package EFULS ElementaryFunctionsUnivariateLaurentSeries>>=
@@ -17100,6 +17465,60 @@ ElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS):_
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{EFUPXS}{acos} &
+\cross{EFUPXS}{acosIfCan} &
+\cross{EFUPXS}{acosh} &
+\cross{EFUPXS}{acoshIfCan} &
+\cross{EFUPXS}{acot} \\
+\cross{EFUPXS}{acotIfCan} &
+\cross{EFUPXS}{acoth} &
+\cross{EFUPXS}{acothIfCan} &
+\cross{EFUPXS}{acsc} &
+\cross{EFUPXS}{acscIfCan} \\
+\cross{EFUPXS}{acsch} &
+\cross{EFUPXS}{acschIfCan} &
+\cross{EFUPXS}{asec} &
+\cross{EFUPXS}{asecIfCan} &
+\cross{EFUPXS}{asech} \\
+\cross{EFUPXS}{asechIfCan} &
+\cross{EFUPXS}{asin} &
+\cross{EFUPXS}{asinIfCan} &
+\cross{EFUPXS}{asinh} &
+\cross{EFUPXS}{asinhIfCan} \\
+\cross{EFUPXS}{atan} &
+\cross{EFUPXS}{atanIfCan} &
+\cross{EFUPXS}{atanh} &
+\cross{EFUPXS}{atanhIfCan} &
+\cross{EFUPXS}{cos} \\
+\cross{EFUPXS}{cosIfCan} &
+\cross{EFUPXS}{cosh} &
+\cross{EFUPXS}{coshIfCan} &
+\cross{EFUPXS}{cot} &
+\cross{EFUPXS}{cotIfCan} \\
+\cross{EFUPXS}{coth} &
+\cross{EFUPXS}{cothIfCan} &
+\cross{EFUPXS}{csc} &
+\cross{EFUPXS}{cscIfCan} &
+\cross{EFUPXS}{csch} \\
+\cross{EFUPXS}{cschIfCan} &
+\cross{EFUPXS}{exp} &
+\cross{EFUPXS}{expIfCan} &
+\cross{EFUPXS}{log} &
+\cross{EFUPXS}{logIfCan} \\
+\cross{EFUPXS}{nthRootIfCan} &
+\cross{EFUPXS}{sec} &
+\cross{EFUPXS}{secIfCan} &
+\cross{EFUPXS}{sech} &
+\cross{EFUPXS}{sechIfCan} \\
+\cross{EFUPXS}{sin} &
+\cross{EFUPXS}{sinIfCan} &
+\cross{EFUPXS}{sinh} &
+\cross{EFUPXS}{sinhIfCan} &
+\cross{EFUPXS}{tan} \\
+\cross{EFUPXS}{tanIfCan} &
+\cross{EFUPXS}{tanh} &
+\cross{EFUPXS}{tanhIfCan} &
+\cross{EFUPXS}{?**?} &
 \end{tabular}
 
 <<package EFUPXS ElementaryFunctionsUnivariatePuiseuxSeries>>=
@@ -17375,6 +17794,11 @@ ElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS):_
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{INTEF}{lfextendedint} &
+\cross{INTEF}{lfextlimint} &
+\cross{INTEF}{lfinfieldint} &
+\cross{INTEF}{lfintegrate} &
+\cross{INTEF}{lflimitedint} 
 \end{tabular}
 
 <<package INTEF ElementaryIntegration>>=
@@ -17772,8 +18196,7 @@ See the above discussion for why this causes an infinite loop.
 \pagepic{ps/v104elementaryrischde.ps}{RDEEF}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{RDEEF}{rischDE} 
 
 <<package RDEEF ElementaryRischDE>>=
 )abbrev package RDEEF ElementaryRischDE
@@ -18159,8 +18582,7 @@ ElementaryRischDE(R, F): Exports == Implementation where
 \pagepic{ps/v104elementaryrischdesystem.ps}{RDEEFS}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{RDEEFS}{rischDEsys} 
 
 <<package RDEEFS ElementaryRischDESystem>>=
 )abbrev package RDEEFS ElementaryRischDESystem
@@ -18268,7 +18690,11 @@ ElementaryRischDESystem(R, F): Exports == Implementation where
 \pagepic{ps/v104ellipticfunctionsunivariatetaylorseries.ps}{ELFUTS}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llll}
+\cross{ELFUTS}{cn} &
+\cross{ELFUTS}{dn} &
+\cross{ELFUTS}{sn} &
+\cross{ELFUTS}{sncndn} 
 \end{tabular}
 
 <<package ELFUTS EllipticFunctionsUnivariateTaylorSeries>>=
@@ -18338,8 +18764,7 @@ EllipticFunctionsUnivariateTaylorSeries(Coef,UTS):
 \pagepic{ps/v104equationfunctions2.ps}{EQ2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{EQ2}{map}
 
 <<package EQ2 EquationFunctions2>>=
 )abbrev package EQ2 EquationFunctions2
@@ -18374,8 +18799,7 @@ EquationFunctions2(S: Type, R: Type): with
 \pagepic{ps/v104errorfunctions.ps}{ERROR}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{ERROR}{error} 
 
 <<package ERROR ErrorFunctions>>=
 )abbrev package ERROR ErrorFunctions
@@ -19595,7 +20019,9 @@ o )show GroebnerPackage
 \pagepic{ps/v104euclideangroebnerbasispackage.ps}{GBEUCLID}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{GBEUCLID}{euclideanGroebner} &
+\cross{GBEUCLID}{euclideanNormalForm} 
 \end{tabular}
 
 <<package GBEUCLID EuclideanGroebnerBasisPackage>>=
@@ -20138,8 +20564,7 @@ EuclideanGroebnerBasisPackage(Dom, Expon, VarSet, Dpol): T == C where
 \pagepic{ps/v104evaluatecycleindicators.ps}{EVALCYC}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{EVALCYC}{eval} 
 
 <<package EVALCYC EvaluateCycleIndicators>>=
 )abbrev package EVALCYC EvaluateCycleIndicators
@@ -20198,6 +20623,17 @@ EvaluateCycleIndicators(F):T==C where
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{ESCONT}{df2st} &
+\cross{ESCONT}{functionIsFracPolynomial?} &
+\cross{ESCONT}{gethi} &
+\cross{ESCONT}{getlo} &
+\cross{ESCONT}{ldf2lst} \\
+\cross{ESCONT}{polynomialZeros} &
+\cross{ESCONT}{problemPoints} &
+\cross{ESCONT}{sdf2lst} &
+\cross{ESCONT}{singularitiesOf} &
+\cross{ESCONT}{singularitiesOf} \\
+\cross{ESCONT}{zerosOf} &
 \end{tabular}
 
 <<package ESCONT ExpertSystemContinuityPackage>>=
@@ -20465,8 +20901,7 @@ ExpertSystemContinuityPackage(): E == I where
 \pagepic{ps/v104expertsystemcontinuitypackage1.ps}{ESCONT1}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{ESCONT1}{in?} 
 
 <<package ESCONT1 ExpertSystemContinuityPackage1>>=
 )abbrev package ESCONT1 ExpertSystemContinuityPackage1
@@ -20528,6 +20963,42 @@ ExpertSystemContinuityPackage1(A:DF,B:DF): E == I where
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{ESTOOLS}{att2Result} &
+\cross{ESTOOLS}{concat} &
+\cross{ESTOOLS}{convert} &
+\cross{ESTOOLS}{dflist} &
+\cross{ESTOOLS}{dfRange} \\
+\cross{ESTOOLS}{df2ef} &
+\cross{ESTOOLS}{df2fi} &
+\cross{ESTOOLS}{df2mf} &
+\cross{ESTOOLS}{df2st} &
+\cross{ESTOOLS}{edf2df} \\
+\cross{ESTOOLS}{edf2ef} &
+\cross{ESTOOLS}{edf2efi} &
+\cross{ESTOOLS}{edf2fi} &
+\cross{ESTOOLS}{ef2edf} &
+\cross{ESTOOLS}{expenseOfEvaluation} \\
+\cross{ESTOOLS}{fi2df} &
+\cross{ESTOOLS}{f2df} &
+\cross{ESTOOLS}{f2st} &
+\cross{ESTOOLS}{gethi} &
+\cross{ESTOOLS}{getlo} \\
+\cross{ESTOOLS}{iflist2Result} &
+\cross{ESTOOLS}{in?} &
+\cross{ESTOOLS}{isQuotient} &
+\cross{ESTOOLS}{ldf2lst} &
+\cross{ESTOOLS}{ldf2vmf} \\
+\cross{ESTOOLS}{mat} &
+\cross{ESTOOLS}{measure2Result} &
+\cross{ESTOOLS}{measure2Result} &
+\cross{ESTOOLS}{numberOfOperations} &
+\cross{ESTOOLS}{ocf2ocdf} \\
+\cross{ESTOOLS}{outputMeasure} &
+\cross{ESTOOLS}{pdf2df} &
+\cross{ESTOOLS}{pdf2ef} &
+\cross{ESTOOLS}{sdf2lst} &
+\cross{ESTOOLS}{socf2socdf} \\
+\cross{ESTOOLS}{vedf2vef} &&&&
 \end{tabular}
 
 <<package ESTOOLS ExpertSystemToolsPackage>>=
@@ -20914,8 +21385,7 @@ ExpertSystemToolsPackage():E == I where
 \pagepic{ps/v104expertsystemtoolspackage1.ps}{ESTOOLS1}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{ESTOOLS1}{neglist} 
 
 <<package ESTOOLS1 ExpertSystemToolsPackage1>>=
 )abbrev package ESTOOLS1 ExpertSystemToolsPackage1
@@ -20947,8 +21417,7 @@ ExpertSystemToolsPackage1(R1:OR): E == I where
 \pagepic{ps/v104expertsystemtoolspackage2.ps}{ESTOOLS2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{ESTOOLS2}{map} 
 
 <<package ESTOOLS2 ExpertSystemToolsPackage2>>=
 )abbrev package ESTOOLS2 ExpertSystemToolsPackage2
@@ -20985,8 +21454,7 @@ ExpertSystemToolsPackage2(R1:R,R2:R): E == I where
 \pagepic{ps/v104ExpressionFunctions2.ps}{EXPR2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{EXPR2}{map} 
 
 <<package EXPR2 ExpressionFunctions2>>=
 )abbrev package EXPR2 ExpressionFunctions2
@@ -21050,7 +21518,9 @@ works. This is probably due to missing ``/'' in UFPS.
 \pagepic{ps/v104expressionsolve.ps}{EXPRSOL}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{EXPRSOL}{replaceDiffs} &
+\cross{EXPRSOL}{seriesSolve} 
 \end{tabular}
 
 <<package EXPRSOL ExpressionSolve>>=
@@ -21141,8 +21611,7 @@ coefficient ring, since it will complain otherwise.
 \pagepic{ps/v104expressionspacefunctions1.ps}{ES1}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{ES1}{map} 
 
 <<package ES1 ExpressionSpaceFunctions1>>=
 )abbrev package ES1 ExpressionSpaceFunctions1
@@ -21181,8 +21650,7 @@ ExpressionSpaceFunctions1(F:ExpressionSpace, S:Type): with
 \pagepic{ps/v104expressionspacefunctions2.ps}{ES2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{ES2}{map} 
 
 <<package ES2 ExpressionSpaceFunctions2>>=
 )abbrev package ES2 ExpressionSpaceFunctions2
@@ -21216,8 +21684,7 @@ ExpressionSpaceFunctions2(E:ExpressionSpace, F:ExpressionSpace): with
 \pagepic{ps/v104expressionspaceodesolver.ps}{EXPRODE}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{EXPRODE}{seriesSolve} 
 
 <<package EXPRODE ExpressionSpaceODESolver>>=
 )abbrev package EXPRODE ExpressionSpaceODESolver
@@ -21431,8 +21898,7 @@ ExpressionSpaceODESolver(R, F): Exports == Implementation where
 \pagepic{ps/v104expressiontoopenmath.ps}{OMEXPR}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{OMEXPR}{OMwrite}
 
 <<package OMEXPR ExpressionToOpenMath>>=
 )abbrev package OMEXPR ExpressionToOpenMath
@@ -21722,7 +22188,11 @@ ExpressionToOpenMath(R: Join(OpenMath, OrderedSet, Ring)): with
 \pagepic{ps/v104expressiontounivariatepowerseries.ps}{EXPR2UPS}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llll}
+\cross{EXPR2UPS}{laurent} &
+\cross{EXPR2UPS}{puiseux} &
+\cross{EXPR2UPS}{series} &
+\cross{EXPR2UPS}{taylor} 
 \end{tabular}
 
 <<package EXPR2UPS ExpressionToUnivariatePowerSeries>>=
@@ -22065,7 +22535,9 @@ ExpressionToUnivariatePowerSeries(R,FE): Exports == Implementation where
 \pagepic{ps/v104expressiontubeplot.ps}{EXPRTUBE}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{EXPRTUBE}{constantToUnaryFunction} &
+\cross{EXPRTUBE}{tubePlot} 
 \end{tabular}
 
 <<package EXPRTUBE ExpressionTubePlot>>=
@@ -22257,6 +22729,21 @@ ExpressionTubePlot(): Exports == Implementation where
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{E04AGNT}{changeNameToObjf} &
+\cross{E04AGNT}{expenseOfEvaluation} &
+\cross{E04AGNT}{finiteBound} &
+\cross{E04AGNT}{linear?} &
+\cross{E04AGNT}{linearMatrix} \\
+\cross{E04AGNT}{linearPart} &
+\cross{E04AGNT}{nonLinearPart} &
+\cross{E04AGNT}{optAttributes} &
+\cross{E04AGNT}{quadratic?} &
+\cross{E04AGNT}{simpleBounds?} \\
+\cross{E04AGNT}{sortConstraints} &
+\cross{E04AGNT}{splitLinear} &
+\cross{E04AGNT}{sumOfSquares} &
+\cross{E04AGNT}{varList} &
+\cross{E04AGNT}{variables} 
 \end{tabular}
 
 <<package E04AGNT e04AgentsPackage>>=
@@ -22531,7 +23018,9 @@ e04AgentsPackage(): E == I where
 \pagepic{ps/v104factoredfunctions.ps}{FACTFUNC}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{FACTFUNC}{log} &
+\cross{FACTFUNC}{nthRoot} 
 \end{tabular}
 
 <<package FACTFUNC FactoredFunctions>>=
@@ -22701,8 +23190,7 @@ o )show FactoredFunctions2
 \pagepic{ps/v104FactoredFunctions2.ps}{FR2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{FR2}{map} 
 
 <<package FR2 FactoredFunctions2>>=
 )abbrev package FR2 FactoredFunctions2
@@ -22750,7 +23238,9 @@ FactoredFunctions2(R, S): Exports == Implementation where
 \pagepic{ps/v104factoredfunctionutilities.ps}{FRUTIL}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{FRUTIL}{mergeFactors} &
+\cross{FRUTIL}{refine} 
 \end{tabular}
 
 <<package FRUTIL FactoredFunctionUtilities>>=
@@ -22823,6 +23313,13 @@ FactoredFunctionUtilities(R): Exports == Implementation where
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{FACUTIL}{completeEval} &
+\cross{FACUTIL}{degree} &
+\cross{FACUTIL}{lowerPolynomial} &
+\cross{FACUTIL}{normalDeriv} &
+\cross{FACUTIL}{raisePolynomial} \\
+\cross{FACUTIL}{ran} &
+\cross{FACUTIL}{variables} &&&
 \end{tabular}
 
 <<package FACUTIL FactoringUtilities>>=
@@ -22933,7 +23430,10 @@ FactoringUtilities(E,OV,R,P) : C == T where
 \pagepic{ps/v104fglmifcanpackage.ps}{FGLMICPK}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{FGLMICPK}{fglmIfCan} &
+\cross{FGLMICPK}{groebner} &
+\cross{FGLMICPK}{zeroDimensional?} 
 \end{tabular}
 
 <<package FGLMICPK FGLMIfCanPackage>>=
@@ -23031,8 +23531,7 @@ FGLMIfCanPackage(R,ls): Exports == Implementation where
 \pagepic{ps/v104findorderfinite.ps}{FORDER}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{FORDER}{order} 
 
 <<package FORDER FindOrderFinite>>=
 )abbrev package FORDER FindOrderFinite
@@ -23069,8 +23568,7 @@ FindOrderFinite(F, UP, UPUP, R): Exports == Implementation where
 \pagepic{ps/v104finiteabelianmonoidringfunctions2.ps}{FAMR2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{FAMR2}{map} 
 
 <<package FAMR2 FiniteAbelianMonoidRingFunctions2>>=
 )abbrev package FAMR2 FiniteAbelianMonoidRingFunctions2
@@ -23112,8 +23610,7 @@ FiniteAbelianMonoidRingFunctions2(E: OrderedAbelianMonoid,
 \pagepic{ps/v104finitedivisorfunctions2.ps}{FDIV2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{FDIV2}{map} 
 
 <<package FDIV2 FiniteDivisorFunctions2>>=
 )abbrev package FDIV2 FiniteDivisorFunctions2
@@ -23160,7 +23657,13 @@ FiniteDivisorFunctions2(R1, UP1, UPUP1, F1, R2, UP2, UPUP2, F2):
 \pagepic{ps/v104finitefieldfunctions.ps}{FFF}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{FFF}{createLowComplexityNormalBasis} &
+\cross{FFF}{createLowComplexityTable} &
+\cross{FFF}{createMultiplicationMatrix} \\
+\cross{FFF}{createMultiplicationTable} &
+\cross{FFF}{createZechTable} &
+\cross{FFF}{sizeMultiplication} 
 \end{tabular}
 
 <<package FFF FiniteFieldFunctions>>=
@@ -23417,8 +23920,7 @@ FiniteFieldFunctions(GF): Exports == Implementation where
 \pagepic{ps/v104finitefieldhomomorphisms.ps}{FFHOM}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{FFHOM}{coerce} 
 
 <<package FFHOM FiniteFieldHomomorphisms>>=
 )abbrev package FFHOM FiniteFieldHomomorphisms
@@ -23796,7 +24298,25 @@ FiniteFieldHomomorphisms(F1,GF,F2): Exports == Implementation where
 \pagepic{ps/v104finitefieldpolynomialpackage.ps}{FFPOLY}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{FFPOLY}{createIrreduciblePoly} &
+\cross{FFPOLY}{createNormalPoly} &
+\cross{FFPOLY}{createNormalPrimitivePoly} \\
+\cross{FFPOLY}{createPrimitiveNormalPoly} &
+\cross{FFPOLY}{createPrimitivePoly} &
+\cross{FFPOLY}{leastAffineMultiple} \\
+\cross{FFPOLY}{nextIrreduciblePoly} &
+\cross{FFPOLY}{nextNormalPoly} &
+\cross{FFPOLY}{nextNormalPrimitivePoly} \\
+\cross{FFPOLY}{nextPrimitiveNormalPoly} &
+\cross{FFPOLY}{nextPrimitivePoly} &
+\cross{FFPOLY}{normal?} \\
+\cross{FFPOLY}{numberOfIrreduciblePoly} &
+\cross{FFPOLY}{numberOfNormalPoly} &
+\cross{FFPOLY}{numberOfPrimitivePoly} \\
+\cross{FFPOLY}{primitive?} &
+\cross{FFPOLY}{random} &
+\cross{FFPOLY}{reducedQPowers} 
 \end{tabular}
 
 <<package FFPOLY FiniteFieldPolynomialPackage>>=
@@ -24787,8 +25307,7 @@ FiniteFieldPolynomialPackage GF : Exports == Implementation where
 \pagepic{ps/v104finitefieldpolynomialpackage2.ps}{FFPOLY2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{FFPOLY2}{rootOfIrreduciblePoly} 
 
 <<package FFPOLY2 FiniteFieldPolynomialPackage2>>=
 )abbrev package FFPOLY2 FiniteFieldPolynomialPackage2
@@ -24919,8 +25438,7 @@ FiniteFieldPolynomialPackage2(F,GF):Exports == Implementation where
 \pagepic{ps/v104finitefieldsolvelinearpolynomialequation.ps}{FFSLPE}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{FFSLPE}{solveLinearPolynomialEquation} 
 
 <<package FFSLPE FiniteFieldSolveLinearPolynomialEquation>>=
 )abbrev package FFSLPE FiniteFieldSolveLinearPolynomialEquation
@@ -24983,7 +25501,10 @@ FiniteFieldSolveLinearPolynomialEquation(F:FiniteFieldCategory,
 \pagepic{ps/v104finitelinearaggregatefunctions2.ps}{FLAGG2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{FLAGG2}{map} &
+\cross{FLAGG2}{reduce} &
+\cross{FLAGG2}{scan} 
 \end{tabular}
 
 <<package FLAGG2 FiniteLinearAggregateFunctions2>>=
@@ -25113,7 +25634,10 @@ FiniteLinearAggregateFunctions2(S, A, R, B):
 \pagepic{ps/v104finitelinearaggregatesort.ps}{FLASORT}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{FLASORT}{heapSort} &
+\cross{FLASORT}{quickSort} &
+\cross{FLASORT}{shellSort} 
 \end{tabular}
 
 <<package FLASORT FiniteLinearAggregateSort>>=
@@ -25228,7 +25752,10 @@ FiniteLinearAggregateSort(S, V): Exports == Implementation where
 \pagepic{ps/v104finitesetaggregatefunctions2.ps}{FSAGG2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{FSAGG2}{map} &
+\cross{FSAGG2}{reduce} &
+\cross{FSAGG2}{scan} 
 \end{tabular}
 
 <<package FSAGG2 FiniteSetAggregateFunctions2>>=
@@ -25293,7 +25820,9 @@ FiniteSetAggregateFunctions2(S, A, R, B): Exports == Implementation where
 \pagepic{ps/v104floatingcomplexpackage.ps}{FLOATCP}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{FLOATCP}{complexRoots} &
+\cross{FLOATCP}{complexSolve} 
 \end{tabular}
 
 <<package FLOATCP FloatingComplexPackage>>=
@@ -25427,7 +25956,9 @@ FloatingComplexPackage(Par): Cat == Cap where
 \pagepic{ps/v104floatingrealpackage.ps}{FLOATRP}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{FLOATRP}{realRoots} &
+\cross{FLOATRP}{solve} 
 \end{tabular}
 
 <<package FLOATRP FloatingRealPackage>>=
@@ -25559,7 +26090,11 @@ FloatingRealPackage(Par): Cat == Cap where
 \pagepic{ps/v104fortrancodepackage1.ps}{FCPAK1}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llll}
+\cross{FCPAK1}{identitySquareMatrix} &
+\cross{FCPAK1}{zeroMatrix} &
+\cross{FCPAK1}{zeroSquareMatrix} &
+\cross{FCPAK1}{zeroVector} 
 \end{tabular}
 
 <<package FCPAK1 FortranCodePackage1>>=
@@ -25715,7 +26250,13 @@ FortranCodePackage1: Exports  == Implementation where
 \pagepic{ps/v104fortranoutputstackpackage.ps}{FOP}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{FOP}{popFortranOutputStack} &
+\cross{FOP}{clearFortranOutputStack} &
+\cross{FOP}{pushFortranOutputStack} \\
+\cross{FOP}{pushFortranOutputStack} &
+\cross{FOP}{showFortranOutputStack} &
+\cross{FOP}{topFortranOutputStack} 
 \end{tabular}
 
 <<package FOP FortranOutputStackPackage>>=
@@ -25812,7 +26353,10 @@ FortranOutputStackPackage() : specification == implementation where
 \pagepic{ps/v104fortranpackage.ps}{FORT}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{FORT}{outputAsFortran} &
+\cross{FORT}{linkToFortran} &
+\cross{FORT}{setLegalFortranSourceExtensions} 
 \end{tabular}
 
 <<package FORT FortranPackage>>=
@@ -25920,8 +26464,7 @@ FortranPackage(): Exports == Implementation where
 \pagepic{ps/v104fractionalidealfunctions2.ps}{FRIDEAL2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{FRIDEAL2}{map} 
 
 <<package FRIDEAL2 FractionalIdealFunctions2>>=
 )abbrev package FRIDEAL2 FractionalIdealFunctions2
@@ -25971,7 +26514,17 @@ FractionalIdealFunctions2(R1, F1, U1, A1, R2, F2, U2, A2):
 \pagepic{ps/v104fractionfreefastgaussian.ps}{FFFG}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llll}
+\cross{FFFG}{DiffAction} &
+\cross{FFFG}{DiffC} &
+\cross{FFFG}{ShiftAction} &
+\cross{FFFG}{ShiftC} \\
+\cross{FFFG}{fffg} &
+\cross{FFFG}{generalCoefficient} &
+\cross{FFFG}{generalInterpolation} &
+\cross{FFFG}{interpolate} \\
+\cross{FFFG}{qShiftAction} &
+\cross{FFFG}{qShiftC} &&
 \end{tabular}
 
 <<package FFFG FractionFreeFastGaussian>>=
@@ -26466,8 +27019,7 @@ $c_{\sigma,\sigma}$.
 \pagepic{ps/v104fractionfreefastgaussianfractions.ps}{FFFGF}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{FFFGF}{generalInterpolation} 
 
 <<package FFFGF FractionFreeFastGaussianFractions>>=
 )abbrev package FFFGF FractionFreeFastGaussianFractions
@@ -26585,8 +27137,7 @@ FractionFreeFastGaussianFractions(D, V, VF): Exports == Implementation where
 \pagepic{ps/v104fractionfunctions2.ps}{FRAC2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{FRAC2}{map} 
 
 <<package FRAC2 FractionFunctions2>>=
 )abbrev package FRAC2 FractionFunctions2
@@ -26629,8 +27180,7 @@ FractionFunctions2(A, B): Exports == Impl where
 \pagepic{ps/v104framednonassociativealgebrafunctions2.ps}{FRNAAF2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{FRNAAF2}{map} 
 
 <<package FRNAAF2 FramedNonAssociativeAlgebraFunctions2>>=
 )abbrev package FRNAAF2 FramedNonAssociativeAlgebraFunctions2
@@ -26692,6 +27242,30 @@ Gregory Vanuxem supplied the fix below.
 
 {\bf Exports:}\\
 \begin{tabular}{lllll}
+\cross{FSPECF}{Beta} &
+\cross{FSPECF}{Gamma} &
+\cross{FSPECF}{abs} &
+\cross{FSPECF}{airyAi} &
+\cross{FSPECF}{airyBi} \\
+\cross{FSPECF}{belong?} &
+\cross{FSPECF}{besselI} &
+\cross{FSPECF}{besselJ} &
+\cross{FSPECF}{besselK} &
+\cross{FSPECF}{besselY} \\
+\cross{FSPECF}{digamma} &
+\cross{FSPECF}{iiAiryAi} &
+\cross{FSPECF}{iiAiryBi} &
+\cross{FSPECF}{iiBesselI} &
+\cross{FSPECF}{iiBesselJ} \\
+\cross{FSPECF}{iiBesselK} &
+\cross{FSPECF}{iiBesselY} &
+\cross{FSPECF}{iiBeta} &
+\cross{FSPECF}{iiGamma} &
+\cross{FSPECF}{iiabs} \\
+\cross{FSPECF}{iidigamma} &
+\cross{FSPECF}{iipolygamma} &
+\cross{FSPECF}{operator} &
+\cross{FSPECF}{polygamma} &
 \end{tabular}
 
 <<package FSPECF FunctionalSpecialFunction>>=
@@ -27092,8 +27666,7 @@ component of the gradient failed, it resulted in an infinite loop for
 \pagepic{ps/v104functionfieldcategoryfunctions2.ps}{FFCAT2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{FFCAT2}{map} 
 
 <<package FFCAT2 FunctionFieldCategoryFunctions2>>=
 )abbrev package FFCAT2 FunctionFieldCategoryFunctions2
@@ -27134,7 +27707,9 @@ FunctionFieldCategoryFunctions2(R1, UP1, UPUP1, F1, R2, UP2, UPUP2, F2):
 \pagepic{ps/v104functionfieldintegralbasis.ps}{FFINTBAS}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{FFINTBAS}{integralBasis} &
+\cross{FFINTBAS}{localIntegralBasis} 
 \end{tabular}
 
 <<package FFINTBAS FunctionFieldIntegralBasis>>=
@@ -27271,7 +27846,11 @@ FunctionFieldIntegralBasis(R,UP,F): Exports == Implementation where
 \pagepic{ps/v104functionspaceassertions.ps}{PMASSFS}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llll}
+\cross{PMASSFS}{assert} &
+\cross{PMASSFS}{constant} &
+\cross{PMASSFS}{multiple} &
+\cross{PMASSFS}{optional} 
 \end{tabular}
 
 <<package PMASSFS FunctionSpaceAssertions>>=
@@ -27358,8 +27937,7 @@ FunctionSpaceAssertions(R, F): Exports == Implementation where
 \pagepic{ps/v104functionspaceattachpredicates.ps}{PMPREDFS}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{PMPREDFS}{suchThat} 
 
 <<package PMPREDFS FunctionSpaceAttachPredicates>>=
 )abbrev package PMPREDFS FunctionSpaceAttachPredicates
@@ -27422,7 +28000,10 @@ FunctionSpaceAttachPredicates(R, F, D): Exports == Implementation where
 \pagepic{ps/v104functionspacecomplexintegration.ps}{FSCINT}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{FSCINT}{complexIntegrate} &
+\cross{FSCINT}{internalIntegrate} &
+\cross{FSCINT}{internalIntegrate0} 
 \end{tabular}
 
 <<package FSCINT FunctionSpaceComplexIntegration>>=
@@ -27511,8 +28092,7 @@ FunctionSpaceComplexIntegration(R, F): Exports == Implementation where
 \pagepic{ps/v104functionspacefunctions2.ps}{FS2}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{FS2}{map} 
 
 <<package FS2 FunctionSpaceFunctions2>>=
 )abbrev package FS2 FunctionSpaceFunctions2
@@ -27563,8 +28143,7 @@ FunctionSpaceFunctions2(R, A, S, B): Exports == Implementation where
 \pagepic{ps/v104functionspaceintegration.ps}{FSINT}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{FSINT}{integrate} 
 
 <<package FSINT FunctionSpaceIntegration>>=
 )abbrev package FSINT FunctionSpaceIntegration
@@ -27710,8 +28289,7 @@ FunctionSpaceIntegration(R, F): Exports == Implementation where
 \pagepic{ps/v104functionspaceprimitiveelement.ps}{FSPRMELT}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{FSPRMELT}{primitiveElement} 
 
 <<package FSPRMELT FunctionSpacePrimitiveElement>>=
 )abbrev package FSPRMELT FunctionSpacePrimitiveElement
@@ -27832,7 +28410,9 @@ FunctionSpacePrimitiveElement(R, F): Exports == Implementation where
 \pagepic{ps/v104functionspacereduce.ps}{FSRED}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{FSRED}{bringDown} &
+\cross{FSRED}{newReduc} 
 \end{tabular}
 
 <<package FSRED FunctionSpaceReduce>>=
@@ -27906,8 +28486,7 @@ FunctionSpaceReduce(R, F): Exports == Implementation where
 \pagepic{ps/v104functionspacesum.ps}{SUMFS}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
-\end{tabular}
+\cross{SUMFS}{sum} 
 
 <<package SUMFS FunctionSpaceSum>>=
 )abbrev package SUMFS FunctionSpaceSum
@@ -27979,7 +28558,9 @@ FunctionSpaceSum(R, F): Exports == Implementation where
 \pagepic{ps/v104functionspacetoexponentialexpansion.ps}{FS2EXPXP}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{ll}
+\cross{FS2EXPXP}{localAbs} &
+\cross{FS2EXPXP}{exprToXXP} 
 \end{tabular}
 
 <<package FS2EXPXP FunctionSpaceToExponentialExpansion>>=
@@ -28537,7 +29118,10 @@ FunctionSpaceToExponentialExpansion(R,FE,x,cen):_
 \pagepic{ps/v104functionspacetounivariatepowerseries.ps}{FS2UPS}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{lll}
+\cross{FS2UPS}{localAbs} &
+\cross{FS2UPS}{exprToGenUPS} &
+\cross{FS2UPS}{exprToUPS} 
 \end{tabular}
 
 <<package FS2UPS FunctionSpaceToUnivariatePowerSeries>>=
@@ -29311,7 +29895,11 @@ FunctionSpaceToUnivariatePowerSeries(R,FE,Expon,UPS,TRAN,x):_
 \pagepic{ps/v104functionspaceunivariatepolynomialfactor.ps}{FSUPFACT}{1.00}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{llll}
+\cross{FSUPFACT}{anfactor} &
+\cross{FSUPFACT}{ffactor} &
+\cross{FSUPFACT}{qfactor} &
+\cross{FSUPFACT}{UP2ifCan} 
 \end{tabular}
 
 <<package FSUPFACT FunctionSpaceUnivariatePolynomialFactor>>=
diff --git a/changelog b/changelog
index 0392eeb..ac8b7b8 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,5 @@
+20090210 tpd src/axiom-website/patches.html 20090210.01.tpd.patch
+20090210 tpd books/bookvol10.4.pamphlet add exports
 20090209 tpd src/axiom-website/patches.html 20090209.02.tpd.patch
 20090209 tpd books/bookvol10.4 add packages
 20090209 tpd src/algebra/Makefile remove spad files
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 7895929..7ffc958 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -937,5 +937,7 @@ bookvol10.4 add packages<br/>
 bookvol10.4 add packages<br/>
 <a href="patches/20090209.02.tpd.patch">20090209.02.tpd.patch</a>
 bookvol10.4 add packages<br/>
+<a href="patches/20090210.01.tpd.patch">20090210.01.tpd.patch</a>
+bookvol10.4 add exports<br/>
  </body>
 </html>



From MAILER-DAEMON Sat Feb 14 11:50:36 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LYNiu-00017C-0o
	for mharc-axiom-developer@gnu.org; Sat, 14 Feb 2009 11:50:36 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LYNir-000177-Of
	for axiom-developer@nongnu.org; Sat, 14 Feb 2009 11:50:33 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LYNie-00016f-N8
	for axiom-developer@nongnu.org; Sat, 14 Feb 2009 11:50:32 -0500
Received: from [199.232.76.173] (port=33934 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LYNie-00016c-Fx
	for axiom-developer@nongnu.org; Sat, 14 Feb 2009 11:50:20 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:42857
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LYNib-0007kV-5e
	for axiom-developer@nongnu.org; Sat, 14 Feb 2009 11:50:20 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1EGoDug016027;
	Sat, 14 Feb 2009 10:50:13 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1EGo9Rx016012;
	Sat, 14 Feb 2009 10:50:10 -0600
Date: Sat, 14 Feb 2009 10:50:10 -0600
Message-Id: <200902141650.n1EGo9Rx016012@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090212.01.tpd.patch (remove unused code)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 14 Feb 2009 16:50:33 -0000

The focus now shifts to Book Volume 5: Axiom Interpreter

The goal is to collect, refactor, and document the interpreter.

====================================================================
diff --git a/changelog b/changelog
index ac8b7b8..5069ea7 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,11 @@
+20090212 tpd src/axiom-website/patches.html 20090212.01.tpd.patch
+20090212 tpd src/interp/interp-proclaims.lisp update proclaims for changes
+20090212 tpd src/interp/sockio.lisp remove unused code
+20090212 tpd src/interp/database.boot remove unused code
+20090212 tpd src/interp/bootlex.lisp remove unused code
+20090212 tpd src/interp/bookvol5 removed
+20090211 tpd src/axiom-website/patches.html 20090211.01.tpd.patch
+20090211 tpd books/bookvol10.4.pamphlet add exports
 20090210 tpd src/axiom-website/patches.html 20090210.01.tpd.patch
 20090210 tpd books/bookvol10.4.pamphlet add exports
 20090209 tpd src/axiom-website/patches.html 20090209.02.tpd.patch
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 7ffc958..2fbdca2 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -939,5 +939,9 @@ bookvol10.4 add packages<br/>
 bookvol10.4 add packages<br/>
 <a href="patches/20090210.01.tpd.patch">20090210.01.tpd.patch</a>
 bookvol10.4 add exports<br/>
+<a href="patches/20090211.01.tpd.patch">20090211.01.tpd.patch</a>
+bookvol10.4 add exports<br/>
+<a href="patches/20090212.01.tpd.patch">20090212.01.tpd.patch</a>
+remove unused code<br/>
  </body>
 </html>
diff --git a/src/interp/bookvol5.pamphlet b/src/interp/bookvol5.pamphlet
deleted file mode 100644
index f8fb4a2..0000000
--- a/src/interp/bookvol5.pamphlet
+++ /dev/null
@@ -1,6360 +0,0 @@
-\documentclass{book}
-\usepackage{axiom}
-\usepackage{graphicx}
-% struggle with latex figure-floating behavior
-\renewcommand\floatpagefraction{.9}
-\renewcommand\topfraction{.9}
-\renewcommand\bottomfraction{.9}
-\renewcommand\textfraction{.1}
-\setcounter{totalnumber}{50}
-\setcounter{topnumber}{50}
-\setcounter{bottomnumber}{50}
-
-\begin{document}
-\begin{titlepage}
-\center{\includegraphics{ps/axiomfront.ps}}
-\vskip 0.1in
-\includegraphics{ps/bluebayou.ps}\\
-\vskip 0.1in
-{\Huge{The 30 Year Horizon}}
-\vskip 0.1in
-$$
-\begin{array}{lll}
-Manuel\ Bronstein      & William\ Burge   & Timothy\ Daly \\
-James\ Davenport       & Michael\ Dewar   & Martin\ Dunstan \\
-Albrecht\ Fortenbacher & Patrizia\ Gianni & Johannes\ Grabmeier \\
-Jocelyn\ Guidry        & Richard\ Jenks   & Larry\ Lambe \\
-Michael\ Monagan       & Scott\ Morrison  & William\ Sit \\
-Jonathan\ Steinbach    & Robert\ Sutor    & Barry\ Trager \\
-Stephen\ Watt          & Jim\ Wen         & Clifton\ Williamson
-\end{array}
-$$
-\center{\large{VOLUME 5: THE AXIOM INTERPRETER}}
-\end{titlepage}
-\pagenumbering{roman}
-\begin{verbatim}
-The Blue Bayou image Copyright (c) 2004 Jocelyn Guidry
-
-Portions Copyright (c) 2004 Martin Dunstan
-
-Portions Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
-All rights reserved.
-
-This book and the Axiom software is licensed as follows:
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
-    - Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-
-    - Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-
-    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
-OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-\end{verbatim}
-\tableofcontents
-\vfill
-\eject
-\setlength{\parindent}{0em}
-\setlength{\parskip}{1ex}
-{\Large{\bf New Foreword}}
-\vskip .25in
-
-On October 1, 2001 Axiom was withdrawn from the market and ended
-life as a commercial product.
-On September 3, 2002 Axiom was released under the Modified BSD
-license, including this document.
-On August 27, 2003 Axiom was released as free and open source
-software available for download from the Free Software Foundation's
-website, Savannah.
-
-Work on Axiom has had the generous support of the Center for 
-Algorithms and Interactive Scientific Computation (CAISS) at
-City College of New York. Special thanks go to Dr. Gilbert 
-Baumslag for his support of the long term goal.
-
-The online version of this documentation is roughly 1000 pages.
-In order to make printed versions we've broken it up into three
-volumes. The first volume is tutorial in nature. The second volume
-is for programmers. The third volume is reference material. We've
-also added a fourth volume for developers. All of these changes
-represent an experiment in print-on-demand delivery of documentation.
-Time will tell whether the experiment succeeded.
-
-Axiom has been in existence for over thirty years. It is estimated to
-contain about three hundred man-years of research and has, as of
-September 3, 2003, 143 people listed in the credits. All of these
-people have contributed directly or indirectly to making Axiom
-available.  Axiom is being passed to the next generation. I'm looking
-forward to future milestones.
-
-With that in mind I've introduced the theme of the ``30 year horizon''.
-We must invent the tools that support the Computational Mathematician
-working 30 years from now. How will research be done when every bit of
-mathematical knowledge is online and instantly available? What happens
-when we scale Axiom by a factor of 100, giving us 1.1 million domains?
-How can we integrate theory with code? How will we integrate theorems
-and proofs of the mathematics with space-time complexity proofs and
-running code? What visualization tools are needed? How do we support
-the conceptual structures and semantics of mathematics in effective
-ways? How do we support results from the sciences? How do we teach
-the next generation to be effective Computational Mathematicians?
-
-The ``30 year horizon'' is much nearer than it appears.
-
-\vskip .25in
-%\noindent
-Tim Daly\\
-CAISS, City College of New York\\
-November 10, 2003 ((iHy))
-\vfill
-\eject
-\pagenumbering{arabic}
-\setcounter{chapter}{0} % Chapter 1
-\chapter{The Interpreter}
-\section{Star Global Variables}
-\begin{tabular}{lll}
-NAME                        & SET              & USE \\
-*default-pathname-defaults* & reroot           & restart \\
-*eof*                       & ncTopLevel       & \\
-*features*                  &                  & restart \\
-*package*                   &                  & restart \\
-*standard-input*            &                  & ncIntLoop \\
-*standard-output*           &                  & ncIntLoop \\
-*top-level-hook*            & set-restart-hook & \\
-\end{tabular}
-\subsection{*default-pathname-defaults*}
-The [[*default-pathname-defaults*]] variable is set by
-[[make-absolute-filename]] called on the empty string. This has
-the effect of setting the value to the [[AXIOM]] variable as this
-function just concatenates the [[AXIOM]] variable onto the given string.
-We pass this string to the common lisp [[pathname]] function to set it
-to a real pathname.
-
-The [[*default-pathname-defaults*]] defaults common lisp variable is
-set in [[restart]] to the current directory in most cases. If we are
-working in Lucid Common Lisp ([[:lucid]]) on an IBM/370 mainframe
-([[:ibm/370]]) then it is set to the empty string. Using Lucid on a 
-mainframe seems to use the variable [[vmlisp::$current-directory]].
-
-\subsection{*eof*}
-The [[*eof*]] variable is set to [[NIL]] in [[ncTopLevel]].
-\subsection{*features*}
-The [[*features*]] variable from common lisp is tested for the presence
-of the [[:unix]] keyword. Apparently this controls the use of Saturn,
-a previous Axiom frontend. The Saturn frontend was never released as
-open source and so this test and the associated variables are probably
-not used.
-
-\subsection{*package*}
-The [[*package*]] variable, from common lisp, is set in [[restart]]
-to the [[BOOT]] package where the intepreter lives.
-\subsection{*standard-input*}
-The [[*standard-input*]] common lisp variable is used to set the 
-[[curinstream]] variable in [[ncIntLoop]]. 
-
-This variable is an argument to [[serverReadLine]] in
-the [[intloopReadConsole]] function.
-
-\subsection{*standard-output*}
-The [[*standard-output*]] common lisp variable is used to set the 
-[[curoutstream]] variable in [[ncIntLoop]].
-
-\subsection{*top-level-hook*}
-The [[*top-level-hook*]] common lisp variable contains the name of
-a function to invoke when an image is started. In our case it is
-called [[restart]]. This is the entry point to the Axiom interpreter.
-
-\section{Dollar Global Variables}
-\begin{tabular}{lll}
-NAME                         & SET                 & USE \\
-\$boot                       & ncTopLevel          & \\
-coerceFailure                &                     & runspad \\
-curinstream                  & ncIntLoop           & \\
-curoutstream                 & ncIntLoop           & \\
-vmlisp::\$current-directory  & restart             & \\
-                             & reroot              & \\
-\$currentLine                & restart             & removeUndoLines \\
-\$dalymode                   &                     & intloopReadConsole \\
-\$defaultMsgDatabaseName     & reroot              & \\
-\$directory-list             & reroot              & \\
-\$displayStartMsgs           &                     & restart \\
-\$e                          & ncTopLevel          & \\
-\$erMsgToss                  & SpadInterpretStream & \\
-\$fn                         & SpadInterpretStream & \\
-\$frameRecord                & initvars            & \\
-                             & clearFrame          & \\
-                             & undoSteps           & undoSteps \\
-                             & recordFrame         & recordFrame \\
-\$HiFiAccess                 & initHist            & historySpad2Cmd \\
-                             & historySpad2Cmd     & \\
-                             &                     & setHistoryCore \\
-\$HistList                   & initHist            & \\
-\$HistListAct                & initHist            & \\
-\$HistListLen                & initHistList        & \\
-\$HistRecord                 & initHistList        & \\
-\$historyDirectory           &                     & makeHistFileName \\
-                             &                     & makeHistFileName \\
-\$historyFileType            & initvars           & histInputFileName \\
-\$inclAssertions             & SpadInterpretStream & \\
-\$inLispVM                   & spad                & \\
-\$InteractiveFrame           & restart             & ncTopLevel \\
-                             & undo                & recordFrame \\
-                             & undoSteps           & undoSteps \\
-                             &                     & reportUndo \\
-\$InteractiveMode            & ncTopLevel          & \\
-\$internalHistoryTable       & initvars            & \\
-\$interpreterFrameName       & initializeInterpreterFrameRing & \\
-\$interpreterFrameRing       & initializeInterpreterFrameRing & \\
-\$InitialModemapFrame        &                     & makeInitialModemapFrame \\
-\$intRestart                 &                     & intloop \\
-\$intTopLevel                & intloop             & \\
-\$IOindex                    & restart             & historySpad2Cmd \\
-                             & removeUndoLines     & undoCount \\
-\$genValue                   & bookvol5            & i-toplev \\
-                             &                     & i-analy \\
-                             &                     & i-syscmd \\
-                             &                     & i-spec1 \\
-                             &                     & i-spec2 \\
-                             &                     & i-map \\
-\$lastPos                    & SpadInterpretStream & \\
-\$libQuiet                   & SpadInterpretStream & \\
-\$library-directory-list     & reroot              & \\
-\$msgDatabaseName            & reroot              * \\
-\$ncMsgList                  & SpadInterpretStream & \\
-\$newcompErrorCount          & SpadInterpretStream & \\
-\$newcompMode                & SpadInterpretStream & \\
-\$newspad                    & ncTopLevel          & \\
-\$nopos                      &                     & SpadInterpretStream \\
-\$okToExecuteMachineCode     & SpadInterpretStream & \\
-\$oldHistoryFileName         & initvars            & oldHistFileName \\
-\$openServerIfTrue           & restart             & restart \\
-                             & spad-save           & \\
-                             & initvars            & \\
-\$options                    &                     & history \\
-                             & historySpad2Cmd     & historySpad2Cmd \\
-                             &                     & undo \\
-\$previousBindings           & initvars            & \\
-                             & clearFrame          & \\
-                             & recordFrame         & recordFrame \\
-\$printLoadMsgs              & restart             & \\
-\$PrintCompilerMessageIfTrue & spad                & \\
-\$promptMsg                  & SpadInterpretStream & \\
-\$relative-directory-list    &                     & reroot \\
-\$relative-library-directory-list &                & reroot \\
-\$reportUndo                 & initvars            & diffAlist \\
-\$shoeReadLineFunction       & SpadInterpretStream & \\
-\$spad                       & ncTopLevel          & \\
-\$spadroot                   & reroot              & initroot \\
-                             &                     & make-absolute-filename \\
-                             &                     & reroot \\
-\$SpadServer                 & restart             & \\
-\$SpadServerName             & initvars            & restart \\
-\$systemCommandFunction      & SpadInterpretStream & \\
-top\_level                   &                     & runspad \\
-\$quitTag                    &                     & runspad \\
-\$useInternalHistoryTable    & initvars            & initHist \\
-                             & setHistoryCore      & setHistoryCore \\
-\$undoFlag                   & initvars            & recordFrame \\
-\end{tabular}
-
-\subsection{\$boot}
-The [[$boot]] variable is set to [[NIL]] in [[ncTopLevel]].
-
-\subsection{coerceFailure}
-The [[coerceFailure]] symbol is a catch tag used in [[runspad]]
-to catch an exit from [[ncTopLevel]].
-
-\subsection{curinstream}
-The [[curinstream]] variable is set to the value of the 
-[[*standard-input*]] common lisp
-variable in [[ncIntLoop]]. While not using the
-``dollar'' convention this variable is still ``global''.
-
-\subsection{curinstream}
-The [[curoutstream]] variable is set to the value of the 
-[[*standard-output*]] common lisp variable in [[ncIntLoop]].
-While not using the ``dollar'' convention this variable is still ``global''.
-
-\subsection{vmlisp::\$current-directory}
-When running in Lucid Common Lisp ([[:lucid]]) on an IBM/370 mainframe
-([[:ibm/370]]) this variable is used in place of the 
-[[*default-pathname-defaults*]] common lisp variable. 
-Otherwise this variable is
-set to the empty string in [[restart]]. 
-
-The [[reroot]] function sets this variable to the value of
-[[$spadroot]] which itself has the value of the argument to the
-[[reroot]] function. Since the argument to the [[reroot]] function is
-an string which represents an absolute pathname pointing to AXIOM the
-net result is that the [[$current-directory]] is set to point to the
-shell [[AXIOM]] variable.
-
-So during execute both [[$current-directory]] and [[$spadroot]] reflect
-the value of the [[AXIOM]] shell variable.
-
-\subsection{\$currentLine}
-The [[$currentLine]] line is set to [[NIL]] in [[restart]].
-It is used in [[removeUndoLines]] in the undo mechanism.
-
-\subsection{\$dalymode}
-The [[$dalymode]] variable is used in a case statement in 
-[[intloopReadConsole]]. This variable can be set to any non-nil
-value. When not nil the interpreter will send any line that begins
-with an ``[[(]]'' to be sent to the underlying lisp. This is useful
-for debugging Axiom. The normal value of this variable is [[NIL]].
-
-This variable was created as an alternative to prefixing every lisp
-command with [[)lisp]]. When doing a lot of debugging this is tedious
-and error prone. This variable was created to shortcut that process.
-Clearly it breaks some semantics of the language accepted by the
-interpreter as parens are used for grouping expressions.
-
-\subsection{\$defaultMsgDatabaseName}
-The [[$defaultMsgDatabaseName]] is the absolute path to the 
-[[s2-us.msgs]] file which contains all of the english language
-messages output by the system.
-
-\subsection{\$directory-list}
-The [[$directory-list]] is a list of absolute directory names.
-These names are made absolute by mapping the [[make-absolute-filename]]
-over the variable [[$relative-directory-list]].
-
-\subsection{\$displayStartMsgs}
-The [[$displayStartMsgs]] variable is used in [[restart]] but is not
-set so this is likely a bug.
-
-\subsection{\$e}
-The [[$e]] variable is set to the value of
-[[$InteractiveFrame]] which is set in [[restart]] to the value of the
-call to the [[makeInitialModemapFrame]] function. This function simply
-returns a copy of the variable [[$InitialModemapFrame]].
-
-Thus [[$e]] is a copy of the variable [[$InitialModemapFrame]].
-
-This variable is used in the undo mechanism.
-
-\subsection{\$erMsgToss}
-The [[$erMsgToss]] variable is set to [[NIL]] in [[SpadInterpretStream]].
-
-\subsection{\$fn}
-The [[$fn]] variable is set in [[SpadInterpretStream]]. It is set to
-the second argument which is a list. It appears that this list has the
-same structure as an argument to the LispVM [[rdefiostream]] function.
-
-\subsection{\$frameRecord}
-[[$frameRecord = [delta1, delta2,... ] ]] where
-[[delta(i)]] contains changes in the ``backwards'' direction.
-Each [[delta(i)]] has the form [[((var . proplist)...)]] where
-proplist denotes an ordinary proplist. For example, an entry
-of the form [[((x (value) (mode (Integer)))...)]] indicates that
-to undo 1 step, [[x]]'s value is cleared and its mode should be set
-to [[(Integer)]].
-
-A [[delta(i)]] of the form [[(systemCommand . delta)]] is a special
-delta indicating changes due to system commands executed between
-the last command and the current command. By recording these deltas
-separately, it is possible to undo to either BEFORE or AFTER
-the command. These special [[delta(i)]]s are given ONLY when a
-a system command is given which alters the environment.
-
-Note: [[recordFrame('system)]] is called before a command is executed, and
-[[recordFrame('normal)]] is called after (see processInteractive1).
-If no changes are found for former, no special entry is given.
-
-This is part of the undo mechanism.
-
-\subsection{\$genValue}
-If the [[$genValue]] variable is true then evaluate generated code,
-otherwise leave code unevaluated. If [[$genValue]] is false then we
-are compiling. This variable is only defined and used locally.
-<<initvars>>=
-(defvar |$genValue| nil "evaluate generated code if true")
-
-@
-
-\subsection{\$HiFiAccess}
-The [[$HiFiAccess]] is set by [[initHist]] to [[T]]. It is a flag
-used by the history mechanism to record whether the history function
-is currently on. It can be reset by using the axiom
-command
-\begin{verbatim}
-  )history off
-\end{verbatim}
-It appears that the name means ``History File Access''.
-
-The [[$HiFiAccess]] variable is used by [[historySpad2Cmd]] to check
-whether history is turned on. [[T]] means it is, [[NIL]] means it is not.
-
-\subsection{\$HistList}
-Thie [[$HistList]] variable is set by [[initHistList]] to an initial
-value of [[NIL]] elements. The last element of the list is smashed to
-point to the first element to make the list circular.
-This is a circular list of length [[$HistListLen]].
-
-\subsection{\$HistListAct}
-The [[$HistListAct]] variable is set by [[initHistList]] to [[0]].
-This variable holds the actual number of elements in the history list.
-This is the number of ``undoable'' steps.
-
-\subsection{\$HistListLen}
-The [[$HistListLen]] variable is set by [[initHistList]] to [[20]].
-This is the length of a circular list maintained in the variable
-[[$HistList]].
-
-\subsection{\$HistRecord}
-The [[$HistRecord]] variable is set by [[initHistList]] to [[NIL]].
-[[$HistRecord]] collects the input line, all variable bindings
-and the output of a step, before it is written to the file named by
-the function [[histFileName]].
-
-\subsection{\$historyFileType}
-The [[$historyFileType]] is set at load time by a call to 
-[[initvars]] to a value of ``[[axh]]''. It appears that this
-is intended to be used as a filetype extension.
-It is part of the history mechanism. It is used in [[makeHistFileName]]
-as part of the history file name.
-
-\subsection{\$inclAssertions}
-The [[$inclAssertions]] is set 
-in the function [[SpadInterpretStream]] to the list [[(aix |CommonLisp|)]]
-
-\subsection{\$internalHistoryTable}
-The [[$internalHistoryTable]] variable is set at load time by a call to
-[[initvars]] to a value of [[NIL]].
-It is part of the history mechanism.
-
-\subsection{\$interpreterFrameName}
-The [[$interpreterFrameName]] variable, set in 
-[[initializeInterpreterFrameRing]] to the constant
-[[initial]] to indicate that this is the initial (default) frame.
-
-Frames are structures that capture all of the variables defined in a
-session. There can be multiple frames and the user can freely switch
-between them. Frames are kept in a ring data structure so you can 
-move around the ring.
-
-\subsection{\$interpreterFrameRing}
-The [[$interpreterFrameRing]] is set to a pair whose car is set to
-the result of [[emptyInterpreterFrame]]
-
-\subsection{\$InitialModemapFrame}
-This variable is copied and returned by the function 
-[[makeInitialModemapFrame]]. There is no initial value so this
-is probably a bug.
-
-\subsection{\$inLispVM}
-The [[$inLispVM]] is set to [[NIL]] in [[spad]]. LispVM is a
-non-common lisp that runs on IBM/370 mainframes. This is probably dead
-code.  It appears that this list has the same structure as an argument
-to the LispVM [[rdefiostream]] function.
-
-\subsection{\$InteractiveFrame}
-The [[$InteractiveFrame]] is set in [[restart]] to the value of the
-call to the [[makeInitialModemapFrame]] function. This function simply
-returns a copy of the variable [[$InitialModemapFrame]]
-
-\subsection{\$InteractiveMode}
-The [[$InteractiveMode]] is set to [[T]] in [[ncTopLevel]].
-
-\subsection{\$intRestart}
-The [[$intRestart]] variable is used in [[intloop]] but has no value.
-This is probably a bug. While the variable's value is unchanged the
-system will continually reenter the [[SpadInterpretStream]] function.
-
-\subsection{\$intTopLevel}
-The [[$intTopLevel]] is a catch tag. Throwing to this tags which is
-caught in the [[intloop]] will 
-restart the [[SpadInterpretStream]] function.
-
-\subsection{\$IOindex}
-The [[$IOindex]] index variable is set to [[1]] in [[restart]].
-This variable is used in the [[historySpad2Cmd]] function in the
-history mechanism. It is set in the [[removeUndoLines]] function
-in the undo mechanism.
-
-This is used in the undo mechanism in function [[undoCount]]
-to compute the number of undos. You can't undo more actions then
-have already happened.
-
-\subsection{\$lastPos}
-The [[$lastPos]] variable is set in [[SpadInterpretStream]]
-to the value of the [[$nopos]] variable.
-Since [[$nopos]] appears to have no value
-this is likely a bug.
-
-\subsection{\$libQuiet}
-The [[$libQuiet]] variable is set to the third argument of the
-[[SpadInterpretStream]] function. This is passed from [[intloop]]
-with the value of [[T]]. This variable appears to be intended to
-control the printing of library loading messages which would need
-to be suppressed if input was coming from a file.
-
-\subsection{\$library-directory-list}
-The [[$library-directory-list]] variable is set by [[reroot]] by
-mapping the function [[make-absolute-filename]] across the 
-[[$relative-library-directory-list]] variable which is not yet set so this
-is probably a bug.
-
-\subsection{\$msgDatabaseName}
-The [[$msgDatabaseName]] is set to [[NIL]] in [[reroot]].
-
-\subsection{\$ncMsgList}
-The [[$ncMsgList]] is set to [[NIL]] in [[SpadInterpretStream]].
-
-\subsection{\$newcompErrorCount}
-The [[$newcompErrorCount]] is set to [[0]] in [[SpadInterpretStream]].
-
-\subsection{\$newcompMode}
-The [[$newcompMode]] is set to [[NIL]] in [[SpadInterpretStream]].
-
-\subsection{\$newspad}
-The [[$newspad]] is set to [[T]] in [[ncTopLevel]].
-
-\subsection{\$nopos}
-The [[$nopos]] variable is used in [[SpadInterpretStream]] but does
-not appear to have a value and is likely a bug.
-
-\subsection{\$oldHistoryFileName}
-The [[$oldHistoryFileName]] is set at load time by a call to 
-[[initvars]] to a value of ``[[last]]''. 
-It is part of the history mechanism. It is used in the function
-[[oldHistFileName]] and [[restoreHistory]].
-
-\subsection{\$okToExecuteMachineCode}
-The [[$okToExecuteMachineCode]] is set to [[T]] in [[SpadInterpretStream]].
-
-\subsection{\$options}
-The [[$options]] variable is tested by the [[history]] function.
-If it is [[NIL]] then output the message 
-\begin{verbatim}
-  You have not used the correct syntax for the history command.
-  Issue )help history for more information.
-\end{verbatim}
-
-The [[$options]] variable is tested in the [[historySpad2Cmd]] function.
-It appears to record the options that were given to a spad command on
-the input line. The function [[selectOptionLC]] appears to take a list
-off options to scan.
-
-This variable is not yet set and is probably a bug.
-
-\subsection{\$previousBindings}
-The [[$previousBindings]] is a copy of the 
-[[CAAR $InteractiveFrame]]. This is used to
-compute the [[delta(i)]]s stored in [[$frameRecord]].
-This is part of the undo mechanism.
-
-\subsection{\$printLoadMsgs}
-The [[$printLoadMsgs]] variable is set to [[T]] in [[restart]].
-
-\subsection{\$PrintCompilerMessageIfTrue}
-The [[$PrintCompilerMessageIfTrue]] variable is set to [[NIL]] in [[spad]].
-
-\subsection{\$openServerIfTrue}
-The [[$openServerIfTrue]] is tested in [[restart]] before it has been
-set (and is thus a bug). It appears to control whether the interpreter
-will be used as an open server, probably for OpenMath use.
-
-If an open server is not requested then this variable to [[NIL]]
-
-\subsection{\$promptMsg}
-The [[$promptMsg]] variable is set to the constant [[S2CTP023]]. This 
-constant points to a message in [[src/doc/msgs/s2-us.msgs]]. This message
-does nothing but print the argument value.
-
-\subsection{\$relative-directory-list}
-The [[$relative-directory-list]] is used in [[reroot]] to create 
-[[$directory-list]] which is a list of absolute directory names.
-It is not yet set and is probably a bug.
-
-\subsection{\$relative-library-directory-list}
-The [[$relative-library-directory-list]] is used in [[reroot]] to create
-a list of absolute directory names from [[$library-directory-list]] (which is 
-It is not yet set and is probably a bug).
-
-\subsection{\$reportUndo}
-The [[$reportUndo]] variable is used in [[diffAlist]]. It was not normally
-bound but has been set to [[T]] in [[initvars]]. If the variable is set
-to [[T]] then we call [[reportUndo]].
-
-It is part of the undo mechanism.
-
-\subsection{\$shoeReadLineFunction}
-The [[$shoeReadLineFunction]] is set in [[SpadInterpretStream]]
-to point to the 
-[[serverReadLine]] 
-
-\subsection{\$spadroot}
-The [[$spadroot]] variable is the internal name for the [[AXIOM]]
-shell variable. 
-
-The [[$spadroot]] variable is set in [[reroot]] to the value of the
-argument. The argument is expected to be a directory name. 
-
-The [[$spadroot]] variable is tested in [[initroot]].
-
-The [[$spadroot]] variable is used by the function 
-[[make-absolute-filename]]. It concatenates this variable to the 
-front of a relative pathname to make it absolute.
-\subsection{\$spad}
-The [[$spad]] variable is set to [[T]] in [[ncTopLevel]].
-
-\subsection{\$SpadServer}
-If an open server is not requested then this variable to [[T]].
-It has no value before this time (and is thus a bug).
-
-\subsection{\$SpadServerName}
-The [[$SpadServerName]] is passed to the [[openServer]] function, if the
-function exists. 
-
-\subsection{\$systemCommandFunction}
-The [[$systemCommandFunction]] is set in [[SpadInterpretStream]]
-to point to the function
-[[InterpExecuteSpadSystemCommand]].
-
-\subsection{top\_level}
-The [[top\_level]] symbol is a catch tag used in [[runspad]]
-to catch an exit from [[ncTopLevel]].
-
-\subsection{\$quitTag}
-The [[$quitTag]] is used as a variable in a [[catch]] block. 
-It appears that it can be thrown somewhere below [[ncTopLevel]].
-
-\subsection{\$useInternalHistoryTable}
-The [[$useInternalHistoryTable]] variable is set at load time by a call to
-[[initvars]] to a value of [[NIL]]. It is part of the history mechanism.
-
-\subsection{\$undoFlag}
-The [[$undoFlag]] is used in [[recordFrame]] to decide whether to do
-undo recording. It is initially set to [[T]] in [[initvars]].
-This is part of the undo mechanism.
-
-\chapter{Starting Axiom}
-Axiom starts by invoking a function value of the lisp symbol
-[[*top-level-hook*]]. The function invocation path to from this
-point until the prompt is approximates (skipping initializations):
-\begin{verbatim}
-  lisp -> restart
-       -> |spad|
-       -> |runspad|
-       -> |ncTopLevel|
-       -> |ncIntLoop|
-       -> |intloop|
-       -> |SpadInterpretStream|
-       -> |intloopReadConsole|
-\end{verbatim}
-The [[|intloopReadConsole|]] function does tail-recursive calls to
-itself (don't break this) and never exits.
-\section{Variables Used}
-\section{Data Structures}
-\section{Functions}
-\subsection{defun set-restart-hook}
-When a lisp image containing code is reloaded there is a hook to
-allow a function to be called. In our case it is the [[restart]]
-function which is the entry to the Axiom interpreter.
-<<defun set-restart-hook>>=
-(defun set-restart-hook ()
-  #+KCL (setq system::*top-level-hook* 'restart)
-  #+Lucid (setq boot::restart-hook 'restart)
-  'restart
- )
-
-@
-\subsection{defun restart}
-The restart function is the real root of the world. It sets up memory
-if we are working in a GCL/akcl version of the system. It sets the
-current package to be the ``BOOT'' package which is the standard
-package in which the interpreter runs. It calls initroot \cite{1}
-to set the \$spadroot variable (usually the \$AXIOM variable).
-
-The [[compiler::*compile-verbose*]] flag has been set to nil globally.
-We do not want to know about the microsteps of GCL's compile facility.
-
-The [[compiler::*suppress-compiler-warnings*]] flag has been set to t.
-We do not care that certain generated variables are not used.
-
-The [[compiler::*suppress-compiler-notes*]] flag has been set to t.
-We do not care that tail recursion occurs.
-<<defun restart>>=
-(defun restart ()
-#+:akcl
-  (init-memory-config :cons 500 :fixnum 200 :symbol 500 :package 8
-    :array 400 :string 500 :cfun 100 :cpages 3000 :rpages 1000 :hole 2000)
-#+:akcl (setq compiler::*compile-verbose* nil)
-#+:akcl (setq compiler::*suppress-compiler-warnings* t)
-#+:akcl (setq compiler::*suppress-compiler-notes* t)
-#-:CCL
-  (in-package "BOOT")
-#+:CCL
-  (setq *package* (find-package "BOOT"))
-#+:CCL (setpchar "") ;; Turn off CCL read prompts
-#+(OR :akcl :CCL) (initroot)
-#+:akcl (system:gbc-time 0)
-#+:akcl
-  (when (and $openServerIfTrue (fboundp '|openServer|))
-   (prog (os)
-    (setq os (|openServer| $SpadServerName))
-    (if (zerop os) 
-     (progn 
-      (setq $openServerIfTrue nil) 
-      (setq |$SpadServer| t)))))
-;; We do the following test at runtime to allow us to use the same images
-;; with Saturn and Sman.  MCD 30-11-95
-#+:CCL
-  (when 
-     (and (memq :unix *features*) $openServerIfTrue (fboundp '|openServer|))
-   (prog (os)
-    (setq os (|openServer| $SpadServerName))
-    (if (zerop os) 
-     (progn 
-      (setq $openServerIfTrue nil) 
-      (setq |$SpadServer| t)))))
-  (setq |$IOindex| 1)
-  (setq |$InteractiveFrame| (|makeInitialModemapFrame|))
-  (setq |$printLoadMsgs| t)
-#+(and :lucid :ibm/370)
-  (setq *default-pathname-defaults* "")
-#+:CCL
-  (setq *default-pathname-defaults* (get-current-directory))
-#-(or :CCL (and :lucid :ibm/370))
-  (setq *default-pathname-defaults* (probe-file "./"))
-#+(and :lucid :ibm/370)
-  (setq vmlisp::$current-directory "")
-#-(and :lucid :ibm/370)
-  (setq vmlisp::$current-directory
-     (make-directory *default-pathname-defaults*))
-  (|loadExposureGroupData|)
-  (|statisticsInitialization|)
-  (|initHist|)
-  (|initializeInterpreterFrameRing|)
-
-  (when |$displayStartMsgs| 
-   (|spadStartUpMsgs|))
-  (setq |$currentLine| nil)
-  (restart0)
-  (|readSpadProfileIfThere|)
-  (|spad|))
-
-@
-\subsection{defun spad}
-\begin{verbatim}
-spad() ==
-  -- starts the interpreter but does not read in profiles, etc.
-  $PrintCompilerMessageIfTrue: local
-  $inLispVM : local := nil
-  setOutputAlgebra "%initialize%"
-  runspad()
-  'EndOfSpad
-\end{verbatim}
-<<defun spad>>=
-(defun |spad| () 
- (prog (|$PrintCompilerMessageIfTrue| |$inLispVM|) 
-  (declare (special |$PrintCompilerMessageIfTrue| |$inLispVM|)) 
-   (return 
-    (progn 
-     (spadlet |$PrintCompilerMessageIfTrue| nil) 
-     (spadlet |$inLispVM| nil) 
-     (|setOutputAlgebra| '|%initialize%|) 
-     (|runspad|) 
-     '|EndOfSpad|))))
-
-@
-\subsection{defun runspad}
-\begin{verbatim}
-runspad() ==
-  mode:='restart
-  while mode='restart repeat
-    resetStackLimits()
-    CATCH($quitTag, CATCH('coerceFailure,
-                  mode:=CATCH('top__level, ncTopLevel())))
-\end{verbatim}
-<<defun runspad>>=
-(defun |runspad| () 
- (prog (mode) 
-  (return 
-   (seq 
-    (progn 
-     (spadlet mode '|restart|) 
-     (do () 
-         ((null (boot-equal mode '|restart|)) NIL)
-      (seq 
-       (exit 
-        (progn 
-         (|resetStackLimits|) 
-         (catch |$quitTag| 
-          (catch '|coerceFailure| 
-           (spadlet mode (catch '|top_level| (|ncTopLevel|))))))))))))))
-
-@
-\subsection{defun ncTopLevel}
-\begin{verbatim}
-ncTopLevel() ==
--- Top-level read-parse-eval-print loop for the interpreter.  Uses
--- the Bill Burge's parser.
-  IN_-STREAM: fluid := CURINSTREAM
-  _*EOF_*: fluid := NIL
-  $InteractiveMode :fluid := true
-  $BOOT: fluid := NIL
-  $NEWSPAD: fluid := true
-  $SPAD: fluid := true
-  $e:fluid := $InteractiveFrame
-  ncIntLoop()
-\end{verbatim}
-<<defun ncTopLevel>>=
-(defun |ncTopLevel| ()
- (prog (|$e| $spad $newspad $boot |$InteractiveMode| *eof* in-stream) 
-  (declare (special |$e| $spad $newspad $boot |$InteractiveMode| *eof*
-             in-stream |$InteractiveFrame|)) 
-   (return
-    (progn 
-     (setq in-stream curinstream) 
-     (setq *eof* nil) 
-     (setq |$InteractiveMode| t) 
-     (setq $boot nil) 
-     (setq $newspad t) 
-     (setq $spad t) 
-     (setq |$e| |$InteractiveFrame|) 
-     (|ncIntLoop|)))))
-
-@
-\subsection{defun ncIntLoop}
-<<defun ncIntLoop>>=
-(defun |ncIntLoop| ()
-  (let ((curinstream *standard-output*)
-	(curoutstream *standard-input*))
-    (declare (special curinstream curoutstream))
-    (|intloop|)))
-
-@
-\subsection{defun intloop}
-Note that the [[SpadInterpretStream]] function uses a list of 
-three strings as an argument. The values in the list seem to have
-no use and can eventually be removed. 
-\begin{verbatim}
-intloop () ==
-    mode := $intRestart
-    while mode = $intRestart repeat
-      resetStackLimits()
-      mode := CATCH($intTopLevel,
-                    SpadInterpretStream(1, ["TIM", "DALY", "?"], true))
-
-\end{verbatim}
-<<defun intloop>>=
-(defun |intloop| () 
- (prog (mode) 
-  (declare (special |$intTopLevel| |$intRestart|)) 
-   (return 
-    (progn 
-     (setq mode |$intRestart|) 
-     ((lambda () 
-       (loop 
-        (cond 
-         ((not (equal mode |$intRestart|))
-           (return nil))
-         (t
-           (progn 
-             (|resetStackLimits|) 
-             (setq mode 
-               (catch |$intTopLevel| 
-                 (|SpadInterpretStream| 1 
-                   (list 'tim  'daly '?) t)))))))))))))
-
-@
-\subsection{defun SpadInterpretStream}
-The [[SpadInterpretStream]] function takes three arguments
-\begin{list}{}
-\item [[str]] This is passed as an argument to [[intloopReadConsole]]
-\item [[source]] This is the name of a source file but appears not
-to be used. It is set to the list [[(tim daly ?)]].
-\item [[interactive?]] If this is false then various messages are 
-suppressed and input does not use piles. If this is true then the
-library loading routines might output messages and piles are expected
-on input (as from a file).
-\end{list}
-\begin{verbatim}
-SpadInterpretStream(str, source, interactive?) ==
-    $fn              : local := source
-    pile?                    := not interactive?
-    $libQuiet        : local := not interactive?
-    $newcompMode     : local := false
---  following seems useless and causes ccl package problems
---    $InteractiveMode : local := false
- 
-    $newcompErrorCount: local := 0 -- SMW Feb 2/90.
-                                   -- Used in highComplete, ncHardError etc.
- 
-    $okToExecuteMachineCode: local := true -- set false on error
-    $inclAssertions: local := ["AIX", "CommonLisp"] -- Jan 28/90
- 
- 
-    $lastPos               : local := $nopos   ------------>!!!
-    $erMsgToss             : local := false --------------->!!!
-    $ncMsgList             : local := nil
- 
-    $systemCommandFunction : local := function InterpExecuteSpadSystemCommand
-    $shoeReadLineFunction  : local := function serverReadLine
-    $promptMsg             : local := 'S2CTP023
- 
-    interactive? =>
-                PRINC(MKPROMPT())
-                intloopReadConsole('"", str)
-                []
-    intloopInclude (source,0)
-    []
- 
-    -----------------------------------------------------------------
-\end{verbatim}
-<<defun SpadInterpretStream>>=
-(defun |SpadInterpretStream| (str source interactive?) 
- (prog (|$promptMsg| |$shoeReadLineFunction| |$systemCommandFunction| 
-        |$ncMsgList| |$erMsgToss| |$lastPos| |$inclAssertions| 
-        |$okToExecuteMachineCode| |$newcompErrorCount| |$newcompMode| 
-        |$libQuiet| |$fn|)
-  (declare (special |$promptMsg| |$shoeReadLineFunction| 
-            |$systemCommandFunction| |$ncMsgList| |$erMsgToss| |$lastPos| 
-            |$inclAssertions| |$okToExecuteMachineCode| |$newcompErrorCount| 
-            |$newcompMode| |$libQuiet| |$fn| |$nopos|))
-   (return 
-    (progn 
-     (setq |$fn| source) 
-     (setq |$libQuiet| (null interactive?)) 
-     (setq |$newcompMode| nil) 
-     (setq |$newcompErrorCount| 0) 
-     (setq |$okToExecuteMachineCode| t) 
-     (setq |$inclAssertions| (list 'aix '|CommonLisp|)) 
-     (setq |$lastPos| |$nopos|) 
-     (setq |$erMsgToss| nil) 
-     (setq |$ncMsgList| nil) 
-     (setq |$systemCommandFunction| #'|InterpExecuteSpadSystemCommand|) 
-     (setq |$shoeReadLineFunction| #'|serverReadLine|) 
-     (setq |$promptMsg| 'S2CTP023) 
-     (cond 
-      (interactive? 
-       (progn 
-        (princ (mkprompt)) 
-        (|intloopReadConsole| "" str) 
-        nil))
-      (t 
-       (progn 
-        (|intloopInclude| source 0) 
-        nil)))))))
-
-@
-\section{The Read-Eval-Print Loop}
-\subsection{defun intloopReadConsole}
-Note that this function relies on the fact that lisp can do tail-recursion.
-The function recursively invokes itself.
-
-The serverReadLine function is a special readline function that handles
-communication with the session manager code, which is a separate process
-running in parallel. 
-
-We read a line from standard input.
-\begin{itemize}
-\item If it is a null line then we exit Axiom.
-\item If it is a zero length line we prompt and recurse
-\item If \$dalymode and open-paren we execute lisp code, prompt and recurse
-The \$dalymode will interpret any input that begins with an open-paren
-as a lisp expression rather than Axiom input. This is useful for debugging
-purposes when most of the input lines will be lisp. Setting \$dalymode
-non-nil will certainly break user expectations and is to be used with 
-caution.
-\item If it is ``)fi'' or ``)fin'' we drop into lisp. Use the (restart)
-      function to return to the interpreter loop.
-\item If it starts with ``)'' we process the command, prompt, and recurse
-\item If it is a command then we remember the current line, process the
-      command, prompt, and recurse.
-\item If the input has a trailing underscore (Axiom line-continuation)
-      then we cut off the continuation character and pass the truncated
-      string to ourselves, prompt, and recurse
-\item otherwise we process the input, prompt, and recurse.
-\end{itemize}
-Notice that all but two paths (a null input or a ``)fi'' or a ``)fin'')
-will end up as a recursive call to ourselves.
-<<defun intloopReadConsole>>=
-(defun |intloopReadConsole| (b n) 
- (declare (special $dalymode)) 
- (let (c d pfx input) 
-   (setq input (|serverReadLine| *standard-input*)) 
-   (when (null (stringp input)) (|leaveScratchpad|)) 
-   (when (eql (length input) 0) 
-     (princ (mkprompt)) 
-     (|intloopReadConsole| "" n))
-   (when (and $dalymode (|intloopPrefix?| "(" input))
-     (|intnplisp| input) 
-     (princ (mkprompt)) 
-     (|intloopReadConsole| "" n))
-   (setq pfx (|intloopPrefix?| ")fi" input))
-   (when (and pfx (or (string= pfx ")fi") (string= pfx ")fin")))
-     (throw '|top_level| nil))
-   (when (and (equal b "") (setq d (|intloopPrefix?| ")" input)))
-     (|setCurrentLine| d) 
-     (setq c (|ncloopCommand| d n)) 
-     (princ (mkprompt)) 
-     (|intloopReadConsole| "" c))
-   (setq input (concat b input)) 
-   (when (|ncloopEscaped| input) 
-     (|intloopReadConsole| (subseq input 0 (- (length input) 1)) n))
-   (setq c (|intloopProcessString| input n)) 
-   (princ (mkprompt)) 
-   (|intloopReadConsole| "" c)))
-
-@
-\section{Helper Functions}
-\subsection{defun getenviron}
-<<defun getenviron>>=
-(defun getenviron (shellvar)
- #+allegro (sys::getenv (string var))
- #+clisp (ext:getenv (string var))
- #+(or cmu scl)
-  (cdr 
-   (assoc (string var) ext:*environment-list* :test #'equalp :key #'string))
- #+(or kcl akcl gcl) (si::getenv (string var))
- #+lispworks (lw:environment-variable (string var))
- #+lucid (lcl:environment-variable (string var))
- #+mcl (ccl::getenv var)
- #+sbcl (sb-ext:posix-getenv var)
- )
-@
-
-\subsection{defun init-memory-config}
-Austin-Kyoto Common Lisp (AKCL), now known as Gnu Common Lisp (GCL)
-requires some changes to the default memory setup to run Axiom efficently.
-This function performs those setup commands. 
-<<defun init-memory-config>>=
-(defun init-memory-config (&key
-			   (cons 500)
-			   (fixnum 200)
-			   (symbol 500)
-			   (package 8)
-			   (array 400)
-			   (string 500)
-			   (cfun 100)
-			   (cpages 3000)
-			   (rpages 1000)
-			   (hole 2000) )
-  ;; initialize AKCL memory allocation parameters
-  #+:AKCL
-  (progn
-    (system:allocate 'cons cons)
-    (system:allocate 'fixnum fixnum)
-    (system:allocate 'symbol symbol)
-    (system:allocate 'package package)
-    (system:allocate 'array array)
-    (system:allocate 'string string)
-    (system:allocate 'cfun cfun)
-    (system:allocate-contiguous-pages cpages)
-    (system:allocate-relocatable-pages rpages)
-    (system:set-hole-size hole))
-  #-:AKCL
-  nil)
-
-@
-
-\subsection{defun initroot}
-Sets up the system to use the {\bf AXIOM} shell variable if we can
-and default to the {\bf \$spadroot} variable (which was the value
-of the {\bf AXIOM} shell variable at build time) if we can't.
-<<defun initroot>>=
-(defun initroot (&optional (newroot (BOOT::|getEnv| "AXIOM")))
-  (reroot (or newroot $spadroot (error "setenv AXIOM or (setq $spadroot)"))))
-
-@
-
-\subsection{defun intloopPrefix?}
-If the prefix string is the same as the whole string initial characters
-(ignoring spaces in the whole string) then we return the whole string
-minus any leading spaces.
-<<defun intloopPrefix?>>=
-(defun |intloopPrefix?| (prefix whole)
- (let ((newprefix (string-left-trim '(#\space) prefix))
-       (newwhole  (string-left-trim '(#\space) whole)))
-  (when (<= (length newprefix) (length newwhole))
-   (when (string= newprefix newwhole :end2 (length prefix))
-    newwhole))))
-
-@
-\subsection{defun loadExposureGroupData}
-<<defun loadExposureGroupData>>=
-#+:AKCL
-(defun |loadExposureGroupData| ()
- (cond
-  ((load "./exposed" :verbose nil :if-does-not-exist nil)
-    '|done|)
-  ((load (concat (system:getenv "AXIOM") "/algebra/exposed")
-     :verbose nil :if-does-not-exist nil)
-   '|done|)
-  (t '|failed|) ))
-
-#+:CCL
-(defun |loadExposureGroupData| ()
- (cond
-  ((load "./exposed.lsp" :verbose NIL :if-does-not-exist NIL) '|done|)
-  ((load (concat (BOOT::|getEnv| "AXIOM") "/../../src/algebra/exposed.lsp") 
-    :verbose nil :if-does-not-exist nil) '|done|)
-  (t nil) ))
-
-@
-
-\subsection{make-absolute-filename}
-Prefix a filename with the {\bf AXIOM} shell variable.
-<<defun make-absolute-filename>>=
-(defun make-absolute-filename (name)
- (concatenate 'string $spadroot name))
-
-@
-
-\subsection{defun makeInitialModemapFrame}
-\begin{verbatim}
-makeInitialModemapFrame() == COPY $InitialModemapFrame
-\end{verbatim}
-<<defun makeInitialModemapFrame>>=
-(defun |makeInitialModemapFrame| ()
-  (copy |$InitialModemapFrame|)) 
-
-@
-
-\subsection{defun ncloopEscaped}
-The ncloopEscaped function will return true if the last non-blank
-character of a line is an underscore, the Axiom line-continuation
-character. Otherwise, it returns nil.
-<<defun ncloopEscaped>>=
-(defun |ncloopEscaped| (x)
- (let ((l (length x)))
-  (dotimes (i l)
-   (when (char= (char x (- l i 1)) #\_) (return t))
-   (unless (char= (char x (- l i 1)) #\space) (return nil)))))
-
-@
-
-\subsection{defun reclaim}
-Call the garbage collector on various platforms.
-<<defun reclaim>>=
-#+abcl 
-(defun reclaim () (ext::gc))
-#+:allegro
-(defun reclaim () (excl::gc t))
-#+:CCL
-(defun reclaim () (gc))
-#+clisp
-(defun reclaim () (#+lisp=cl ext::gc #-lisp=cl lisp::gc))
-#+(or :cmulisp :cmu)
-(defun reclaim () (ext:gc))
-#+cormanlisp
-(defun reclaim () (cl::gc))
-#+(OR IBCL KCL GCL)
-(defun reclaim () (si::gbc t))
-#+lispworks 
-(defun reclaim () (hcl::normal-gc))
-#+Lucid
-(defun reclaim () (lcl::gc))
-#+sbcl
-(defun reclaim () (sb-ext::gc))
-@
-
-\subsection{defun reroot}
-The reroot function is used to reset the important variables used by
-the system. In particular, these variables are sensitive to the
-{\bf AXIOM} shell variable. That variable is renamed internally to
-be {\bf \$spadroot}. The {\bf reroot} function will change the
-system to use a new root directory and will have the same effect
-as changing the {\bf AXIOM} shell variable and rerunning the system
-from scratch. Note that we have changed from the
-NAG distribution back to the original form. If you need the NAG
-version you can push {\bf :tpd} on the {\bf *features*} variable
-before compiling this file. A correct call looks like:
-\begin{verbatim}
-(in-package "BOOT")
-(reroot "/spad/mnt/${SYS}")
-\end{verbatim}
-where the [[${SYS}]] variable is the same one set at build time.
-<<defun reroot>>=
-(defun reroot (dir)
-  (setq $spadroot dir)
-  (setq $directory-list
-   (mapcar #'make-absolute-filename $relative-directory-list))
-  (setq $library-directory-list
-   (mapcar #'make-absolute-filename $relative-library-directory-list))
-  (setq |$defaultMsgDatabaseName|
-	(pathname (make-absolute-filename "/doc/msgs/s2-us.msgs")))
-  (setq |$msgDatabaseName| ())
-  (setq *default-pathname-defaults*
-	(pathname (make-absolute-filename "")))
-  (setq $current-directory $spadroot))
-
-@
-
-\subsection{defun setCurrentLine}
-Remember the current line. The cases are:
-\begin{itemize}
-\item If there is no \$currentLine set it to the input
-\item Is the current line a string and the input a string?
-      Make them into a list
-\item Is \$currentLine not a cons cell? Make it one.
-\item Is the input a string? Cons it on the end of the list.
-\item Otherwise stick it on the end of the list
-\end{itemize}
-Note I suspect the last two cases do not occur in practice since
-they result in a dotted pair if the input is not a cons. However,
-this is what the current code does so I won't change it.
-<<defun setCurrentLine>>=
-(defun |setCurrentLine| (s)
- (cond 
-  ((null |$currentLine|) 
-    (setq |$currentLine| s))
-  ((and (stringp |$currentLine|) (stringp s))
-    (setq |$currentLine| (list |$currentLine| s)))
-  ((not (consp |$currentLine|))
-    (setq |$currentLine| (cons |$currentLine| s)))
-  ((stringp s)
-    (rplacd (last |$currentLine|) (cons s nil)))
-  (t 
-    (rplacd (last |$currentLine|) s)))
- |$currentLine|)
-
-@
-
-\subsection{defun statisticsInitialization}
-<<defun statisticsInitialization>>=
-(defun |statisticsInitialization| () 
- "initialize the garbage collection timer"
- #+:akcl (system:gbc-time 0)
- nil)
-
-@
-\chapter{System Command Handling}
-\section{Variables Used}
-\subsection{defvar \$systemCommands}
-The system commands are the top-level commands available in Axiom
-that can all be invoked by prefixing the symbol with a closed-paren. 
-Thus, to see they copyright you type:
-\begin{verbatim}
-   )copyright
-\end{verbatim}
-New commands need to be added to this table. The command invoked will
-be the first entry of the pair and the ``user level'' of the command
-will be the second entry. 
-<<initvars>>=
-(defvar |$systemCommands| nil)
-
-(eval-when (eval load)
- (setq |$systemCommands|
- '(
-   (|abbreviations|		     . |compiler|   )
-   (|boot|			     . |development|)
-   (|browse|                         . |development|)
-   (|cd|			     . |interpreter|)
-   (|clear|			     . |interpreter|)
-   (|close|			     . |interpreter|)
-   (|compiler|			     . |compiler|   )
-   (|copyright|			     . |interpreter|)
-   (|credits|			     . |interpreter|)
-   (|display|			     . |interpreter|)
-   (|edit|			     . |interpreter|)
-   (|fin|			     . |development|)
-   (|frame|			     . |interpreter|)
-   (|help|			     . |interpreter|)
-   (|history|			     . |interpreter|)
-;; (|input|			     . |interpreter|)
-   (|lisp|			     . |development|)
-   (|library|			     . |interpreter|)
-   (|load|			     . |interpreter|)
-   (|ltrace|			     . |interpreter|)
-   (|pquit|			     . |interpreter|)
-   (|quit|			     . |interpreter|)
-   (|read|			     . |interpreter|)
-   (|savesystem|		     . |interpreter|)
-   (|set|			     . |interpreter|)
-   (|show|			     . |interpreter|)
-   (|spool|			     . |interpreter|)
-   (|summary|			     . |interpreter|)
-   (|synonym|			     . |interpreter|)
-   (|system|			     . |interpreter|)
-   (|trace|			     . |interpreter|)
-   (|undo|			     . |interpreter|)
-   (|what|			     . |interpreter|)
-   (|with|			     . |interpreter|)
-   (|workfiles|			     . |development|)
-   (|zsystemdevelopment| . |interpreter|)
- )))
-
-@
-
-\subsection{defvar \$SYSCOMMANDS}
-This table is used to look up a symbol to see if it might be a command.
-<<initvars>>=
-(defvar $SYSCOMMANDS nil)
-(eval-when (eval load)
- (setq $SYSCOMMANDS (mapcar #'car |$systemCommands|)))
-
-@
-\subsection{defvar \$noParseCommands}
-This is a list of the commands which have their arguments passed verbatim.
-Certain functions, such as the lisp function need to be able to handle
-all kinds of input that will not be acceptable to the interpreter. 
-<<initvars>>=
-(defvar |$noParseCommands| nil)
-(eval-when (eval load)
- (setq |$noParseCommands| 
- '( |boot|
-    |copyright|
-    |credits|
-    |fin|
-    |lisp|
-    |pquit|
-    |quit|
-    |suspend|
-    |synonym|
-    |system|
-    )))
-
-@
-\subsection{defvar \$tokenCommands}
-This is a list of the commands that expect the interpreter to parse
-their arguments. Thus the history command expects that Axiom will have
-tokenized and validated the input before calling the history function.
-<<initvars>>=
-(defvar |$tokenCommands| nil)
-(eval-when (eval load)
- (setq |$tokenCommands|
- '( |abbreviations|
-    |cd|
-    |clear|
-    |close|
-    |compiler|
-    |depends|
-    |display|
-    |edit|
-    |frame|
-    |frame|
-    |help|
-    |history|
-    |input|
-    |library|
-    |load|
-    |ltrace|
-    |read|
-    |savesystem|
-    |set|
-    |spool|
-    |undo|
-    |what|
-    |with|
-    |workfiles|
-    |zsystemdevelopment|
-    )))
-
-@
-
-\subsection{defvar \$InitialCommandSynonymAlist}
-Axiom can create ``synonyms'' for commands. We create an initial table
-of synonyms which are in common use.
-<<initvars>>=
-(defvar |$InitialCommandSynonymAlist| nil)
-(eval-when (eval load)
- (setq |$InitialCommandSynonymAlist|
-   '(
-       (|?|	     . "what commands")
-       (|ap|	     . "what things")
-       (|apr|	     . "what things")
-       (|apropos|    . "what things")
-       (|cache|	     . "set functions cache")
-       (|cl|	     . "clear")
-       (|cls|	     . "zsystemdevelopment )cls")
-       (|cms|	     . "system")
-       (|co|	     . "compiler")
-       (|d|	     . "display")
-       (|dep|	     . "display dependents")
-       (|dependents| . "display dependents")
-       (|e|	     . "edit")
-       (|expose|     . "set expose add constructor")
-       (|fc|	     . "zsystemdevelopment )c")
-       (|fd|	     . "zsystemdevelopment )d")
-       (|fdt|	     . "zsystemdevelopment )dt")
-       (|fct|	     . "zsystemdevelopment )ct")
-       (|fctl|	     . "zsystemdevelopment )ctl")
-       (|fe|	     . "zsystemdevelopment )e")
-       (|fec|	     . "zsystemdevelopment )ec")
-       (|fect|	     . "zsystemdevelopment )ect")
-       (|fns|	     . "exec spadfn")
-       (|fortran|    . "set output fortran")
-       (|h|	     . "help")
-       (|hd|	     . "system hypertex &")
-       (|kclam|	     . "boot clearClams ( )")
-       (|killcaches| . "boot clearConstructorAndLisplibCaches ( )")
-       (|patch|	     . "zsystemdevelopment )patch")
-       (|pause|	     . "zsystemdevelopment )pause")
-       (|prompt|     . "set message prompt")
-       (|recurrence| . "set functions recurrence")
-       (|restore|    . "history )restore")
-       (|save|	     . "history )save")
-       (|startGraphics|    .  "system $AXIOM/lib/viewman &")
-       (|startNAGLink|     .  "system $AXIOM/lib/nagman &")
-       (|stopGraphics|     .  "lisp (|sockSendSignal| 2 15)")
-       (|stopNAGLink|      .  "lisp (|sockSendSignal| 8 15)")
-       (|time|	     . "set message time")
-       (|type|	     . "set message type")
-       (|unexpose|   . "set expose drop constructor")
-       (|up|	     . "zsystemdevelopment )update")
-       (|version|    . "lisp *yearweek*")
-       (|w|	     . "what")
-       (|wc|	     . "what categories")
-       (|wd|	     . "what domains")
-       (|who|        . "lisp (pprint credits)")
-       (|wp|	     . "what packages")
-       (|ws|	     . "what synonyms")
-)))
-
-@
-\subsection{defvar \$CommandSynonymAlist}
-The actual list of synonyms is initialized to be the same as the 
-above initial list of synonyms. The user synonyms that are added
-during a session are pushed onto this list for later lookup.
-<<initvars>>=
-(defvar |$CommandSynonymAlist| nil)
-(eval-when (eval load)
- (setq |$CommandSynonymAlist| (copy-alist |$InitialCommandSynonymAlist|)))
-
-@
-\section{Functions}
-\subsection{defun ncloopCommand}
-The \$systemCommandFunction is set in SpadInterpretStream
-to point to the function InterpExecuteSpadSystemCommand.
-<<defun ncloopCommand>>=
-(defun |ncloopCommand| (line n)
- (declare (special |$systemCommandFunction|))
- (let (a)
-  (cond
-   ((setq a (|ncloopPrefix?| ")include" line))
-     (|ncloopInclude1| a n))
-   (t
-     (funcall |$systemCommandFunction| line)
-     n))))
-
-@
-\subsection{defun ncloopPrefix?}
-If we find the prefix string in the whole string starting at position zero
-we return the remainder of the string without the leading prefix.
-<<defun ncloopPrefix?>>=
-(defun |ncloopPrefix?| (prefix whole)
- (when (eql (search prefix whole) 0)
-  (subseq whole (length prefix))))
-
-@
-\subsection{defun ncloopInclude1}
-<<defun ncloopInclude1>>=
-(defun |ncloopInclude1| (name n)
- (let (a)
-  (if (setq a (|ncloopIncFileName| name))
-    (|ncloopInclude| a n)
-    n)))
-
-@
-\subsection{defun ncloopIncFileName}
-Returns the first non-blank substring of the given string.
-<<defun ncloopIncFileName>>=
-(defun |ncloopIncFileName| (string)
- (let (fn)
-  (unless (setq fn (|incFileName| string))
-   (write-line (concat string " not found")))
- fn))
-
-@
-
-\subsection{defun ncloopInclude}
-Open the file and read it in. The ncloopInclude0 function is part
-of the parser and lives in int-top.boot.
-<<defun ncloopInclude>>=
-(defun |ncloopInclude| (name n)
-  (with-open-file (st name) (|ncloopInclude0| st name n)))
-
-@
-
-\subsection{defun incFileName}
-Given a string we return the first token from the string which is
-the first non-blank substring.
-<<defun incFileName>>=
-(defun |incFileName| (x)
-  (car (|incBiteOff| x)))
-
-@
-
-\subsection{defun incBiteOff}
-Takes a sequence and returns the a list of the first token and the
-remaining string characters. If there are no remaining string characters
-the second string is of length 0. Effectively it "bites off" the first 
-token in the string. If the string only 0 or more blanks it returns nil.
-<<defun incBiteOff>>=
-(defun |incBiteOff| (x)
- (let (blank nonblank)
-  (setq x (string x))
-  (when (setq nonblank (position #\space x :test-not #'char=))
-    (setq blank (position #\space x :start nonblank))
-    (if blank
-     (list (subseq x nonblank blank) (subseq x blank))
-     (list (subseq x nonblank) "")))))
-
-@
-\chapter{The Display Command}
-\section{)display}
-\begin{verbatim}
-  )display abbreviations 
-  )display abbreviations [obj]
-  )display all
-  )display macros
-  )display mode all
-  )display mode [obj1 [obj2 ...]]
-  )display names
-  )display operations opname
-  )display properties
-  )display properties all
-  )display properties [obj1 [obj2 ...]]
-  )display value all
-  )display value [obj1 [obj2 ...]]
-\end{verbatim}
-
-This command is used to display the contents of the workspace and
-signatures of functions with a given name. A signature gives the
-argument and return types of a function.
-
-The command
-\begin{verbatim}
-  )display abbreviations 
-  )display abbreviations [obj]
-\end{verbatim}
-will show all of the abbreviations in the current workspace.
-
-The command
-\begin{verbatim}
-  )display all 
-\end{verbatim}
-is equivalent to 
-\begin{verbatim}
-  )display properties
-\end{verbatim}
-
-The command
-\begin{verbatim}
-  )display macros
-\end{verbatim}
-will show all of the macros in the current workspace.
-
-
-The command
-\begin{verbatim}
-  )display names
-\end{verbatim}
-lists the names of all user-defined objects in the workspace. This is
-useful if you do not wish to see everything about the objects and need
-only be reminded of their names.
-
-To just show the declared mode of ``d'', issue
-\begin{verbatim}
-  )display mode d
-\end{verbatim}
-
-All modemaps for a given operation may be displayed by using
-\begin{verbatim}
-  )display operations
-\end{verbatim}
-
-A modemap is a collection of information about a particular reference
-to an operation. This includes the types of the arguments and the
-return value, the location of the implementation and any conditions on
-the types. The modemap may contain patterns. The following displays
-the modemaps for the operation {\bf complex}:
-\begin{verbatim}
-  )d op complex
-\end{verbatim}
-
-In addition to the modemaps for an operation the request to display
-an operation will be followed by examples of the operation from each
-domain.
-
-The commands
-\begin{verbatim}
-  )display all
-  )display properties
-  )display properties all
-\end{verbatim}
-all do the  same thing: show the values and types and declared modes
-of all variables in the workspace. If you have defined functions,
-their signatures and definitions will also be displayed.
-
-To show all information about a particular variable or user functions,
-for example, something named ``d'', issue
-\begin{verbatim}
-  )display properties d
-\end{verbatim}
-
-To just show the value (and the type) of ``d'', issue
-\begin{verbatim}
-  )display value d
-\end{verbatim}
-\section{Variables Used}
-\subsection{defvar \$displayOptions}
-The current value of \$displayOptions is
-
-<<initvars>>=
-(defvar |$displayOptions| 
- '(|abbreviations| |all| |macros| |modes| |names| |operations| 
-   |properties| |types| |values|))
-
-@
-
-\section{Data Structures}
-\section{Functions}
-\subsection{defun display}
-This trivial function satisfies the standard pattern of making a
-user command match the name of the function which implements the
-command. That command immediatly invokes a ``Spad2Cmd'' version.
-<<defun display>>=
-(defun |display| (l)
- (displaySpad2Cmd l)) 
-
-@
-
-\subsection{displaySpad2Cmd}
-We process the options to the command and call the appropriate
-display function. There are really only 4 display functions.
-All of the other options are just subcases.
-
-There is a slight mismatch between the \$displayOptions list of
-symbols and the options this command accepts so we have a cond
-branch to clean up the option variable.
-
-If we fall all the way thru we use the \$displayOptions list
-to construct a list of strings for the sayMessage function
-and tell the user what options are available.
-<<defun displaySpad2Cmd>>=
-(defun displaySpad2Cmd (l)
- (declare (special |$e|))
- (let ((|$e| |$EmptyEnvironment|) (opt (car l)) (vl (cdr l)) 
-       option optList msg)
-  (if (and (pairp l) (not (eq opt '?)))
-   (progn
-    (setq option (|selectOptionLC| opt |$displayOptions| '|optionError|))
-    (cond
-     ((eq option '|all|)
-       (setq l (list '|properties|))
-       (setq option '|properties|))
-     ((or (eq option '|modes|) (eq option '|types|))
-       (setq l (cons '|type| vl))
-       (setq option '|type|))
-     ((eq option '|values|)
-       (setq l (cons '|value| vl))
-       (setq option '|value|)))
-    (cond 
-     ((eq option '|abbreviations|)
-      (if (null vl)
-        (|listConstructorAbbreviations|)
-        (dolist (v vl) (|abbQuery| (|opOf| v)))))
-     ((eq option '|operations|) (|displayOperations| vl))
-     ((eq option '|macros|) (|displayMacros| vl))
-     ((eq option '|names|) (|displayWorkspaceNames|))
-     (t (|displayProperties| option l))))
-   (|sayMessage|
-    (append 
-      '("  )display keyword arguments are")
-      (mapcar #'(lambda (x) (format nil "~%     ~a" x)) |$displayOptions|)
-      (format nil "~%  or abbreviations thereof"))))))
-
-@
-\subsection{defun displayOperations}
-This function takes a list of operation names. If the list is null
-we query the user to see if they want all operations printed. Otherwise
-we print the information for the requested symbols.
-<<defun displayOperations>>=
-(defun |displayOperations| (l)
- (if l
-  (dolist (op l) (|reportOpSymbol| op))
-  (if (yesanswer)
-   (dolist (op (|allOperations|)) (|reportOpSymbol| op))
-   (|sayKeyedMsg| 's2iz0059 nil))))
-
-@
-\subsection{defun yesanswer}
-This is a trivial function to simplify the logic of displaySpad2Cmd.
-If the user didn't supply an argument to the )display op command
-we ask if they wish to have all information about all Axiom operations
-displayed. If the answer is either Y or YES we return true else nil.
-<<defun yesanswer>>=
-(defun yesanswer ()
- (memq (string2id-n (upcase (|queryUserKeyedMsg| 's2iz0058 nil)) 1) '(y yes)))
-
-@
-
-\subsection{defun displayMacros}
-;displayMacros names ==
-;  imacs := getInterpMacroNames()
-;  pmacs := getParserMacroNames()
-;  macros :=
-;     null names => APPEND (imacs, pmacs)
-;     names
-;  macros := REMDUP macros
-;  null macros => sayBrightly '"   There are no Axiom macros."
-;  -- first do user defined ones
-;  first := true
-;  for macro in macros repeat
-;    macro in pmacs =>
-;        if first then
-;            sayBrightly ['%l,'"User-defined macros:"]
-;            first := NIL
-;        displayParserMacro macro
-;    macro in imacs => 'iterate
-;    sayBrightly (["   ",'%b, macro, '%d, " is not a known Axiom macro."])
-;  -- now system ones
-;  first := true
-;  for macro in macros repeat
-;    macro in imacs =>
-;        macro in pmacs => 'iterate
-;        if first then
-;            sayBrightly ['%l,'"System-defined macros:"]
-;            first := NIL
-;        displayMacro macro
-;    macro in pmacs => 'iterate
-;  NIL
-<<defun displayMacros>>=
-(defun |displayMacros| (names)
- (let (imacs pmacs macros first)
-  (setq imacs (|getInterpMacroNames|))
-  (setq pmacs (|getParserMacroNames|))
-  (if names
-    (setq macros names)
-    (setq macros (append imacs pmacs)))
-  (setq macros (remdup macros))
-  (cond
-   ((null macros) (|sayBrightly| "   There are no Axiom macros."))
-   (t
-     (setq first t)
-     (do ((t0 macros (cdr t0)) (macro nil))
-         ((or (atom t0) (progn (setq macro (car t0)) nil)) nil)
-      (seq
-       (exit
-        (cond
-         ((|member| macro pmacs)
-           (cond
-            (first (|sayBrightly| (cons '|%l| (cons "User-defined macros:" nil))) (setq first nil)))
-           (|displayParserMacro| macro))
-         ((|member| macro imacs) '|iterate|)
-         (t (|sayBrightly| (cons "   " (cons '|%b| (cons macro (cons '|%d| (cons " is not a known Axiom macro." nil)))))))))))
-     (setq first t)
-     (do ((t1 macros (cdr t1)) (macro nil))
-         ((or (atom t1) (progn (setq macro (car t1)) nil)) nil)
-      (seq
-       (exit
-        (cond
-         ((|member| macro imacs)
-           (cond
-            ((|member| macro pmacs) '|iterate|)
-            (t 
-             (cond
-              (first
-               (|sayBrightly|
-                (cons '|%l|
-                 (cons "System-defined macros:" nil))) (setq first nil)))
-             (|displayMacro| macro))))
-         ((|member| macro pmacs) '|iterate|)))))
-     nil)))) 
-
-@
-\chapter{The History Mechanism}
-\section{)history}
-\index{ugSysCmdhistory}
-
-\index{history}
-
-
-\par\noindent{\bf User Level Required:} interpreter
-
-\par\noindent{\bf Command Syntax:}
-\begin{list}{}
-\item{\tt )history )on}
-\item{\tt )history )off}
-\item{\tt )history )write} {\it historyInputFileName}
-\item{\tt )history )show [{\it n}] [both]}
-\item{\tt )history )save} {\it savedHistoryName}
-\item{\tt )history )restore} [{\it savedHistoryName}]
-\item{\tt )history )reset}
-\item{\tt )history )change} {\it n}
-\item{\tt )history )memory}
-\item{\tt )history )file}
-\item{\tt \%}
-\item{\tt \%\%({\it n})}
-\item{\tt )set history on | off}
-\end{list}
-
-\par\noindent{\bf Command Description:}
-
-The {\it history} facility within Axiom allows you to restore your
-environment to that of another session and recall previous
-computational results.
-Additional commands allow you to review previous
-input lines and to create an {\bf .input} file of the lines typed to
-\index{file!input}
-Axiom.
-
-Axiom saves your input and output if the history facility is
-turned on (which is the default).
-This information is saved if either of
-\begin{verbatim}
-)set history on
-)history )on
-\end{verbatim}
-has been issued.
-Issuing either
-\begin{verbatim}
-)set history off
-)history )off
-\end{verbatim}
-will discontinue the recording of information.
-\index{history )on}
-\index{set history on}
-\index{set history off}
-\index{history )off}
-
-Whether the facility is disabled or not,
-the value of {\tt \%} in Axiom always
-refers to the result of the last computation.
-If you have not yet entered anything,
-{\tt \%} evaluates to an object of type
-{\tt Variable('\%)}.
-The function {\tt \%\%} may be  used to refer
-to other previous results if the history facility is enabled.
-In that case,
-{\tt \%\%(n)} is  the output from step {\tt n} if {\tt n > 0}.
-If {\tt n < 0}, the step is computed relative to the current step.
-Thus {\tt \%\%(-1)} is also the previous step,
-{\tt \%\%(-2)}, is the  step before that, and so on.
-If an invalid step number is given, Axiom will signal an error.
-
-The {\it environment} information can either be saved in a file or entirely in
-memory (the default).
-Each frame 
-(\ref{ugSysCmdframe} on page~\pageref{ugSysCmdframe})
-has its own history database.
-When it is kept in a file, some of it may also be kept in memory for
-efficiency.
-When the information is saved in a file, the name of the file is
-of the form {\bf FRAME.axh} where ``{\bf FRAME}'' is the name of the
-current frame.
-The history file is placed in the current working directory
-(see \ref{ugSysCmdcd} on page~\pageref{ugSysCmdcd}).
-Note that these history database files are not text files (in fact,
-they are directories themselves), and so are not in human-readable
-format.
-
-The options to the {\tt )history} command are as follows:
-
-\begin{description}
-\item[{\tt )change} {\it n}]
-will set the number of steps that are saved in memory to {\it n}.
-This option only has effect when the history data is maintained in a
-file.
-If you have issued {\tt )history )memory} (or not changed the default)
-there is no need to use {\tt )history )change}.
-\index{history )change}
-
-\item[{\tt )on}]
-will start the recording of information.
-If the workspace is not empty, you will be asked to confirm this
-request.
-If you do so, the workspace will be cleared and history data will begin
-being saved.
-You can also turn the facility on by issuing {\tt )set history on}.
-
-\item[{\tt )off}]
-will stop the recording of information.
-The {\tt )history )show} command will not work after issuing this
-command.
-Note that this command may be issued to save time, as there is some
-performance penalty paid for saving the environment data.
-You can also turn the facility off by issuing {\tt )set history off}.
-
-\item[{\tt )file}]
-indicates that history data should be saved in an external file on disk.
-
-\item[{\tt )memory}]
-indicates that all history data should be kept in memory rather than
-saved in a file.
-Note that if you are computing with very large objects it may not be
-practical to kept this data in memory.
-
-\item[{\tt )reset}]
-will flush the internal list of the most recent workspace calculations
-so that the data structures may be garbage collected by the underlying
-Common Lisp system.
-Like {\tt )history )change}, this option only has real effect when
-history data is being saved in a file.
-
-\item[{\tt )restore} [{\it savedHistoryName}]]
-completely clears the environment and restores it to a saved session, if
-possible.
-The {\tt )save} option below allows you to save a session to a file
-with a given name. If you had issued
-{\tt )history )save jacobi}
-the command
-{\tt )history )restore jacobi}
-would clear the current workspace and load the contents of the named
-saved session. If no saved session name is specified, the system looks
-for a file called {\bf last.axh}.
-
-\item[{\tt )save} {\it savedHistoryName}]
-is used to save  a snapshot of the environment in a file.
-This file is placed in the current working directory
-(see \ref{ugSysCmdcd} on page~\pageref{ugSysCmdcd}).
-Use {\tt )history )restore} to restore the environment to the state
-preserved in the file.
-This option also creates an input file containing all the lines of input
-since you created the workspace frame (for example, by starting your
-Axiom session) or last did a {\tt )clear all} or
-{\tt )clear completely}.
-
-\item[{\tt )show} [{\it n}] [{\tt both}]]
-can show previous input lines and output results.
-{\tt )show} will display up to twenty of the last input lines
-(fewer if you haven't typed in twenty lines).
-{\tt )show} {\it n} will display up to {\it n} of the last input lines.
-{\tt )show both} will display up to five of the last input lines and
-output results.
-{\tt )show} {\it n} {\tt both} will display up to {\it n} of the last
-input lines and output results.
-
-\item[{\tt )write} {\it historyInputFile}]
-creates an {\bf .input} file with the input lines typed since the start
-of the session/frame or the last {\tt )clear all} or {\tt )clear
-completely}.
-If {\it historyInputFileName} does not contain a period (``.'') in the filename,
-{\bf .input} is appended to it.
-For example,
-{\tt )history )write chaos}
-and
-{\tt )history )write chaos.input}
-both write the input lines to a file called {\bf chaos.input} in your
-current working directory.
-If you issued one or more {\tt )undo} commands,
-{\tt )history )write}
-eliminates all
-input lines backtracked over as a result of {\tt )undo}.
-You can edit this file and then use {\tt )read} to have Axiom process
-the contents.
-\end{description}
-
-\par\noindent{\bf Also See:}
-{\tt )frame} \index{ugSysCmdframe},
-{\tt )read} \index{ugSysCmdread},
-{\tt )set} \index{ugSysCmdset}, and
-{\tt )undo} \index{ugSysCmdundo}.
-
-
-History recording is done in two different ways:
-\begin{itemize}
-\item all changes in variable bindings (i.e. previous values) are
-    written to [[$HistList]], which is a circular list
-\item all new bindings (including the binding to [[%]]) are written to a
-    file called [[histFileName()]]
-    one older session is accessible via the file [[$oldHistFileName()]]
-\end{itemize}
-
-\section{Variables Used}
-The following global variables are used:
-\begin{list}{}
-\item [[$HistList]], [[$HistListLen]] and [[$HistListAct]] which is the
-       actual number of ``undoable'' steps)
-\item [[$HistRecord]] collects the input line, all variable bindings
-      and the output of a step, before it is written to the file
-      [[histFileName()]].
-\item [[$HiFiAccess]] is a flag, which is reset by [[)history )off]]
-\end{list}
-The result of step n can be accessed by [[%n]], which is translated
-into a call of [[fetchOutput(n)]]. The 
-[[updateHist]] is called after every interpreter step. The 
-[[putHist]] function records all changes in the environment to [[$HistList]]
-  and [[$HistRecord]]
- 
-\subsection{Initialized history variables}
-<<initvars>>=
-(defvar |$oldHistoryFileName| '|last| "vm/370 filename name component")
-(defvar |$historyFileType| '|axh|     "vm/370 filename type component")
-(defvar |$historyDirectory| 'A        "vm/370 filename disk component")
-(defvar |$HiFiAccess| t               "t means turn on history mechanism")
-(defvar |$useInternalHistoryTable| t  "t means keep history in core")
-
-@
-\section{Data Structures}
-\section{Functions}
-\subsection{defun makeHistFileName}
-\begin{verbatim}
-makeHistFileName(fname) ==
-  makePathname(fname,$historyFileType,$historyDirectory)
-\end{verbatim}
-<<defun makeHistFileName>>=
-(defun |makeHistFileName| (fname) 
- (|makePathname| fname |$historyFileType| |$historyDirectory|)) 
-
-@ 
-\subsection{defun oldHistFileName}
-\begin{verbatim}
-oldHistFileName() ==
-  makeHistFileName($oldHistoryFileName)
-\end{verbatim}
-<<defun oldHistFileName>>=
-(defun |oldHistFileName| ()
- (|makeHistFileName| |$oldHistoryFileName|)) 
-
-@
-\subsection{defun histFileName}
-\begin{verbatim}
-histFileName() ==
-  makeHistFileName($interpreterFrameName)
-\end{verbatim}
-<<defun histFileName>>=
-(defun |histFileName| () 
- (|makeHistFileName| |$interpreterFrameName|)) 
-
-@
-\subsection{defun histInputFileName}
-\begin{verbatim}
-histInputFileName(fn) ==
-  null fn =>
-    makePathname($interpreterFrameName,'INPUT,$historyDirectory)
-  makePathname(fn,'INPUT,$historyDirectory)
-\end{verbatim}
-<<defun histInputFileName>>=
-(defun |histInputFileName| (fn)
- (if (null fn)
-    (|makePathname| |$interpreterFrameName| 'input |$historyDirectory|)
-    (|makePathname| fn 'input |$historyDirectory|)))
-@
-
-\subsection{defun initHist}
-\begin{verbatim}
-initHist() ==
-  $useInternalHistoryTable => initHistList()
-  oldFile := oldHistFileName()
-  newFile := histFileName()
-  -- see if history directory is writable
-  histFileErase oldFile
-  if MAKE_-INPUT_-FILENAME newFile then $REPLACE(oldFile,newFile)
-  $HiFiAccess:= 'T
-  initHistList()
-\end{verbatim}
-<<defun initHist>>=
-(defun |initHist| ()
- (prog (oldFile newFile)
-  (return
-   (cond
-     (|$useInternalHistoryTable| 
-       (|initHistList|))
-     (t
-       (spadlet oldFile (|oldHistFileName|))
-       (spadlet newFile (|histFileName|))
-       (|histFileErase| oldFile)
-       (when (make-input-filename newFile)
-        ($replace oldFile newFile))
-       (spadlet |$HiFiAccess| t)
-       (|initHistList|)))))) 
- 
-@
-\subsection{defun initHistList}
-\begin{verbatim}
-initHistList() ==
-  -- creates $HistList as a circular list of length $HistListLen
-  -- and $HistRecord
-  $HistListLen:= 20
-  $HistList:= LIST NIL
-  li:= $HistList
-  for i in 1..$HistListLen repeat li:= CONS(NIL,li)
-  RPLACD($HistList,li)
-  $HistListAct:= 0
-  $HistRecord:= NIL
-\end{verbatim}
-<<defun initHistList>>=
-(defun |initHistList| () 
- (prog (li) 
-  (return 
-   (seq 
-    (progn 
-     (spadlet |$HistListLen| 20) 
-     (spadlet |$HistList| (list nil)) 
-     (spadlet li |$HistList|) 
-     (do ((|i| 1 (qsadd1 |i|))) 
-         ((qsgreaterp |i| |$HistListLen|) nil) 
-      (seq 
-       (exit 
-        (spadlet li (cons nil li)))))
-     (rplacd |$HistList| li) 
-     (spadlet |$HistListAct| 0) 
-     (spadlet |$HistRecord| NIL))))))
- 
-@
-\subsection{defun history}
-\begin{verbatim}
-history l ==
-  l or null $options => sayKeyedMsg("S2IH0006",NIL) 
-  historySpad2Cmd()
-\end{verbatim}
-<<defun history>>=
-(defun |history| (l) 
- (cond 
-  ((or l (null |$options|)) 
-    (|sayKeyedMsg| 'S2IH0006 nil)) ; syntax error
-  (t 
-    (|historySpad2Cmd|)))) 
-
-@
-\subsection{defun historySpad2Cmd}
-\begin{verbatim}
-historySpad2Cmd() ==
-  -- history is a system command which can call resetInCoreHist
-  -- and changeHistListLen, and restore last session
-  histOptions:=
-    '(on off yes no change reset restore write save show file memory)
-  opts:= [ [selectOptionLC(opt,histOptions,'optionError),:optargs]
-    for [opt,:optargs] in $options]
-  for [opt,:optargs] in opts repeat
-    opt in '(on yes) =>
-      $HiFiAccess => sayKeyedMsg("S2IH0007",NIL) 
-      $IOindex = 1 =>       -- haven't done anything yet
-        $HiFiAccess:= 'T
-        initHistList()
-        sayKeyedMsg("S2IH0008",NIL) 
-      x := UPCASE queryUserKeyedMsg("S2IH0009",NIL) 
-      MEMQ(STRING2ID_-N(x,1),'(Y YES)) =>
-        histFileErase histFileName()
-        $HiFiAccess:= 'T
-        $options := nil
-        clearSpad2Cmd '(all)
-        sayKeyedMsg("S2IH0008",NIL)
-        initHistList()
-      sayKeyedMsg("S2IH0010",NIL)
-    opt in '(off no) =>
-      null $HiFiAccess => sayKeyedMsg("S2IH0011",NIL)
-      $HiFiAccess:= NIL
-      disableHist()
-      sayKeyedMsg("S2IH0012",NIL)
-    opt = 'file    => setHistoryCore NIL
-    opt = 'memory  => setHistoryCore true
-    opt = 'reset   => resetInCoreHist()
-    opt = 'save    => saveHistory optargs
-    opt = 'show    => showHistory optargs
-    opt = 'change  => changeHistListLen first optargs
-    opt = 'restore => restoreHistory optargs
-    opt = 'write   => writeInputLines(optargs,1)
-  'done
-\end{verbatim}
-<<defun historySpad2Cmd>>=
-(defun |historySpad2Cmd| () 
- (prog (histOptions opts opt optargs x) 
-  (return 
-   (seq 
-    (progn 
-     (spadlet histOptions 
-       '(|on| |off| |yes| |no| |change| |reset| |restore| |write| 
-         |save| |show| |file| |memory|)) 
-     (spadlet opts 
-      (prog (tmp1) 
-        (spadlet tmp1 nil) 
-        (return 
-         (do ((tmp2 |$options| (cdr tmp2)) (tmp3 NIL))
-             ((or (atom tmp2) 
-                  (progn 
-                    (setq tmp3 (car tmp2)) 
-                    nil) 
-                  (progn 
-                   (progn 
-                    (spadlet opt (car tmp3)) 
-                    (spadlet optargs (cdr tmp3)) 
-                    tmp3) 
-                   nil))
-                (nreverse0 tmp1))
-          (seq 
-           (exit 
-            (setq tmp1 
-             (cons 
-               (cons 
-                 (|selectOptionLC| opt histOptions '|optionError|)
-                 optargs)
-               tmp1)))))))) 
-     (do ((tmp4 opts (cdr tmp4)) (tmp5 nil))
-         ((or (atom tmp4) 
-              (progn 
-                (setq tmp5 (car tmp4))
-                 nil) 
-              (progn 
-               (progn 
-                (spadlet opt (car tmp5)) 
-                (spadlet optargs (cdr tmp5)) 
-                tmp5) 
-               nil))
-           nil)
-       (seq 
-        (exit 
-         (cond 
-          ((|member| opt '(|on| |yes|))
-             (cond 
-              (|$HiFiAccess| 
-                (|sayKeyedMsg| 'S2IH0007 nil)) ; history already on
-              ((eql |$IOindex| 1) 
-                (spadlet |$HiFiAccess| t)
-                (|initHistList|)
-                (|sayKeyedMsg| 'S2IH0008 nil)) ; history now on
-              (t 
-                (spadlet x ; really want to turn history on?
-                  (upcase (|queryUserKeyedMsg| 'S2IH0009 nil)))
-                (cond 
-                 ((memq (string2id-n x 1) '(Y YES)) 
-                   (|histFileErase| (|histFileName|)) 
-                   (spadlet |$HiFiAccess| t)
-                   (spadlet |$options| nil) 
-                   (|clearSpad2Cmd| '(|all|))
-                   (|sayKeyedMsg| 'S2IH0008 nil) ; history now on
-                   (|initHistList|)) 
-                 (t 
-                   (|sayKeyedMsg| 'S2IH0010 nil)))))) ; history still off
-          ((|member| opt '(|off| |no|)) 
-            (cond 
-             ((null |$HiFiAccess|) 
-               (|sayKeyedMsg| 'S2IH0011 nil)) ; history already off
-             (t 
-               (spadlet |$HiFiAccess| nil) 
-               (|disableHist|) 
-               (|sayKeyedMsg| 'S2IH0012 nil)))) ; history now off
-          ((boot-equal opt '|file|)
-             (|setHistoryCore| nil)) 
-          ((boot-equal opt '|memory|)
-             (|setHistoryCore| t)) 
-          ((boot-equal opt '|reset|) 
-             (|resetInCoreHist|)) 
-          ((boot-equal opt '|save|) 
-             (|saveHistory| optargs)) 
-          ((boot-equal opt '|show|) 
-             (|showHistory| optargs)) 
-          ((boot-equal opt '|change|)
-             (|changeHistListLen| (CAR optargs))) 
-          ((boot-equal opt '|restore|)
-             (|restoreHistory| optargs)) 
-          ((boot-equal opt '|write|)
-             (|writeInputLines| optargs 1)))))) 
-     '|done|)))))
-
-@ 
-\subsection{defun setHistoryCore}
-We [[case]] on the [[inCore]] argument value
-\begin{list}{}
-\item If history is already on and is kept in the same location as requested
-(file or memory) then complain.
-\item If history is not in use then start using the file or memory as 
-requested. This is done by simply setting the [[$useInternalHistoryTable]] 
-to the requested value, where [[T]] means use memory and [[NIL]] means
-use a file. We tell the user.
-\item If history should be in memory, that is [[inCore]] is not [[NIL]],
-and the history file already contains information we read the information
-from the file, store it in memory, and erase the history file. We modify
-[[$useInternalHistoryTable]] to [[T]] to indicate that we're maintining
-the history in memory and tell the user.
-\item Otherwise history must be on and in memory. We erase any old history
-file and then write the in-memory history to a new file
-\end{list}
-\begin{verbatim}
-setHistoryCore inCore ==
-  inCore = $useInternalHistoryTable =>
-    sayKeyedMsg((inCore => "S2IH0030"; "S2IH0029"),NIL) 
-  not $HiFiAccess =>
-    $useInternalHistoryTable := inCore
-    inCore => sayKeyedMsg("S2IH0032",NIL)
-    sayKeyedMsg("S2IH0031",NIL)
-  inCore =>
-    $internalHistoryTable := NIL
-    if $IOindex ^= 0 then
-      -- actually put something in there
-      l := LENGTH RKEYIDS histFileName()
-      for i in 1..l repeat
-        vec:= UNWIND_-PROTECT(readHiFi(i),disableHist())
-        $internalHistoryTable := CONS([i,:vec],$internalHistoryTable)
-      histFileErase histFileName()
-    $useInternalHistoryTable := true
-    sayKeyedMsg("S2IH0032",NIL)
-  $HiFiAccess:= 'NIL
-  histFileErase histFileName()
-  str := RDEFIOSTREAM ['(MODE . OUTPUT),['FILE,:histFileName()]]
-  for [n,:rec] in reverse $internalHistoryTable repeat
-    SPADRWRITE(object2Identifier n,rec,str)
-  RSHUT str
-  $HiFiAccess:= 'T
-  $internalHistoryTable := NIL
-  $useInternalHistoryTable := NIL
-  sayKeyedMsg("S2IH0031",NIL)
-\end{verbatim}
-<<defun setHistoryCore>>=
-(defun |setHistoryCore| (inCore) 
- (prog (l vec str n rec) 
-  (cond 
-   ((boot-equal inCore |$useInternalHistoryTable|) 
-     (if inCore 
-        (|sayKeyedMsg| 'S2IH0030 NIL) ; memory history already in use
-        (|sayKeyedMsg| 'S2IH0029 NIL))) ; file history already in use
-   ((null |$HiFiAccess|) 
-     (spadlet |$useInternalHistoryTable| inCore) 
-     (if inCore 
-        (|sayKeyedMsg| 'S2IH0032 NIL) ; use memory history
-        (|sayKeyedMsg| 'S2IH0031 NIL))) ; use file history
-   (inCore 
-     (spadlet |$internalHistoryTable| nil) 
-     (cond 
-      ((nequal |$IOindex| 0) 
-        (spadlet l (length (rkeyids (|histFileName|)))) 
-        (do ((|i| 1 (qsadd1 |i|)))
-            ((qsgreaterp |i| l) NIL)
-         (seq 
-          (exit 
-           (progn 
-            (spadlet vec (unwind-protect (|readHiFi| |i|) (|disableHist|)))
-            (spadlet |$internalHistoryTable| 
-              (cons (cons |i| vec) |$internalHistoryTable|))))))
-         (|histFileErase| (|histFileName|)))) 
-     (spadlet |$useInternalHistoryTable| t) 
-     (|sayKeyedMsg| 'S2IH0032 nil)) ; use memory history
-   (t 
-     (spadlet |$HiFiAccess| nil)
-     (|histFileErase| (|histFileName|))
-     (spadlet str 
-      (rdefiostream 
-       (cons 
-         '(mode . output) 
-          (cons
-            (cons 'file (|histFileName|))
-             nil))))
-     (do ((tmp0 (reverse |$internalHistoryTable|) (cdr tmp0))
-          (tmp1 NIL))
-         ((or (atom tmp0) 
-              (progn 
-                (setq tmp1 (car tmp0))
-                nil) 
-              (progn 
-               (progn 
-                (spadlet n (car tmp1))
-                (spadlet rec (cdr tmp1))
-                tmp1) 
-               nil)) 
-              nil)
-       (seq 
-        (exit 
-         (spadrwrite (|object2Identifier| n) rec str))))
-     (rshut str)
-     (spadlet |$HiFiAccess| t)
-     (spadlet |$internalHistoryTable| nil)
-     (spadlet |$useInternalHistoryTable| nil)
-     (|sayKeyedMsg| 'S2IH0031 NIL))))) ; use file history
-
-@
-\subsection{defun writeInputLines}
-\begin{verbatim}
-writeInputLines(fn,initial) == 
-  -- writes all input lines into file histInputFileName()
-  not $HiFiAccess => sayKeyedMsg("S2IH0013",NIL) ; history not on
-  null fn =>
-    throwKeyedMsg("S2IH0038", nil) ; missing file name
-  maxn := 72
-  breakChars := [" ","+"]
-  for i in initial..$IOindex - 1 repeat
-    vecl := CAR readHiFi i
-    if STRINGP vecl then vecl := [vecl]
-    for vec in vecl repeat
-      n := SIZE vec
-      while n > maxn repeat
-        -- search backwards for a blank
-        done := nil
-        for j in 1..maxn while ^done repeat
-          k := 1 + maxn - j
-          MEMQ(vec.k,breakChars) =>
-            svec := STRCONC(SUBSTRING(vec,0,k+1),UNDERBAR)
-            lineList := [svec,:lineList]
-            done := true
-            vec := SUBSTRING(vec,k+1,NIL)
-            n := SIZE vec
-        -- in case we can't find a breaking point
-        if ^done then n := 0
-      lineList := [vec,:lineList]
-  file := histInputFileName(fn)
-  histFileErase file
-  inp:= DEFIOSTREAM(['(MODE . OUTPUT),['FILE,:file]],255,0)
-  for x in removeUndoLines NREVERSE lineList repeat WRITE_-LINE(x,inp)
-  -- see file "undo" for definition of removeUndoLines
-  if fn ^= 'redo then sayKeyedMsg("S2IH0014",[namestring file])
-  SHUT inp
-  NIL
-\end{verbatim}
-<<defun writeInputLines>>=
-(defun |writeInputLines| (fn initial) 
- (prog (maxn breakChars vecl k svec done vec n lineList file inp) 
-  (return 
-   (seq 
-    (cond 
-     ((null |$HiFiAccess|)
-       (|sayKeyedMsg| 'S2IH0013 nil)) ; history is not on
-     ((null fn) 
-       (|throwKeyedMsg| 'S2IH0038 nil)) ; missing file name
-     (t 
-       (spadlet maxn 72)
-       (spadlet breakChars (cons '| | (cons '+ nil)))
-       (do ((tmp0 (spaddifference |$IOindex| 1))
-            (|i| initial (+ |i| 1)))
-           ((> |i| tmp0) nil)
-        (seq 
-         (exit 
-          (progn 
-           (spadlet vecl (car (|readHiFi| |i|)))
-           (cond
-            ((stringp vecl) (spadlet vecl (cons vecl nil))))
-           (do ((tmp1 vecl (cdr tmp1)) (vec nil))
-               ((or (atom tmp1) (progn (setq vec (car tmp1)) nil)) nil)
-            (seq 
-             (exit 
-              (progn 
-               (spadlet n (size vec))
-               (do () 
-                   ((null (> n maxn)) nil) 
-                (seq 
-                 (exit 
-                  (progn 
-                   (spadlet done nil)
-                   (do ((|j| 1 (qsadd1 |j|)))
-                       ((or (qsgreaterp |j| maxn) (null (null done))) nil)
-                    (seq 
-                     (exit 
-                      (progn 
-                       (spadlet k (spaddifference (plus 1 maxn) |j|))
-                       (cond 
-                        ((memq (ELT vec k) breakChars)
-                          (progn 
-                           (spadlet svec (strconc 
-                             (substring vec 0 (plus k 1)) underbar))
-                           (spadlet lineList (cons svec lineList))
-                           (spadlet done t)
-                           (spadlet vec (substring vec (plus k 1) nil))
-                           (spadlet n (size vec)))))))))
-                   (cond 
-                    ((null done) (spadlet n 0))
-                    (t nil))))))
-               (spadlet lineList (cons vec lineList))))))))))
-       (spadlet file (|histInputFileName| fn))
-       (|histFileErase| file)
-       (spadlet inp 
-        (defiostream 
-         (cons 
-          '(mode . output) 
-          (cons (cons 'file file) nil)) 255 0))
-       (do ((tmp2 (|removeUndoLines| (nreverse lineList)) (cdr tmp2))
-            (x nil)) 
-           ((or (atom tmp2) 
-                (progn 
-                 (setq x (car tmp2)) 
-                 nil))
-             nil) 
-        (seq 
-         (exit 
-          (write-line x inp))))
-       (cond 
-        ((nequal fn '|redo|) 
-          (|sayKeyedMsg| 'S2IH0014 ; edit this file to see input lines
-            (cons (|namestring| file) nil))))
-       (shut inp)
-       nil)))))) 
-
-@ 
-\subsection{defun resetInCoreHist}
-\begin{verbatim}
-resetInCoreHist() ==
-  -- removes all pointers from $HistList
-  $HistListAct:= 0
-  for i in 1..$HistListLen repeat
-    $HistList:= CDR $HistList
-    RPLACA($HistList,NIL)
-\end{verbatim}
-<<defun resetInCoreHist>>=
-(defun |resetInCoreHist| () 
- (seq 
-  (progn 
-   (spadlet |$HistListAct| 0) 
-   (do ((|i| 1 (qsadd1 |i|)))
-       ((qsgreaterp |i| |$HistListLen|) nil)
-    (seq
-     (exit
-      (progn
-       (spadlet |$HistList| (cdr |$HistList|))
-       (rplaca |$HistList| nil)))))))) 
-
-@
-\subsection{defun changeHistListLen}
-\begin{verbatim}
-changeHistListLen(n) ==
-  -- changes the length of $HistList.  n must be nonnegative
-  NULL INTEGERP n => sayKeyedMsg("S2IH0015",[n]) 
-  dif:= n-$HistListLen
-  $HistListLen:= n
-  l:= CDR $HistList
-  if dif > 0 then
-    for i in 1..dif repeat l:= CONS(NIL,l)
-  if dif < 0 then
-    for i in 1..-dif repeat l:= CDR l
-    if $HistListAct > n then $HistListAct:= n
-  RPLACD($HistList,l)
-  'done
-\end{verbatim}
-<<defun changeHistListLen>>=
-(defun |changeHistListLen| (n)
- (prog (dif l) 
-  (return
-   (seq
-    (cond
-     ((null (integerp n)) 
-       (|sayKeyedMsg| 'S2IH0015 (cons n nil))) ; only positive integers
-     (t 
-       (spadlet dif (spaddifference n |$HistListLen|))
-       (spadlet |$HistListLen| n) 
-       (spadlet l (cdr |$HistList|)) 
-       (cond 
-        ((> dif 0) 
-          (do ((|i| 1 (qsadd1 |i|)))
-              ((qsgreaterp |i| dif) nil)
-           (seq
-            (exit
-             (spadlet l (cons nil l)))))))
-       (cond
-        ((minusp dif)
-          (do ((tmp0 (spaddifference dif)) 
-               (|i| 1 (qsadd1 |i|)))
-              ((qsgreaterp |i| tmp0) nil)
-           (seq
-            (exit
-             (spadlet l (cdr l)))))
-          (cond
-           ((> |$HistListAct| n) (spadlet |$HistListAct| n))
-           (t nil))))
-       (rplacd |$HistList| l) 
-       '|done|)))))) 
-
-@
-\subsection{defun updateHist}
-\begin{verbatim}
-updateHist() ==
-  -- updates the history file and calls updateInCoreHist
-  null $IOindex => nil
-  startTimingProcess 'history
-  updateInCoreHist()
-  if $HiFiAccess then
-    UNWIND_-PROTECT(writeHiFi(),disableHist())
-    $HistRecord:= NIL
-  $IOindex:= $IOindex+1
-  updateCurrentInterpreterFrame()
-  $mkTestInputStack := nil
-  $currentLine := nil
-  stopTimingProcess 'history
-\end{verbatim}
-<<defun updateHist>>=
-(defun |updateHist| () 
- (cond
-   ((null |$IOindex|) nil)
-   (t 
-     (|startTimingProcess| '|history|)
-     (|updateInCoreHist|)
-     (when |$HiFiAccess| 
-        (unwind-protect (|writeHiFi|) (|disableHist|))
-        (spadlet |$HistRecord| nil))
-     (spadlet |$IOindex| (plus |$IOindex| 1))
-     (|updateCurrentInterpreterFrame|)
-     (spadlet |$mkTestInputStack| nil)
-     (spadlet |$currentLine| nil)
-     (|stopTimingProcess| '|history|)))) 
-
-@
-\subsection{defun updateInCoreHist}
-\begin{verbatim}
-updateInCoreHist() ==
-  -- updates $HistList and $IOindex
-  $HistList:= CDR($HistList)
-  RPLACA($HistList,NIL)
-  if $HistListAct < $HistListLen then $HistListAct:= $HistListAct+1
-\end{verbatim}
-<<defun updateInCoreHist>>=
-(defun |updateInCoreHist| ()
- (progn
-  (spadlet |$HistList| (cdr |$HistList|))
-  (rplaca |$HistList| nil) 
-  (COND 
-   ((> |$HistListLen| |$HistListAct|) 
-     (spadlet |$HistListAct| (plus |$HistListAct| 1)))
-   (t nil)))) 
-
-@
-\subsection{defun putHist}
-\begin{verbatim}
-putHist(x,prop,val,e) ==
-  -- records new value to $HistRecord and old value to $HistList
-  -- then put is called with e
-  if not (x='%) then recordOldValue(x,prop,get(x,prop,e))
-  if $HiFiAccess then recordNewValue(x,prop,val)
-  putIntSymTab(x,prop,val,e)
-\end{verbatim}
-<<defun putHist>>=
-(defun |putHist| (x prop val e)
- (progn
-  (when (null (boot-equal x '%))
-    (|recordOldValue| x prop (|get| x prop e)))
-  (when |$HiFiAccess|
-    (|recordNewValue| x prop val))
-  (|putIntSymTab| x prop val e))) 
-
-@
-\subsection{defun recordNewValue}
-\begin{verbatim}
-recordNewValue(x,prop,val) ==
-  startTimingProcess 'history
-  recordNewValue0(x,prop,val)
-  stopTimingProcess 'history
-\end{verbatim}
-<<defun recordNewValue>>=
-(defun |recordNewValue| (x prop val)
- (progn 
-  (|startTimingProcess| '|history|)
-  (|recordNewValue0| x prop val)
-  (|stopTimingProcess| '|history|))) 
-
-@
-\subsection{defun recordNewValue0}
-\begin{verbatim}
-recordNewValue0(x,prop,val) ==
-  -- writes (prop . val) into $HistRecord
-  -- updateHist writes this stuff out into the history file
-  p1:= ASSQ(x,$HistRecord) =>
-    p2:= ASSQ(prop,CDR p1) =>
-      RPLACD(p2,val)
-    RPLACD(p1,CONS(CONS(prop,val),CDR p1))
-  p:= CONS(x,list CONS(prop,val))
-  $HistRecord:= CONS(p,$HistRecord)
-\end{verbatim}
-<<defun recordNewValue0>>=
-(defun |recordNewValue0| (x prop val)
- (prog (p1 p2 p)
-  (return 
-   (cond 
-    ((spadlet p1 (ASSQ x |$HistRecord|))
-      (cond 
-       ((spadlet p2 (assq prop (cdr p1))) (rplacd p2 val))
-       (t (rplacd p1 (cons (cons prop val) (cdr p1))))))
-    (t
-      (spadlet p (cons x (list (cons prop val))))
-      (spadlet |$HistRecord| (cons p |$HistRecord|))))))) 
-
-@
-\subsection{defun recordOldValue}
-\begin{verbatim}
-recordOldValue(x,prop,val) ==
-  startTimingProcess 'history
-  recordOldValue0(x,prop,val)
-  stopTimingProcess 'history
-\end{verbatim}
-<<defun recordOldValue>>=
-(defun |recordOldValue| (x prop val)
- (progn
-  (|startTimingProcess| '|history|)
-  (|recordOldValue0| x prop val)
-  (|stopTimingProcess| '|history|)))
-
-@
-\subsection{defun recordOldValue0}
-\begin{verbatim}
-recordOldValue0(x,prop,val) ==
-  -- writes (prop . val) into $HistList
-  p1:= ASSQ(x,CAR $HistList) =>
-    not ASSQ(prop,CDR p1) =>
-      RPLACD(p1,CONS(CONS(prop,val),CDR p1))
-  p:= CONS(x,list CONS(prop,val))
-  RPLACA($HistList,CONS(p,CAR $HistList))
-\end{verbatim}
-<<defun recordOldValue0>>=
-(defun |recordOldValue0| (x prop val)
- (prog (p1 p)
-  (return
-   (seq
-    (when (spadlet p1 (assq x (car |$HistList|)))
-      (exit
-        (when (null (assq prop (cdr p1)))
-          (exit
-            (rplacd p1 (cons (cons prop val) (cdr p1)))))))
-    (spadlet p (cons x (list (cons prop val))))
-    (rplaca |$HistList| (cons p (car |$HistList|))))))) 
-
-@
-\subsection{defun undoInCore}
-\begin{verbatim}
-undoInCore(n) ==
-  -- undoes the last n>0 steps using $HistList
-  -- resets $InteractiveFrame
-  li:= $HistList
-  for i in n..$HistListLen repeat li:= CDR li
-  undoChanges(li)
-  n:= $IOindex-n-1
-  n>0 and
-    $HiFiAccess =>
-      vec:= CDR UNWIND_-PROTECT(readHiFi(n),disableHist())
-      val:= ( p:= ASSQ('%,vec) ) and ( p1:= ASSQ('value,CDR p) ) and
-        CDR p1
-    sayKeyedMsg("S2IH0019",[n])
-  $InteractiveFrame:= putHist('%,'value,val,$InteractiveFrame)
-  updateHist()
-\end{verbatim}
-<<defun undoInCore>>=
-(defun |undoInCore| (n)
- (prog (li vec p p1 val)
-  (return
-   (seq
-    (progn
-     (spadlet li |$HistList|) 
-     (do ((i n (+ i 1)))
-         ((> i |$HistListLen|) nil)
-      (seq
-       (exit
-        (spadlet li (cdr li)))))
-     (|undoChanges| li)
-     (spadlet n (spaddifference (spaddifference |$IOindex| n) 1))
-     (and
-       (> n 0)
-       (cond 
-        (|$HiFiAccess|
-          (spadlet vec 
-           (cdr (unwind-protect (|readHiFi| n) (|disableHist|))))
-          (spadlet val 
-           (and 
-            (spadlet p (assq '% vec))
-            (spadlet p1 (assq '|value| (cdr p)))
-            (cdr p1))))
-        (t 
-          (|sayKeyedMsg| 'S2IH0019 (cons n nil))))) ; no history file
-     (spadlet |$InteractiveFrame| 
-       (|putHist| '% '|value| val |$InteractiveFrame|))
-     (|updateHist|)))))) 
-
-@
-\subsection{defun undoChanges}
-\begin{verbatim}
-undoChanges(li) ==
-  -- undoes all changes of list 'li'
-  if not CDR li = $HistList then undoChanges CDR li
-  for p1 in CAR li repeat
-    x:= CAR p1
-    for p2 in CDR p1 repeat
-      putHist(x,CAR p2,CDR p2,$InteractiveFrame)
-\end{verbatim}
-<<defun undoChanges>>=
-(defun |undoChanges| (li)
- (prog (x)
-  (return
-   (seq
-    (progn
-     (when (null (boot-equal (cdr li) |$HistList|))
-       (|undoChanges| (cdr li)))
-     (do ((tmp0 (car li) (cdr tmp0)) (p1 NIL))
-         ((or (atom tmp0) (progn (setq p1 (car tmp0)) nil)) nil)
-      (seq
-       (exit
-        (progn
-         (spadlet x (car p1))
-         (do ((tmp1 (cdr p1) (cdr tmp1)) (p2 nil))
-             ((or (atom tmp1) (progn (setq p2 (car tmp1)) nil)) nil)
-          (seq
-           (exit
-            (|putHist| x (car p2) (cdr p2) |$InteractiveFrame|)
-      )))))))))))) 
-
-@
-\subsection{defun undoFromFile}
-\begin{verbatim}
-undoFromFile(n) ==
-  -- makes a clear and redoes all the assignments until step n
-  for [x,:varl] in CAAR $InteractiveFrame repeat
-    for p in varl repeat
-      [prop,:val]:= p
-      val =>
-        if not (x='%) then recordOldValue(x,prop,val)
-        if $HiFiAccess then recordNewValue(x,prop,val)
-        RPLACD(p,NIL)
-  for i in 1..n repeat
-    vec:= UNWIND_-PROTECT(CDR readHiFi(i),disableHist())
-    for p1 in vec repeat
-      x:= CAR p1
-      for p2 in CDR p1 repeat
-        $InteractiveFrame:= putHist(x,CAR p2,CDR p2,$InteractiveFrame)
-  val:= ( p:= ASSQ('%,vec) ) and ( p1:= ASSQ('value,CDR p) ) and CDR p1
-  $InteractiveFrame:= putHist('%,'value,val,$InteractiveFrame)
-  updateHist()
-\end{verbatim}
-<<defun undoFromFile>>=
-(defun |undoFromFile| (n)
- (prog (varl prop vec x p p1 val)
-  (return
-   (seq
-    (progn
-     (do ((tmp0 (caar |$InteractiveFrame|) (cdr tmp0)) (tmp1 nil))
-         ((or (atom tmp0) 
-              (progn (setq tmp1 (car tmp0)) nil) 
-              (progn
-                (progn
-                 (spadlet x (car tmp1)) 
-                 (spadlet varl (cdr tmp1))
-                 tmp1)
-                 nil))
-               nil)
-      (seq
-       (exit
-        (do ((tmp2 varl (cdr tmp2)) (p nil))
-            ((or (atom tmp2) (progn (setq p (car tmp2)) nil)) nil)
-         (seq
-          (exit
-           (progn
-            (spadlet prop (car p))
-            (spadlet val (cdr p))
-            (when val 
-              (progn
-                (when (null (boot-equal x '%))
-                  (|recordOldValue| x prop val))
-                (when |$HiFiAccess| 
-                  (|recordNewValue| x prop val))
-                (rplacd p nil))))))))))
-     (do ((|i| 1 (qsadd1 |i|)))
-         ((qsgreaterp |i| n) nil)
-      (seq
-       (exit
-        (progn
-         (spadlet vec 
-           (unwind-protect (cdr (|readHiFi| |i|)) (|disableHist|)))
-         (do ((tmp3 vec (cdr tmp3)) (p1 nil))
-             ((or (atom tmp3) (progn (setq p1 (car tmp3)) nil)) nil)
-          (seq
-           (exit
-            (progn
-             (spadlet x (car p1))
-             (do ((tmp4 (cdr p1) (cdr tmp4)) (p2 nil))
-                 ((or (atom tmp4) (progn (setq p2 (car tmp4)) nil)) nil)
-              (seq
-               (exit
-                (spadlet |$InteractiveFrame| 
-                 (|putHist| x (car p2) (CDR p2) |$InteractiveFrame|)
-       ))))))))))))
-     (spadlet val
-      (and 
-       (spadlet p (assq '% vec))
-       (spadlet p1 (assq '|value| (cdr p)))
-       (cdr p1)))
-     (spadlet |$InteractiveFrame| 
-       (|putHist| '% '|value| val |$InteractiveFrame|))
-     (|updateHist|)))))) 
-
-@
-\subsection{defun saveHistory}
-\begin{verbatim}
-saveHistory(fn) ==
-  $seen: local := MAKE_-HASHTABLE 'EQ
-  not $HiFiAccess => sayKeyedMsg("S2IH0016",NIL)
-  not $useInternalHistoryTable and
-    null MAKE_-INPUT_-FILENAME histFileName() => sayKeyedMsg("S2IH0022",NIL)
-  null fn => 
-    throwKeyedMsg("S2IH0037", nil)
-  savefile := makeHistFileName(fn)
-  inputfile := histInputFileName(fn)
-  writeInputLines(fn,1)
-  histFileErase savefile
- 
-  if $useInternalHistoryTable
-    then
-      saveStr := RDEFIOSTREAM ['(MODE . OUTPUT),['FILE,:savefile]]
-      for [n,:rec] in reverse $internalHistoryTable repeat
-        val := SPADRWRITE0(object2Identifier n,rec,saveStr)
-        val = 'writifyFailed =>
-          sayKeyedMsg("S2IH0035", [n, inputfile]) ; unable to save step
-      RSHUT saveStr
-  sayKeyedMsg("S2IH0018",[namestring(savefile)]) ; saved hist file named
-  nil
-\end{verbatim}
-<<defun saveHistory>>=
-(defun |saveHistory| (fn)
- (prog (|$seen| savefile inputfile saveStr n rec val)
-  (declare (special |$seen|))
-   (return
-    (seq
-     (progn
-      (spadlet |$seen| (make-hashtable 'eq))
-      (cond 
-       ((null |$HiFiAccess|) 
-         (|sayKeyedMsg| 'S2IH0016 nil)) ; the history file is not on
-       ((and (null |$useInternalHistoryTable|) 
-             (null (make-input-filename (|histFileName|))))
-         (|sayKeyedMsg| 'S2IH0022 nil)) ; no history saved yet
-       ((null fn) 
-         (|throwKeyedMsg| 'S2IH0037 nil)) ; need to specify a history filename
-       (t 
-         (spadlet savefile (|makeHistFileName| fn))
-         (spadlet inputfile (|histInputFileName| fn))
-         (|writeInputLines| fn 1)
-         (|histFileErase| savefile)
-         (when |$useInternalHistoryTable| 
-           (spadlet saveStr 
-             (rdefiostream 
-              (cons '(mode . output) 
-                (cons (cons 'file savefile) nil))))
-           (do ((tmp0 (reverse |$internalHistoryTable|) (cdr tmp0))
-                (tmp1 nil))
-               ((or (atom tmp0) 
-                    (progn (setq tmp1 (car tmp0)) nil)
-                    (progn
-                     (progn
-                      (spadlet n (car tmp1)) 
-                      (spadlet rec (cdr tmp1)) 
-                      tmp1) 
-                     nil)) 
-                    nil)
-            (seq
-             (exit
-              (progn
-               (spadlet val 
-                 (spadrwrite0 (|object2Identifier| n) rec saveStr))
-               (when (boot-equal val '|writifyFailed|)
-                (|sayKeyedMsg| 'S2IH0035 ; can't save the value of step
-                 (cons n (cons inputfile nil))))))))
-           (rshut saveStr))
-         (|sayKeyedMsg| 'S2IH0018 ; saved history file is
-           (cons (|namestring| savefile) nil))
-         nil)))))))
-
-@
-\subsection{defun restoreHistory}
-\begin{verbatim}
-restoreHistory(fn) ==
-  -- uses fn $historyFileType to recover an old session
-  -- if fn = NIL, then use $oldHistoryFileName
-  if null fn then fn' := $oldHistoryFileName
-  else if fn is [fn'] and IDENTP(fn') then fn' := fn'
-       else throwKeyedMsg("S2IH0023",[fn'])
-  restfile := makeHistFileName(fn')
-  null MAKE_-INPUT_-FILENAME restfile =>
-    sayKeyedMsg("S2IH0024",[namestring(restfile)]) ; no history file
- 
-  -- if clear is changed to be undoable, this should be a reset-clear
-  $options: local := nil
-  clearSpad2Cmd '(all)
- 
-  curfile := histFileName()
-  histFileErase curfile
-  _$FCOPY(restfile,curfile)
- 
-  l:= LENGTH RKEYIDS curfile
-  $HiFiAccess:= 'T
-  oldInternal := $useInternalHistoryTable
-  $useInternalHistoryTable := NIL
-  if oldInternal then $internalHistoryTable := NIL
-  for i in 1..l repeat
-    vec:= UNWIND_-PROTECT(readHiFi(i),disableHist())
-    if oldInternal then $internalHistoryTable :=
-      CONS([i,:vec],$internalHistoryTable)
-    LINE:= CAR vec
-    for p1 in CDR vec repeat
-      x:= CAR p1
-      for p2 in CDR p1 repeat
-        $InteractiveFrame:= putHist(x,CAR p2,CDR p2,$InteractiveFrame)
-    updateInCoreHist()
-  $e := $InteractiveFrame
-  for [a,:.] in CAAR $InteractiveFrame repeat
-    get(a,'localModemap,$InteractiveFrame) =>
-      rempropI(a,'localModemap)
-      rempropI(a,'localVars)
-      rempropI(a,'mapBody)
-  $IOindex:= l+1
-  $useInternalHistoryTable := oldInternal
-  sayKeyedMsg("S2IH0025",[namestring(restfile)]) 
-  clearCmdSortedCaches()
-  nil
-\end{verbatim}
-<<defun restoreHistory>>=
-(defun |restoreHistory| (fn)
- (prog (|$options| fnq restfile curfile l oldInternal vec line x a)
-  (declare (special |$options|))
-   (return
-    (seq
-     (progn
-      (cond 
-        ((null fn)
-          (spadlet fnq |$oldHistoryFileName|))
-        ((and (pairp fn) 
-              (eq (qcdr fn) nil)
-              (progn
-               (spadlet fnq (qcar fn))
-               t)
-              (identp fnq))
-          (spadlet fnq fnq))
-        (t (|throwKeyedMsg| 'S2IH0023 (cons fnq nil)))) ; invalid filename
-      (spadlet restfile (|makeHistFileName| fnq))
-      (cond 
-       ((null (make-input-filename restfile))
-         (|sayKeyedMsg| 'S2IH0024  ; file does not exist
-            (cons (|namestring| restfile) nil)))
-       (t 
-         (spadlet |$options| NIL)
-         (|clearSpad2Cmd| '(|all|))
-         (spadlet curfile (|histFileName|))
-         (|histFileErase| curfile)
-         ($fcopy restfile curfile)
-         (spadlet l (length (rkeyids curfile)))
-         (spadlet |$HiFiAccess| t)
-         (spadlet oldInternal |$useInternalHistoryTable|)
-         (spadlet |$useInternalHistoryTable| nil)
-         (when oldInternal
-           (spadlet |$internalHistoryTable| nil))
-         (do ((|i| 1 (qsadd1 |i|)))
-             ((qsgreaterp |i| l) nil)
-          (seq
-           (exit
-            (progn
-             (spadlet vec (unwind-protect (|readHiFi| |i|) (|disableHist|)))
-             (when oldInternal
-               (spadlet |$internalHistoryTable| 
-                (cons (cons |i| vec) |$internalHistoryTable|)))
-             (spadlet line (car vec))
-             (do ((tmp0 (cdr vec) (cdr tmp0)) (p1 nil))
-                 ((or (atom tmp0) (progn (setq p1 (car tmp0)) nil)) nil)
-              (seq
-               (exit
-                (progn
-                 (spadlet x (car p1))
-                 (do ((tmp1 (cdr p1) (cdr tmp1)) (p2 nil))
-                     ((or (atom tmp1) (progn (setq p2 (car tmp1)) nil)) nil)
-                  (seq
-                   (exit
-                    (spadlet |$InteractiveFrame| 
-                      (|putHist| x 
-                       (car p2) (cdr p2) |$InteractiveFrame|)))))))))
-             (|updateInCoreHist|)))))
-         (spadlet |$e| |$InteractiveFrame|)
-         (seq
-          (do ((tmp2 (caar |$InteractiveFrame|) (cdr tmp2)) (tmp3 nil))
-              ((or (atom tmp2) 
-                   (progn
-                     (setq tmp3 (car tmp2))
-                     nil) 
-                   (progn
-                    (progn
-                      (spadlet a (car tmp3))
-                      tmp3) 
-                      nil))
-                   nil)
-           (seq
-            (exit
-             (when (|get| a '|localModemap| |$InteractiveFrame|)
-              (exit
-               (progn
-                (|rempropI| a '|localModemap|)
-                (|rempropI| a '|localVars|)
-                (|rempropI| a '|mapBody|)))))))
-          (spadlet |$IOindex| (plus l 1))
-          (spadlet |$useInternalHistoryTable| oldInternal)
-          (|sayKeyedMsg| 'S2IH0025 ; workspace restored
-            (cons (|namestring| restfile) nil))
-          (|clearCmdSortedCaches|)
-          nil)))))))) 
-
-@
-\subsection{defun showHistory}
-\begin{verbatim}
--- the following used to be the show command when that was used to
--- show history.
-showHistory(arg) ==
-  -- arg can be of form
-  --    NIL          show at most last 20 input lines
-  --    (n)          show at most last n input lines
-  --    (lit)        where lit is an abbreviation for 'input or 'both
-  --                 if 'input, same as NIL
-  --                 if 'both, show last 5 input and outputs
-  --    (n lit)      show last n input lines + last n output lines
-  --                 if lit expands to 'both
-  $evalTimePrint: local:= 0
-  $printTimeSum: local:= 0
-  -- ugh!!! these are needed for timedEvaluateStream
-  -- displays the last n steps, default n=20
-  not $HiFiAccess => sayKeyedMsg("S2IH0026",['show])
-  showInputOrBoth := 'input
-  n := 20
-  nset := nil
-  if arg then
-    arg1 := CAR arg
-    if INTEGERP arg1 then
-      n := arg1
-      nset := true
-      KDR arg => arg1 := CADR arg
-      arg1 := NIL
-    arg1 =>
-      arg2 := selectOptionLC(arg1,'(input both),nil)
-      if arg2
-        then ((showInputOrBoth := arg2) = 'both) and (null nset) => n:= 5
-        else sayMSG
-          concat('"  ",bright arg1,'"is an invalid argument.")
-  if n >= $IOindex then n:= $IOindex-1
-  mini:= $IOindex-n
-  maxi:= $IOindex-1
-  showInputOrBoth = 'both =>
-    UNWIND_-PROTECT(showInOut(mini,maxi),setIOindex(maxi+1))
-  showInput(mini,maxi)
-\end{verbatim}
-<<defun showHistory>>=
-(defun |showHistory| (arg)
- (prog (|$evalTimePrint| |$printTimeSum| nset arg1 arg2 
-        showInputOrBoth n mini maxi)
-  (declare (special |$evalTimePrint| |$printTimeSum|))
-   (return
-    (seq
-     (progn
-      (spadlet |$evalTimePrint| 0)
-      (spadlet |$printTimeSum| 0)
-      (cond
-       ((null |$HiFiAccess|)
-         (|sayKeyedMsg| 'S2IH0026 (cons '|show| nil))) ; history not on
-       (t
-         (spadlet showInputOrBoth '|input|)
-         (spadlet n 20)
-         (spadlet nset nil)
-         (when arg 
-          (spadlet arg1 (car arg))
-          (when  (integerp arg1)
-           (spadlet n arg1)
-           (spadlet nset t)
-           (cond
-            ((kdr arg) (spadlet arg1 (cadr arg)))
-            (t (spadlet arg1 nil))))
-          (when arg1 
-           (progn
-            (spadlet arg2 (|selectOptionLC| arg1 '(|input| |both|) nil))
-            (seq
-             (cond 
-              (arg2
-                 (when (and (boot-equal 
-                              (spadlet showInputOrBoth arg2) '|both|)
-                            (null nset))
-                   (exit (spadlet n 5))))
-              (t
-                (|sayMSG| 
-                  (|concat| 
-                   (makestring "  ")
-                   (|bright| arg1)
-                   (makestring "is an invalid argument.")))))))))
-         (when (>= n |$IOindex|)
-           (spadlet n (spaddifference |$IOindex| 1)))
-         (spadlet mini (spaddifference |$IOindex| n))
-         (spadlet maxi (spaddifference |$IOindex| 1))
-         (cond 
-           ((boot-equal showInputOrBoth '|both|)
-             (unwind-protect 
-               (|showInOut| mini maxi)
-               (|setIOindex| (plus maxi 1))))
-           (t (|showInput| mini maxi))))))))))
- 
-@
-\subsection{defun setIOindex}
-\begin{verbatim}
-setIOindex(n) ==
-  -- set $IOindex to n
-  $IOindex:= n
-\end{verbatim}
-<<defun setIOindex>>=
-(defun |setIOindex| (n)
-  (spadlet |$IOindex| n)) 
-
-@
-\subsection{defun showInput}
-\begin{verbatim}
-showInput(mini,maxi) ==
-  -- displays all input lines from mini to maxi
-  for ind in mini..maxi repeat
-    vec:= UNWIND_-PROTECT(readHiFi(ind),disableHist())
-    if ind<10 then TAB 2 else if ind<100 then TAB 1
-    l := CAR vec
-    STRINGP l =>
-      sayMSG ['"   [",ind,'"] ",CAR vec]
-    sayMSG ['"   [",ind,'"] " ]
-    for ln in l repeat
-      sayMSG ['"      ", ln]
-\end{verbatim}
-<<defun showInput>>=
-(defun |showInput| (mini maxi)
- (prog (vec l)
-  (return
-   (seq
-    (do ((|ind| mini (+ |ind| 1)))
-        ((> |ind| maxi) NIL)
-     (seq
-      (exit
-       (progn
-        (spadlet vec (unwind-protect (|readHiFi| |ind|) (|disableHist|)))
-        (cond
-         ((> 10 |ind|) (tab 2))
-         ((> 100 |ind|) (tab 1))
-         (t nil))
-        (spadlet l (car vec))
-        (cond
-          ((stringp l)
-            (|sayMSG| 
-             (cons 
-              (makestring "   [")
-              (cons |ind| 
-               (cons (makestring "] ")
-                (cons (car vec) nil))))))
-          (t
-            (|sayMSG|
-             (cons (makestring "   [")
-              (cons |ind|
-               (cons (makestring "] ") nil))))
-           (do ((tmp0 l (cdr tmp0)) (|ln| nil))
-               ((or (atom tmp0) (progn (setq |ln| (car tmp0)) nil)) nil)
-            (seq
-             (exit
-              (|sayMSG|
-               (cons (makestring "      ") (cons |ln| nil)))))))))))))))) 
-
-@
-\subsection{defun showInOut}
-\begin{verbatim}
-showInOut(mini,maxi) ==
-  -- displays all steps from mini to maxi
-  for ind in mini..maxi repeat
-    vec:= UNWIND_-PROTECT(readHiFi(ind),disableHist())
-    sayMSG [CAR vec]
-    Alist:= ASSQ('%,CDR vec) =>
-      triple:= CDR ASSQ('value,CDR Alist)
-      $IOindex:= ind
-      spadPrint(objValUnwrap triple,objMode triple)
-\end{verbatim}
-<<defun showInOut>>=
-(defun |showInOut| (mini maxi)
- (prog (vec Alist triple)
-  (return
-   (seq
-    (do ((ind mini (+ ind 1)))
-        ((> ind maxi) nil)
-     (seq
-      (exit
-       (progn
-        (spadlet vec (unwind-protect (|readHiFi| ind) (|disableHist|)))
-        (|sayMSG| (cons (car vec) nil))
-        (cond
-         ((spadlet Alist (assq '% (cdr vec)))
-          (progn
-           (spadlet triple (cdr (assq '|value| (cdr Alist))))
-           (spadlet |$IOindex| ind)
-           (|spadPrint| 
-             (|objValUnwrap| triple) (|objMode| triple))))))))))))) 
-
-@
-\subsection{defun fetchOutput}
-\begin{verbatim}
-fetchOutput(n) ==
-  -- result is the output of step n
-  (n = -1) and (val := getI("%",'value)) => val
-  $HiFiAccess =>
-    n:=
-      n < 0 => $IOindex+n
-      n
-    n >= $IOindex => throwKeyedMsg("S2IH0001",[n])
-    n < 1        => throwKeyedMsg("S2IH0002",[n])
-    vec:= UNWIND_-PROTECT(readHiFi(n),disableHist())
-    Alist:= ASSQ('%,CDR vec) =>
-      val:= CDR ASSQ('value,CDR Alist) => val
-      throwKeyedMsg("S2IH0003",[n])
-    throwKeyedMsg("S2IH0003",[n])
-  throwKeyedMsg("S2IH0004",NIL)
-\end{verbatim}
-<<defun fetchOutput>>=
-(defun |fetchOutput| (n)
- (prog (vec Alist val)
-  (return
-   (cond
-    ((and (boot-equal n (spaddifference 1))
-          (spadlet val (|getI| '% '|value|)))
-       val)
-    (|$HiFiAccess|
-     (spadlet n
-      (cond
-       ((minusp n) (plus |$IOindex| n))
-       (t n)))
-     (cond
-      ((>= n |$IOindex|) 
-        (|throwKeyedMsg| 'S2IH0001 (cons n nil))) ; no step n yet
-      ((> 1 n)
-        (|throwKeyedMsg| 'S2IH0002 (cons n nil))) ; only nonzero steps
-      (t
-        (spadlet vec (unwind-protect (|readHiFi| n) (|disableHist|)))
-        (cond
-         ((spadlet Alist (assq '% (cdr vec)))
-           (cond
-             ((spadlet val (cdr (assq '|value| (cdr Alist))))
-               val)
-             (t
-               (|throwKeyedMsg| 'S2IH0003 (cons n nil))))) ; no step value
-         (t (|throwKeyedMsg| 'S2IH0003 (cons n nil))))))) ; no step value
-    (t (|throwKeyedMsg| 'S2IH0004 nil)))))) ; history not on
-
-@
-\subsection{defun readHiFi}
-\begin{verbatim}
-readHiFi(n) ==
-  -- reads the file using index n
-  if $useInternalHistoryTable
-  then
-    pair := assoc(n,$internalHistoryTable)
-    ATOM pair => keyedSystemError("S2IH0034",NIL)
-    vec := QCDR pair
-  else
-    HiFi:= RDEFIOSTREAM ['(MODE . INPUT),['FILE,:histFileName()]]
-    vec:= SPADRREAD(object2Identifier n,HiFi)
-    RSHUT HiFi
-  vec
-\end{verbatim}
-<<defun readHiFi>>=
-(defun |readHiFi| (n)
- (prog (pair HiFi vec)
-  (return
-   (progn
-    (cond
-     (|$useInternalHistoryTable|
-      (spadlet pair (|assoc| n |$internalHistoryTable|))
-      (cond
-       ((atom pair) 
-         (|keyedSystemError| 'S2IH0034 nil)) ; missing element
-       (t 
-         (spadlet vec (qcdr pair)))))
-     (t
-       (spadlet HiFi
-        (rdefiostream
-         (cons
-          '(mode . input)
-           (cons
-            (cons 'file (|histFileName|)) nil))))
-       (spadlet vec (spadrread (|object2Identifier| n) HiFi))
-       (rshut HiFi)))
-    vec)))) 
-
-@
-\subsection{defun writeHiFi}
-\begin{verbatim}
-writeHiFi() ==
-  -- writes the information of the current step out to history file
-  if $useInternalHistoryTable
-  then
-    $internalHistoryTable := CONS([$IOindex,$currentLine,:$HistRecord],
-      $internalHistoryTable)
-  else
-    HiFi:= RDEFIOSTREAM ['(MODE . OUTPUT),['FILE,:histFileName()]]
-    SPADRWRITE(object2Identifier $IOindex, CONS($currentLine,$HistRecord),HiFi)
-    RSHUT HiFi
-\end{verbatim}
-<<defun writeHiFi>>=
-(defun |writeHiFi| ()
- (prog (HiFi)
-  (return
-   (cond
-    (|$useInternalHistoryTable|
-     (spadlet |$internalHistoryTable|
-      (cons
-       (cons |$IOindex|
-        (cons |$currentLine| |$HistRecord|))
-        |$internalHistoryTable|)))
-    (t
-      (spadlet HiFi
-        (rdefiostream
-         (cons
-           '(mode . output)
-            (cons (cons 'file (|histFileName|)) nil))))
-      (spadrwrite (|object2Identifier| |$IOindex|)
-        (cons |$currentLine| |$HistRecord|) HiFi)
-      (rshut HiFi)))))) 
-
-@
-\subsection{defun disableHist}
-\begin{verbatim} 
-disableHist() ==
-  -- disables the history mechanism if an error occurred in the protected
-  -- piece of code
-  not $HiFiAccess => histFileErase histFileName()
-  NIL
-\end{verbatim}
-<<defun disableHist>>=
-(defun |disableHist| () 
- (cond
-  ((null |$HiFiAccess|) 
-    (|histFileErase| (|histFileName|)))
-  (t nil))) 
-
-@
-\subsection{defun writeHistModesAndValues}
-\begin{verbatim}
-writeHistModesAndValues() ==
-  for [a,:.] in CAAR $InteractiveFrame repeat
-    x := get(a,'value,$InteractiveFrame) =>
-      putHist(a,'value,x,$InteractiveFrame)
-    x := get(a,'mode,$InteractiveFrame) =>
-      putHist(a,'mode,x,$InteractiveFrame)
-  NIL
-\end{verbatim}
-<<defun writeHistModesAndValues>>=
-(defun |writeHistModesAndValues| ()
- (prog (a x)
-  (return
-   (seq
-    (progn
-     (do ((tmp0 (caar |$InteractiveFrame|) (cdr tmp0)) (tmp1 nil))
-         ((or (atom tmp0) 
-              (progn
-                (setq tmp1 (car tmp0))
-                nil)
-              (progn
-                (progn
-                  (spadlet a (car tmp1))
-                  tmp1)
-              nil))
-          nil)
-      (seq
-       (exit
-        (cond
-         ((spadlet x (|get| a '|value| |$InteractiveFrame|))
-           (|putHist| a '|value| x |$InteractiveFrame|))
-         ((spadlet x (|get| a '|mode| |$InteractiveFrame|))
-           (|putHist| a '|mode| x |$InteractiveFrame|))))))
-     nil))))) 
-
-@
-\section{Lisplib output transformations}
---% Lisplib output transformations
---  Some types of objects cannot be saved by LISP/VM in lisplibs.
---  These functions transform an object to a writable form and back.
---  SMW
-\subsection{defun SPADRWRITE0}
-\begin{verbatim}
-SPADRWRITE0(vec, item, stream) ==
-    val := safeWritify item
-    val = 'writifyFailed => val
-    rwrite(vec, val, stream)
-    item
-\end{verbatim}
-<<defun SPADRWRITE0>>=
-(defun spadrwrite0 (vec item stream)
- (prog (val)
-  (return
-   (progn
-    (spadlet val (|safeWritify| item))
-    (cond
-     ((boot-equal val '|writifyFailed|) val)
-     (t (|rwrite| vec val stream) item)))))) 
-
-@
-\subsection{defun SPADRWRITE}
-\begin{verbatim}
-SPADRWRITE(vec, item, stream) ==
-  val := SPADRWRITE0(vec, item, stream) 
-  val = 'writifyFailed =>
-    throwKeyedMsg("S2IH0036", nil) ; cannot save value to file
-  item
-\end{verbatim}
-<<defun SPADRWRITE>>=
-(defun spadrwrite (vec item stream)
- (prog (val)
-  (return
-   (progn
-    (spadlet val (spadrwrite0 vec item stream))
-    (cond
-     ((boot-equal val '|writifyFailed|)
-        (|throwKeyedMsg| 'S2IH0036 nil)) ; cannot save value to file
-     (t item))))))
-
-@
-\subsection{defun SPADRREAD}
-\begin{verbatim}
-SPADRREAD(vec, stream) ==
-    dewritify rread(vec, stream, nil)
-\end{verbatim}
-<<defun SPADRREAD>>=
-(defun spadrread (vec stream)
- (|dewritify| (|rread| vec stream nil))) 
-
-@ 
-\subsection{defun unwritable?}
-\begin{verbatim}
-unwritable? ob ==
-    PAIRP  ob or VECP ob       => false   -- first for speed
-    COMPILED_-FUNCTION_-P   ob or HASHTABLEP ob => true
-    PLACEP ob or READTABLEP ob => true
-    FLOATP ob => true
-    false
-\end{verbatim}
-<<defun unwritable?>>=
-(defun |unwritable?| (ob)
- (cond
-  ((or (pairp ob) (vecp ob)) nil)
-  ((or (compiled-function-p ob) (hashtablep ob)) t)
-  ((or (placep ob) (readtablep ob)) t)
-  ((floatp ob) t)
-  (t nil))) 
-
-@
-\subsection{defun writifyComplain}
-\begin{verbatim}
--- Create a full isomorphic object which can be saved in a lisplib.
--- Note that  dewritify(writify(x))  preserves UEQUALity of hashtables.
--- HASHTABLEs go both ways.
--- READTABLEs cannot presently be transformed back.
- 
-writifyComplain s ==
-   $writifyComplained  = true => nil
-   $writifyComplained := true
-   sayKeyedMsg("S2IH0027",[s]) 
-\end{verbatim}
-<<defun writifyComplain>>=
-(defun |writifyComplain| (s)
- (cond 
-   ((boot-equal |$writifyComplained| t) NIL)
-   (t
-    (spadlet |$writifyComplained| t)
-    (|sayKeyedMsg| 'S2IH0027 (cons s nil))))) ; cannot save value
-
-@
-\subsection{defun safeWritify}
-\begin{verbatim}
-safeWritify ob ==
-  CATCH('writifyTag,  writify ob)
-\end{verbatim}
-<<defun safeWritify>>=
-(defun |safeWritify| (ob)
- (catch '|writifyTag| (|writify| ob))) 
-
-@
-\subsection{defun writify}
-\begin{verbatim}
-writify ob ==
-    not ScanOrPairVec(function(unwritable?), ob) => ob
-    $seen:     local := MAKE_-HASHTABLE 'EQ
-    $writifyComplained: local := false
- 
-    writifyInner ob where
-        writifyInner ob ==
-            null ob                => nil
-            (e := HGET($seen, ob)) => e
- 
-            PAIRP ob =>
-                qcar := QCAR ob
-                qcdr := QCDR ob
-                (name := spadClosure? ob) =>
-                   d := writifyInner QCDR ob
-                   nob := ['WRITIFIED_!_!, 'SPADCLOSURE, d, name]
-                   HPUT($seen, ob, nob)
-                   HPUT($seen, nob, nob)
-                   nob
-                (ob is ['LAMBDA_-CLOSURE, ., ., x, :.]) and x =>
-                  THROW('writifyTag, 'writifyFailed)
-                nob := CONS(qcar, qcdr)
-                HPUT($seen, ob, nob)
-                HPUT($seen, nob, nob)
-                qcar := writifyInner qcar
-                qcdr := writifyInner qcdr
-                QRPLACA(nob, qcar)
-                QRPLACD(nob, qcdr)
-                nob
-            VECP ob =>
-                isDomainOrPackage ob =>
-                    d := mkEvalable devaluate ob
-                    nob := ['WRITIFIED_!_!, 'DEVALUATED, writifyInner d]
-                    HPUT($seen, ob, nob)
-                    HPUT($seen, nob, nob)
-                    nob
-                n   := QVMAXINDEX ob
-                nob := MAKE_-VEC(n+1)
-                HPUT($seen, ob, nob)
-                HPUT($seen, nob, nob)
-                for i in 0..n repeat
-                    QSETVELT(nob, i, writifyInner QVELT(ob,i))
-                nob
-            ob = 'WRITIFIED_!_! =>
-                ['WRITIFIED_!_!, 'SELF]
-            -- In CCL constructors are also compiled functions, so we 
-            -- need this line:
-            constructor? ob => ob
-            COMPILED_-FUNCTION_-P ob =>
-                THROW('writifyTag, 'writifyFailed)
-            HASHTABLEP ob =>
-                nob := ['WRITIFIED_!_!]
-                HPUT($seen, ob,  nob)
-                HPUT($seen, nob, nob)
-                keys := HKEYS ob
-                QRPLACD(nob,
-                        ['HASHTABLE,
-                          HASHTABLE_-CLASS ob,
-                            writifyInner keys,
-                              [writifyInner HGET(ob,k) for k in keys]])
-                nob
-            PLACEP ob =>
-                nob := ['WRITIFIED_!_!, 'PLACE]
-                HPUT($seen, ob,  nob)
-                HPUT($seen, nob, nob)
-                nob
-            -- The next three types cause an error on de-writifying.
-            -- Create an object of the right shape, nonetheless.
-            READTABLEP ob =>
-                THROW('writifyTag, 'writifyFailed)
-            -- Default case: return the object itself.
-            STRINGP ob =>
-                EQ(ob, $NullStream) => ['WRITIFIED_!_!, 'NULLSTREAM]
-                EQ(ob, $NonNullStream) => ['WRITIFIED_!_!, 'NONNULLSTREAM]
-                ob
-            FLOATP ob =>
-                ob = READ_-FROM_-STRING STRINGIMAGE ob => ob
-                ['WRITIFIED_!_!, 'FLOAT, ob,:
-                   MULTIPLE_-VALUE_-LIST INTEGER_-DECODE_-FLOAT ob]
-            ob
-\end{verbatim}
-<<defun writify,writifyInner>>=
-(defun |writify,writifyInner| (ob)
- (prog (e name tmp1 tmp2 tmp3 x qcar qcdr d n keys nob)
-  (return
-   (seq
-    (when (null ob)
-     (exit nil))
-    (when (spadlet e (hget |$seen| ob))
-     (exit e))
-    (when (pairp ob)
-     (exit
-      (seq
-       (spadlet qcar (qcar ob))
-       (spadlet qcdr (qcdr ob))
-       (when (spadlet name (|spadClosure?| ob))
-        (exit
-         (seq
-          (spadlet d (|writify,writifyInner| (qcdr ob)))
-          (spadlet nob 
-           (cons 'writified!!
-            (cons 'spadclosure 
-             (cons d (cons name nil)))))
-          (hput |$seen| ob nob)
-          (hput |$seen| nob nob)
-          (exit nob))))
-       (when 
-        (and 
-         (and (pairp ob)
-              (eq (qcar ob) 'lambda-closure)
-              (progn
-               (spadlet tmp1 (qcdr ob))
-               (and (pairp tmp1)
-                    (progn 
-                     (spadlet tmp2 (qcdr tmp1))
-                     (and 
-                      (pairp tmp2)
-                      (progn 
-                       (spadlet tmp3 (qcdr tmp2))
-                       (and (pairp tmp3)
-                            (progn
-                             (spadlet x (qcar tmp3))
-                             t)))))))) x)
-        (exit
-         (throw '|writifyTag| '|writifyFailed|)))
-       (spadlet nob (cons qcar qcdr))
-       (hput |$seen| ob nob)
-       (hput |$seen| nob nob)
-       (spadlet qcar (|writify,writifyInner| qcar))
-       (spadlet qcdr (|writify,writifyInner| qcdr))
-       (qrplaca nob qcar)
-       (qrplacd nob qcdr)
-       (exit nob))))
-    (when (vecp ob)
-     (exit
-      (seq
-       (when (|isDomainOrPackage| ob)
-        (exit
-         (seq
-          (spadlet d (|mkEvalable| (|devaluate| ob)))
-          (spadlet nob 
-           (cons 'writified!! 
-            (cons 'devaluated 
-             (cons (|writify,writifyInner| d) nil))))
-          (hput |$seen| ob nob)
-          (hput |$seen| nob nob)
-          (exit nob))))
-       (spadlet n (qvmaxindex ob))
-       (spadlet nob (make-vec (plus n 1)))
-       (hput |$seen| ob nob)
-       (hput |$seen| nob nob)
-       (do ((|i| 0 (qsadd1 |i|)))
-           ((qsgreaterp |i| n) NIL)
-        (seq
-         (exit
-          (qsetvelt nob |i| (|writify,writifyInner| (QVELT ob |i|))))))
-       (exit nob))))
-    (when (boot-equal ob 'writified!!)
-     (exit
-      (cons 'writified!! (cons 'self nil))))
-    (when (|constructor?| ob)
-     (exit ob))
-    (when (compiled-function-p ob)
-     (exit
-      (throw '|writifyTag| '|writifyFailed|)))
-    (when (hashtablep ob)
-     (exit
-      (seq
-       (spadlet nob (cons 'writified!! nil))
-       (hput |$seen| ob nob)
-       (hput |$seen| nob nob)
-       (spadlet keys (hkeys ob))
-       (qrplacd nob
-        (cons 
-          'hashtable
-          (cons 
-            (hashtable-class ob)
-            (cons
-              (|writify,writifyInner| keys)
-              (cons
-                (prog (tmp0)
-                  (spadlet tmp0 nil)
-                  (return
-                   (do ((tmp1 keys (cdr tmp1)) (k nil))
-                       ((or (atom tmp1)
-                            (progn
-                             (setq k (car tmp1))
-                              nil))
-                            (nreverse0 tmp0))
-                    (seq
-                     (exit
-                      (setq tmp0 
-                       (cons 
-                         (|writify,writifyInner| (HGET ob k))
-                         tmp0)))))))
-                nil)))))
-       (exit nob))))
-    (when (placep ob)
-     (exit
-      (seq
-       (spadlet nob (cons 'writified!! (cons 'place nil)))
-       (hput |$seen| ob nob)
-       (hput |$seen| nob nob)
-       (exit nob))))
-    (when (readtablep ob)
-     (exit
-      (throw '|writifyTag| '|writifyFailed|)))
-    (when (stringp ob)
-     (exit
-      (seq
-       (when (eq ob |$NullStream|)
-        (exit
-         (cons 'writified!! (cons 'nullstream nil))))
-       (when (eq ob |$NonNullStream|)
-        (exit
-         (cons 'writified!! (cons 'nonnullstream nil))))
-       (exit ob))))
-    (when (floatp ob)
-     (exit
-      (seq
-       (when (boot-equal ob (read-from-string (stringimage ob)))
-        (exit ob))
-       (exit
-        (cons 'writified!!
-         (cons 'float 
-          (cons ob 
-           (multiple-value-list (integer-decode-float ob)))))))))
-    (exit ob))))) 
-
-@
-<<defun writify>>=
-(defun |writify| (ob)
- (prog (|$seen| |$writifyComplained|)
-  (declare (special |$seen| |$writifyComplained|))
-   (return
-    (cond
-     ((null (|ScanOrPairVec| (|function| |unwritable?|) ob))
-       ob)
-     (t
-      (spadlet |$seen| (make-hashtable 'eq))
-      (spadlet |$writifyComplained| nil)
-      (|writify,writifyInner| ob)))))) 
-
-@
-\subsection{defun spadClosure?}
-\begin{verbatim}
-spadClosure? ob ==
-  fun := QCAR ob
-  not (name := BPINAME fun) => nil
-  vec := QCDR ob
-  not VECP vec => nil
-  name
-\end{verbatim}
-<<defun spadClosure?>>=
-(defun |spadClosure?| (ob)
- (prog (fun name vec)
-  (return
-   (progn
-    (spadlet fun (qcar ob))
-    (cond 
-     ((null (spadlet name (bpiname fun))) nil)
-     (t
-       (spadlet vec (qcdr ob))
-       (cond
-        ((null (vecp vec)) nil)
-        (t name)))))))) 
-
-@
-\subsection{defun dewritify}
-\begin{verbatim}
-dewritify ob ==
-    (not ScanOrPairVec(function is?, ob)
-            where  is? a == a = 'WRITIFIED_!_!) => ob
- 
-    $seen:     local := MAKE_-HASHTABLE 'EQ
- 
-    dewritifyInner ob where
-        dewritifyInner ob ==
-            null ob => nil
-            e := HGET($seen, ob) => e
- 
-            PAIRP ob and CAR ob = 'WRITIFIED_!_! =>
-                type := ob.1
-                type = 'SELF =>
-                    'WRITIFIED_!_!
-                type = 'BPI =>
-                    oname := ob.2
-                    f :=
-                        INTP oname => EVAL GENSYMMER oname
-                        SYMBOL_-FUNCTION oname
-                    not COMPILED_-FUNCTION_-P f =>
-                        error '"A required BPI does not exist."
-                    #ob > 3 and HASHEQ f ^= ob.3 =>
-                        error '"A required BPI has been redefined."
-                    HPUT($seen, ob, f)
-                    f
-                type = 'HASHTABLE =>
-                    nob := MAKE_-HASHTABLE ob.2
-                    HPUT($seen, ob, nob)
-                    HPUT($seen, nob, nob)
-                    for k in ob.3 for e in ob.4 repeat
-                        HPUT(nob, dewritifyInner k, dewritifyInner e)
-                    nob
-                type = 'DEVALUATED =>
-                    nob := EVAL dewritifyInner ob.2
-                    HPUT($seen, ob, nob)
-                    HPUT($seen, nob, nob)
-                    nob
-                type = 'SPADCLOSURE =>
-                    vec := dewritifyInner ob.2
-                    name := ob.3
-                    not FBOUNDP name => 
-                       error STRCONC('"undefined function: ", SYMBOL_-NAME name)
-                    nob := CONS(SYMBOL_-FUNCTION name, vec)
-                    HPUT($seen, ob, nob)
-                    HPUT($seen, nob, nob)
-                    nob
-                type = 'PLACE =>
-                    nob := READ MAKE_-INSTREAM NIL
-                    HPUT($seen, ob, nob)
-                    HPUT($seen, nob, nob)
-                    nob
-                type = 'READTABLE =>
-                    error '"Cannot de-writify a read table."
-                type = 'NULLSTREAM => $NullStream
-                type = 'NONNULLSTREAM => $NonNullStream
-                type = 'FLOAT =>
-	           [fval, signif, expon, sign] := CDDR ob
-                   fval := SCALE_-FLOAT( FLOAT(signif, fval), expon)
-                   sign<0 => -fval
-                   fval
-                error '"Unknown type to de-writify."
- 
-            PAIRP ob =>
-                qcar := QCAR ob
-                qcdr := QCDR ob
-                nob  := CONS(qcar, qcdr)
-                HPUT($seen, ob, nob)
-                HPUT($seen, nob, nob)
-                QRPLACA(nob, dewritifyInner qcar)
-                QRPLACD(nob, dewritifyInner qcdr)
-                nob
-            VECP ob =>
-                n   := QVMAXINDEX ob
-                nob := MAKE_-VEC(n+1)
-                HPUT($seen, ob, nob)
-                HPUT($seen, nob, nob)
-                for i in 0..n repeat
-                    QSETVELT(nob, i, dewritifyInner QVELT(ob,i))
-                nob
-            -- Default case: return the object itself.
-            ob
-\end{verbatim}
-<<defun dewritify,is?>>=
-(defun |dewritify,is?| (a)
- (boot-equal a 'writified!!))
-
-@
-<<defun dewritify,dewritifyInner>>=
-(defun |dewritify,dewritifyInner| (ob)
- (prog (e type oname f vec name tmp1 signif expon sign fval qcar qcdr n nob)
-  (return
-   (seq
-    (when (null ob) 
-      (exit nil))
-    (when (spadlet e (hget |$seen| ob)) 
-      (exit e))
-    (when (and (pairp ob) (boot-equal (car ob) 'writified!!))
-     (exit
-      (seq
-       (spadlet type (elt ob 1))
-       (when (boot-equal type 'self) 
-        (exit 'writified!!))
-       (when (boot-equal type 'bpi)
-        (exit
-         (seq
-          (spadlet oname (elt ob 2))
-          (spadlet f 
-           (seq 
-            (when (intp oname) (exit (eval (gensymmer oname))))
-            (exit (symbol-function oname))))
-          (when (null (compiled-function-p f))
-           (exit (|error| (makestring "A required BPI does not exist."))))
-          (when (and (> (|#| ob) 3) (nequal (hasheq f) (elt ob 3)))
-           (exit (|error| (makestring "A required BPI has been redefined."))))
-          (hput |$seen| ob f)
-          (exit f))))
-       (when (boot-equal type 'hashtable)
-        (exit
-         (seq
-          (spadlet nob (make-hashtable (elt ob 2)))
-          (hput |$seen| ob nob)
-          (hput |$seen| nob nob)
-          (do ((tmp0 (elt ob 3) (cdr tmp0))
-               (k nil)
-               (tmp1 (elt ob 4) (cdr tmp1))
-               (e nil))
-              ((or (atom tmp0) 
-                   (progn
-                    (setq k (car tmp0))
-                    nil) 
-                   (atom tmp1) 
-                   (progn
-                    (setq e (car tmp1))
-                    nil))
-                   nil)
-           (seq
-            (exit
-             (hput nob (|dewritify,dewritifyInner| k) 
-              (|dewritify,dewritifyInner| e)))))
-          (exit nob))))
-       (when (boot-equal type 'devaluated)
-        (exit
-         (seq
-          (spadlet nob (eval (|dewritify,dewritifyInner| (elt ob 2))))
-          (hput |$seen| ob nob)
-          (hput |$seen| nob nob)
-          (exit nob))))
-       (when (boot-equal type 'spadclosure)
-        (exit
-         (seq
-          (spadlet vec (|dewritify,dewritifyInner| (elt ob 2)))
-          (spadlet name (ELT ob 3))
-          (when (null (fboundp name))
-           (exit
-            (|error| 
-             (strconc (makestring "undefined function: ")
-              (symbol-name name)))))
-          (spadlet nob (cons (symbol-function name) vec))
-          (hput |$seen| ob nob)
-          (hput |$seen| nob nob)
-          (exit nob))))
-       (when (boot-equal type 'place) 
-        (exit
-         (seq
-          (spadlet nob (vmread (make-instream nil)))
-          (hput |$seen| ob nob)
-          (hput |$seen| nob nob)
-          (exit nob))))
-       (when (boot-equal type 'readtable)
-        (exit (|error| (makestring "Cannot de-writify a read table."))))
-       (when (boot-equal type 'nullstream)
-        (exit |$NullStream|))
-       (when (boot-equal type 'nonnullstream) 
-        (exit |$NonNullStream|))
-       (when (boot-equal type 'float) 
-        (exit
-         (seq
-          (progn
-           (spadlet tmp1 (cddr ob))
-           (spadlet fval (car tmp1))
-           (spadlet signif (cadr tmp1))
-           (spadlet expon (caddr tmp1))
-           (spadlet sign (cadddr tmp1))
-           tmp1)
-          (spadlet fval (scale-float (float signif fval) expon))
-          (when (minusp sign)
-           (exit (spaddifference fval)))
-          (exit fval))))
-       (exit (|error| (makestring "Unknown type to de-writify."))))))
-    (when (pairp ob)
-     (exit
-      (seq
-       (spadlet qcar (qcar ob))
-       (spadlet qcdr (qcdr ob))
-       (spadlet nob (cons qcar qcdr))
-       (hput |$seen| ob nob)
-       (hput |$seen| nob nob)
-       (qrplaca nob (|dewritify,dewritifyInner| qcar))
-       (qrplacd nob (|dewritify,dewritifyInner| qcdr))
-       (exit nob))))
-    (when (vecp ob)
-     (exit
-      (seq
-       (spadlet n (qvmaxindex ob))
-       (spadlet nob (make-vec (plus n 1)))
-       (hput |$seen| ob nob)
-       (hput |$seen| nob nob)
-       (do ((|i| 0 (qsadd1 |i|)))
-           ((qsgreaterp |i| n) nil)
-        (seq
-         (exit
-          (qsetvelt nob |i| 
-            (|dewritify,dewritifyInner| (qvelt ob |i|))))))
-       (exit nob))))
-    (exit ob))))) 
-
-@
-<<defun dewritify>>=
-(defun |dewritify| (ob)
- (prog (|$seen|)
-  (declare (special |$seen|))
-   (return
-    (cond 
-     ((null (|ScanOrPairVec| (|function| |dewritify,is?|) ob))
-       ob)
-     (t
-       (spadlet |$seen| (make-hashtable 'EQ))
-       (|dewritify,dewritifyInner| ob)))))) 
-
-@
-\subsection{defun ScanOrPairVec}
-\begin{verbatim}
-ScanOrPairVec(f, ob) ==
-    $seen:     local := MAKE_-HASHTABLE 'EQ
- 
-    CATCH('ScanOrPairVecAnswer, ScanOrInner(f, ob)) where
-        ScanOrInner(f, ob) ==
-            HGET($seen, ob) => nil
-            PAIRP ob =>
-                HPUT($seen, ob, true)
-                ScanOrInner(f, QCAR ob)
-                ScanOrInner(f, QCDR ob)
-                nil
-            VECP ob =>
-                HPUT($seen, ob, true)
-                for i in 0..#ob-1 repeat ScanOrInner(f, ob.i)
-                nil
-            FUNCALL(f, ob) =>
-                THROW('ScanOrPairVecAnswer, true)
-            nil
-\end{verbatim}
-<<defun ScanOrPairVec>>=
-(defun |ScanOrPairVec,ScanOrInner| (f ob)
- (seq
-  (when (hget |$seen| ob) 
-   (exit nil))
-  (when (pairp ob) 
-   (exit
-    (seq
-     (hput |$seen| ob t)
-     (|ScanOrPairVec,ScanOrInner| f (qcar ob))
-     (|ScanOrPairVec,ScanOrInner| f (qcdr ob))
-     (exit nil))))
-  (when (vecp ob) 
-   (exit
-    (seq
-     (hput |$seen| ob t)
-     (do ((tmp0 (spaddifference (|#| ob) 1)) (|i| 0 (qsadd1 |i|)))
-         ((qsgreaterp |i| tmp0) nil)
-      (seq
-       (exit (|ScanOrPairVec,ScanOrInner| f (elt ob |i|)))))
-     (exit nil))))
-  (when (funcall f ob) 
-   (exit
-    (throw '|ScanOrPairVecAnswer| t)))
-  (exit nil))) 
-
-(defun |ScanOrPairVec| (f ob)
- (prog (|$seen|) 
-  (declare (special |$seen|)) 
-   (return
-    (progn
-     (spadlet |$seen| (make-hashtable 'eq))
-     (catch '|ScanOrPairVecAnswer| (|ScanOrPairVec,ScanOrInner| f ob))))))
-
-@
-\subsection{defun gensymInt}
-\begin{verbatim}
-gensymInt g ==
-  not GENSYMP g => error '"Need a GENSYM"
-  p := PNAME g
-  n := 0
-  for i in 2..#p-1 repeat n := 10 * n + charDigitVal p.i
-  n
-\end{verbatim}
-<<defun gensymInt>>=
-(defun |gensymInt| (g) 
- (prog (p n)
-  (return
-   (seq
-    (cond 
-     ((null (gensymp g)) 
-       (|error| (makestring "Need a GENSYM")))
-     (t
-       (spadlet p (pname g))
-       (spadlet n 0)
-       (do ((tmp0 (spaddifference (|#| p) 1)) (|i| 2 (qsadd1 |i|)))
-           ((qsgreaterp |i| tmp0) nil)
-        (seq
-         (exit
-          (spadlet n (plus (times 10 n) (|charDigitVal| (elt p |i|)))))))
-       n))))))
-
-@
-\subsection{defun charDigitVal}
-\begin{verbatim}
-charDigitVal c ==
-  digits := '"0123456789"
-  n := -1
-  for i in 0..#digits-1 while n < 0 repeat
-      if c = digits.i then n := i
-  n < 0 => error '"Character is not a digit"
-  n
-\end{verbatim}
-<<defun charDigitVal>>=
-(defun |charDigitVal| (c)
- (prog (digits n)
-  (return
-   (seq
-    (progn
-     (spadlet digits (makestring "0123456789"))
-     (spadlet n (spaddifference 1)) 
-     (do ((tmp0 (spaddifference (|#| digits) 1)) (|i| 0 (qsadd1 |i|)))
-         ((or (qsgreaterp |i| tmp0) (null (minusp n))) nil)
-      (seq
-       (exit
-        (cond 
-         ((boot-equal c (elt digits |i|)) (spadlet n |i|))
-         (t nil)))))
-     (cond
-      ((minusp n) (|error| (makestring "Character is not a digit")))
-      (t n)))))))
-
-@
-\subsection{defun histFileErase}
-\begin{verbatim}
-histFileErase file ==
-  --OBEY STRCONC('"rm -rf ", file)
-  PROBE_-FILE(file) and DELETE_-FILE(file)
-\end{verbatim}
-<<defun histFileErase>>=
-(defun |histFileErase| (file)
- (when (probe-file file) 
-  (delete-file file)))
-
-@
-\section{History File Messages}
-<<History File Messages>>=
-S2IH0001
- You have not reached step %1b yet, and so its value cannot be
- supplied.
-S2IH0002
- Cannot supply value for step %1b because 1 is the first step.
-S2IH0003
- Step %1b has no value.
-S2IH0004
- The history facility is not on, so you cannot use %b %% %d .
-S2IH0006
- You have not used the correct syntax for the %b history %d command.
- Issue %b )help history %d for more information.
-S2IH0007
- The history facility is already on.
-S2IH0008
- The history facility is now on.
-S2IH0009
- Turning on the history facility will clear the contents of the
- workspace.
- Please enter %b y %d or %b yes %d if you really want to do this:
-S2IH0010
- The history facility is still off.
-S2IH0011
- The history facility is already off.
-S2IH0012
- The history facility is now off.
-S2IH0013
- The history facility is not on, so the .input file containing your user input
- cannot be created.
-S2IH0014
- Edit %b %1 %d to see the saved input lines.
-S2IH0015
- The argument %b n %d for %b )history )change n must be a nonnegative
- integer and your argument, %1b , is not one.
-S2IH0016
- The history facility is not on, so no information can be saved.
-S2IH0018
- The saved history file is %1b .
-S2IH0019
- There is no history file, so value of step %1b is
- undefined.
-S2IH0022
- No history information had been saved yet.
-S2IH0023
- %1b is not a valid filename for the history file.
-S2IH0024
- History information cannot be restored from %1b because the file does
- not exist.
-S2IH0025
- The workspace has been successfully restored from the history file
- %1b .
-S2IH0026
- The history facility command %1b cannot be performed because the
- history facility is not on.
-S2IH0027
- A value containing a %1b is being saved in a history file or a
- compiled input file INLIB. This type
- is not yet usable in other history operations.  You might want to issue
- %b )history )off %d
-S2IH0029
- History information is already being maintained in an external file
- (and not in memory).
-S2IH0030
- History information is already being maintained in memory (and not
- in an external file).
-S2IH0031
- When the history facility is active, history information will be
- maintained in a file (and not in an internal table).
-S2IH0032
- When the history facility is active, history information will be
- maintained in memory (and not in an external file).
-S2IH0034
- Missing element in internal history table.
-S2IH0035
- Can't save the value of step number %1b.  You can re-generate this value
- by running the input file %2b.
-S2IH0036
- The value specified cannot be saved to a file.
-S2IH0037
- You must specify a file name to the history save command
-S2IH0038
- You must specify a file name to the history write command
-@
-
-\chapter{The Frame Mechanism}
-\section{)frame}
-%\label{ugSysCmdframe}
-%\index{frame}
-\par\noindent{\bf Command Syntax:}
-\begin{list}{}
-\item{\tt )frame  new  {\it frameName}}
-\item{\tt )frame  drop  {\it [frameName]}}
-\item{\tt )frame  next}
-\item{\tt )frame  last}
-\item{\tt )frame  names}
-\item{\tt )frame  import {\it frameName} {\it [objectName1 [objectName2 ...]]}}
-\item{\tt )set message frame on | off}
-\item{\tt )set message prompt frame}
-\end{list}
-
-\par\noindent{\bf Command Description:}
-
-A {\it frame} can be thought of as a logical session within the
-physical session that you get when you start the system.  You can
-have as many frames as you want, within the limits of your computer's
-storage, paging space, and so on.
-Each frame has its own {\it step number}, {\it environment} and {\it history.}
-You can have a variable named {\tt a} in one frame and it will
-have nothing to do with anything that might be called {\tt a} in
-any other frame.
-
-Some frames are created by the HyperDoc program and these can
-have pretty strange names, since they are generated automatically.
-\index{frame names}
-To find out the names
-of all frames, issue
-\begin{verbatim}
-)frame names
-\end{verbatim}
-It will indicate the name of the current frame.
-
-You create a new frame
-\index{frame new}
-``{\bf quark}'' by issuing
-\begin{verbatim}
-)frame new quark
-\end{verbatim}
-The history facility can be turned on by issuing either
-{\tt )set history on} or {\tt )history )on}.
-If the history facility is on and you are saving history information
-in a file rather than in the Axiom environment
-then a history file with filename {\bf quark.axh} will
-be created as you enter commands.
-If you wish to go back to what
-you were doing in the
-\index{frame next}
-``{\bf initial}'' frame, use
-\index{frame last}
-\begin{verbatim}
-)frame next
-\end{verbatim}
-or
-\begin{verbatim}
-)frame last
-\end{verbatim}
-to cycle through the ring of available frames to get back to
-``{\bf initial}''.
-
-If you want to throw
-away a frame (say ``{\bf quark}''), issue
-\begin{verbatim}
-)frame drop quark
-\end{verbatim}
-If you omit the name, the current frame is dropped.
-\index{frame drop}
-
-If you do use frames with the history facility on and writing to a file,
-you may want to delete some of the older history files.
-\index{file!history}
-These are directories, so you may want to issue a command like
-{\tt rm -r quark.axh} to the operating system.
-
-You can bring things from another frame by using
-\index{frame import}
-{\tt )frame import}.
-For example, to bring the {\tt f} and {\tt g} from the frame ``{\bf quark}''
-to the current frame, issue
-\begin{verbatim}
-)frame import quark f g
-\end{verbatim}
-If you want everything from the frame ``{\bf quark}'', issue
-\begin{verbatim}
-)frame import quark
-\end{verbatim}
-You will be asked to verify that you really want everything.
-
-There are two {\tt )set} flags
-\index{set message frame}
-to make it easier to tell where you are.
-\begin{verbatim}
-)set message frame on | off
-\end{verbatim}
-will print more messages about frames when it is set on.
-By default, it is off.
-\begin{verbatim}
-)set message prompt frame
-\end{verbatim}
-will give a prompt
-\index{set message prompt frame}
-that looks like
-\begin{verbatim}
-initial (1) ->
-\end{verbatim}
-\index{prompt!with frame name}
-when you start up. In this case, the frame name and step make up the
-prompt.
-
-\par\noindent{\bf Also See:}
-{\tt )history} \index{ugSysCmdhistory} and
-{\tt )set} \index{ugSysCmdset}.
-
-\subsection{defun frameName}
-\begin{verbatim}
-frameName(frame) == CAR frame
-\end{verbatim}
-<<defun frameName>>=
-(defun |frameName| (frame)
- (car frame)) 
-
-@
-\section{Variables Used}
-\section{Data Structures}
-\section{Functions}
-\subsection{defun frameNames}
-\begin{verbatim}
-frameNames() == [frameName f for f in $interpreterFrameRing]
-\end{verbatim}
-<<defun frameNames>>=
-(defun |frameNames| () 
- (prog () 
-  (return
-   (seq
-    (prog (tmp0)
-     (spadlet tmp0 nil) 
-     (return
-      (do ((tmp1 |$interpreterFrameRing| (cdr tmp1)) (f nil))
-          ((or (atom tmp1) 
-               (progn (setq f (car tmp1)) nil))
-            (nreverse0 tmp0))
-       (seq
-        (exit
-         (setq tmp0 (cons (|frameName| f) tmp0))))))))))) 
-
-@
-\subsection{defun frameEnvironment}
-\begin{verbatim}
-frameEnvironment fname ==
-  -- extracts the environment portion of a frame
-  -- if fname is not a valid frame name then the empty environment
-  -- is returned
-  fname = frameName first $interpreterFrameRing => $InteractiveFrame
-  ifr := rest $interpreterFrameRing
-  e := LIST LIST NIL
-  while ifr repeat
-    [f,:ifr] := ifr
-    if fname = frameName f   then
-      e := CADR f
-      ifr := NIL
-  e
-\end{verbatim}
-<<defun frameEnvironment>>=
-(defun |frameEnvironment| (fname)
- (prog
-  (tmp1 f e ifr)
-  (return
-   (seq
-    (cond
-     ((boot-equal fname (|frameName| (CAR |$interpreterFrameRing|)))
-       |$InteractiveFrame|)
-     (t
-       (spadlet ifr (cdr |$interpreterFrameRing|))
-       (spadlet e (list (list nil)))
-       (do () 
-           ((null ifr) nil)
-        (seq
-         (exit
-          (progn
-           (spadlet tmp1 ifr)
-           (spadlet f (car tmp1))
-           (spadlet ifr (cdr tmp1))
-           (cond
-            ((boot-equal fname (|frameName| f))
-              (spadlet e (cadr f))
-              (spadlet ifr nil))
-            (t nil)))))) e)))))) 
-
-@
-\subsection{defun emptyInterpreterFrame}
-\begin{verbatim}
-emptyInterpreterFrame(name) ==
-  LIST(name,                            -- frame name
-       LIST LIST NIL,                   -- environment
-       1,                               -- $IOindex
-       $HiFiAccess,                     -- $HiFiAccess
-       $HistList,                       -- $HistList
-       $HistListLen,                    -- $HistListLen
-       $HistListAct,                    -- $HistListAct
-       $HistRecord,                     -- $HistRecord
-       NIL,                             -- $internalHistoryTable
-       COPY_-SEQ $localExposureDataDefault        -- $localExposureData
-      )
-\end{verbatim}
-<<defun emptyInterpreterFrame>>=
-(defun |emptyInterpreterFrame| (name)
- (list name
-   (list (list nil))
-   1 
-   |$HiFiAccess| 
-   |$HistList| 
-   |$HistListLen| 
-   |$HistListAct| 
-   |$HistRecord| 
-   nil 
-   (copy-seq |$localExposureDataDefault|))) 
-
-@
-\subsection{defun createCurrentInterpreterFrame}
-\begin{verbatim}
-createCurrentInterpreterFrame() ==
-  LIST($interpreterFrameName,           -- frame name
-       $InteractiveFrame,               -- environment
-       $IOindex,                        -- $IOindex
-       $HiFiAccess,                     -- $HiFiAccess
-       $HistList,                       -- $HistList
-       $HistListLen,                    -- $HistListLen
-       $HistListAct,                    -- $HistListAct
-       $HistRecord,                     -- $HistRecord
-       $internalHistoryTable,           -- $internalHistoryTable
-       $localExposureData               -- $localExposureData
-      )
-\end{verbatim}
-<<defun createCurrentInterpreterFrame>>=
-(defun |createCurrentInterpreterFrame| ()
- (list 
-   |$interpreterFrameName| 
-   |$InteractiveFrame| 
-   |$IOindex| 
-   |$HiFiAccess| 
-   |$HistList| 
-   |$HistListLen| 
-   |$HistListAct| 
-   |$HistRecord| 
-   |$internalHistoryTable| 
-   |$localExposureData|)) 
-
-@
-\subsection{defun updateFromCurrentInterpreterFrame}
-\begin{verbatim}
-updateFromCurrentInterpreterFrame() ==
-  [$interpreterFrameName,          _
-   $InteractiveFrame,              _
-   $IOindex,                       _
-   $HiFiAccess,                    _
-   $HistList,                      _
-   $HistListLen,                   _
-   $HistListAct,                   _
-   $HistRecord,                    _
-   $internalHistoryTable,          _
-   $localExposureData              _
-   ] := first $interpreterFrameRing
-  if $frameMessages then
-    sayMessage ['"   Current interpreter frame is called",:bright
-      $interpreterFrameName]
-  NIL
-\end{verbatim}
-<<defun updateFromCurrentInterpreterFrame>>=
-(defun |updateFromCurrentInterpreterFrame| ()
- (prog (tmp1)
-  (return
-   (progn
-    (spadlet tmp1 (CAR |$interpreterFrameRing|))
-    (spadlet |$interpreterFrameName| (car tmp1))
-    (spadlet |$InteractiveFrame| (cadr tmp1))
-    (spadlet |$IOindex| (caddr tmp1))
-    (spadlet |$HiFiAccess| (cadddr tmp1))
-    (spadlet |$HistList| (car (cddddr tmp1)))
-    (spadlet |$HistListLen| (cadr (cddddr tmp1)))
-    (spadlet |$HistListAct| (caddr (cddddr tmp1)))
-    (spadlet |$HistRecord| (cadddr (cddddr tmp1)))
-    (spadlet |$internalHistoryTable| (car (cddddr (cddddr tmp1))))
-    (spadlet |$localExposureData| (cadr (cddddr (cddddr tmp1))))
-    (when |$frameMessages| 
-      (|sayMessage| 
-       (cons 
-        (makestring "   Current interpreter frame is called") 
-        (|bright| |$interpreterFrameName|))))
-    nil)))) 
-
-@
-\subsection{defun findFrameInRing}
-\begin{verbatim}
-findFrameInRing(name) ==
-  val := NIL
-  for frame in $interpreterFrameRing repeat
-    CAR frame = name =>
-      val := frame
-      return frame
-  val
-\end{verbatim}
-<<defun findFrameInRing>>=
-(defun |findFrameInRing| (name)
- (prog (val)
-  (return 
-   (seq 
-    (progn 
-     (spadlet val nil)
-     (seq 
-      (do ((tmp0 |$interpreterFrameRing| (cdr tmp0)) (frame nil))
-          ((or (atom tmp0)
-               (progn (setq frame (car tmp0)) nil)) 
-            nil)
-       (seq 
-        (exit 
-         (when (boot-equal (CAR frame) name)
-          (exit
-           (progn
-            (spadlet val frame)
-            (return frame)))))))
-      (exit val))))))) 
-
-@
-\subsection{defun updateCurrentInterpreterFrame}
-\begin{verbatim}
-updateCurrentInterpreterFrame() ==
-  RPLACA($interpreterFrameRing,createCurrentInterpreterFrame())
-  updateFromCurrentInterpreterFrame()
-  NIL
-\end{verbatim}
-<<defun updateCurrentInterpreterFrame>>=
-(defun |updateCurrentInterpreterFrame| ()
- (progn
-  (rplaca |$interpreterFrameRing| (|createCurrentInterpreterFrame|))
-  (|updateFromCurrentInterpreterFrame|)
-  nil)) 
-
-@
-\subsection{defun initializeInterpreterFrameRing}
-\begin{verbatim}
-initializeInterpreterFrameRing() ==
-  $interpreterFrameName := 'initial
-  $interpreterFrameRing := [emptyInterpreterFrame($interpreterFrameName)]
-  updateFromCurrentInterpreterFrame()
-  NIL
-\end{verbatim}
-<<defun initializeInterpreterFrameRing>>=
-(defun |initializeInterpreterFrameRing| ()
- (progn
-  (spadlet |$interpreterFrameName| '|initial|)
-  (spadlet |$interpreterFrameRing|
-   (cons (|emptyInterpreterFrame| |$interpreterFrameName|) nil))
-  (|updateFromCurrentInterpreterFrame|) nil)) 
-
-@
-\subsection{defun nextInterpreterFrame}
-\begin{verbatim}
-nextInterpreterFrame() ==
-  updateCurrentInterpreterFrame()
-  null rest $interpreterFrameRing => NIL  -- nothing to do
-  $interpreterFrameRing :=
-    NCONC2(rest $interpreterFrameRing,[first $interpreterFrameRing])
-  updateFromCurrentInterpreterFrame()
-\end{verbatim}
-<<defun nextInterpreterFrame>>=
-(defun |nextInterpreterFrame| ()
- (progn
-  (|updateCurrentInterpreterFrame|)
-  (cond
-    ((null (cdr |$interpreterFrameRing|))
-      nil)
-    (t 
-      (spadlet |$interpreterFrameRing|
-       (nconc2
-        (cdr |$interpreterFrameRing|)
-        (cons
-         (car |$interpreterFrameRing|) nil)))
-      (|updateFromCurrentInterpreterFrame|))))) 
-
-@
-\subsection{defun changeToNamedInterpreterFrame}
-\begin{verbatim}
-changeToNamedInterpreterFrame(name) ==
-  updateCurrentInterpreterFrame()
-  frame := findFrameInRing(name)
-  null frame => NIL
-  $interpreterFrameRing := [frame,:NREMOVE($interpreterFrameRing, frame)]
-  updateFromCurrentInterpreterFrame()
-\end{verbatim}
-<<defun changeToNamedInterpreterFrame>>=
-(defun |changeToNamedInterpreterFrame| (name)
- (prog (frame)
-  (return
-   (progn 
-    (|updateCurrentInterpreterFrame|)
-    (spadlet frame (|findFrameInRing| name))
-    (cond 
-     ((null frame) 
-       nil)
-     (t 
-       (spadlet |$interpreterFrameRing|
-        (cons frame (nremove |$interpreterFrameRing| frame)))
-       (|updateFromCurrentInterpreterFrame|))))))) 
-
-@
-\subsection{defun previousInterpreterFrame}
-\begin{verbatim}
-previousInterpreterFrame() ==
-  updateCurrentInterpreterFrame()
-  null rest $interpreterFrameRing => NIL  -- nothing to do
-  [:b,l] := $interpreterFrameRing
-  $interpreterFrameRing := NCONC2([l],b)
-  updateFromCurrentInterpreterFrame()
-\end{verbatim}
-<<defun previousInterpreterFrame>>=
-(defun |previousInterpreterFrame| ()
- (prog (tmp1 l b)
-  (return
-   (progn
-    (|updateCurrentInterpreterFrame|)
-    (cond
-     ((null (cdr |$interpreterFrameRing|))
-       nil)
-     (t
-       (spadlet tmp1 (reverse |$interpreterFrameRing|))
-       (spadlet l (car tmp1))
-       (spadlet b (nreverse (cdr tmp1)))
-       (spadlet |$interpreterFrameRing| (nconc2 (cons l nil) b))
-       (|updateFromCurrentInterpreterFrame|))))))) 
-
-@
-\subsection{defun addNewInterpreterFrame}
-\begin{verbatim}
-addNewInterpreterFrame(name) ==
-  null name => throwKeyedMsg("S2IZ0018",NIL)
-  updateCurrentInterpreterFrame()
-  -- see if we already have one by that name
-  for f in $interpreterFrameRing repeat
-    name = frameName(f) => throwKeyedMsg("S2IZ0019",[name])
-  initHistList()
-  $interpreterFrameRing := CONS(emptyInterpreterFrame(name),
-    $interpreterFrameRing)
-  updateFromCurrentInterpreterFrame()
-  _$ERASE histFileName()
-\end{verbatim}
-<<defun addNewInterpreterFrame>>=
-(defun |addNewInterpreterFrame| (name)
- (seq
-  (cond
-   ((null name)
-    (|throwKeyedMsg| 'S2IZ0018 nil))  ; you must provide a name for new frame
-   (t
-     (|updateCurrentInterpreterFrame|)
-     (seq
-      (do ((tmp0 |$interpreterFrameRing| (cdr tmp0)) (f nil))
-          ((or (atom tmp0) 
-               (progn (setq f (car tmp0)) nil))
-             nil)
-       (seq
-        (exit
-         (when (boot-equal name (|frameName| f))
-          (exit 
-           (|throwKeyedMsg| 'S2IZ0019 ; existing frame with same name
-            (cons name nil)))))))
-      (|initHistList|)
-      (spadlet |$interpreterFrameRing|
-       (cons (|emptyInterpreterFrame| name) |$interpreterFrameRing|))
-      (|updateFromCurrentInterpreterFrame|)
-      ($erase (|histFileName|))))))) 
-
-@
-\subsection{defun closeInterpreterFrame}
-\begin{verbatim}
-closeInterpreterFrame(name) ==
-  -- if name = NIL then it means the current frame
-  null rest $interpreterFrameRing =>
-    name and (name ^= $interpreterFrameName) =>
-      throwKeyedMsg("S2IZ0020",[$interpreterFrameName])
-    throwKeyedMsg("S2IZ0021",NIL)
-  if null name then $interpreterFrameRing := rest $interpreterFrameRing
-  else   -- find the frame
-    found := nil
-    ifr := NIL
-    for f in $interpreterFrameRing repeat
-      found or (name ^= frameName(f)) => ifr := CONS(f,ifr)
-      found := true
-    not found => throwKeyedMsg("S2IZ0022",[name])
-    _$ERASE makeHistFileName(name)
-    $interpreterFrameRing := nreverse ifr
-  updateFromCurrentInterpreterFrame()
-\end{verbatim}
-<<defun closeInterpreterFrame>>=
-(defun |closeInterpreterFrame| (name)
- (prog (ifr found)
-  (return
-   (seq
-    (cond
-     ((null (cdr |$interpreterFrameRing|))
-       (cond
-        ((and name (nequal name |$interpreterFrameName|))
-          (|throwKeyedMsg| 'S2IZ0020 ; 1 frame left. not the correct name.
-            (cons |$interpreterFrameName| nil))) 
-        (t (|throwKeyedMsg| 'S2IZ0021 nil)))) ; only 1 frame left, not closed
-     (t
-       (cond
-        ((null name)
-          (spadlet |$interpreterFrameRing| (cdr |$interpreterFrameRing|)))
-        (t 
-          (spadlet found nil)
-          (spadlet ifr nil)
-          (do ((tmp0 |$interpreterFrameRing| (cdr tmp0)) (f nil))
-              ((or (atom tmp0) (progn (setq f (car tmp0)) nil)) nil)
-           (seq
-            (exit
-             (cond
-              ((or found (nequal name (|frameName| f)))
-                (spadlet ifr (cons f ifr)))
-              (t 
-                (spadlet found t))))))
-          (cond
-           ((null found) 
-              (|throwKeyedMsg| 'S2IZ0022 (cons name nil)))
-           (t
-              ($erase (|makeHistFileName| name))
-              (spadlet |$interpreterFrameRing| (nreverse ifr))))))
-       (|updateFromCurrentInterpreterFrame|))))))) 
-
-@
-\subsection{defun displayFrameNames}
-\begin{verbatim}
-displayFrameNames() ==
-  fs := "append"/[ ['%l,'"     ",:bright frameName f] for f in
-    $interpreterFrameRing]
-  sayKeyedMsg("S2IZ0024",[fs])
-\end{verbatim}
-<<defun displayFrameNames>>=
-(defun |displayFrameNames| ()
- (prog (fs)
-  (return
-   (seq
-    (progn
-     (spadlet fs
-      (prog (tmp0)
-       (spadlet tmp0 NIL)
-       (return
-        (do ((tmp1 |$interpreterFrameRing| (cdr tmp1)) (f nil))
-            ((or (atom tmp1)
-                 (progn (setq f (car tmp1)) nil))
-               tmp0)
-         (seq
-          (exit
-           (setq tmp0
-            (append tmp0 (cons '|%l| 
-              (cons (makestring "     ") (|bright| (|frameName| f))))))))))))
-      (|sayKeyedMsg| 'S2IZ0024 (cons fs nil))))))) ; frame names are ...
-
-@
-\subsection{defun importFromFrame}
-\begin{verbatim}
-importFromFrame args ==
-  -- args should have the form [frameName,:varNames]
-  if args and atom args then args := [args]
-  null args => throwKeyedMsg("S2IZ0073",NIL)
-  [fname,:args] := args
-  not member(fname,frameNames()) =>
-    throwKeyedMsg("S2IZ0074",[fname])
-  fname = frameName first $interpreterFrameRing =>
-    throwKeyedMsg("S2IZ0075",NIL)
-  fenv := frameEnvironment fname
-  null args =>
-    x := UPCASE queryUserKeyedMsg("S2IZ0076",[fname])
-    MEMQ(STRING2ID_-N(x,1),'(Y YES)) =>
-      vars := NIL
-      for [v,:props] in CAAR fenv repeat
-        v = "--macros" =>
-          for [m,:.] in props repeat vars := cons(m,vars)
-        vars := cons(v,vars)
-      importFromFrame [fname,:vars]
-    sayKeyedMsg("S2IZ0077",[fname])
-  for v in args repeat
-    plist := GETALIST(CAAR fenv,v)
-    plist =>
-      -- remove anything with the same name in the current frame
-      clearCmdParts ['propert,v]
-      for [prop,:val] in plist repeat
-        putHist(v,prop,val,$InteractiveFrame)
-    (m := get("--macros--",v,fenv)) =>
-      putHist("--macros--",v,m,$InteractiveFrame)
-    sayKeyedMsg("S2IZ0079",[v,fname])
-  sayKeyedMsg("S2IZ0078",[fname])
-\end{verbatim}
-<<defun importFromFrame>>=
-(defun |importFromFrame| (args)
- (prog (temp1 fname fenv x v props vars plist prop val m)
-  (return
-   (seq
-    (progn
-     (when (and args (atom args))
-       (spadlet args (cons args nil))) 
-     (cond
-      ((null args)
-        (|throwKeyedMsg| 'S2IZ0073 nil)) ; missing frame name
-      (t
-        (spadlet temp1 args)
-        (spadlet fname (car temp1))
-        (spadlet args (cdr temp1))
-        (cond
-         ((null (|member| fname (|frameNames|)))
-           (|throwKeyedMsg| 'S2IZ0074 (cons fname nil))) ; not frame name
-         ((boot-equal fname (|frameName| (car |$interpreterFrameRing|)))
-           (|throwKeyedMsg| 'S2IZ0075 NIL)) ; cannot import from curr frame
-         (t
-           (spadlet fenv (|frameEnvironment| fname))
-           (cond
-            ((null args)
-              (spadlet x
-                (upcase (|queryUserKeyedMsg| 'S2IZ0076 (cons fname nil))))
-                                             ; import everything?
-              (cond
-               ((memq (string2id-n x 1) '(y yes))
-                 (spadlet vars nil)
-                 (do ((tmp0 (caar fenv) (cdr tmp0)) (tmp1 nil))
-                     ((or (atom tmp0) 
-                          (progn (setq tmp1 (car tmp0)) nil)
-                          (progn 
-                           (progn 
-                            (spadlet v (car tmp1))
-                            (spadlet props (cdr tmp1))
-                            tmp1)
-                           nil))
-                       nil)
-                  (seq
-                   (exit
-                    (cond
-                     ((boot-equal v '|--macros|)
-                       (do ((tmp2 props (cdr tmp2))
-                            (tmp3 nil))
-                           ((or (atom tmp2) 
-                                (progn (setq tmp3 (car tmp2)) nil)
-                                (progn 
-                                 (progn (spadlet m (car tmp3)) tmp3)
-                                 nil))
-                              nil)
-                        (seq
-                         (exit
-                          (spadlet vars (cons m vars))))))
-                     (t (spadlet vars (cons v vars)))))))
-                 (|importFromFrame| (cons fname vars)))
-               (t
-                 (|sayKeyedMsg| 'S2IZ0077 (cons fname nil)))))
-            (t
-             (do ((tmp4 args (cdr tmp4)) (v nil))
-                 ((or (atom tmp4) (progn (setq v (car tmp4)) nil)) nil)
-              (seq
-               (exit
-                (progn
-                 (spadlet plist (getalist (caar fenv) v))
-                 (cond
-                  (plist 
-                   (|clearCmdParts| (cons '|propert| (cons v nil)))
-                   (do ((tmp5 plist (cdr tmp5)) (tmp6 nil))
-                       ((or (atom tmp5)
-                            (progn (setq tmp6 (car tmp5)) nil)
-                            (progn 
-                             (progn 
-                              (spadlet prop (car tmp6))
-                              (spadlet val (cdr tmp6))
-                              tmp6)
-                             nil))
-                          nil)
-                    (seq
-                     (exit (|putHist| v prop val |$InteractiveFrame|)))))
-                  ((spadlet m (|get| '|--macros--| v fenv))
-                    (|putHist| '|--macros--| v m |$InteractiveFrame|))
-                  (t 
-                    (|sayKeyedMsg| 'S2IZ0079 ; frame not found
-                      (cons v (cons fname nil)))))))))
-             (|sayKeyedMsg| 'S2IZ0078 ; import complete
-               (cons fname nil))))))))))))) 
-
-@
-\subsection{defun frame}
-\begin{verbatim}
--- the system command
-
-frame l == frameSpad2Cmd l
-\end{verbatim}
-<<defun frame>>=
-(defun |frame| (l)
- (|frameSpad2Cmd| l)) 
-
-@
-\subsection{defun frameSpad2Cmd}
-\begin{verbatim}
-frameSpad2Cmd args ==
-  frameArgs := '(drop import last names new next)
-  $options => throwKeyedMsg("S2IZ0016",['")frame"])
-  null(args) => helpSpad2Cmd ['frame]
-  arg  := selectOptionLC(first args,frameArgs,'optionError)
-  args := rest args
-  if args is [a] then args := a
-  if ATOM args then args := object2Identifier args
-  arg = 'drop  =>
-    args and PAIRP(args) => throwKeyedMsg("S2IZ0017",[args])
-    closeInterpreterFrame(args)
-  arg = 'import =>  importFromFrame args
-  arg = 'last  =>   previousInterpreterFrame()
-  arg = 'names =>   displayFrameNames()
-  arg = 'new   =>
-    args and PAIRP(args) => throwKeyedMsg("S2IZ0017",[args])
-    addNewInterpreterFrame(args)
-  arg = 'next  =>   nextInterpreterFrame()
-
-  NIL
-\end{verbatim}
-<<defun frameSpad2Cmd>>=
-(defun |frameSpad2Cmd| (args)
- (prog (frameArgs arg a)
-  (return
-   (progn
-    (spadlet frameArgs '(|drop| |import| |last| |names| |new| |next|))
-    (cond
-     (|$options|
-      (|throwKeyedMsg| 'S2IZ0016 ; frame command does not take options
-       (cons (makestring ")frame") nil)))
-     ((null args) 
-       (|helpSpad2Cmd| (cons '|frame| nil)))
-     (t
-       (spadlet arg 
-         (|selectOptionLC| (car args) frameArgs '|optionError|))
-       (spadlet args (cdr args))
-       (cond
-        ((and (pairp args) 
-              (eq (qcdr args) nil)
-              (progn (spadlet a (qcar args)) t))
-          (spadlet args a)))
-       (when (atom args)
-          (spadlet args (|object2Identifier| args)))
-       (cond
-        ((boot-equal arg '|drop|)
-          (cond
-           ((and args (pairp args))
-             (|throwKeyedMsg| 'S2IZ0017 ; not a valid frame name
-               (cons args nil)))
-           (t (|closeInterpreterFrame| args))))
-        ((boot-equal arg '|import|)
-          (|importFromFrame| args))
-        ((boot-equal arg '|last|)
-          (|previousInterpreterFrame|))
-        ((boot-equal arg '|names|)
-          (|displayFrameNames|))
-        ((boot-equal arg '|new|)
-          (cond 
-           ((and args (pairp args))
-             (|throwKeyedMsg| 'S2IZ0017 ; not a valid frame name
-               (cons args nil)))
-           (t
-             (|addNewInterpreterFrame| args))))
-        ((boot-equal arg '|next|)
-          (|nextInterpreterFrame|))
-        (t nil)))))))) 
-
-@
-\section{Frame File Messages}
-<<Frame File Messages>>=
-S2IZ0016
- The %1b system command takes arguments but no options.
-S2IZ0017
- %1b is not a valid frame name
-S2IZ0018
- You must provide a name for the new frame.
-S2IZ0019
- You cannot use the name %1b for a new frame because an existing
- frame already has that name.
-S2IZ0020
- There is only one frame active and therefore that cannot be closed.
- Furthermore, the frame name you gave is not the name of the current frame.
- The current frame is called %1b .
-S2IZ0021
- The current frame is the only active one.  Issue %b )clear all %d to
- clear its contents.
-S2IZ0022
- There is no frame called %1b and so your command cannot be
- processed.
-S2IZ0024
- The names of the existing frames are: %1 %l
- The current frame is the first one listed.
-S2IZ0073
- %b )frame import %d must be followed by the frame name. The names
- of objects in that frame can then optionally follow the frame name.
- For example,
- %ceon %b )frame import calculus %d %ceoff
- imports all objects in the %b calculus %d frame, and
- %ceon %b )frame import calculus epsilon delta %d %ceoff
- imports the objects named %b epsilon %d and %b delta %d from the
- frame %b calculus %d .
- Please note that if the current frame contained any information
- about objects with these names, then that information would be
- cleared before the import took place.
-S2IZ0074
- You cannot import anything from the frame %1b because that is not
- the name of an existing frame.
-S2IZ0075
- You cannot import from the current frame (nor is there a need!).
-S2IZ0076
- User verification required:
- do you really want to import everything from the frame %1b ?
- If so, please enter %b y %d or %b yes %d :
-S2IZ0077
- On your request, AXIOM will not import everything from frame %1b.
-S2IZ0078
- Import from frame %1b is complete. Please issue %b )display all %d
- if you wish to see the contents of the current frame.
-S2IZ0079
- AXIOM cannot import %1b from frame %2b because it cannot be found.
-@
-\chapter{The Undo Mechanism}
-\section{)undo}
-\index{ugSysCmdundo}
-
-\index{undo}
-
-
-\par\noindent{\bf User Level Required:} interpreter
-
-\par\noindent{\bf Command Syntax:}
-\begin{list}{}
-\item{\tt )undo}
-\item{\tt )undo} {\it integer}
-\item{\tt )undo} {\it integer [option]}
-\item{\tt )undo} {\tt )redo}
-\end{list}
-%
-where {\it option} is one of
-%
-\begin{list}{}
-\item{\tt )after}
-\item{\tt )before}
-\end{list}
-
-\par\noindent{\bf Command Description:}
-
-This command is used to
-restore the state of the user environment to an earlier
-point in the interactive session.
-The argument of an {\tt )undo} is an integer which must designate some
-step number in the interactive session.
-
-\begin{verbatim}
-)undo n
-)undo n )after
-\end{verbatim}
-These commands return the state of the interactive
-environment to that immediately after step {\tt n}.
-If {\tt n} is a positive number, then {\tt n} refers to step nummber
-{\tt n}. If {\tt n} is a negative number, it refers to the \tt n-th
-previous command (that is, undoes the effects of the last $-n$
-commands).
-
-A {\tt )clear all} resets the {\tt )undo} facility.
-Otherwise, an {\tt )undo} undoes the effect of {\tt )clear} with
-options {\tt properties}, {\tt value}, and {\tt mode}, and
-that of a previous {\tt undo}.
-If any such system commands are given between steps $n$ and
-$n + 1$ ($n > 0$), their effect is undone
-for {\tt )undo m} for any $0 < m \leq n$..
-
-The command {\tt )undo} is equivalent to {\tt )undo -1} (it undoes
-the effect of the previous user expression).
-The command {\tt )undo 0} undoes any of the above system commands
-issued since the last user expression.
-
-\begin{verbatim}
-)undo n )before
-\end{verbatim}
-This command returns the state of the interactive
-environment to that immediately before step {\tt n}.
-Any {\tt )undo} or {\tt )clear} system commands
-given before step {\tt n} will not be undone.
-
-\begin{verbatim}
-)undo )redo
-\end{verbatim}
-This command reads the file {\tt redo.input}.
-created by the last {\tt )undo} command.
-This file consists of all user input lines, excluding those
-backtracked over due to a previous {\tt )undo}.
-
-\par\noindent{\bf Also See:}
-{\tt )history} \index{ugSysCmdhistory}.
-The command {\tt )history )write} will eliminate the ``undone'' command
-lines of your program.
-\section{Variables Used}
-\section{Data Structures}
-[[$frameRecord = [delta1, delta2,... ] ]] where
-[[delta(i)]] contains changes in the ``backwards'' direction.
-Each [[delta(i)]] has the form [[((var . proplist)...)]] where
-proplist denotes an ordinary proplist. For example, an entry
-of the form [[((x (value) (mode (Integer)))...)]] indicates that
-to undo 1 step, [[x]]'s value is cleared and its mode should be set
-to [[(Integer)]].
-
-A [[delta(i)]] of the form [[(systemCommand . delta)]] is a special
-delta indicating changes due to system commands executed between
-the last command and the current command. By recording these deltas
-separately, it is possible to undo to either BEFORE or AFTER
-the command. These special [[delta(i)]]s are given ONLY when a
-a system command is given which alters the environment.
-
-Note: [[recordFrame('system)]] is called before a command is executed, and
-[[recordFrame('normal)]] is called after (see processInteractive1).
-If no changes are found for former, no special entry is given.
-
-The [[$previousBindings]] is a copy of the 
-[[CAAR $InteractiveFrame]]. This is used to
-compute the [[delta(i)]]s stored in [[$frameRecord]].
-\section{Functions}
-\subsection{Initial Undo Variables}
-\begin{verbatim}
-$undoFlag := true     --Default setting for undo is "on"
-$frameRecord  := nil  --Initial setting for frame record
-$previousBindings := nil
-\end{verbatim}
-<<initvars>>=
-(defvar |$undoFlag| t "t means we record undo information")
-(defvar |$frameRecord| nil "a list of value changes") 
-(defvar |$previousBindings| nil "a copy of Interactive Frame info for undo") 
-(defvar |$reportUndo| nil "t means we report the steps undo takes")
-@
-\subsection{defun undo}
-\begin{verbatim}
-undo(l) ==
---undo takes one option ")redo" which simply reads "redo.input",
---  a file created by every normal )undo command (see below)
-  undoWhen := 'after
-  if $options is [[key]] then
-    stringPrefix?(s := PNAME key,'"redo") =>
-      $options := nil           --clear $options so that "read" won't see them
-      read '(redo_.input)
-    not stringPrefix?(s,'"before") =>
-       userError '"only option to undo is _")redo_""
-    undoWhen := 'before
-  n :=
-    null l => -1
-    first l
-  if IDENTP n then
-    n := PARSE_-INTEGER PNAME n
-    if not FIXP n then userError '"undo argument must be an integer"
-  $InteractiveFrame := undoSteps(undoCount n,undoWhen)
-  nil
-\end{verbatim}
-<<defun undo>>=
-(defun |undo| (l)
- (prog (tmp1 key s undoWhen n)
-  (return
-   (progn
-    (spadlet undoWhen '|after|)
-    (when
-      (and (pairp |$options|)
-           (eq (qcdr |$options|) nil)
-           (progn
-            (spadlet tmp1 (qcar |$options|))
-            (and (pairp tmp1)
-                 (eq (qcdr tmp1) nil)
-                 (progn (spadlet key (qcar tmp1)) t)))
-       (cond
-        ((|stringPrefix?| (spadlet s (pname key)) (makestring "redo"))
-          (spadlet |$options| nil) 
-          (|read| '(|redo.input|)))
-        ((null (|stringPrefix?| s (makestring "before")))
-          (|userError| (makestring "only option to undo is \")redo\"")))
-        (t 
-          (spadlet undoWhen '|before|)))))
-    (if (null l)
-      (spadlet n (spaddifference 1))
-      (spadlet n (car l)))
-    (when (identp n)
-      (spadlet n (parse-integer (pname n)))
-      (cond
-       ((null (fixp n)) 
-         (|userError| (makestring "undo argument must be an integer")))
-       (t 
-         nil)))
-    (spadlet |$InteractiveFrame| (|undoSteps| (|undoCount| n) undoWhen))
-    nil)))) 
-
-@
-\subsection{defun recordFrame}
-\begin{verbatim}
-recordFrame(systemNormal) ==
-  null $undoFlag => nil        --do nothing if facility is turned off
-  currentAlist := KAR $frameRecord
-  delta := diffAlist(CAAR $InteractiveFrame,$previousBindings)
-  if systemNormal = 'system then
-    null delta => return nil     --do not record
-    delta := ['systemCommand,:delta]
-  $frameRecord := [delta,:$frameRecord]
-  $previousBindings := --copy all but the individual properties
-    [CONS(CAR x,[CONS(CAR y,CDR y) for y in CDR x]) for x in CAAR $InteractiveFrame]
-  first $frameRecord
-\end{verbatim}
-<<defun recordFrame>>=
-(defun |recordFrame| (systemNormal)
- (prog (currentAlist delta)
-  (return
-   (seq
-    (cond 
-     ((null |$undoFlag|) nil)
-     (t 
-       (spadlet currentAlist (kar |$frameRecord|))
-       (spadlet delta 
-         (|diffAlist| (caar |$InteractiveFrame|) |$previousBindings|))
-       (cond
-        ((boot-equal systemNormal '|system|)
-          (cond 
-           ((null delta)
-             (return nil))
-           (t
-             (spadlet delta (cons '|systemCommand| delta))))))
-       (spadlet |$frameRecord| (cons delta |$frameRecord|))
-       (spadlet |$previousBindings|
-        (prog (tmp0)
-         (spadlet tmp0 nil)
-         (return
-          (do ((tmp1 (caar |$InteractiveFrame|) (cdr tmp1)) (x nil))
-              ((or (atom tmp1) 
-                   (progn (setq x (car tmp1)) nil))
-                (nreverse0 tmp0))
-           (seq
-            (exit
-             (setq tmp0
-              (cons 
-               (cons 
-                (car x)
-                (prog (tmp2)
-                 (spadlet tmp2 nil)
-                 (return
-                  (do ((tmp3 (cdr x) (cdr tmp3)) (|y| nil))
-                      ((or (atom tmp3) 
-                           (progn (setq |y| (car tmp3)) nil))
-                        (nreverse0 tmp2))
-                   (seq
-                    (exit
-                     (setq tmp2 (cons (cons (car |y|) (cdr |y|)) tmp2))))))))
-                tmp0))))))))
-       (car |$frameRecord|))))))) 
-
-@
-\subsection{defun diffAlist}
-\begin{verbatim}
-diffAlist(new,old) ==
---record only those properties which are different
-  for (pair := [name,:proplist]) in new repeat
-    -- name has an entry both in new and old world
-    -- (1) if the old world had no proplist for that variable, then
-    --     record NIL as the value of each new property
-    -- (2) if the old world does have a proplist for that variable, then
-    --     a) for each property with a value: give the old value
-    --     b) for each property missing:      give NIL as the old value
-    oldPair := ASSQ(name,old) =>
-      null (oldProplist := CDR oldPair) =>
-      --record old values of new properties as NIL
-        acc := [[name,:[[prop] for [prop,:.] in proplist]],:acc]
-      deltas := nil
-      for (propval := [prop,:val]) in proplist repeat
-        null (oldPropval := ASSOC(prop,oldProplist)) => --missing property
-          deltas := [[prop],:deltas]
-        EQ(CDR oldPropval,val) => 'skip
-        deltas := [oldPropval,:deltas]
-      deltas => acc := [[name,:NREVERSE deltas],:acc]
-    acc := [[name,:[[prop] for [prop,:.] in proplist]],:acc]
---record properties absent on new list (say, from a )cl all)
-  for (oldPair := [name,:r]) in old repeat
-    r and null LASSQ(name,new) =>
-      acc := [oldPair,:acc]
-    -- name has an entry both in new and old world
-    -- (1) if the new world has no proplist for that variable
-    --     (a) if the old world does, record the old proplist
-    --     (b) if the old world does not, record nothing
-    -- (2) if the new world has a proplist for that variable, it has
-    --     been handled by the first loop.
-  res := NREVERSE acc
-  if BOUNDP '$reportUndo and $reportUndo then reportUndo res
-  res
-\end{verbatim}
-<<defun diffAlist>>=
-(defun |diffAlist| (new old)
- (prog (proplist oldPair oldProplist val oldPropval deltas prop name r acc res)
-  (return
-   (seq
-    (progn
-     (do ((tmp0 new (cdr tmp0)) (pair nil))
-         ((or (atom tmp0) 
-              (progn (setq pair (car tmp0)) nil)
-              (progn 
-               (progn 
-                (spadlet name (car pair))
-                (spadlet proplist (cdr pair))
-                pair) 
-               nil))
-             nil)
-      (seq
-       (exit
-        (cond
-         ((spadlet oldPair (assq name old))
-          (cond
-           ((null (spadlet oldProplist (cdr oldPair)))
-             (spadlet acc
-              (cons
-               (cons
-                 name 
-                 (prog (tmp1)
-                  (spadlet tmp1 nil)
-                  (return
-                   (do ((tmp2 proplist (cdr tmp2)) (tmp3 nil))
-                       ((or (atom tmp2) 
-                            (progn (setq tmp3 (car tmp2)) nil)
-                            (progn 
-                             (progn (spadlet prop (car tmp3)) tmp3)
-                             nil))
-                         (nreverse0 tmp1))
-                    (seq
-                     (exit
-                      (setq tmp1 (cons (cons prop nil) tmp1))))))))
-               acc)))
-           (t 
-             (spadlet deltas nil)
-             (do ((tmp4 proplist (cdr tmp4)) (|propval| nil))
-                 ((or (atom tmp4) 
-                      (progn (setq |propval| (car tmp4)) nil)
-                      (progn
-                       (progn
-                        (spadlet prop (car |propval|))
-                        (spadlet val (cdr |propval|))
-                        |propval|)
-                       nil))
-                   nil)
-              (seq
-               (exit
-                (cond
-                 ((null (spadlet oldPropval (|assoc| prop oldProplist)))
-                   (spadlet deltas (cons (cons prop nil) deltas)))
-                 ((eq (cdr oldPropval) val) '|skip|)
-                 (t (spadlet deltas (cons oldPropval deltas)))))))
-             (when deltas
-               (spadlet acc 
-                (cons (cons name (nreverse deltas)) acc))))))
-         (t
-           (spadlet acc
-            (cons
-             (cons
-              name
-              (prog (tmp5)
-               (spadlet tmp5 nil)
-               (return
-                (do ((tmp6 proplist (cdr tmp6)) (tmp7 nil))
-                    ((or (atom tmp6) 
-                         (progn (setq tmp7 (CAR tmp6)) nil)
-                         (progn
-                          (progn (spadlet prop (CAR tmp7)) tmp7)
-                          nil))
-                       (nreverse0 tmp5))
-                 (seq
-                  (exit
-                   (setq tmp5 (cons (cons prop nil) tmp5))))))))
-             acc)))))))
-     (seq
-      (do ((tmp8 old (cdr tmp8)) (oldPair nil))
-          ((or (atom tmp8) 
-               (progn (setq oldPair (car tmp8)) nil)
-               (progn
-                (progn
-                 (spadlet name (car oldPair))
-                 (spadlet r (cdr oldPair))
-                 oldPair)
-                nil))
-              nil)
-       (seq
-        (exit
-         (cond
-          ((and r (null (lassq name new)))
-            (exit 
-             (spadlet acc (cons oldPair acc))))))))
-      (spadlet res (nreverse acc))
-      (cond 
-       ((and (boundp '|$reportUndo|) |$reportUndo|)
-         (|reportUndo| res)))
-      (exit res))))))) 
-
-@
-\subsection{defun reportUndo}
-This function is enabled by setting [[|$reportUndo]] to a non-nil value.
-An example of the output generated is:
-\begin{verbatim}
-r := binary(22/7)
- 
-
-           ___
-   (1)  11.001
-                                                        Type: BinaryExpansion
-Properties of % ::
-  value was: NIL
-  value is:  ((|BinaryExpansion|) WRAPPED . #(1 (1 1) NIL (0 0 1)))
-Properties of r ::
-  value was: NIL
-  value is:  ((|BinaryExpansion|) WRAPPED . #(1 (1 1) NIL (0 0 1)))
-
-\end{verbatim}
-
-\begin{verbatim}
-reportUndo acc ==
-  for [name,:proplist] in acc repeat
-    sayBrightly STRCONC("Properties of ",PNAME name,'" ::")
-    curproplist := LASSOC(name,CAAR $InteractiveFrame)
-    for [prop,:value] in proplist repeat
-      sayBrightlyNT ['"  ",prop,'" was: "]
-      pp value
-      sayBrightlyNT ['"  ",prop,'" is:  "]
-      pp LASSOC(prop,curproplist)
-\end{verbatim}
-<<defun reportUndo>>=
-(defun |reportUndo| (acc)
- (prog (name proplist curproplist prop value)
-  (return
-   (seq
-    (do ((tmp0 acc (cdr tmp0)) (tmp1 nil))
-        ((or (atom tmp0) 
-             (progn (setq tmp1 (car tmp0)) nil)
-             (progn
-              (progn
-               (spadlet name (car tmp1))
-               (spadlet proplist (cdr tmp1))
-               tmp1)
-              nil))
-            nil)
-     (seq
-      (exit
-       (progn
-        (|sayBrightly|
-          (strconc '|Properties of | (pname name) (makestring " ::")))
-        (spadlet curproplist (lassoc name (caar |$InteractiveFrame|)))
-        (do ((tmp2 proplist (cdr tmp2)) (tmp3 nil))
-            ((or (atom tmp2) 
-                 (progn (setq tmp3 (car tmp2)) nil)
-                 (progn 
-                  (progn 
-                   (spadlet prop (car tmp3))
-                   (spadlet value (cdr tmp3))
-                   tmp3)
-                  nil))
-                nil)
-         (seq
-          (exit
-           (progn
-            (|sayBrightlyNT|
-             (cons
-              (makestring "  ")
-              (cons prop (cons (makestring " was: ") nil))))
-            (|pp| value)
-            (|sayBrightlyNT| 
-             (cons 
-              (makestring "  ") 
-              (cons prop (cons (makestring " is:  ") nil))))
-            (|pp| (lassoc prop curproplist)))))))))))))) 
-
-@
-\subsection{defun clearFrame}
-\begin{verbatim}
-clearFrame() ==
-  clearCmdAll()
-  $frameRecord := nil
-  $previousBindings := nil
-\end{verbatim}
-<<defun clearFrame>>=
-(defun |clearFrame| ()
- (progn 
-  (|clearCmdAll|)
-  (spadlet |$frameRecord| nil) 
-  (spadlet |$previousBindings| nil))) 
-
-@
-\subsection{defun undoCount}
-\begin{verbatim}
---=======================================================================
---              Undoing previous m commands
---=======================================================================
-undoCount(n) ==  --computes the number of undo's, given $IOindex
---pp ["IOindex = ",$IOindex]
-  m :=
-    n >= 0 => $IOindex - n - 1
-    -n
-  m >= $IOindex => userError STRCONC('"Magnitude of undo argument must be less than step number (",STRINGIMAGE $IOindex,'").")
-  m
-\end{verbatim}
-<<defun undoCount>>=
-(defun |undoCount| (n)
- (prog (m)
-  (return
-   (progn
-    (spadlet m 
-     (cond 
-       ((>= n 0) (spaddifference (spaddifference |$IOindex| n) 1))
-       (t (spaddifference n))))
-    (cond
-     ((>= m |$IOindex|)
-       (|userError| 
-        (strconc
-         (makestring 
-           "Magnitude of undo argument must be less than step number (")
-           (stringimage |$IOindex|) (makestring ")."))))
-     (t m)))))) 
-
-@
-\subsection{defun undoSteps}
-\begin{verbatim}
-undoSteps(m,beforeOrAfter) ==
--- undoes m previous commands; if )before option, then undo one extra at end
---Example: if $IOindex now is 6 and m = 2 then general layout of $frameRecord,
---  after the call to recordFrame below will be:
---  (<change for systemcommands>
---  (<change for #5> <change for system commands>
---  (<change for #4> <change for system commands>
---  (<change for #3> <change for system commands>
---   <change for #2> <change for system commands>
---   <change for #1> <change for system commands>) where system
---  command entries are optional and identified by (systemCommand . change).
---  For a ")undo 3 )after", m = 2 and undoStep swill restore the environment
---  up to, but not including <change for #3>.
---  An "undo 3 )before" will additionally restore <change for #3>.
---  Thus, the later requires one extra undo at the end.
-  writeInputLines('redo,$IOindex - m)
-  recordFrame('normal)  --do NOT mark this as a system command change
-                       --do this undo FIRST (i=0 case)
-  env := COPY CAAR $InteractiveFrame
-  for i in 0..m for framelist in tails $frameRecord repeat
-    env := undoSingleStep(first framelist,env)
-    framelist is [.,['systemCommand,:systemDelta],:.] =>
---     pp '"===============> AHA <============="
-       framelist := rest framelist             --undoing system commands given
-       env := undoSingleStep(systemDelta,env)  --  before command line
-    lastTailSeen := framelist
-  if beforeOrAfter = 'before then  --do one additional undo for )before
-    env := undoSingleStep(first rest lastTailSeen,env)
-  $frameRecord := rest $frameRecord --flush the effect of extra recordFrame
-  $InteractiveFrame := LIST LIST env
-\end{verbatim}
-<<defun undoSteps>>=
-(defun |undoSteps| (m beforeOrAfter)
- (prog (tmp1 tmp2 systemDelta framelist lastTailSeen env)
-  (return
-   (seq
-    (progn
-     (|writeInputLines| '|redo| (spaddifference |$IOindex| m))
-     (|recordFrame| '|normal|)
-     (spadlet env (copy (caar |$InteractiveFrame|)))
-     (do ((|i| 0 (qsadd1 |i|)) (framelist |$frameRecord| (cdr framelist)))
-         ((or (qsgreaterp |i| m) (atom framelist)) nil)
-      (seq
-       (exit
-        (progn
-         (spadlet env (|undoSingleStep| (CAR framelist) env))
-         (cond
-           ((and (pairp framelist) 
-                 (progn
-                  (spadlet tmp1 (qcdr framelist))
-                  (and (pairp tmp1) 
-                       (progn
-                        (spadlet tmp2 (qcar tmp1))
-                        (and (pairp tmp2)
-                             (eq (qcar tmp2) '|systemCommand|)
-                             (progn 
-                              (spadlet systemDelta (qcdr tmp2))
-                              t))))))
-             (spadlet framelist (cdr framelist))
-             (spadlet env (|undoSingleStep| systemDelta env)))
-           (t (spadlet lastTailSeen framelist)))))))
-     (cond
-      ((boot-equal beforeOrAfter '|before|)
-        (spadlet env (|undoSingleStep| (car (cdr lastTailSeen)) env))))
-     (spadlet |$frameRecord| (cdr |$frameRecord|))
-     (spadlet |$InteractiveFrame| (list (list env)))))))) 
-
-@
-\subsection{defun undoSingleStep}
-\begin{verbatim}
-undoSingleStep(changes,env) ==
---Each change is a name-proplist pair. For each change:
---  (1) if there exists a proplist in env, then for each prop-value change:
---      (a) if the prop exists in env, RPLAC in the change value
---      (b) otherwise, CONS it onto the front of prop-values for that name
---  (2) add change to the front of env
---  pp '"----Undoing 1 step--------"
---  pp changes
-  for (change := [name,:changeList]) in changes repeat
-    if LASSOC('localModemap,changeList) then
-      changeList := undoLocalModemapHack changeList
-    pairlist := ASSQ(name,env) =>
-      proplist := CDR pairlist =>
-        for (pair := [prop,:value]) in changeList repeat
-          node := ASSQ(prop,proplist) => RPLACD(node,value)
-          RPLACD(proplist,[CAR proplist,:CDR proplist])
-          RPLACA(proplist,pair)
-      RPLACD(pairlist,changeList)
-    env := [change,:env]
-  env
-\end{verbatim}
-<<defun undoSingleStep>>=
-(defun |undoSingleStep| (changes env)
- (prog (name changeList pairlist proplist prop value node)
-  (return
-   (seq
-    (progn
-     (do ((tmp0 changes (cdr tmp0)) (|change| nil))
-         ((or (atom tmp0) 
-              (progn (setq |change| (car tmp0)) nil)
-              (progn 
-               (progn 
-                (spadlet name (car |change|))
-                (spadlet changeList (cdr |change|))
-                |change|)
-               nil))
-             nil)
-      (seq
-       (exit
-        (progn
-         (when (lassoc '|localModemap| changeList)
-           (spadlet changeList (|undoLocalModemapHack| changeList)))
-         (cond
-          ((spadlet pairlist (assq name env))
-            (cond
-             ((spadlet proplist (cdr pairlist))
-               (do ((tmp1 changeList (cdr tmp1)) (pair nil))
-                   ((or (atom tmp1) 
-                        (progn (setq pair (car tmp1)) nil)
-                        (progn
-                         (progn
-                          (spadlet prop (car pair))
-                          (spadlet value (cdr pair))
-                          pair)
-                          nil))
-                        nil)
-                (seq
-                 (exit
-                  (cond
-                   ((spadlet node (assq prop proplist))
-                     (rplacd node value))
-                   (t
-                     (rplacd proplist
-                       (cons (car proplist) (cdr proplist)))
-                     (rplaca proplist pair)))))))
-             (t (rplacd pairlist changeList))))
-          (t 
-            (spadlet env (cons |change| env))))))))
-     env))))) 
-
-@
-\subsection{defun undoLocalModemapHack} 
-\begin{verbatim}
-undoLocalModemapHack changeList ==
-  [newPair for (pair := [name,:value]) in changeList | newPair] where newPair  ==
-     name = 'localModemap => [name]
-     pair
-\end{verbatim}
-<<defun undoLocalModemapHack>>=
-(defun |undoLocalModemapHack| (changeList)
- (prog (name value)
-  (return
-   (seq
-    (prog (tmp0)
-     (spadlet tmp0 NIL)
-     (return
-      (do ((tmp1 changeList (cdr tmp1)) (pair nil))
-          ((or (atom tmp1) 
-               (progn (setq pair (car tmp1)) nil)
-               (progn
-                (progn
-                 (spadlet name (car pair))
-                 (spadlet value (cdr pair))
-                 pair)
-                nil))
-              (nreverse0 tmp0))
-       (seq
-        (exit
-         (cond
-          ((cond
-             ((boot-equal name '|localModemap|) (cons name nil))
-             (t pair))
-           (setq tmp0 
-            (cons 
-             (cond 
-              ((boot-equal name '|localModemap|) (cons name nil))
-              (t pair)) tmp0))))))))))))) 
-
-@
-\subsection{defun removeUndoLines}
-Removing undo lines from [[)hist )write linelist]]
-\begin{verbatim}
-removeUndoLines u == --called by writeInputLines
-  xtra :=
-    STRINGP $currentLine => [$currentLine]
-    REVERSE $currentLine
-  xtra := [x for x in xtra | not stringPrefix?('")history",x)]
-  u := [:u, :xtra]
-  not (or/[stringPrefix?('")undo",x) for x in u])  => u
-  --(1) reverse the list
-  --(2) walk down the (reversed) list: when >n appears remove:
-  --    (a) system commands
-  --    (b) if n > 0: (replace n by n-1; remove a command; repeat (a-b))
-  savedIOindex := $IOindex  --save value
-  $IOindex := 1
-  for y in tails u repeat
-    (x := first y).0 = char '_) =>
-      stringPrefix?('")undo",s := trimString x) => --parse "undo )option"
-        s1 := trimString SUBSTRING(s,5,nil)
-        if s1 ^= '")redo" then
-          m := charPosition(char '_),s1,0)
-          code :=
-            m < MAXINDEX s1 => s1.(m + 1)
-            char 'a
-          s2 := trimString SUBSTRING(s1,0,m)
-        n :=
-           s1 = '")redo" => 0
-           s2 ^= '"" => undoCount PARSE_-INTEGER s2
-           -1
-        RPLACA(y,CONCAT('">",code,STRINGIMAGE n))
-      nil
-    $IOindex := $IOindex + 1   --referenced by undoCount
-  acc := nil
-  for y in tails NREVERSE u repeat
-    (x := first y).0 = char '_> =>
-      code := x . 1                                 --code = a,b, or r
-      n := PARSE_-INTEGER SUBSTRING(x,2,nil)        --n = number of undo steps
-      y := rest y                                   --kill >n line
-      while y repeat
-        c := first y
-        c.0 = char '_) or c.0 = char '_> => y := rest y  --kill system commands
-        n = 0 => return nil                              --including undos
-        n := n - 1
-        y := rest y                                 --kill command
-      y and code^= char 'b => acc := [c,:acc]       --add last unless )before
-    acc := [x,:acc]
-  $IOindex := savedIOindex
-  acc
-\end{verbatim}
-<<defun removeUndoLines>>=
-(defun |removeUndoLines| (u)
- (prog (xtra savedIOindex s s1 m s2 x code c n y acc)
-  (return
-   (seq
-    (progn
-     (spadlet xtra 
-      (cond
-       ((stringp |$currentLine|) (cons |$currentLine| nil))
-       (t (reverse |$currentLine|))))
-     (spadlet xtra
-      (prog (tmp0)
-       (spadlet tmp0 nil)
-       (return
-        (do ((tmp1 xtra (cdr tmp1)) (x nil))
-            ((or (atom tmp1)
-                 (progn (setq x (car tmp1)) nil))
-               (nreverse0 tmp0))
-         (seq
-          (exit
-           (cond
-            ((null (|stringPrefix?| (makestring ")history") x))
-              (setq tmp0 (cons x tmp0))))))))))
-     (spadlet u (append u xtra))
-     (cond
-      ((null
-        (prog (tmp2)
-         (spadlet tmp2 nil)
-         (return
-          (do ((tmp3 nil tmp2) (tmp4 u (cdr tmp4)) (x nil))
-              ((or tmp3 (atom tmp4) (progn (setq x (car tmp4)) nil)) tmp2)
-           (seq
-            (exit
-             (setq tmp2 
-               (or tmp2 (|stringPrefix?| (makestring ")undo") x))))))))) u)
-      (t
-        (spadlet savedIOindex |$IOindex|)
-        (spadlet |$IOindex| 1)
-        (do ((y u (cdr y)))
-            ((atom y) nil)
-         (seq
-          (exit
-           (cond
-            ((boot-equal (elt (spadlet x (car y)) 0) (|char| '|)|))
-              (cond
-               ((|stringPrefix?| (makestring ")undo") 
-                                 (spadlet s (|trimString| x)))
-                (spadlet s1 (|trimString| (substring s 5 nil)))
-                (cond
-                  ((nequal s1 (makestring ")redo"))
-                    (spadlet m (|charPosition| (|char| '|)|) s1 0))
-                    (spadlet code
-                     (cond
-                       ((> (maxindex s1) m) (elt s1 (plus m 1)))
-                       (t (|char| '|a|))))
-                    (spadlet s2 (|trimString| (substring s1 0 m)))))
-                (spadlet n
-                 (cond
-                  ((boot-equal s1 (makestring ")redo"))
-                     0)
-                  ((nequal s2 (makestring ""))
-                    (|undoCount| (parse-integer s2)))
-                  (t (spaddifference 1))))
-                (rplaca y
-                  (concat (makestring ">") code (stringimage n))))
-               (t nil)))
-            (t (spadlet |$IOindex| (plus |$IOindex| 1)))))))
-        (spadlet acc nil)
-        (do ((y (nreverse u) (cdr y)))
-            ((atom y) nil)
-         (seq
-          (exit
-           (cond
-            ((boot-equal (elt (spadlet x (car y)) 0) (|char| '>))
-              (spadlet code (elt x 1))
-              (spadlet n (parse-integer (substring x 2 nil)))
-              (spadlet y (cdr y))
-              (do () 
-                  ((null y) nil)
-               (seq
-                (exit
-                 (progn
-                  (spadlet c (car y))
-                  (cond 
-                   ((or (boot-equal (elt c 0) (|char| '|)|))
-                        (boot-equal (elt c 0) (|char| '>)))
-                     (spadlet y (cdr y)))
-                   ((eql n 0)
-                     (return nil))
-                   (t
-                     (spadlet n (spaddifference n 1))
-                     (spadlet y (cdr y))))))))
-              (cond
-               ((and y (nequal code (|char| '|b|)))
-                 (spadlet acc (cons c acc)))))
-            (t (spadlet acc (cons x acc)))))))
-        (spadlet |$IOindex| savedIOindex)
-        acc))))))) 
-
-@
-
-\chapter{The Spad Server Mechanism}
-<<initvars>>=
-(defvar $openServerIfTrue t "t means try starting an open server")
-(defconstant $SpadServerName "/tmp/.d" "the name of the spad server socket")
-(defvar |$SpadServer| nil "t means Scratchpad acts as a remote server")
-
-@
-
-\chapter{The Help Browser Mechanism}
-The Axiom book on the help browser is a complete rewrite of the 
-hyperdoc mechanism. There are several components that were needed
-to make this function. Most of the web browser components are
-described in bookvol11.pamphlet. This portion describes some of
-the design issues needed to support the interface.
-
-The axServer command takes a port (defaulting to 8085) and a
-program to handle the browser interaction (defaulting to multiServ).
-The axServer function opens the port, constructs the stream, and
-passes the stream to multiServ. The multiServ loop processes one
-interaction at a time.
-
-So the basic process is that the Axiom ``)browse'' command opens a
-socket and listens for http requests. Based on the type of request
-(either 'GET' or 'POST') and the content of the request, which is
-one of:
-\begin{itemize}
-\item command - algebra request/response
-\item lispcall - a lisp s-expression to be evaluated
-\item showcall - an Axiom )show command
-\end{itemize}
-the multiServ function will call a handler function to evaluate
-the command line and construct a response. GET requests result
-in a new browser page. POST requests result in an inline result.
-
-Most responses contain the fields:
-\begin{itemize}
-\item stepnum - this is the Axiom step number 
-\item command - this is the original command from the browser
-\item algebra - this is the Axiom 2D algebra output
-\item mathml - this is the MathML version of the Axiom algebra
-\item type - this is the type of the Axiom result
-\end{itemize}
-
-\section{Browsers, MathML, and Fonts}
-This work has the Firefox browser as its target. Firefox has built-in
-support for MathML, javascript, and XMLHttpRequest handling. More details
-are available in bookvol11.pamphlet but the very basic machinery for 
-communication with the browser involves a dance between the browser
-and the multiServ function (see the axserver.spad.pamphlet). 
-
-In particular, a simple request is embedded in a web page as:
-\begin{verbatim}
-<ul>
- <li>
-  <input type="submit" id="p3" class="subbut" 
-    onclick="makeRequest('p3');"
-    value="sin(x)" />
-  <div id="ansp3"><div></div></div>
- </li>
-</ul>
-\end{verbatim}
-which says that this is an html ``input'' field of type ``submit''.
-The CSS display class is ``subbut'' which is of a different color
-than the surrounding text to make it obvious that you can click on
-this field. Clickable fields that have no response text are of class
-``noresult''.
-
-The javascript call to ``makeRequest'' gives the ``id'' of this input
-field, which must be unique in the page, as an argument. In this case,
-the argument is 'p3'. The ``value'' field holds the display text which
-will be passed back to Axiom as a command.
-
-When the result arrives the ``showanswer'' function will select out
-the mathml field of the response, construct the ``id'' of the html
-div to hold the response by concatenating the string ``ans'' (answer)
-to the ``id'' of the request resulting, in this case, as ``ansp3''.
-The ``showanswer'' function will find this div and replace it with a
-div containing the mathml result.
-
-The ``makeRequest'' function is:
-\begin{verbatim}
- function makeRequest(arg) {
-   http_request = new XMLHttpRequest();         
-   var command = commandline(arg);
-   //alert(command);
-   http_request.open('POST', '127.0.0.1:8085', true);
-   http_request.onreadystatechange = handleResponse;
-   http_request.setRequestHeader('Content-Type', 'text/plain');
-   http_request.send("command="+command);
-   return(false);
-\end{verbatim}
-It contains a request to open a local server connection to Axiom,
-sets ``handleResponse'' as the function to call on reply, sets up
-the type of request, fills in the command field, and sends off the
-http request.
-
-When a response is received, the ``handleResponse'' function checks
-for the correct reply state, strips out the important text, and
-calls ``showanswer''.
-\begin{verbatim}
- function handleResponse() {
-  if (http_request.readyState == 4) {
-   if (http_request.status == 200) {
-    showanswer(http_request.responseText,'mathAns');
-   } else
-   {
-     alert('There was a problem with the request.'+ http_request.statusText);
-   }
-  }
- }
-\end{verbatim}
-See bookvol11.pamphlet for further details.
-
-\section{The axServer/multiServ loop}
-The basic call to start an Axiom browser listener is:
-\begin{verbatim}
-  )set message autoload off
-  )set output mathml on
-  axServer(8085,multiServ)$AXSERV
-\end{verbatim}
-
-This call sets the port, opens a socket, attaches it to a stream,
-and then calls ``multiServ'' with that stream. The ``multiServ''
-function loops serving web responses to that port.
-
-\section{The )browse command}
-In order to make the whole process cleaner the function ``)browse''
-handles the details. This code creates the command-line function for )browse
-
-The browse function does the internal equivalent of the following 3 command
-line statments:
-\begin{verbatim}
-  )set message autoload off
-  )set output mathml on
-  axServer(8085,multiServ)$AXSERV
-\end{verbatim}
-which causes Axiom to start serving web pages on port 8085
-
-For those unfamiliar with calling algebra from lisp there are a 
-few points to mention. 
-
-The loadLib needs to be called to load the algebra code into the image.
-Normally this is automatic but we are not using the interpreter so
-we need to do this ``by hand''.
-
-Each algebra file contains a "constructor function" which builds the
-domain, which is a vector, and then caches the vector so that every
-call to the contructor returns an EQ vector, that is, the same vector.
-In this case, we call the constructor $\vert$AxiomServer$\vert$
-
-The axServer function was mangled internally to 
-$\vert$AXSERV;axServer;IMV;2$\vert$.
-The multiServ function was mangled to $\vert$AXSERV;multiServ;SeV;3$\vert$
-Note well that if you change axserver.spad these names might change
-which will generate the error message along the lines of:
-\begin{verbatim}
-    System error:
-    The function $\vert$AXSERV;axServer;IMV;2$\vert$ is undefined.
-\end{verbatim}
-
-To fix this you need to look at int/algebra/AXSERV.nrlib/code.lsp
-and find the new mangled function name. A better solution would
-be to dynamically look up the surface names in the domain vector.
-
-Each Axiom function expects the domain vector as the last argument.
-This is not obvious from the call as the interpreter supplies it.
-We must do that ``by hand''.
-
-We don't call the multiServ function. We pass it as a parameter to
-the axServer function. When it does get called by the SPADCALL
-macro it needs to be a lisp pair whose car is the function and
-whose cdr is the domain vector. We construct that pair here as
-the second argument to axServer. The third, hidden, argument to
-axServer is the domain vector which we supply ``by hand''.
-
-The socket can be supplied on the command line but defaults to 8085.
-Axiom supplies the arguments as a list.
-<<defun browse>>=
-(defun |browse| (socket)
- (let (axserv browser)
-  (if socket 
-    (setq socket (car socket))
-    (setq socket 8085))
-  (|set| '(|mes| |auto| |off|))
-  (|set| '(|out| |mathml| |on|))
-  (|loadLib| '|AxiomServer|)
-  (setq axserv (|AxiomServer|))
-  (setq browser 
-   (|AXSERV;axServer;IMV;2| socket
-    (cons #'|AXSERV;multiServ;SeV;3| axserv) axserv))))
-
-@
-Now we have to bolt it into Axiom. This involves two lookups.
-
-We create the lisp pair 
-\begin{verbatim}
-(|browse| . |development|)
-\end{verbatim} 
-and cons it into the \$systemCommands command table.  This allows the
-command to be executed in development mode.  This lookup decides if
-this command is allowed. It also has the side-effect of putting the
-command into the \$SYSCOMMANDS variable which is used to determine
-if the token is a command.
-
-\section{The server support code}
-
-\chapter{Axiom Build-time Functions}
-\subsection{defun spad-save}
-The {\bf spad-save} function is just a cover function for more
-lisp system specific save functions. There is no standard name
-for saving a lisp image so we make one and conditionalize it
-at compile time.
-
-This function is passed the name of an image that will be saved.
-The saved image contains all of the loaded functions.
-
-This is used in the [[src/interp/Makefile.pamphlet]] in three places:
-\begin{list}{}
-\item creating depsys, an image for compiling axiom.
-
-Some of the Common Lisp code we compile uses macros which
-are assumed to be available at compile time. The {\bf DEPSYS}
-image is created to contain the compile time environment
-and saved. We pipe compile commands into this environment
-to compile from Common Lisp to machine dependent code.
-\begin{verbatim}
-DEPSYS=	${OBJ}/${SYS}/bin/depsys
-\end{verbatim}
-
-\item creating savesys, an image for running axiom.
-
-Once we've compile all of the Common Lisp files we fire up
-a clean lisp image called {\bf LOADSYS}, load all of the
-final executable code and save it out as {\bf SAVESYS}.
-The {\bf SAVESYS} image is copied to the [[${MNT}/${SYS}/bin]]
-subdirectory and becomes the axiom executable image.
-\begin{verbatim}
-LOADSYS= ${OBJ}/${SYS}/bin/lisp
-SAVESYS= ${OBJ}/${SYS}/bin/interpsys
-AXIOMSYS= ${MNT}/${SYS}/bin/AXIOMsys
-\end{verbatim}
-
-
-\item creating debugsys, an image with all interpreted functions loaded.
-
-Occasionally we need to really get into the system internals.
-The best way to do this is to run almost all of the lisp code
-interpreted rather than compiled (note that cfuns.lisp and sockio.lisp
-still need to be loaded in compiled form as they depend on the 
-loader to link with lisp internals). This image is nothing more
-than a load of the file src/interp/debugsys.lisp.pamphlet. If
-you need to make test modifications you can add code to that
-file and it will show up here.
-\begin{verbatim}
-DEBUGSYS=${OBJ}/${SYS}/bin/debugsys
-\end{verbatim}
-\end{list}
-<<defun spad-save>>=
-(defun user::spad-save (save-file)
-  (setq |$SpadServer| nil)
-  (setq $openServerIfTrue t)
-#+:AKCL
-  (system::save-system save-file)
-#+:allegro
-  (if (fboundp 'boot::restart)
-   (excl::dumplisp :name save-file :restart-function #'boot::restart)
-   (excl::dumplisp :name save-file))
-#+Lucid
-  (if (fboundp 'boot::restart)
-   (sys::disksave save-file :restart-function #'boot::restart)
-   (sys::disksave save-file))
-#+:CCL
-  (preserve)
-)
-
-@
-
-\chapter{The Interpreter}
-<<Interpreter>>=
-(in-package "BOOT")
-<<initvars>>
-
-<<defun addNewInterpreterFrame>>
-
-<<defun browse>>
-
-<<defun changeHistListLen>>
-<<defun changeToNamedInterpreterFrame>>
-<<defun charDigitVal>>
-<<defun clearFrame>>
-<<defun closeInterpreterFrame>>
-<<defun createCurrentInterpreterFrame>>
-
-<<defun dewritify>>
-<<defun dewritify,dewritifyInner>>
-<<defun dewritify,is?>>
-<<defun diffAlist>>
-<<defun disableHist>>
-<<defun display>>
-<<defun displayFrameNames>>
-<<defun displayMacros>>
-<<defun displayOperations>>
-<<defun displaySpad2Cmd>>
-
-<<defun emptyInterpreterFrame>>
-
-<<defun fetchOutput>>
-<<defun findFrameInRing>>
-<<defun frame>>
-<<defun frameEnvironment>>
-<<defun frameName>>
-<<defun frameNames>>
-<<defun frameSpad2Cmd>>
-
-<<defun getenviron>>
-<<defun gensymInt>>
-
-<<defun histFileErase>>
-<<defun history>>
-<<defun histFileName>>
-<<defun histInputFileName>>
-<<defun historySpad2Cmd>>
-
-<<defun incBiteOff>>
-<<defun incFileName>>
-<<defun importFromFrame>>
-<<defun init-memory-config>>
-<<defun initHist>>
-<<defun initHistList>>
-<<defun initializeInterpreterFrameRing>>
-<<defun initroot>>
-<<defun intloop>>
-<<defun intloopPrefix?>>
-<<defun intloopReadConsole>>
-
-<<defun loadExposureGroupData>>
-
-<<defun make-absolute-filename>>
-<<defun makeHistFileName>>
-<<defun makeInitialModemapFrame>>
-
-<<defun ncIntLoop>>
-<<defun ncloopCommand>>
-<<defun ncloopEscaped>>
-<<defun ncloopInclude>>
-<<defun ncloopInclude1>>
-<<defun ncloopIncFileName>>
-<<defun ncloopPrefix?>>
-<<defun ncTopLevel>>
-<<defun nextInterpreterFrame>>
-
-<<defun oldHistFileName>>
-
-<<defun previousInterpreterFrame>>
-<<defun putHist>>
-
-<<defun readHiFi>>
-<<defun reclaim>>
-<<defun recordNewValue>>
-<<defun recordNewValue0>>
-<<defun recordOldValue>>
-<<defun recordOldValue0>>
-<<defun recordFrame>>
-<<defun removeUndoLines>>
-<<defun reportUndo>>
-<<defun reroot>>
-<<defun resetInCoreHist>>
-<<defun restart>>
-<<defun restoreHistory>>
-<<defun runspad>>
-
-<<defun safeWritify>>
-<<defun saveHistory>>
-<<defun ScanOrPairVec>>
-<<defun setCurrentLine>>
-<<defun setHistoryCore>>
-<<defun set-restart-hook>>
-<<defun showInOut>>
-<<defun showInput>>
-<<defun setIOindex>>
-<<defun showHistory>>
-<<defun spad>>
-<<defun spad-save>>
-<<defun spadClosure?>>
-<<defun SpadInterpretStream>>
-<<defun SPADRREAD>>
-<<defun SPADRWRITE>>
-<<defun SPADRWRITE0>>
-<<defun statisticsInitialization>>
-
-<<defun undo>>
-<<defun undoChanges>>
-<<defun undoCount>>
-<<defun undoFromFile>>
-<<defun undoInCore>>
-<<defun undoLocalModemapHack>>
-<<defun undoSingleStep>>
-<<defun undoSteps>>
-<<defun unwritable?>>
-<<defun updateCurrentInterpreterFrame>>
-<<defun updateFromCurrentInterpreterFrame>>
-<<defun updateHist>>
-<<defun updateInCoreHist>>
-
-<<defun writify>>
-<<defun writify,writifyInner>>
-<<defun writifyComplain>>
-<<defun writeHiFi>>
-<<defun writeHistModesAndValues>>
-<<defun writeInputLines>>
-
-<<defun yesanswer>>
-
-@
-\chapter{Makefile.bookvol5}
-<<*>>=
-LATEX=/usr/bin/latex
-LISP=${AXIOM}/obj/linux/bin/lisp
-TANGLE=/usr/local/bin/NOTANGLE
-WEAVE=/usr/local/bin/NOWEAVE -delay
-
-all: bookvol5
-	@echo 0 done
-
-bookvol5: bookvol5.pamphlet
-	@echo 1 extracting the bookvol5reter
-	${WEAVE} bookvol5.pamphlet >bookvol5.tex
-	${LATEX} bookvol5.tex
-	${LATEX} bookvol5.tex
-	${TANGLE} -R"Interpreter" bookvol5.pamphlet >bookvol5.lisp
-
-remake:	
-	@echo 2 rebuilding the makefile
-	@${TANGLE} bookvol5.pamphlet >Makefile.bookvol5
-
-@
-\eject
-\begin{thebibliography}{99}
-\bibitem nothing
-\end{thebibliography}
-\end{document}
diff --git a/src/interp/bootlex.lisp.pamphlet b/src/interp/bootlex.lisp.pamphlet
index 37ddf16..c281226 100644
--- a/src/interp/bootlex.lisp.pamphlet
+++ b/src/interp/bootlex.lisp.pamphlet
@@ -173,18 +173,14 @@
 	      (*spad-input-file* nil)
 	      (*spad-output-file* nil)
 	     &aux
-	 ;;  (Echo-Meta *spad-input-file*)
-	 ;;  (*comp370-apply* (function print-and-eval-defun))
 	   (*comp370-apply* (function print-defun))
 	   (*fileactq-apply* (function print-defun))
-	 ;;  (|$InteractiveMode| nil)
 	   ($SPAD T)
 	   ($BOOT nil)
 	   (XCape #\_)
 	   (OPTIONLIST nil)
 	   (*EOF* NIL)
 	   (File-Closed NIL)
-	 ;;  ($current-directory "/spad/libraries/")
 	   (/editfile *spad-input-file*)
 	   (|$noSubsumption| |$noSubsumption|)
 	   in-stream out-stream)
diff --git a/src/interp/database.boot.pamphlet b/src/interp/database.boot.pamphlet
index 383cf07..3c11489 100644
--- a/src/interp/database.boot.pamphlet
+++ b/src/interp/database.boot.pamphlet
@@ -582,46 +582,6 @@ dropPrefix(fn) ==
   MEMBER(fn.0,[char "?",char "-",char "+"]) => SUBSTRING(fn,1,nil)
   fn
 
---moved to util.lisp
---++loadExposureGroupData() ==
---++  egFile := ['interp,'exposed]
---++--  null MAKE_-INPUT_-FILENAME(egFile) =>
---++--    throwKeyedMsg("S2IL0003",[namestring egFile])
---++  stream:= DEFIOSTREAM(['(MODE . INPUT),['FILE,:egFile]],80,0)
---++  $globalExposureGroupAlist := NIL
---++  egName  := NIL
---++  egFiles := NIL
---++  while (not PLACEP (x:= READ_-LINE stream)) repeat
---++    x := DROPTRAILINGBLANKS x
---++    SIZE(x) = 0 => 'iterate				-- blank line
---++    (x.0 = char "#") or (x.0 = char "*") => 'iterate    -- comment
---++    x.0 = char " " =>
---++       -- possible exposure group member name and library name
---++       null egName =>
---++	 throwKeyedMsg("S2IZ0069A",[namestring egFile,x])
---++       x := dropLeadingBlanks x
---++       -- should be two tokens on the line
---++       p := STRPOS('" ",x,1,NIL)
---++       NULL p =>
---++	 throwKeyedMsg("S2IZ0069B",[namestring egFile,x])
---++       n := object2Identifier SUBSTRING(x,0,p)
---++       x := dropLeadingBlanks SUBSTRING(x,p+1,NIL)
---++       SIZE(x) = 0 =>
---++	 throwKeyedMsg("S2IZ0069B",[namestring egFile,x])
---++       egFiles := [[n,:object2Identifier x],:egFiles]
---++    -- have a new group name
---++    if egName then $globalExposureGroupAlist :=
---++      [[egName,:nreverse egFiles],:$globalExposureGroupAlist]
---++    egFiles := NIL
---++    STRPOS('" ",x,1,NIL) =>
---++      throwKeyedMsg("S2IZ0069C",[namestring egFile,x])
---++    egName := object2Identifier x
---++  if egFiles then $globalExposureGroupAlist :=
---++      [[egName,:nreverse egFiles],:$globalExposureGroupAlist]
---++  SHUT stream
---++  $globalExposureGroupAlist := nreverse $globalExposureGroupAlist
---++  'done
-
 isExposedConstructor name ==
   -- this function checks the local exposure data in the frame to
   -- see if the given constructor is exposed. The format of
diff --git a/src/interp/interp-proclaims.lisp b/src/interp/interp-proclaims.lisp
index 85867b2..3c9d854 100644
--- a/src/interp/interp-proclaims.lisp
+++ b/src/interp/interp-proclaims.lisp
@@ -56,7 +56,7 @@
             BOOT::|compExpression| BOOT::|e02gafDefaultSolve|
             BOOT::|e02aefDefaultSolve| BOOT::|e02bbfDefaultSolve|
             BOOT::|asytranForm| BOOT::|asytranFormSpecial|
-            BOOT::|asytranApplySpecial| BOOT::SOCK-GET-STRING
+            BOOT::|asytranApplySpecial|
             BOOT::|sockGetString| BOOT::|showIt| BOOT::|pmPreparse,fn|
             BOOT::|pmPreparse,gn| BOOT::|dbSearchAbbrev|
             BOOT::|mkUpDownPattern,recurse| BOOT::|htMkPath|
@@ -687,7 +687,7 @@
             BOOT::|e02dff| BOOT::|e02def| BOOT::|e02ddf| BOOT::|e02dcf|
             BOOT::|e02daf| BOOT::|e02bef| BOOT::|e02bdf|
             BOOT::|minusInfinity| BOOT::|plusInfinity|
-            BOOT::SERVER-SWITCH BOOT::CLEARDATABASE BOOT::NBOOT-LEXPR
+            BOOT::CLEARDATABASE BOOT::NBOOT-LEXPR
             BOOT::BOOT-LEXPR BOOT::|executeQuietCommand|
             BOOT::|serverSwitch| BOOT::|scanS|
             BOOT::|sendNagmanErrorSignal| BOOT::|d01gbf| BOOT::|d01gaf|
@@ -1060,12 +1060,11 @@
             BOOT::|e02dafGen| BOOT::|e02bdfSolve| BOOT::|e02dffGen|
             BOOT::|e02akfSolve| BOOT::|asyJoinPart| BOOT::|printLine|
             BOOT::|sockSendWakeup| BOOT::|sockGetFloat|
-            BOOT::PRINT-LINE BOOT::SOCK-SEND-WAKEUP
-            BOOT::SOCK-GET-FLOAT BOOT::|/tb| BOOT::|/ry| BOOT::|/rx|
+            BOOT::|/tb| BOOT::|/ry| BOOT::|/rx|
             BOOT::|/cxd| BOOT::/FOOBAR BOOT::/CX BOOT::NEWNAMTRANS
             BOOT::|htMakeInputList| BOOT::SPAD-MODETRAN
-            BOOT::|popSatOutput| BOOT::|subrname| BOOT::SOCK-GET-INT
-            BOOT::OPEN-SERVER BOOT::|protectedEVAL|
+            BOOT::|popSatOutput| BOOT::|subrname|
+            BOOT::|protectedEVAL|
             BOOT::|setOutputTex| BOOT::|setOutputFortran| BOOT::|set|
             BOOT::|setLinkerArgs| BOOT::|protectSymbols|
             BOOT::|protectedSymbolsWarning| BOOT::|setStreamsCalculate|
@@ -1122,7 +1121,7 @@
             BOOT::|sayDisplayWidth| BOOT::INIT-LIB-FILE-GETTER
             BOOT::INIT-FILE-GETTER BOOT::|entryWidth| BOOT::FILE-RUNNER
             BOOT::|editFile| BOOT::|readForDoc| BOOT::|checkNumOfArgs|
-            BOOT::|openServer| BOOT::|removeBackslashes|
+            BOOT::OPENSERVER BOOT::|removeBackslashes|
             BOOT::|checkAddBackSlashes| BOOT::/RF-1 BOOT::|docreport|
             BOOT::|ExecuteInterpSystemCommand| BOOT::|pfFileName|
             BOOT::|InterpExecuteSpadSystemCommand| BOOT::|alistSize|
@@ -2611,8 +2610,7 @@
             BOOT::|e01dafDefaultSolve| BOOT::|replaceNamedHTPage|
             BOOT::|e02bafDefaultSolve| BOOT::|e02bdfDefaultSolve|
             BOOT::|e02defDefaultSolve| BOOT::|sockSendFloat|
-            BOOT::SOCK-SEND-SIGNAL BOOT::SOCK-SEND-FLOAT
-            BOOT::SOCK-SEND-STRING BOOT::SOCK-SEND-INT BOOT::ERASE
+            BOOT::ERASE
             BOOT::|sayErrorly| BOOT::|saturnSayErrorly| BOOT::|set1|
             BOOT::|displaySetOptionInformation| BOOT::|mkGrepPattern|
             BOOT::|showDoc| BOOT::|genSearchSayJump| BOOT::|oPageFrom|
diff --git a/src/interp/sockio.lisp.pamphlet b/src/interp/sockio.lisp.pamphlet
index c58f2cf..f03492e 100644
--- a/src/interp/sockio.lisp.pamphlet
+++ b/src/interp/sockio.lisp.pamphlet
@@ -113,57 +113,11 @@ resolve the problem
   (defentry NANQ () (double "NANQ"))
   )
 
-(defun open-server (name)
-#+(and :lucid :ibm/370) -2
-#-(and :lucid :ibm/370)
-  (open_server name))
-(defun sock-get-int (type)
-#+(and :lucid :ibm/370) ()
-#-(and :lucid :ibm/370)
-  (sock_get_int type))
-(defun sock-send-int (type val)
-#+(and :lucid :ibm/370) ()
-#-(and :lucid :ibm/370)
-  (sock_send_int type val))
-(defun sock-get-string (type buf buf-len)
-#+(and :lucid :ibm/370) ()
-#-(and :lucid :ibm/370)
-  (sock_get_string_buf type buf buf-len))
-(defun sock-send-string (type str)
-#+(and :lucid :ibm/370) ()
-#-(and :lucid :ibm/370)
-  (sock_send_string_len type str (length str)))
-(defun sock-get-float (type)
-#+(and :lucid :ibm/370) ()
-#-(and :lucid :ibm/370)
-  (sock_get_float type))
-(defun sock-send-float (type val)
-#+(and :lucid :ibm/370) ()
-#-(and :lucid :ibm/370)
-  (sock_send_float type val))
-(defun sock-send-wakeup (type)
-#+(and :lucid :ibm/370) ()
-#-(and :lucid :ibm/370)
-  (sock_send_wakeup type))
-(defun server-switch ()
-#+(and :lucid :ibm/370) ()
-#-(and :lucid :ibm/370)
-  (server_switch))
-(defun sock-send-signal (type signal)
-#+(and :lucid :ibm/370) ()
-#-(and :lucid :ibm/370)
-  (sock_send_signal type signal))
-(defun print-line (str)
-#+(and :lucid :ibm/370) ()
-#-(and :lucid :ibm/370)
-  (print_line str))
 (defun |plusInfinity| () (plus_infinity))
 (defun |minusInfinity| () (minus_infinity))
 
 ;; Macros for use in Boot
 
-(defun |openServer| (name)
-  (open_server name))
 (defun |sockGetInt| (type)
   (sock_get_int type))
 (defun |sockSendInt| (type val)



From MAILER-DAEMON Sat Feb 14 18:17:43 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LYTlX-0007b0-By
	for mharc-axiom-developer@gnu.org; Sat, 14 Feb 2009 18:17:43 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LYTlU-0007as-Ur
	for axiom-developer@nongnu.org; Sat, 14 Feb 2009 18:17:40 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LYTlS-0007ae-V4
	for axiom-developer@nongnu.org; Sat, 14 Feb 2009 18:17:39 -0500
Received: from [199.232.76.173] (port=53831 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LYTlS-0007ab-Pk
	for axiom-developer@nongnu.org; Sat, 14 Feb 2009 18:17:38 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:55621
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LYTlS-0002X2-19
	for axiom-developer@nongnu.org; Sat, 14 Feb 2009 18:17:38 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1ENHaug003328;
	Sat, 14 Feb 2009 17:17:36 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1ENHYJY003317;
	Sat, 14 Feb 2009 17:17:34 -0600
Date: Sat, 14 Feb 2009 17:17:34 -0600
Message-Id: <200902142317.n1ENHYJY003317@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090212.02.tpd.patch (rewrite restart)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 14 Feb 2009 23:17:41 -0000

The restart function was refactored, documented and simplified.

=======================================================================
diff --git a/books/bookvol5.pamphlet b/books/bookvol5.pamphlet
index 4414f64..60c94d6 100644
--- a/books/bookvol5.pamphlet
+++ b/books/bookvol5.pamphlet
@@ -4,6 +4,83 @@
 \usepackage{makeidx}
 \makeindex
 \usepackage{graphicx}
+%%
+%% Note that this file will eventually generate a dvi file
+%% which will eventually be processed by dvipdfm to create a pdf.
+%% The categories/domains/packages will be placed in a graphviz graph.
+%% The graphviz dot syntax allows an href parameter.
+%% The href parameter will reference this file. 
+%% pdf href syntax allows named destinations.
+%% This macro creates a named destination using \special
+%% Thus, you reference http://thispdf#nameddest=ABBREV 
+%% and you end up at the right page.
+%% This macro is called implicitly by \pagehead so every 
+%% category/domain/package can be referenced by fullname or abbrev.
+%%
+%% dest will give the ability to use nameddest= in html pdfs
+%%
+\newcommand{\dest}[1]{% e.g. \dest{abb}
+\special{pdf:dest (#1) [ @thispage /FitH @ypos ]}}
+
+%%
+%% pagehead consolidates standard page indexing
+%%
+\newcommand{\pagehead}[2]{% e.g. \pagehead{name}{abb}
+\dest{#1}%
+\dest{#2}%
+\subsection{#1 (#2)}
+\label{#1}%
+\label{#2}%
+\index{{#1}}%
+\index{{#2}}}%
+
+%%
+%% pagepic adds an image and an index entry
+%%
+\newcommand{\pagepic}[3]{% e.g. \pagepic{pathandfile}{abb}{scale}
+\includegraphics[scale=#3]{#1}\\%
+\index{images!#2}}
+
+%%
+%% \refto is a link to a referenced page that returns it arg
+%%
+\newcommand{\refto}[1]{% e.g. \refto{name}
+(p\pageref{#1}) #1}
+
+%%
+%% pageto is a forward link to a referenced page
+%%
+\newcommand{\pageto}[2]{% e.g. \pageto{abb}{name}
+\ \\${\bf\Rightarrow{}}${``#1''} (#2) \ref{#1} on page~\pageref{#1}}
+
+%%
+%% pagefrom is a backward link to a referencing page
+%%
+\newcommand{\pagefrom}[2]{% e.g. \pagefrom{name}{abb}
+\ \\${\bf\Leftarrow{}}${``#1''} (#2) \ref{#1} on page~\pageref{#1}}
+
+
+%%
+%% fnref sets a reference link
+%%
+\newcommand{\fnref}[1]{% e.g. \fnref{functionname}
+``#1'' (\ref{#1} p~\pageref{#1})}
+
+%%
+%% varref sets a reference link
+%%
+\newcommand{\varref}[1]{% e.g. \varref{variablename}
+``#1'' (\ref{#1} p~\pageref{#1})}
+
+%% cross will put the category and function in the index
+%% cross will leave the funcname so it can be put inline.
+%%
+\newcommand{\cross}[2]{% e.g. \pagefrom{cat}{funcname}
+\index{#1!#2}%
+\index{#2!#1}%
+#2}
+
+
 % struggle with latex figure-floating behavior
 \renewcommand\floatpagefraction{.9}
 \renewcommand\topfraction{.9}
@@ -180,12 +257,10 @@ function which is the entry to the Axiom interpreter.
  )
 
 @
-\subsection{defun restart}
+\pagehead{restart}{restart}
+\pagepic{ps/v5restart.ps}{restart}{1.00}
 The restart function is the real root of the world. It sets up memory
-if we are working in a GCL/akcl version of the system. It sets the
-current package to be the ``BOOT'' package which is the standard
-package in which the interpreter runs. It calls initroot \cite{1}
-to set the \$spadroot variable (usually the \$AXIOM variable).
+if we are working in a GCL/akcl version of the system. 
 
 The [[compiler::*compile-verbose*]] flag has been set to nil globally.
 We do not want to know about the microsteps of GCL's compile facility.
@@ -195,6 +270,50 @@ We do not care that certain generated variables are not used.
 
 The [[compiler::*suppress-compiler-notes*]] flag has been set to t.
 We do not care that tail recursion occurs.
+
+It sets the
+current package to be the ``BOOT'' package which is the standard
+package in which the interpreter runs. 
+
+The \fnref{initroot} function sets global variables that depend on the
+AXIOM shell variable. These are needed to find basic files like s2-us.msgs,
+which contains the error message text.
+
+The \fnref{openserver} function tried to set up the socket connection
+used for things like hyperdoc. The \verb|$openServerIfTrue| variable
+starts true, which implies trying to start a server.
+
+The \verb|$IOindex| variable is the number associated with the input prompt.
+Every successful expression evaluated increments this number until a
+\verb|)clear all| resets it. Here we set it to the initial value.
+
+Axiom has multiple frames that contain independent information about a
+computation. There can be several frames at any one time and you can 
+shift back and forth between the frames. By default, the system starts
+in ``frame0'' (try the \verb|)frame names| command). See the Frame
+Mechanism chapter (\ref{TheFrameMechanism} page~\pageref{TheFrameMechanism}).
+
+The \verb|$InteractiveFrame| variable contains the state information
+related to the current frame, which includes things like the last value,
+the value of all of the variables, etc.
+
+The \varref{printLoadMsgs} variable controls whether load messages will
+be output as library routines are loaded. We enable this by default.
+It can be changed by using \verb|)set message autoload|.
+
+The \varref{current-directory} variable is set to the current directory.
+This is used by the \verb|)cd| function and some of the compile routines.
+
+The \fnref{loadExposureGroupData} function initializes several variables
+with the exposure groups. These lists limit the user visible names in
+order to keep the user and interpreter from being confused by names
+which are common but whose signatures are for internal algebra uses.
+
+The \fnref{statisticsInitialization} function initializes variables
+used to collect statistics. Currently, only the garbage collector
+information is initialized.
+
+
 <<defun restart>>=
 (defun restart ()
 #+:akcl
@@ -203,53 +322,22 @@ We do not care that tail recursion occurs.
 #+:akcl (setq compiler::*compile-verbose* nil)
 #+:akcl (setq compiler::*suppress-compiler-warnings* t)
 #+:akcl (setq compiler::*suppress-compiler-notes* t)
-#-:CCL
-  (in-package "BOOT")
-#+:CCL
-  (setq *package* (find-package "BOOT"))
-#+:CCL (setpchar "") ;; Turn off CCL read prompts
-#+(OR :akcl :CCL) (initroot)
 #+:akcl (system:gbc-time 0)
+  (in-package "BOOT")
+  (initroot)
 #+:akcl
-  (when (and $openServerIfTrue (fboundp '|openServer|))
-   (prog (os)
-    (setq os (|openServer| $SpadServerName))
-    (if (zerop os) 
-     (progn 
-      (setq $openServerIfTrue nil) 
-      (setq |$SpadServer| t)))))
-;; We do the following test at runtime to allow us to use the same images
-;; with Saturn and Sman.  MCD 30-11-95
-#+:CCL
-  (when 
-     (and (memq :unix *features*) $openServerIfTrue (fboundp '|openServer|))
-   (prog (os)
-    (setq os (|openServer| $SpadServerName))
-    (if (zerop os) 
-     (progn 
-      (setq $openServerIfTrue nil) 
-      (setq |$SpadServer| t)))))
+  (when (and $openServerIfTrue (zerop (openserver $SpadServerName)))
+    (setq $openServerIfTrue nil) 
+    (setq |$SpadServer| t))
   (setq |$IOindex| 1)
   (setq |$InteractiveFrame| (|makeInitialModemapFrame|))
   (setq |$printLoadMsgs| t)
-#+(and :lucid :ibm/370)
-  (setq *default-pathname-defaults* "")
-#+:CCL
-  (setq *default-pathname-defaults* (get-current-directory))
-#-(or :CCL (and :lucid :ibm/370))
-  (setq *default-pathname-defaults* (probe-file "./"))
-#+(and :lucid :ibm/370)
-  (setq vmlisp::$current-directory "")
-#-(and :lucid :ibm/370)
-  (setq vmlisp::$current-directory
-     (make-directory *default-pathname-defaults*))
+  (setq $current-directory (get-current-directory))
   (|loadExposureGroupData|)
   (|statisticsInitialization|)
   (|initHist|)
   (|initializeInterpreterFrameRing|)
-
-  (when |$displayStartMsgs| 
-   (|spadStartUpMsgs|))
+  (when |$displayStartMsgs| (|spadStartUpMsgs|))
   (setq |$currentLine| nil)
   (restart0)
   (|readSpadProfileIfThere|)
@@ -571,10 +659,12 @@ This function performs those setup commands.
 
 @
 
-\subsection{defun initroot}
+\pagehead{initroot}{initroot}
 Sets up the system to use the {\bf AXIOM} shell variable if we can
 and default to the {\bf \$spadroot} variable (which was the value
 of the {\bf AXIOM} shell variable at build time) if we can't.
+
+Called from \fnref{restart}.
 <<defun initroot>>=
 (defun initroot (&optional (newroot (BOOT::|getEnv| "AXIOM")))
   (reroot (or newroot $spadroot (error "setenv AXIOM or (setq $spadroot)"))))
@@ -594,28 +684,6 @@ minus any leading spaces.
     newwhole))))
 
 @
-\subsection{defun loadExposureGroupData}
-<<defun loadExposureGroupData>>=
-#+:AKCL
-(defun |loadExposureGroupData| ()
- (cond
-  ((load "./exposed" :verbose nil :if-does-not-exist nil)
-    '|done|)
-  ((load (concat (system:getenv "AXIOM") "/algebra/exposed")
-     :verbose nil :if-does-not-exist nil)
-   '|done|)
-  (t '|failed|) ))
-
-#+:CCL
-(defun |loadExposureGroupData| ()
- (cond
-  ((load "./exposed.lsp" :verbose NIL :if-does-not-exist NIL) '|done|)
-  ((load (concat (BOOT::|getEnv| "AXIOM") "/../../src/algebra/exposed.lsp") 
-    :verbose nil :if-does-not-exist nil) '|done|)
-  (t nil) ))
-
-@
-
 \subsection{make-absolute-filename}
 Prefix a filename with the {\bf AXIOM} shell variable.
 <<defun make-absolute-filename>>=
@@ -691,16 +759,14 @@ where the [[${SYS}]] variable is the same one set at build time.
 <<defun reroot>>=
 (defun reroot (dir)
   (setq $spadroot dir)
+  (setq $current-directory dir)
   (setq $directory-list
    (mapcar #'make-absolute-filename $relative-directory-list))
   (setq $library-directory-list
    (mapcar #'make-absolute-filename $relative-library-directory-list))
   (setq |$defaultMsgDatabaseName|
 	(pathname (make-absolute-filename "/doc/msgs/s2-us.msgs")))
-  (setq |$msgDatabaseName| ())
-  (setq *default-pathname-defaults*
-	(pathname (make-absolute-filename "")))
-  (setq $current-directory $spadroot))
+  (setq |$msgDatabaseName| ()))
 
 @
 
@@ -734,7 +800,8 @@ this is what the current code does so I won't change it.
 
 @
 
-\subsection{defun statisticsInitialization}
+\chapter{System Statistics}
+\pagehead{statisticsInitialization}{statisticsInitialization}
 <<defun statisticsInitialization>>=
 (defun |statisticsInitialization| () 
  "initialize the garbage collection timer"
@@ -3506,8 +3573,8 @@ S2IH0038
 
 \chapter{The Frame Mechanism}
 \section{)frame}
-%\label{ugSysCmdframe}
-%\index{frame}
+\label{TheFrameMechanism}
+\index{TheFrameMechanism}
 \par\noindent{\bf Command Syntax:}
 \begin{list}{}
 \item{\tt )frame  new  {\it frameName}}
@@ -5188,6 +5255,14 @@ removeUndoLines u == --called by writeInputLines
 
 @
 
+\pagehead{openserver}{openserver}
+This is a cover function for the C code used for communication interface.
+<<defun openserver>>=
+(defun openserver (name)
+  (open_server name))
+
+@
+
 \chapter{The Help Browser Mechanism}
 The Axiom book on the help browser is a complete rewrite of the 
 hyperdoc mechanism. There are several components that were needed
@@ -5457,12 +5532,60 @@ DEBUGSYS=${OBJ}/${SYS}/bin/debugsys
 
 @
 
+\chapter{Exposure Groups}
+Exposure groups are a way of controlling the namespace available
+to the user. Certain algebra files are only useful for internal
+purposes but they contain functions have common names (like 
+``map''. In order to separate the user visible  functions
+from the internal functions the algebra files are collected into
+``exposure groups''. These large groups are grouped into sets in
+the file \verb|exposed.lsp| which lives in the algebra subdirectory.
+
+Exposure group information is kept in the local frame. For more
+information ``The Frame Mechanism'' \ref{TheFrameMechanism} on
+page~\pageref{TheFrameMechanism}.
+
+\pagehead{loadExposureGroupData}{loadExposureGroupData}
+This function is called from \fnref{restart} at system startup time to 
+load the file \verb|exposed.lsp| to set up the exposure group information.
+<<defun loadExposureGroupData>>=
+(defun |loadExposureGroupData| ()
+ (cond
+  ((load "./exposed" :verbose nil :if-does-not-exist nil)
+    '|done|)
+  ((load (concat (system:getenv "AXIOM") "/algebra/exposed")
+     :verbose nil :if-does-not-exist nil)
+   '|done|)
+  (t '|failed|) ))
+
+@
+
+\chapter{Support Functions from Lisp}
+\pagehead{current-directory}{current-directory}
+<<initvars>>=
+(defvar $current-directory "")
+
+@
+\pagehead{get-current-directory}{get-current-directory}
+This function returns a string representing the current directory.
+This is maintained in the \$current-directory variable. It is called 
+from the \fnref{restart} function.
+<<defun get-current-directory>>=
+#+:cmu
+(defun get-current-directory ()
+  (namestring (extensions::default-directory)))
+
+#+(or :akcl :gcl)
+(defun get-current-directory ()
+  (namestring (truename "")))
+
+@ 
+
 \chapter{The Interpreter}
 <<Interpreter>>=
 (in-package "BOOT")
 <<initvars>>
 
-
 <<defun addNewInterpreterFrame>>
 
 <<defun browse>>
@@ -5500,6 +5623,7 @@ DEBUGSYS=${OBJ}/${SYS}/bin/debugsys
 <<defun frameNames>>
 <<defun frameSpad2Cmd>>
 
+<<defun get-current-directory>>
 <<defun getenviron>>
 <<defun gensymInt>>
 
@@ -5538,6 +5662,7 @@ DEBUGSYS=${OBJ}/${SYS}/bin/debugsys
 <<defun nextInterpreterFrame>>
 
 <<defun oldHistFileName>>
+<<defun openserver>>
 
 <<defun previousInterpreterFrame>>
 <<defun putHist>>
@@ -5602,7 +5727,6 @@ DEBUGSYS=${OBJ}/${SYS}/bin/debugsys
 \section{Star Global Variables}
 \begin{tabular}{lll}
 NAME                        & SET              & USE \\
-*default-pathname-defaults* & reroot           & restart \\
 *eof*                       & ncTopLevel       & \\
 *features*                  &                  & restart \\
 *package*                   &                  & restart \\
@@ -5610,20 +5734,6 @@ NAME                        & SET              & USE \\
 *standard-output*           &                  & ncIntLoop \\
 *top-level-hook*            & set-restart-hook & \\
 \end{tabular}
-\subsection{*default-pathname-defaults*}
-The [[*default-pathname-defaults*]] variable is set by
-[[make-absolute-filename]] called on the empty string. This has
-the effect of setting the value to the [[AXIOM]] variable as this
-function just concatenates the [[AXIOM]] variable onto the given string.
-We pass this string to the common lisp [[pathname]] function to set it
-to a real pathname.
-
-The [[*default-pathname-defaults*]] defaults common lisp variable is
-set in [[restart]] to the current directory in most cases. If we are
-working in Lucid Common Lisp ([[:lucid]]) on an IBM/370 mainframe
-([[:ibm/370]]) then it is set to the empty string. Using Lucid on a 
-mainframe seems to use the variable [[vmlisp::$current-directory]].
-
 \subsection{*eof*}
 The [[*eof*]] variable is set to [[NIL]] in [[ncTopLevel]].
 \subsection{*features*}
@@ -5659,7 +5769,7 @@ NAME                         & SET                 & USE \\
 coerceFailure                &                     & runspad \\
 curinstream                  & ncIntLoop           & \\
 curoutstream                 & ncIntLoop           & \\
-vmlisp::\$current-directory  & restart             & \\
+\$current-directory          & restart             & \\
                              & reroot              & \\
 \$currentLine                & restart             & removeUndoLines \\
 \$dalymode                   &                     & intloopReadConsole \\
@@ -5763,19 +5873,10 @@ The [[curoutstream]] variable is set to the value of the
 [[*standard-output*]] common lisp variable in [[ncIntLoop]].
 While not using the ``dollar'' convention this variable is still ``global''.
 
-\subsection{vmlisp::\$current-directory}
-When running in Lucid Common Lisp ([[:lucid]]) on an IBM/370 mainframe
-([[:ibm/370]]) this variable is used in place of the 
-[[*default-pathname-defaults*]] common lisp variable. 
-Otherwise this variable is
-set to the empty string in [[restart]]. 
-
-The [[reroot]] function sets this variable to the value of
-[[$spadroot]] which itself has the value of the argument to the
-[[reroot]] function. Since the argument to the [[reroot]] function is
-an string which represents an absolute pathname pointing to AXIOM the
-net result is that the [[$current-directory]] is set to point to the
-shell [[AXIOM]] variable.
+\subsection{\$current-directory}
+This is set to the value returned by the \verb|get-current-directory| 
+function in \fnref{restart}. It is set to the argument of the 
+\verb|reroot| function.
 
 So during execute both [[$current-directory]] and [[$spadroot]] reflect
 the value of the [[AXIOM]] shell variable.
@@ -6032,7 +6133,7 @@ The [[$previousBindings]] is a copy of the
 compute the [[delta(i)]]s stored in [[$frameRecord]].
 This is part of the undo mechanism.
 
-\subsection{\$printLoadMsgs}
+\pagehead{printLoadMsgs}{printLoadMsgs}
 The [[$printLoadMsgs]] variable is set to [[T]] in [[restart]].
 
 \subsection{\$PrintCompilerMessageIfTrue}
diff --git a/books/ps/v5restart.ps b/books/ps/v5restart.ps
new file mode 100644
index 0000000..eefd825
--- /dev/null
+++ b/books/ps/v5restart.ps
@@ -0,0 +1,468 @@
+%!PS-Adobe-2.0
+%%Creator: Graphviz version 2.16.1 (Mon Jul  7 18:20:33 UTC 2008)
+%%For: (root) root
+%%Title: g
+%%Pages: (atend)
+%%BoundingBox: (atend)
+%%EndComments
+save
+%%BeginProlog
+/DotDict 200 dict def
+DotDict begin
+
+/setupLatin1 {
+mark
+/EncodingVector 256 array def
+ EncodingVector 0
+
+ISOLatin1Encoding 0 255 getinterval putinterval
+EncodingVector 45 /hyphen put
+
+% Set up ISO Latin 1 character encoding
+/starnetISO {
+        dup dup findfont dup length dict begin
+        { 1 index /FID ne { def }{ pop pop } ifelse
+        } forall
+        /Encoding EncodingVector def
+        currentdict end definefont
+} def
+/Times-Roman starnetISO def
+/Times-Italic starnetISO def
+/Times-Bold starnetISO def
+/Times-BoldItalic starnetISO def
+/Helvetica starnetISO def
+/Helvetica-Oblique starnetISO def
+/Helvetica-Bold starnetISO def
+/Helvetica-BoldOblique starnetISO def
+/Courier starnetISO def
+/Courier-Oblique starnetISO def
+/Courier-Bold starnetISO def
+/Courier-BoldOblique starnetISO def
+cleartomark
+} bind def
+
+%%BeginResource: procset graphviz 0 0
+/coord-font-family /Times-Roman def
+/default-font-family /Times-Roman def
+/coordfont coord-font-family findfont 8 scalefont def
+
+/InvScaleFactor 1.0 def
+/set_scale {
+       dup 1 exch div /InvScaleFactor exch def
+       scale
+} bind def
+
+% styles
+/solid { [] 0 setdash } bind def
+/dashed { [9 InvScaleFactor mul dup ] 0 setdash } bind def
+/dotted { [1 InvScaleFactor mul 6 InvScaleFactor mul] 0 setdash } bind def
+/invis {/fill {newpath} def /stroke {newpath} def /show {pop newpath} def} bind def
+/bold { 2 setlinewidth } bind def
+/filled { } bind def
+/unfilled { } bind def
+/rounded { } bind def
+/diagonals { } bind def
+
+% hooks for setting color 
+/nodecolor { sethsbcolor } bind def
+/edgecolor { sethsbcolor } bind def
+/graphcolor { sethsbcolor } bind def
+/nopcolor {pop pop pop} bind def
+
+/beginpage {	% i j npages
+	/npages exch def
+	/j exch def
+	/i exch def
+	/str 10 string def
+	npages 1 gt {
+		gsave
+			coordfont setfont
+			0 0 moveto
+			(\() show i str cvs show (,) show j str cvs show (\)) show
+		grestore
+	} if
+} bind def
+
+/set_font {
+	findfont exch
+	scalefont setfont
+} def
+
+% draw text fitted to its expected width
+/alignedtext {			% width text
+	/text exch def
+	/width exch def
+	gsave
+		width 0 gt {
+			[] 0 setdash
+			text stringwidth pop width exch sub text length div 0 text ashow
+		} if
+	grestore
+} def
+
+/boxprim {				% xcorner ycorner xsize ysize
+		4 2 roll
+		moveto
+		2 copy
+		exch 0 rlineto
+		0 exch rlineto
+		pop neg 0 rlineto
+		closepath
+} bind def
+
+/ellipse_path {
+	/ry exch def
+	/rx exch def
+	/y exch def
+	/x exch def
+	matrix currentmatrix
+	newpath
+	x y translate
+	rx ry scale
+	0 0 1 0 360 arc
+	setmatrix
+} bind def
+
+/endpage { showpage } bind def
+/showpage { } def
+
+/layercolorseq
+	[	% layer color sequence - darkest to lightest
+		[0 0 0]
+		[.2 .8 .8]
+		[.4 .8 .8]
+		[.6 .8 .8]
+		[.8 .8 .8]
+	]
+def
+
+/layerlen layercolorseq length def
+
+/setlayer {/maxlayer exch def /curlayer exch def
+	layercolorseq curlayer 1 sub layerlen mod get
+	aload pop sethsbcolor
+	/nodecolor {nopcolor} def
+	/edgecolor {nopcolor} def
+	/graphcolor {nopcolor} def
+} bind def
+
+/onlayer { curlayer ne {invis} if } def
+
+/onlayers {
+	/myupper exch def
+	/mylower exch def
+	curlayer mylower lt
+	curlayer myupper gt
+	or
+	{invis} if
+} def
+
+/curlayer 0 def
+
+%%EndResource
+%%EndProlog
+%%BeginSetup
+14 default-font-family set_font
+1 setmiterlimit
+% /arrowlength 10 def
+% /arrowwidth 5 def
+
+% make sure pdfmark is harmless for PS-interpreters other than Distiller
+/pdfmark where {pop} {userdict /pdfmark /cleartomark load put} ifelse
+% make '<<' and '>>' safe on PS Level 1 devices
+/languagelevel where {pop languagelevel}{1} ifelse
+2 lt {
+    userdict (<<) cvn ([) cvn load put
+    userdict (>>) cvn ([) cvn load put
+} if
+
+%%EndSetup
+setupLatin1
+%%Page: 1 1
+%%PageBoundingBox: 36 36 238 404
+%%PageOrientation: Portrait
+0 0 1 beginpage
+gsave
+36 36 202 368 boxprim clip newpath
+1 1 set_scale 0 rotate 40 40 translate
+0.167 0.600 1.000 graphcolor
+newpath -4 -4 moveto
+-4 716 lineto
+536 716 lineto
+536 -4 lineto
+closepath fill
+1 setlinewidth
+0.167 0.600 1.000 graphcolor
+newpath -4 -4 moveto
+-4 716 lineto
+536 716 lineto
+536 -4 lineto
+closepath stroke
+% lisp
+gsave
+[ /Rect [ 68 304 126 352 ]
+  /Border [ 0 0 0 ]
+  /Action << /Subtype /URI /URI (bookvol5.pdf#nameddest=lisp) >>
+  /Subtype /Link
+/ANN pdfmark
+0.167 0.600 1.000 nodecolor
+newpath 126 352 moveto
+68 352 lineto
+68 304 lineto
+126 304 lineto
+closepath fill
+1 setlinewidth
+filled
+0.167 0.600 1.000 nodecolor
+newpath 126 352 moveto
+68 352 lineto
+68 304 lineto
+126 304 lineto
+closepath stroke
+0.537 0.247 0.902 nodecolor
+newpath 76 328 moveto
+76 348 lineto
+118 348 lineto
+118 328 lineto
+closepath fill
+1 setlinewidth
+solid
+0.537 0.247 0.902 nodecolor
+newpath 76 328 moveto
+76 348 lineto
+118 348 lineto
+118 328 lineto
+closepath stroke
+1 setlinewidth
+solid
+0.000 0.000 0.000 nodecolor
+newpath 76 328 moveto
+76 348 lineto
+118 348 lineto
+118 328 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+79 334.733 moveto 20 (lisp) alignedtext
+1 setlinewidth
+solid
+0.000 0.000 0.000 nodecolor
+newpath 76 308 moveto
+76 328 lineto
+118 328 lineto
+118 308 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+79 314.733 moveto 36 (restart) alignedtext
+grestore
+% restart
+gsave
+[ /Rect [ 0 0 194 268 ]
+  /Border [ 0 0 0 ]
+  /Action << /Subtype /URI /URI (bookvol5.pdf#nameddest=restart) >>
+  /Subtype /Link
+/ANN pdfmark
+0.167 0.600 1.000 nodecolor
+newpath 194 268 moveto
+5.68434e-14 268 lineto
+1.42109e-14 8.52651e-14 lineto
+194 0 lineto
+closepath fill
+1 setlinewidth
+filled
+0.167 0.600 1.000 nodecolor
+newpath 194 268 moveto
+5.68434e-14 268 lineto
+1.42109e-14 8.52651e-14 lineto
+194 0 lineto
+closepath stroke
+0.537 0.247 0.902 nodecolor
+newpath 8 244 moveto
+8 264 lineto
+186 264 lineto
+186 244 lineto
+closepath fill
+1 setlinewidth
+solid
+0.537 0.247 0.902 nodecolor
+newpath 8 244 moveto
+8 264 lineto
+186 264 lineto
+186 244 lineto
+closepath stroke
+1 setlinewidth
+solid
+0.000 0.000 0.000 nodecolor
+newpath 8 244 moveto
+8 264 lineto
+186 264 lineto
+186 244 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+11 250.733 moveto 36 (restart) alignedtext
+1 setlinewidth
+solid
+0.000 0.000 0.000 nodecolor
+newpath 8 224 moveto
+8 244 lineto
+186 244 lineto
+186 224 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+76.5 230.733 moveto 41 (initroot) alignedtext
+1 setlinewidth
+solid
+0.000 0.000 0.000 nodecolor
+newpath 8 204 moveto
+8 224 lineto
+186 224 lineto
+186 204 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+65.5 210.733 moveto 63 (openserver) alignedtext
+1 setlinewidth
+solid
+0.000 0.000 0.000 nodecolor
+newpath 8 184 moveto
+8 204 lineto
+186 204 lineto
+186 184 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+17.5 190.733 moveto 159 (makeInitialModemapFrame) alignedtext
+1 setlinewidth
+solid
+0.000 0.000 0.000 nodecolor
+newpath 8 164 moveto
+8 184 lineto
+186 184 lineto
+186 164 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+37 170.733 moveto 120 (get-current-directory) alignedtext
+1 setlinewidth
+solid
+0.000 0.000 0.000 nodecolor
+newpath 8 144 moveto
+8 164 lineto
+186 164 lineto
+186 144 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+25.5 150.733 moveto 143 (loadExposureGroupData) alignedtext
+1 setlinewidth
+solid
+0.000 0.000 0.000 nodecolor
+newpath 8 124 moveto
+8 144 lineto
+186 144 lineto
+186 124 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+36 130.733 moveto 122 (statisticsInitialization) alignedtext
+1 setlinewidth
+solid
+0.000 0.000 0.000 nodecolor
+newpath 8 104 moveto
+8 124 lineto
+186 124 lineto
+186 104 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+76.5 110.733 moveto 41 (initHist) alignedtext
+1 setlinewidth
+solid
+0.000 0.000 0.000 nodecolor
+newpath 8 84 moveto
+8 104 lineto
+186 104 lineto
+186 84 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+11.5 90.7333 moveto 171 (initializeInterpreterFrameRing) alignedtext
+1 setlinewidth
+solid
+0.000 0.000 0.000 nodecolor
+newpath 8 64 moveto
+8 84 lineto
+186 84 lineto
+186 64 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+45.5 70.7333 moveto 103 (spadStartUpMsgs) alignedtext
+1 setlinewidth
+solid
+0.000 0.000 0.000 nodecolor
+newpath 8 44 moveto
+8 64 lineto
+186 64 lineto
+186 44 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+75 50.7333 moveto 44 (restart0) alignedtext
+1 setlinewidth
+solid
+0.000 0.000 0.000 nodecolor
+newpath 8 24 moveto
+8 44 lineto
+186 44 lineto
+186 24 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+29.5 30.7333 moveto 135 (readSpadProfileIfThere) alignedtext
+1 setlinewidth
+solid
+0.000 0.000 0.000 nodecolor
+newpath 8 4 moveto
+8 24 lineto
+186 24 lineto
+186 4 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+83.5 10.7333 moveto 27 (spad) alignedtext
+grestore
+% lisp->restart
+gsave
+5 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 97 308 moveto
+97 299 97 286 97 274 curveto
+stroke
+0.000 0.000 0.000 edgecolor
+newpath 100.5 274 moveto
+97 264 lineto
+93.5001 274 lineto
+closepath fill
+1 setlinewidth
+solid
+0.000 0.000 0.000 edgecolor
+newpath 100.5 274 moveto
+97 264 lineto
+93.5001 274 lineto
+closepath stroke
+grestore
+endpage
+showpage
+grestore
+%%PageTrailer
+%%EndPage: 1
+%%Trailer
+%%Pages: 1
+%%BoundingBox: 36 36 238 404
+end
+restore
+%%EOF
diff --git a/changelog b/changelog
index 5069ea7..1eb750a 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,7 @@
+20090212 tpd src/axiom-website/patches.html 20090212.02.tpd.patch
+20090212 tpd src/Makefile.pamphlet copy bookvol5
+20090212 tpd books/ps/v5restart.ps added
+20090212 tpd books/bookvol5.pamphlet rewrite/document restart function
 20090212 tpd src/axiom-website/patches.html 20090212.01.tpd.patch
 20090212 tpd src/interp/interp-proclaims.lisp update proclaims for changes
 20090212 tpd src/interp/sockio.lisp remove unused code
diff --git a/src/Makefile.pamphlet b/src/Makefile.pamphlet
index 34820b0..a48ac4b 100644
--- a/src/Makefile.pamphlet
+++ b/src/Makefile.pamphlet
@@ -259,6 +259,7 @@ interpdir: ${SRC}/interp/Makefile
 	@mkdir -p ${MNT}/${SYS}/algebra
 	@mkdir -p ${MNT}/${SYS}/doc/msgs
 	@mkdir -p ${MNT}/${SYS}/doc/src/interp
+	@cp ${SPD}/books/bookvol5.pamphlet interp
 	@(cd interp ; ${ENV} ${MAKE} )
 
 ${SRC}/interp/Makefile: ${SRC}/interp/Makefile.pamphlet
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 2fbdca2..140c90c 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -943,5 +943,7 @@ bookvol10.4 add exports<br/>
 bookvol10.4 add exports<br/>
 <a href="patches/20090212.01.tpd.patch">20090212.01.tpd.patch</a>
 remove unused code<br/>
+<a href="patches/20090212.02.tpd.patch">20090212.02.tpd.patch</a>
+rewrite restart<br/>
  </body>
 </html>



From MAILER-DAEMON Wed Feb 18 10:18:00 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LZoBT-0003Tb-Vz
	for mharc-axiom-developer@gnu.org; Wed, 18 Feb 2009 10:18:00 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LZWU4-0007mW-6U
	for axiom-developer@nongnu.org; Tue, 17 Feb 2009 15:24:00 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LZWU2-0007mK-Ll
	for axiom-developer@nongnu.org; Tue, 17 Feb 2009 15:23:59 -0500
Received: from [199.232.76.173] (port=51370 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43)
	id 1LZWU2-0007mH-FV; Tue, 17 Feb 2009 15:23:58 -0500
Received: from tvwna-ip-b-236.princeton.org ([66.180.186.73]:39258
	helo=localhost.princeton.org)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <camm@maguirefamily.org>)
	id 1LZWU2-0000Yq-44; Tue, 17 Feb 2009 15:23:58 -0500
Received: from camm by localhost.princeton.org with local (Exim 4.69)
	(envelope-from <camm@maguirefamily.org>)
	id 1LZWTg-0001uA-MZ; Tue, 17 Feb 2009 15:23:36 -0500
To: daly@axiom-developer.org
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
From: Camm Maguire <camm@maguirefamily.org>
Date: Tue, 17 Feb 2009 15:23:36 -0500
In-Reply-To: <200902051354.n15Dsb221922@localhost.localdomain> (root's message
	of "Thu\, 5 Feb 2009 08\:54\:37 -0500")
Message-ID: <87ljs44xtj.fsf@maguirefamily.org>
User-Agent: Gnus/5.11 (Gnus v5.11) Emacs/22.2 (gnu/linux)
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
X-Mailman-Approved-At: Wed, 18 Feb 2009 10:17:58 -0500
Cc: axiom-developer@nongnu.org, gcl-devel@gnu.org
Subject: [Axiom-developer] Re: Axiom on Debian
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 17 Feb 2009 20:24:00 -0000

Greetings!  Just a heads up Tim, I'm uploading a Nov 2008 package to
Debian now.  Please take a look and feel free to offer any
suggestions.

Take care,

root <daly@axiom-developer.org> writes:

>> Greetings!  I'm still here, but dealing with some life changes.  I'm
>> gearing up now to restart the gcl and dependency package maintenance
>> work.  If you still have an issue here, please feel free to forward me
>> the details.
>> 
>> Take care,
>> 
>> root <daly@axiom-developer.org> writes:
>> 
>> > Camm,
>> >
>> > I get a message from INTECH that you're no longer employed there.
>> > Hope it was because you found a different job.
>> >
>> > What is your status relative to GCL and Axiom on Debian?
>> >
>> > I recently ran across a bug list on Launchpad for Axiom that I
>> > did not know about. I'm trying to reclaim the bug list and I'm
>> > trying to update the Debian package for Axiom. The debian package
>> > simply fails for almost all inputs.
>> >
>
> Camm,
>
> Good to see you back. I fell off the face of the earth during my divorce
> so life has a way of slowing us all down at times.
>
> The axiom distribution on Debian is broken out of the box everywhere,
> it seems. Plus, it is from 2005 and some things might have changed.
> I'd really like to update it because the "first use" of Axiom for
> most people on a lot of systems, like ubuntu, come from the fetch of
> this broken image.
>
> I'm willing to do the work. I just don't have any debian contact but you.
>
> Tim
>
>
>
>
>

-- 
Camm Maguire			     		    camm@maguirefamily.org
==========================================================================
"The earth is but one country, and mankind its citizens."  --  Baha'u'llah



From MAILER-DAEMON Sun Feb 22 00:56:13 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lb7K1-0000Rx-KN
	for mharc-axiom-developer@gnu.org; Sun, 22 Feb 2009 00:56:13 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lb7Jy-0000Qs-GO
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 00:56:10 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lb7Jq-0000Oa-E7
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 00:56:09 -0500
Received: from [199.232.76.173] (port=43391 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lb7Jq-0000OX-6j
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 00:56:02 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:45774
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Lb7Jm-0000OP-TO
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 00:56:01 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1M5tpug015765;
	Sat, 21 Feb 2009 23:55:54 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1M5tmgX015741;
	Sat, 21 Feb 2009 23:55:48 -0600
Date: Sat, 21 Feb 2009 23:55:48 -0600
Message-Id: <200902220555.n1M5tmgX015741@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090220.01.tpd.patch (regression test )d op,
	)frame )
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 22 Feb 2009 05:56:10 -0000

Book Volume 5: Axiom Interpreter was updated with more code, more
documentation, and more structure. More boot code was rewritten in lisp.

The )frame code was rewritten and a regression test file was created
(src/input/frame.input)

Bug 7170 (X in comments) and bug 7171 (off-by-one printing) were fixed.

All )d op Example code was reviewed and a regression test file was
created (src/input/dop.input). About 5% of the functions now show
examples as part of the output of )d op function, such as:

)d op binaryTree

There are 2 exposed functions called binaryTree :
   [1] (BinaryTree D1,D1,BinaryTree D1) -> BinaryTree D1 from 
            BinaryTree D1
            if D1 has SETCAT
   [2] D1 -> BinaryTree D1 from BinaryTree D1 if D1 has SETCAT

Examples of binaryTree from BinaryTree

t1:=binaryTree([1,2,3]) 
t2:=binaryTree([4,5,6]) 
binaryTree(t1,[7,8,9],t2)

t1:=binaryTree([1,2,3])



====================================================================
diff --git a/books/bookvol10.4.pamphlet b/books/bookvol10.4.pamphlet
index b842bb7..23f6c27 100644
--- a/books/bookvol10.4.pamphlet
+++ b/books/bookvol10.4.pamphlet
@@ -2982,7 +2982,7 @@ AnnaOrdinaryDifferentialEquationPackage(): with
     ++ numerically a system of ordinary differential equations i.e. equations 
     ++ for the derivatives y[1]'..y[n]' defined in terms of x,y[1]..y[n], 
     ++ together with a starting value for x and y[1]..y[n] (called the initial
-    ++ conditions) and a final value of X.  A default value
+    ++ conditions) and a final value of x.  A default value
     ++ is used for the accuracy requirement.
     ++
     ++ It iterates over the \axiom{domains} of
@@ -94278,7 +94278,7 @@ TopLevelDrawFunctionsForPoints(): Exports == Implementation where
     draw: (L SF, L SF, L SF) -> VIEW3
       ++ draw(lx,ly,lz) draws the surface constructed by projecting the values
       ++ in the \axiom{lz} list onto the rectangular grid formed by the 
-      ++ \axiom{lx X ly}.
+      ++ \axiom{lx x ly}.
     draw: (L SF, L SF, L SF, L DROP) -> VIEW3
       ++ draw(lx,ly,lz,l) draws the surface constructed by 
       ++ projecting the values
diff --git a/books/bookvol5.pamphlet b/books/bookvol5.pamphlet
index 383055c..2becf4e 100644
--- a/books/bookvol5.pamphlet
+++ b/books/bookvol5.pamphlet
@@ -1395,7 +1395,7 @@ If there is only one then we clean it up and print it.
    (setq line (subseq docstring (+ point 8)))
    (do ((mark (search "spad{X}" line) (search "spad{X}" line)))
      ((null mark))
-    (princ (cleanupLine (subseq line (+ mark 8))))
+    (princ (cleanupLine (subseq line 0 mark)))
     (|sayNewLine|)
     (setq line (subseq line (+ mark 8))))
    (princ (cleanupLine line))
@@ -4055,39 +4055,175 @@ prompt.
 {\tt )history} \index{ugSysCmdhistory} and
 {\tt )set} \index{ugSysCmdset}.
 
-\subsection{defun frameName}
+\section{Variables Used}
+The frame mechanism uses several dollar variables.
+\subsection{Primary variables}
+Primary variables are those which exist solely to make the frame
+mechanism work. 
+
+The \$interpreterFrameName contains a symbol which is the name
+of the current frame in use. 
+
+The \$interpreterFrameRing contains a list of all of the existing
+frames. The first frame on the list is the ``current'' frame. When
+AXIOMsys is started directly there is only one frame named ``initial''.
+
+If the system is started under sman (using the axiom shell script,
+for example), there are two frames, ``initial'' and ``frame0''. In
+this case, ``frame0'' is the current frame. This can cause subtle
+problems because functions defined in the axiom initialization file
+(.axiom.input) will be defined in frame ``initial'' but the current
+frame will be ``frame0''. They will appear to be undefined. However,
+if the user does ``)frame next'' they can switch to the ``initial''
+frame and see the functions correctly defined.
+
+The \$frameMessages variable controls when frame messages will be
+displayed. The variable is initially NIL. It can be set on (T) or off (NIL)
+using the system command:
 \begin{verbatim}
-frameName(frame) == CAR frame
+    )set message frame on | off
 \end{verbatim}
+Setting frame messages on will output a line detailing the 
+current frame after every output is complete. 
+
+\subsection{Used variables}
+
+The frame collects and uses a few top level variables. These are:
+\$InteractiveFrame, \$IOindex, \$HiFiAccess, \$HistList, \$HistListLen,
+\$HistListAct, \$HistRecord, \$internalHistoryTable, and \$localExposureData.
+
+These variables can also be changed by the frame mechanism when the user
+requests changing to a different frame.
+
+\section{Data Structures}
+\subsection{Frames and the Interpreter Frame Ring}
+
+Axiom has the notion of ``frames''. A frame is a data structure which
+holds all the vital data from an Axiom session. There can be multiple
+frames and these live in a top-level variable called
+\$interpreterFrameRing. This variable holds a circular list of frames.
+The parts of a frame and their initial, default values are:
+
+\begin{verbatim}
+  $interpreterFrameName      a string, named on creation
+  $InteractiveFrame          (list (list nil))
+  $IOindex                   an integer, 1
+  $HiFiAccess                $HiFiAccess, see the variable description
+  $HistList                  $HistList, see the variable description
+  $HistListLen               $HistListLen, see the variable description
+  $HistListAct               $HistListAct, see the variable description
+  $HistRecord                $HistRecord, see the variable description
+  $internalHistoryTable      nil
+  $localExposureData         a copy of $localExposureData
+\end{verbatim}
+
+\section{Accessor Functions}
+These could be macros but we wish to export them to the API code
+in the algebra so we keep them as functions.
+\subsection{0th Frame Component -- frameName}
+\subsection{defun frameName}
 <<defun frameName>>=
-(defun |frameName| (frame)
+(defun frameName (frame)
  (car frame)) 
 
 @
+\subsection{1st Frame Component -- frameInteractive}
+<<defun frameInteractive>>=
+(defun frameInteractive (frame)
+ (nth 1 frame))
+
+@
+\subsection{2nd Frame Component -- frameIOIndex}
+<<defun frameIOIndex>>=
+(defun frameIOIndex (frame)
+ (nth 2 frame))
+
+@
+\subsection{3rd Frame Component -- frameHiFiAccess}
+<<defun frameHiFiAccess>>=
+(defun frameHiFiAccess (frame)
+ (nth 3 frame))
+
+@
+\subsection{4th Frame Component -- frameHistList}
+<<defun frameHistList>>=
+(defun frameHistList (frame)
+ (nth 4 frame))
+
+@
+\subsection{5th Frame Component -- frameHistListLen}
+<<defun frameHistListLen>>=
+(defun frameHistListLen (frame)
+ (nth 5 frame))
+
+@
+\subsection{6th Frame Component -- frameHistListAct}
+<<defun frameHistListAct>>=
+(defun frameHistListAct (frame)
+ (nth 6 frame))
+
+@
+\subsection{7th Frame Component -- frameHistRecord}
+<<defun frameHistRecord>>=
+(defun frameHistRecord (frame)
+ (nth 7 frame))
+
+@
+\subsection{8th Frame Component -- frameHistoryTable}
+<<defun frameHistoryTable>>=
+(defun frameHistoryTable (frame)
+ (nth 8 frame))
+
+@
+\subsection{9th Frame Component -- frameExposureData}
+<<defun frameExposureData>>=
+(defun frameExposureData (frame)
+ (nth 9 frame))
+
+@
+
 \section{Variables Used}
 \section{Data Structures}
 \section{Functions}
+\subsection{Initializing the Interpreter Frame Ring}
+
+Now that we know what a frame looks like we need a function to
+initialize the list of frames. This function sets the initial frame
+name to ``initial'' and creates a list of frames containing an empty
+frame. This list is the interpreter frame ring and is not actually
+circular but is managed as a circular list. 
+
+As a final step we update the world from this frame. This has the
+side-effect of resetting all the important global variables to their
+initial values.
+
+<<defun initializeInterpreterFrameRing>>=
+(defun |initializeInterpreterFrameRing| ()
+ (setq |$interpreterFrameName| '|initial|)
+ (setq |$interpreterFrameRing|
+   (list (|emptyInterpreterFrame| |$interpreterFrameName|)))
+ (|updateFromCurrentInterpreterFrame|)
+ nil) 
+
+@
+\subsection{Creating a List of all of the Frame Names}
 \subsection{defun frameNames}
+This function simply walks across the frame in the frame ring and
+returns a list of the name of each frame. 
 \begin{verbatim}
 frameNames() == [frameName f for f in $interpreterFrameRing]
 \end{verbatim}
 <<defun frameNames>>=
 (defun |frameNames| () 
- (prog () 
-  (return
-   (seq
-    (prog (tmp0)
-     (spadlet tmp0 nil) 
-     (return
-      (do ((tmp1 |$interpreterFrameRing| (cdr tmp1)) (f nil))
-          ((or (atom tmp1) 
-               (progn (setq f (car tmp1)) nil))
-            (nreverse0 tmp0))
-       (seq
-        (exit
-         (setq tmp0 (cons (|frameName| f) tmp0))))))))))) 
+ (mapcar #'frameName |$interpreterFrameRing|))
 
 @
+
+\subsection{Get Named Frame Environment (aka Interactive)}
+If the frame is found we return the environment portion of the frame
+otherwise we construct an empty environment and return it.
+The initial values of an empty frame are created here. This function
+returns a single frame that will be placed in the frame ring.
 \subsection{defun frameEnvironment}
 \begin{verbatim}
 frameEnvironment fname ==
@@ -4106,29 +4242,10 @@ frameEnvironment fname ==
 \end{verbatim}
 <<defun frameEnvironment>>=
 (defun |frameEnvironment| (fname)
- (prog
-  (tmp1 f e ifr)
-  (return
-   (seq
-    (cond
-     ((boot-equal fname (|frameName| (CAR |$interpreterFrameRing|)))
-       |$InteractiveFrame|)
-     (t
-       (spadlet ifr (cdr |$interpreterFrameRing|))
-       (spadlet e (list (list nil)))
-       (do () 
-           ((null ifr) nil)
-        (seq
-         (exit
-          (progn
-           (spadlet tmp1 ifr)
-           (spadlet f (car tmp1))
-           (spadlet ifr (cdr tmp1))
-           (cond
-            ((boot-equal fname (|frameName| f))
-              (spadlet e (cadr f))
-              (spadlet ifr nil))
-            (t nil)))))) e)))))) 
+ (let ((frame (|findFrameInRing| fname)))
+  (if frame
+   (frameInteractive frame)
+   (list (list nil)))))
 
 @
 \subsection{defun emptyInterpreterFrame}
@@ -4160,6 +4277,12 @@ emptyInterpreterFrame(name) ==
    (copy-seq |$localExposureDataDefault|))) 
 
 @
+\subsection{Collecting up the Environment into a Frame}
+
+We can collect up all the current environment information into
+one frame element with this call. It creates a list of the current
+values of the global variables and returns this as a frame element.
+
 \subsection{defun createCurrentInterpreterFrame}
 \begin{verbatim}
 createCurrentInterpreterFrame() ==
@@ -4190,6 +4313,12 @@ createCurrentInterpreterFrame() ==
    |$localExposureData|)) 
 
 @
+\subsection{Updating from the Current Frame}
+
+The frames are kept on a circular list. The first element on that
+list is known as ``the current frame''. This will initialize all
+of the interesting interpreter data structures from that frame.
+
 \subsection{defun updateFromCurrentInterpreterFrame}
 \begin{verbatim}
 updateFromCurrentInterpreterFrame() ==
@@ -4211,28 +4340,26 @@ updateFromCurrentInterpreterFrame() ==
 \end{verbatim}
 <<defun updateFromCurrentInterpreterFrame>>=
 (defun |updateFromCurrentInterpreterFrame| ()
- (prog (tmp1)
-  (return
-   (progn
-    (spadlet tmp1 (CAR |$interpreterFrameRing|))
-    (spadlet |$interpreterFrameName| (car tmp1))
-    (spadlet |$InteractiveFrame| (cadr tmp1))
-    (spadlet |$IOindex| (caddr tmp1))
-    (spadlet |$HiFiAccess| (cadddr tmp1))
-    (spadlet |$HistList| (car (cddddr tmp1)))
-    (spadlet |$HistListLen| (cadr (cddddr tmp1)))
-    (spadlet |$HistListAct| (caddr (cddddr tmp1)))
-    (spadlet |$HistRecord| (cadddr (cddddr tmp1)))
-    (spadlet |$internalHistoryTable| (car (cddddr (cddddr tmp1))))
-    (spadlet |$localExposureData| (cadr (cddddr (cddddr tmp1))))
-    (when |$frameMessages| 
-      (|sayMessage| 
-       (cons 
-        (makestring "   Current interpreter frame is called") 
-        (|bright| |$interpreterFrameName|))))
-    nil)))) 
+ (let (tmp1)
+  (setq tmp1 (first |$interpreterFrameRing|))
+  (setq |$interpreterFrameName| (nth 0 tmp1))
+  (setq |$InteractiveFrame|     (nth 1 tmp1))
+  (setq |$IOindex|              (nth 2 tmp1))
+  (setq |$HiFiAccess|           (nth 3 tmp1))
+  (setq |$HistList|             (nth 4 tmp1))
+  (setq |$HistListLen|          (nth 5 tmp1))
+  (setq |$HistListAct|          (nth 6 tmp1))
+  (setq |$HistRecord|           (nth 7 tmp1))
+  (setq |$internalHistoryTable| (nth 8 tmp1))
+  (setq |$localExposureData|    (nth 9 tmp1))
+  (when |$frameMessages| 
+   (|sayMessage| 
+    (cons "   Current interpreter frame is called" |$interpreterFrameName|)))))
 
 @
+\subsection{Find a Frame in the Frame Ring by Name}
+Each frame contains its name as the 0th element.  We simply walk all
+the frames and if we find one we return it.
 \subsection{defun findFrameInRing}
 \begin{verbatim}
 findFrameInRing(name) ==
@@ -4245,26 +4372,17 @@ findFrameInRing(name) ==
 \end{verbatim}
 <<defun findFrameInRing>>=
 (defun |findFrameInRing| (name)
- (prog (val)
-  (return 
-   (seq 
-    (progn 
-     (spadlet val nil)
-     (seq 
-      (do ((tmp0 |$interpreterFrameRing| (cdr tmp0)) (frame nil))
-          ((or (atom tmp0)
-               (progn (setq frame (car tmp0)) nil)) 
-            nil)
-       (seq 
-        (exit 
-         (when (boot-equal (CAR frame) name)
-          (exit
-           (progn
-            (spadlet val frame)
-            (return frame)))))))
-      (exit val))))))) 
+ (block ()
+  (dolist (frame |$interpreterFrameRing|)
+   (when (boot-equal (frameName frame) name) (return frame)))))
 
 @
+\subsection{Update the Current Interpreter Frame}
+
+This function collects the normal contents of the world into a 
+frame object, places it first on the frame list, and then sets
+the current values of the world from the frame object. 
+
 \subsection{defun updateCurrentInterpreterFrame}
 \begin{verbatim}
 updateCurrentInterpreterFrame() ==
@@ -4274,10 +4392,9 @@ updateCurrentInterpreterFrame() ==
 \end{verbatim}
 <<defun updateCurrentInterpreterFrame>>=
 (defun |updateCurrentInterpreterFrame| ()
- (progn
   (rplaca |$interpreterFrameRing| (|createCurrentInterpreterFrame|))
   (|updateFromCurrentInterpreterFrame|)
-  nil)) 
+  nil)
 
 @
 \subsection{defun initializeInterpreterFrameRing}
@@ -4290,14 +4407,23 @@ initializeInterpreterFrameRing() ==
 \end{verbatim}
 <<defun initializeInterpreterFrameRing>>=
 (defun |initializeInterpreterFrameRing| ()
- (progn
   (spadlet |$interpreterFrameName| '|initial|)
   (spadlet |$interpreterFrameRing|
    (cons (|emptyInterpreterFrame| |$interpreterFrameName|) nil))
-  (|updateFromCurrentInterpreterFrame|) nil)) 
+  (|updateFromCurrentInterpreterFrame|)
+  nil)
 
 @
 \subsection{defun nextInterpreterFrame}
+
+This function updates the current frame to make sure all of the
+current information is recorded. If there are more frame elements
+in the list then this will destructively move the current frame
+to the end of the list, that is, assume the frame list reads (1 2 3)
+this function will destructively change it to (2 3 1).
+
+Note: the nconc2 function destructively inserts the second list at the
+end of the first.
 \begin{verbatim}
 nextInterpreterFrame() ==
   updateCurrentInterpreterFrame()
@@ -4308,18 +4434,11 @@ nextInterpreterFrame() ==
 \end{verbatim}
 <<defun nextInterpreterFrame>>=
 (defun |nextInterpreterFrame| ()
- (progn
-  (|updateCurrentInterpreterFrame|)
-  (cond
-    ((null (cdr |$interpreterFrameRing|))
-      nil)
-    (t 
-      (spadlet |$interpreterFrameRing|
-       (nconc2
-        (cdr |$interpreterFrameRing|)
-        (cons
-         (car |$interpreterFrameRing|) nil)))
-      (|updateFromCurrentInterpreterFrame|))))) 
+  (when (cdr |$interpreterFrameRing|)
+   (setq |$interpreterFrameRing|
+    (nconc2 (cdr |$interpreterFrameRing|) 
+      (list (car |$interpreterFrameRing|))))
+   (|updateFromCurrentInterpreterFrame|)))
 
 @
 \subsection{defun changeToNamedInterpreterFrame}
@@ -4402,7 +4521,7 @@ addNewInterpreterFrame(name) ==
              nil)
        (seq
         (exit
-         (when (boot-equal name (|frameName| f))
+         (when (boot-equal name (frameName f))
           (exit 
            (|throwKeyedMsg| 'S2IZ0019 ; existing frame with same name
             (cons name nil)))))))
@@ -4457,7 +4576,7 @@ closeInterpreterFrame(name) ==
            (seq
             (exit
              (cond
-              ((or found (nequal name (|frameName| f)))
+              ((or found (nequal name (frameName f)))
                 (spadlet ifr (cons f ifr)))
               (t 
                 (spadlet found t))))))
@@ -4495,7 +4614,7 @@ displayFrameNames() ==
           (exit
            (setq tmp0
             (append tmp0 (cons '|%l| 
-              (cons (makestring "     ") (|bright| (|frameName| f))))))))))))
+              (cons (makestring "     ") (|bright| (frameName f))))))))))))
       (|sayKeyedMsg| 'S2IZ0024 (cons fs nil))))))) ; frame names are ...
 
 @
@@ -4551,7 +4670,7 @@ importFromFrame args ==
         (cond
          ((null (|member| fname (|frameNames|)))
            (|throwKeyedMsg| 'S2IZ0074 (cons fname nil))) ; not frame name
-         ((boot-equal fname (|frameName| (car |$interpreterFrameRing|)))
+         ((boot-equal fname (frameName (car |$interpreterFrameRing|)))
            (|throwKeyedMsg| 'S2IZ0075 NIL)) ; cannot import from curr frame
          (t
            (spadlet fenv (|frameEnvironment| fname))
@@ -5934,6 +6053,15 @@ load the file \verb|exposed.lsp| to set up the exposure group information.
 <<defun findFrameInRing>>
 <<defun frame>>
 <<defun frameEnvironment>>
+<<defun frameExposureData>>
+<<defun frameHiFiAccess>>
+<<defun frameHistList>>
+<<defun frameHistListAct>>
+<<defun frameHistListLen>>
+<<defun frameHistoryTable>>
+<<defun frameHistRecord>>
+<<defun frameInteractive>>
+<<defun frameIOIndex>>
 <<defun frameName>>
 <<defun frameNames>>
 <<defun frameSpad2Cmd>>
diff --git a/changelog b/changelog
index 1eb750a..416cdb6 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,18 @@
+20090212 tpd src/axiom-website/patches.html 20090220.01.tpd.patch
+20090220 tpd src/input/Makefile add dop.input, frame.input
+20090220 tpd src/input/frame.input regression test )frame
+20090220 tpd src/input/dop.input regression test )d op documentation
+20090220 tpd books/bookvol10.4 fix comments
+20090220 tpd books/bookvol5 fixup sayExample
+20090220 tpd books/bookvol5 fixup frameName
+20090220 tpd src/interp/i-map.boot.pamphlet fix frameName
+20090212 tpd src/axiom-website/patches.html 20090212.03.tpd.patch
+20090212 tpd readme add Zeilberger quote
+20090212 tpd src/interp/format.boot move sayExample, cleanupLine
+20090212 tpd books/bookvol5 move sayExample, cleanupLine
+20090212 tpd books/bookvol10.4 make rm forceful
+20090212 tpd books/bookvol10.3 make rm forceful
+20090212 tpd books/bookvol5 fixup restart
 20090212 tpd src/axiom-website/patches.html 20090212.02.tpd.patch
 20090212 tpd src/Makefile.pamphlet copy bookvol5
 20090212 tpd books/ps/v5restart.ps added
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 140c90c..93fa5c5 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -945,5 +945,9 @@ bookvol10.4 add exports<br/>
 remove unused code<br/>
 <a href="patches/20090212.02.tpd.patch">20090212.02.tpd.patch</a>
 rewrite restart<br/>
+<a href="patches/20090212.03.tpd.patch">20090212.03.tpd.patch</a>
+rewrite sayExample, frame<br/>
+<a href="patches/20090220.01.tpd.patch">20090220.01.tpd.patch</a>
+regression test )d op, )frame<br/>
  </body>
 </html>
diff --git a/src/input/Makefile.pamphlet b/src/input/Makefile.pamphlet
index b341753..eb8cbf6 100644
--- a/src/input/Makefile.pamphlet
+++ b/src/input/Makefile.pamphlet
@@ -294,7 +294,8 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     decimal.regress   defintef.regress defintrf.regress \
     derham.regress    dfloat.regress   dhmatrix.regress \
     dhtri.regress     directproduct.regress divisor.regress \
-    dmp.regress       dpol.regress     e1.regress       ei.regress \
+    dmp.regress       dop.regress      dpol.regress     \
+    e1.regress        ei.regress \
     easter.regress    efi.regress \
     eigen.regress     elemfun.regress  elemnum.regress  elfuts.regress \
     elt.regress       en.regress \
@@ -308,7 +309,8 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     fib.regress       file.regress     fixed.regress \
     float1.regress    float2.regress \
     float.regress     fname1.regress   fname.regress    fnla.regress \
-    fns.regress       fparfrac.regress fparfrc.regress  fr1.regress \
+    fns.regress       fparfrac.regress fparfrc.regress  \
+    frame.regress     fr1.regress \
     fr2.regress       frac.regress     fr.regress       free.regress \
     function.regress  galois.regress    gamma.regress \
     gbf.regress       genups.regress   gonshor.regress  grpthry.regress \
@@ -553,7 +555,8 @@ FILES= ${OUT}/algaggr.input  ${OUT}/algbrbf.input    ${OUT}/algfacob.input \
        ${OUT}/dfloat.input   ${OUT}/dhmatrix.input \
        ${OUT}/dhtri.input  ${OUT}/directproduct.input \
        ${OUT}/divisor.input \
-       ${OUT}/dmp.input      ${OUT}/dpol.input       ${OUT}/draw2dsf.input \
+       ${OUT}/dmp.input      ${OUT}/dop.input \
+       ${OUT}/dpol.input     ${OUT}/draw2dsf.input \
        ${OUT}/drawalg.input  ${OUT}/drawcfn.input \
        ${OUT}/drawcfun.input ${OUT}/drawcurv.input \
        ${OUT}/draw.input     ${OUT}/drawcx.input     ${OUT}/drawex.input \
@@ -577,7 +580,8 @@ FILES= ${OUT}/algaggr.input  ${OUT}/algbrbf.input    ${OUT}/algfacob.input \
        ${OUT}/fname1.input   ${OUT}/fnla.input       ${OUT}/folium.input   \
        ${OUT}/fparfrac.input \
        ${OUT}/fparfrc.input  ${OUT}/fr2.input        ${OUT}/frac.input \
-       ${OUT}/fr.input       ${OUT}/fr1.input        ${OUT}/gary1.input \
+       ${OUT}/fr.input       ${OUT}/frame.input \
+       ${OUT}/fr1.input      ${OUT}/gary1.input \
        ${OUT}/gbf.input      ${OUT}/genups.input     ${OUT}/gnarly1.input \
        ${OUT}/gonshor.input  ${OUT}/grdef.input    \
        ${OUT}/gstbl.input \
@@ -791,7 +795,7 @@ DOCFILES= \
   ${DOC}/dhtri.input.dvi      \
   ${DOC}/directproduct.input.dvi \
   ${DOC}/divisor.input.dvi     ${DOC}/dmp.input.dvi        \
-  ${DOC}/dpol.input.dvi        \
+  ${DOC}/dop.input.dvi         ${DOC}/dpol.input.dvi       \
   ${DOC}/draw2dsf.input.dvi    ${DOC}/drawalg.input.dvi    \
   ${DOC}/drawcfn.input.dvi     ${DOC}/drawcfun.input.dvi   \
   ${DOC}/drawcurv.input.dvi    ${DOC}/drawcx.input.dvi     \
@@ -863,6 +867,7 @@ DOCFILES= \
   ${DOC}/fname.input.dvi       ${DOC}/fnla.input.dvi       \
   ${DOC}/fns.input.dvi         ${DOC}/folium.input.dvi     \
   ${DOC}/fparfrac.input.dvi    ${DOC}/fparfrc.input.dvi    \
+  ${DOC}/frame.input.dvi \
   ${DOC}/fr1.input.dvi         ${DOC}/fr2.input.dvi        \
   ${DOC}/frac.input.dvi        ${DOC}/fr.input.dvi         \
   ${DOC}/free.input.dvi        \
diff --git a/src/input/dop.input.pamphlet b/src/input/dop.input.pamphlet
new file mode 100644
index 0000000..887f4bc
--- /dev/null
+++ b/src/input/dop.input.pamphlet
@@ -0,0 +1,6163 @@
+\documentclass{article}
+\usepackage{axiom}
+\begin{document}
+\title{\$SPAD/src/input dop.input}
+\author{Timothy Daly}
+\maketitle
+\begin{abstract}
+\end{abstract}
+\eject
+\tableofcontents
+\eject
+\section{License}
+<<license>>=
+--Copyright The Numerical Algorithms Group Limited 1991.
+@
+<<*>>=
+)spool dop.output
+)set message test on
+)set message auto off
+)clear all
+ 
+--S 1 of 127
+)d op binaryTree
+--R 
+--R
+--RThere are 2 exposed functions called binaryTree :
+--R   [1] (BinaryTree D1,D1,BinaryTree D1) -> BinaryTree D1 from 
+--R            BinaryTree D1
+--R            if D1 has SETCAT
+--R   [2] D1 -> BinaryTree D1 from BinaryTree D1 if D1 has SETCAT
+--R
+--RExamples of binaryTree from BinaryTree
+--R
+--Rt1:=binaryTree([1,2,3]) 
+--Rt2:=binaryTree([4,5,6]) 
+--RbinaryTree(t1,[7,8,9],t2)
+--R
+--Rt1:=binaryTree([1,2,3])
+--R
+--E 1
+
+--S 2 of 127
+)d op rationalPoint?
+--R 
+--R
+--RThere is one exposed function called rationalPoint? :
+--R   [1] (D2,D2) -> Boolean from D
+--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
+--R            D2 and D4 has UPOLYC FRAC D3
+--R
+--RThere is one unexposed function called rationalPoint? :
+--R   [1] (D2,D2) -> Boolean from FunctionFieldCategory&(D3,D2,D4,D5)
+--R            if D2 has UFD and D4 has UPOLYC D2 and D5 has UPOLYC FRAC 
+--R            D4 and D3 has FFCAT(D2,D4,D5)
+--R
+--RExamples of rationalPoint? from FunctionFieldCategory&
+--R
+--RP0 := UnivariatePolynomial(x, Integer) 
+--RP1 := UnivariatePolynomial(y, Fraction P0) 
+--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
+--RrationalPoint?(0,0)$R 
+--RR2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4) 
+--RrationalPoint?(0,0)$R2
+--R
+--R
+--RExamples of rationalPoint? from FunctionFieldCategory
+--R
+--RP0 := UnivariatePolynomial(x, Integer) 
+--RP1 := UnivariatePolynomial(y, Fraction P0) 
+--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
+--RrationalPoint?(0,0)$R 
+--RR2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4) 
+--RrationalPoint?(0,0)$R2
+--R
+--E 2
+
+--S 3 of 127
+--R)d op nthFactor
+--R 
+--R
+--RThere are 2 exposed functions called nthFactor :
+--R   [1] (D,Integer) -> D1 from D
+--R            if D has FAMONC(D1,D3) and D3 has CABMON and D1 has SETCAT
+--R            
+--R   [2] (Factored D1,Integer) -> D1 from Factored D1 if D1 has INTDOM
+--R         
+--R
+--RThere are 4 unexposed functions called nthFactor :
+--R   [1] (FreeGroup D1,Integer) -> D1 from FreeGroup D1 if D1 has SETCAT
+--R            
+--R   [2] (FreeMonoid D1,Integer) -> D1 from FreeMonoid D1 if D1 has 
+--R            SETCAT
+--R   [3] (ListMonoidOps(D1,D3,D4),Integer) -> D1 from ListMonoidOps(D1,D3
+--R            ,D4)
+--R            if D1 has SETCAT and D3 has ABELMON and D4: D3
+--R   [4] (OrderedFreeMonoid D1,Integer) -> D1 from OrderedFreeMonoid D1
+--R            if D1 has ORDSET
+--R
+--RExamples of nthFactor from FreeAbelianMonoidCategory
+--R
+--R
+--RExamples of nthFactor from FreeGroup
+--R
+--R
+--RExamples of nthFactor from FreeMonoid
+--R
+--R
+--RExamples of nthFactor from Factored
+--R
+--Ra:=factor 9720000 
+--RnthFactor(a,2)
+--R
+--R
+--RExamples of nthFactor from ListMonoidOps
+--R
+--R
+--RExamples of nthFactor from OrderedFreeMonoid
+--R
+--E 3
+
+--S 4 of 127
+--R)d op qsetelt!
+--R 
+--R
+--RThere are 2 exposed functions called qsetelt! :
+--R   [1] (D,Integer,Integer,D1) -> D1 from D
+--R            if D has ARR2CAT(D1,D3,D4) and D1 has TYPE and D3 has FLAGG
+--R            D1 and D4 has FLAGG D1
+--R   [2] (D,D2,D1) -> D1 from D
+--R            if D has shallowlyMutable and D has ELTAGG(D2,D1) and D2 
+--R            has SETCAT and D1 has TYPE
+--R
+--RExamples of qsetelt! from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,0) 
+--Rqsetelt!(arr,1,1,17)
+--R
+--R
+--RExamples of qsetelt! from EltableAggregate
+--R
+--E 4
+
+--S 5 of 127
+--R)d op cycleElt
+--R 
+--R
+--RThere is one unexposed function called cycleElt :
+--R   [1] D1 -> Union(D1,"failed") from CyclicStreamTools(D2,D1)
+--R            if D2 has TYPE and D1 has LZSTAGG D2
+--R
+--RExamples of cycleElt from CyclicStreamTools
+--R
+--Rp:=repeating([1,2,3]) 
+--Rq:=cons(4,p) 
+--RcycleElt q 
+--Rr:=[1,2,3]::Stream(Integer) 
+--RcycleElt r
+--R
+--E 5
+
+--S 6 of 127
+--R)d op cyclicEntries
+--R 
+--R
+--RThere is one exposed function called cyclicEntries :
+--R   [1] Tree D2 -> List Tree D2 from Tree D2 if D2 has SETCAT
+--R
+--RExamples of cyclicEntries from Tree
+--R
+--Rt1:=tree [1,2,3,4] 
+--RcyclicEntries t1
+--R
+--E 6
+
+--S 7 of 127
+--R)d op oneDimensionalArray
+--R 
+--R
+--RThere are 2 exposed functions called oneDimensionalArray :
+--R   [1] (NonNegativeInteger,D2) -> OneDimensionalArray D2
+--R            from OneDimensionalArray D2 if D2 has TYPE
+--R   [2] List D2 -> OneDimensionalArray D2 from OneDimensionalArray D2
+--R            if D2 has TYPE
+--R
+--RExamples of oneDimensionalArray from OneDimensionalArray
+--R
+--RoneDimensionalArray(10,0.0)
+--R
+--RoneDimensionalArray [i**2 for i in 1..10]
+--R
+--E 7
+
+--S 8 of 127
+--R)d op alphanumeric?
+--R 
+--R
+--RThere is one exposed function called alphanumeric? :
+--R   [1] Character -> Boolean from Character
+--R
+--RExamples of alphanumeric? from Character
+--R
+--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
+--R[alphanumeric? c for c in chars]
+--R
+--E 8
+
+--S 9 of 127
+--R)d op digit?
+--R 
+--R
+--RThere is one exposed function called digit? :
+--R   [1] Character -> Boolean from Character
+--R
+--RExamples of digit? from Character
+--R
+--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
+--R[digit? c for c in chars]
+--R
+--E 9
+
+--S 10 of 127
+--R)d op sqfrFactor
+--R 
+--R
+--RThere is one exposed function called sqfrFactor :
+--R   [1] (D1,Integer) -> Factored D1 from Factored D1 if D1 has INTDOM
+--R         
+--R
+--RExamples of sqfrFactor from Factored
+--R
+--Ra:=sqfrFactor(3,5) 
+--RnthFlag(a,1)
+--R
+--E 10
+
+--S 11 of 127
+--R)d op integralMatrix
+--R 
+--R
+--RThere is one exposed function called integralMatrix :
+--R   [1]  -> Matrix Fraction D3 from D
+--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
+--R            D2 and D4 has UPOLYC FRAC D3
+--R
+--RExamples of integralMatrix from FunctionFieldCategory
+--R
+--RP0 := UnivariatePolynomial(x, Integer) 
+--RP1 := UnivariatePolynomial(y, Fraction P0) 
+--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
+--RintegralMatrix()$R
+--R
+--E 11
+
+--S 12 of 127
+--R)d op ptree
+--R 
+--R
+--RThere are 2 exposed functions called ptree :
+--R   [1] (PendantTree D1,PendantTree D1) -> PendantTree D1 from 
+--R            PendantTree D1
+--R            if D1 has SETCAT
+--R   [2] D1 -> PendantTree D1 from PendantTree D1 if D1 has SETCAT
+--R
+--RExamples of ptree from PendantTree
+--R
+--Rt1:=ptree([1,2,3]) 
+--Rptree(t1,ptree([1,2,3]))
+--R
+--Rt1:=ptree([1,2,3])
+--R
+--E 12
+
+--S 13 of 127
+--R)d op insert!
+--R 
+--R
+--RThere are 8 exposed functions called insert! :
+--R   [1] (D1,D) -> D from D if D has BGAGG D1 and D1 has TYPE
+--R   [2] (D1,BinarySearchTree D1) -> BinarySearchTree D1
+--R            from BinarySearchTree D1 if D1 has ORDSET
+--R   [3] (D1,BinaryTournament D1) -> BinaryTournament D1
+--R            from BinaryTournament D1 if D1 has ORDSET
+--R   [4] (D,D,Integer) -> D from D if D has ELAGG D2 and D2 has TYPE
+--R   [5] (D1,D,Integer) -> D from D if D has ELAGG D1 and D1 has TYPE
+--R   [6] Record(key: Record(var: Symbol,fn: Expression DoubleFloat,range
+--R            : Segment OrderedCompletion DoubleFloat,abserr: DoubleFloat,
+--R            relerr: DoubleFloat),entry: Record(endPointContinuity: Union(
+--R            continuous: Continuous at the end points,lowerSingular: 
+--R            There is a singularity at the lower end point,upperSingular: 
+--R            There is a singularity at the upper end point,bothSingular: 
+--R            There are singularities at both end points,notEvaluated: 
+--R            End point continuity not yet evaluated),singularitiesStream: 
+--R            Union(str: Stream DoubleFloat,notEvaluated: 
+--R            Internal singularities not yet evaluated),range: Union(finite: 
+--R            The range is finite,lowerInfinite: 
+--R            The bottom of range is infinite,upperInfinite: 
+--R            The top of range is infinite,bothInfinite: 
+--R            Both top and bottom points are infinite,notEvaluated: 
+--R            Range not yet evaluated))) -> IntegrationFunctionsTable
+--R            from IntegrationFunctionsTable
+--R   [7] (D1,D,NonNegativeInteger) -> D from D
+--R            if D has MDAGG D1 and D1 has SETCAT
+--R   [8] Record(key: Record(xinit: DoubleFloat,xend: DoubleFloat,fn: 
+--R            Vector Expression DoubleFloat,yinit: List DoubleFloat,intvals: 
+--R            List DoubleFloat,g: Expression DoubleFloat,abserr: DoubleFloat,
+--R            relerr: DoubleFloat),entry: Record(stiffness: Float,stability: 
+--R            Float,expense: Float,accuracy: Float,intermediateResults: Float))
+--R             -> ODEIntensityFunctionsTable
+--R            from ODEIntensityFunctionsTable
+--R
+--RThere is one unexposed function called insert! :
+--R   [1] (D2,D3) -> Void from TabulatedComputationPackage(D2,D3)
+--R            if D2 has SETCAT and D3 has SETCAT
+--R
+--RExamples of insert! from BagAggregate
+--R
+--R
+--RExamples of insert! from BinarySearchTree
+--R
+--Rt1:=binarySearchTree [1,2,3,4] 
+--Rinsert!(5,t1)
+--R
+--R
+--RExamples of insert! from BinaryTournament
+--R
+--Rt1:=binaryTournament [1,2,3,4] 
+--Rinsert!(5,t1) 
+--Rt1
+--R
+--R
+--RExamples of insert! from ExtensibleLinearAggregate
+--R
+--R
+--RExamples of insert! from IntegrationFunctionsTable
+--R
+--R
+--RExamples of insert! from MultiDictionary
+--R
+--R
+--RExamples of insert! from ODEIntensityFunctionsTable
+--R
+--R
+--RExamples of insert! from TabulatedComputationPackage
+--R
+--E 13
+
+--S 14 of 127
+--R)d op genus
+--R 
+--R
+--RThere is one exposed function called genus :
+--R   [1]  -> NonNegativeInteger from D
+--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
+--R            D2 and D4 has UPOLYC FRAC D3
+--R
+--RThere is one unexposed function called genus :
+--R   [1]  -> NonNegativeInteger from FunctionFieldCategory&(D2,D3,D4,D5)
+--R            if D3 has UFD and D4 has UPOLYC D3 and D5 has UPOLYC FRAC 
+--R            D4 and D2 has FFCAT(D3,D4,D5)
+--R
+--RExamples of genus from FunctionFieldCategory&
+--R
+--RP0 := UnivariatePolynomial(x, Integer) 
+--RP1 := UnivariatePolynomial(y, Fraction P0) 
+--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
+--Rgenus()$R
+--R
+--R
+--RExamples of genus from FunctionFieldCategory
+--R
+--RP0 := UnivariatePolynomial(x, Integer) 
+--RP1 := UnivariatePolynomial(y, Fraction P0) 
+--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
+--Rgenus()$R
+--R
+--E 14
+
+--S 15 of 127
+--R)d op hexDigit?
+--R 
+--R
+--RThere is one exposed function called hexDigit? :
+--R   [1] Character -> Boolean from Character
+--R
+--RExamples of hexDigit? from Character
+--R
+--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
+--R[hexDigit? c for c in chars]
+--R
+--E 15
+
+--S 16 of 127
+--R)d op computeCycleLength
+--R 
+--R
+--RThere is one unexposed function called computeCycleLength :
+--R   [1] D2 -> NonNegativeInteger from CyclicStreamTools(D3,D2)
+--R            if D3 has TYPE and D2 has LZSTAGG D3
+--R
+--RExamples of computeCycleLength from CyclicStreamTools
+--R
+--Rp:=repeating([1,2,3]) 
+--Rq:=cons(4,p) 
+--RcomputeCycleLength(cycleElt(q))
+--R
+--E 16
+
+--S 17 of 127
+--R)d op findCycle
+--R 
+--R
+--RThere is one exposed function called findCycle :
+--R   [1] (NonNegativeInteger,Stream D3) -> Record(cycle?: Boolean,prefix
+--R            : NonNegativeInteger,period: NonNegativeInteger)
+--R            from Stream D3 if D3 has TYPE
+--R
+--RExamples of findCycle from Stream
+--R
+--Rm:=[1,2,3] 
+--Rn:=repeating(m) 
+--RfindCycle(3,n) 
+--RfindCycle(2,n)
+--R
+--E 17
+
+--S 18 of 127
+--R)d op draw
+--R 
+--R
+--RThere are 31 exposed functions called draw :
+--R   [1] ((DoubleFloat -> DoubleFloat),Segment Float,List DrawOption) -> 
+--R            TwoDimensionalViewport
+--R            from TopLevelDrawFunctionsForCompiledFunctions
+--R   [2] ((DoubleFloat -> DoubleFloat),Segment Float) -> 
+--R            TwoDimensionalViewport
+--R            from TopLevelDrawFunctionsForCompiledFunctions
+--R   [3] (ParametricPlaneCurve (DoubleFloat -> DoubleFloat),Segment Float
+--R            ,List DrawOption) -> TwoDimensionalViewport
+--R            from TopLevelDrawFunctionsForCompiledFunctions
+--R   [4] (ParametricPlaneCurve (DoubleFloat -> DoubleFloat),Segment Float
+--R            ) -> TwoDimensionalViewport
+--R            from TopLevelDrawFunctionsForCompiledFunctions
+--R   [5] (ParametricSpaceCurve (DoubleFloat -> DoubleFloat),Segment Float
+--R            ,List DrawOption) -> ThreeDimensionalViewport
+--R            from TopLevelDrawFunctionsForCompiledFunctions
+--R   [6] (ParametricSpaceCurve (DoubleFloat -> DoubleFloat),Segment Float
+--R            ) -> ThreeDimensionalViewport
+--R            from TopLevelDrawFunctionsForCompiledFunctions
+--R   [7] ((DoubleFloat -> Point DoubleFloat),Segment Float,List 
+--R            DrawOption) -> ThreeDimensionalViewport
+--R            from TopLevelDrawFunctionsForCompiledFunctions
+--R   [8] ((DoubleFloat -> Point DoubleFloat),Segment Float) -> 
+--R            ThreeDimensionalViewport
+--R            from TopLevelDrawFunctionsForCompiledFunctions
+--R   [9] (((DoubleFloat,DoubleFloat) -> DoubleFloat),Segment Float,
+--R            Segment Float,List DrawOption) -> ThreeDimensionalViewport
+--R            from TopLevelDrawFunctionsForCompiledFunctions
+--R   [10] (((DoubleFloat,DoubleFloat) -> DoubleFloat),Segment Float,
+--R            Segment Float) -> ThreeDimensionalViewport
+--R            from TopLevelDrawFunctionsForCompiledFunctions
+--R   [11] (((DoubleFloat,DoubleFloat) -> Point DoubleFloat),Segment Float
+--R            ,Segment Float,List DrawOption) -> ThreeDimensionalViewport
+--R            from TopLevelDrawFunctionsForCompiledFunctions
+--R   [12] (((DoubleFloat,DoubleFloat) -> Point DoubleFloat),Segment Float
+--R            ,Segment Float) -> ThreeDimensionalViewport
+--R            from TopLevelDrawFunctionsForCompiledFunctions
+--R   [13] (ParametricSurface ((DoubleFloat,DoubleFloat) -> DoubleFloat),
+--R            Segment Float,Segment Float,List DrawOption) -> 
+--R            ThreeDimensionalViewport
+--R            from TopLevelDrawFunctionsForCompiledFunctions
+--R   [14] (ParametricSurface ((DoubleFloat,DoubleFloat) -> DoubleFloat),
+--R            Segment Float,Segment Float) -> ThreeDimensionalViewport
+--R            from TopLevelDrawFunctionsForCompiledFunctions
+--R   [15] (Equation D6,Symbol,Symbol,List DrawOption) -> 
+--R            TwoDimensionalViewport
+--R            from TopLevelDrawFunctionsForAlgebraicCurves(D5,D6)
+--R            if D6 has FS D5 and D5 has Join(IntegralDomain,OrderedSet,
+--R            RetractableTo Integer)
+--R   [16] (D2,SegmentBinding Float,List DrawOption) -> 
+--R            TwoDimensionalViewport
+--R            from TopLevelDrawFunctions D2
+--R            if D2 has Join(ConvertibleTo InputForm,SetCategory)
+--R   [17] (D2,SegmentBinding Float) -> TwoDimensionalViewport
+--R            from TopLevelDrawFunctions D2
+--R            if D2 has Join(ConvertibleTo InputForm,SetCategory)
+--R   [18] (ParametricPlaneCurve D5,SegmentBinding Float,List DrawOption)
+--R             -> TwoDimensionalViewport
+--R            from TopLevelDrawFunctions D5
+--R            if D5 has Join(ConvertibleTo InputForm,SetCategory)
+--R   [19] (ParametricPlaneCurve D4,SegmentBinding Float) -> 
+--R            TwoDimensionalViewport
+--R            from TopLevelDrawFunctions D4
+--R            if D4 has Join(ConvertibleTo InputForm,SetCategory)
+--R   [20] (ParametricSpaceCurve D5,SegmentBinding Float,List DrawOption)
+--R             -> ThreeDimensionalViewport
+--R            from TopLevelDrawFunctions D5
+--R            if D5 has Join(ConvertibleTo InputForm,SetCategory)
+--R   [21] (ParametricSpaceCurve D4,SegmentBinding Float) -> 
+--R            ThreeDimensionalViewport
+--R            from TopLevelDrawFunctions D4
+--R            if D4 has Join(ConvertibleTo InputForm,SetCategory)
+--R   [22] (D2,SegmentBinding Float,SegmentBinding Float,List DrawOption)
+--R             -> ThreeDimensionalViewport
+--R            from TopLevelDrawFunctions D2
+--R            if D2 has Join(ConvertibleTo InputForm,SetCategory)
+--R   [23] (D2,SegmentBinding Float,SegmentBinding Float) -> 
+--R            ThreeDimensionalViewport
+--R            from TopLevelDrawFunctions D2
+--R            if D2 has Join(ConvertibleTo InputForm,SetCategory)
+--R   [24] (ParametricSurface D5,SegmentBinding Float,SegmentBinding Float
+--R            ,List DrawOption) -> ThreeDimensionalViewport
+--R            from TopLevelDrawFunctions D5
+--R            if D5 has Join(ConvertibleTo InputForm,SetCategory)
+--R   [25] (ParametricSurface D4,SegmentBinding Float,SegmentBinding Float
+--R            ) -> ThreeDimensionalViewport
+--R            from TopLevelDrawFunctions D4
+--R            if D4 has Join(ConvertibleTo InputForm,SetCategory)
+--R   [26] (List DoubleFloat,List DoubleFloat) -> TwoDimensionalViewport
+--R            from TopLevelDrawFunctionsForPoints
+--R   [27] (List DoubleFloat,List DoubleFloat,List DrawOption) -> 
+--R            TwoDimensionalViewport
+--R            from TopLevelDrawFunctionsForPoints
+--R   [28] List Point DoubleFloat -> TwoDimensionalViewport
+--R            from TopLevelDrawFunctionsForPoints
+--R   [29] (List Point DoubleFloat,List DrawOption) -> 
+--R            TwoDimensionalViewport
+--R            from TopLevelDrawFunctionsForPoints
+--R   [30] (List DoubleFloat,List DoubleFloat,List DoubleFloat) -> 
+--R            ThreeDimensionalViewport
+--R            from TopLevelDrawFunctionsForPoints
+--R   [31] (List DoubleFloat,List DoubleFloat,List DoubleFloat,List 
+--R            DrawOption) -> ThreeDimensionalViewport
+--R            from TopLevelDrawFunctionsForPoints
+--R
+--RExamples of draw from TopLevelDrawFunctionsForCompiledFunctions
+--R
+--R
+--RExamples of draw from TopLevelDrawFunctionsForAlgebraicCurves
+--R
+--R
+--RExamples of draw from TopLevelDrawFunctions
+--R
+--R
+--RExamples of draw from TopLevelDrawFunctionsForPoints
+--R
+--E 18
+
+--S 19 of 127
+--R)d op repeating
+--R 
+--R
+--RThere is one exposed function called repeating :
+--R   [1] List D2 -> Stream D2 from Stream D2 if D2 has TYPE
+--R
+--RExamples of repeating from Stream
+--R
+--Rm:=repeating([-1,0,1,2,3])
+--R
+--E 19
+
+--S 20 of 127
+--R)d op cons
+--R 
+--R
+--RThere are 2 exposed functions called cons :
+--R   [1] (D1,List D1) -> List D1 from List D1 if D1 has TYPE
+--R   [2] (D1,Stream D1) -> Stream D1 from Stream D1 if D1 has TYPE
+--R
+--RExamples of cons from List
+--R
+--R
+--RExamples of cons from Stream
+--R
+--Rm:=[1,2,3] 
+--Rn:=repeating(m) 
+--Rcons(4,n)
+--R
+--E 20
+
+--S 21 of 127
+--R)d op map
+--R 
+--R
+--RThere are 80 exposed functions called map :
+--R   [1] ((D2 -> D2),D) -> D from D
+--R            if D has AMR(D2,D3) and D2 has RING and D3 has OAMON
+--R   [2] (((D2,D2) -> D2),D,D,D2) -> D from D
+--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
+--R            D2 and D4 has FLAGG D2
+--R   [3] (((D2,D2) -> D2),D,D) -> D from D
+--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
+--R            D2 and D4 has FLAGG D2
+--R   [4] ((D2 -> D2),D) -> D from D
+--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
+--R            D2 and D4 has FLAGG D2
+--R   [5] ((D4 -> D5),OneDimensionalArray D4) -> OneDimensionalArray D5
+--R            from OneDimensionalArrayFunctions2(D4,D5)
+--R            if D4 has TYPE and D5 has TYPE
+--R   [6] ((D6 -> D7),CartesianTensor(D4,D5,D6)) -> CartesianTensor(D4,D5,
+--R            D7)
+--R            from CartesianTensorFunctions2(D4,D5,D6,D7)
+--R            if D4: INT and D5: NNI and D6 has COMRING and D7 has 
+--R            COMRING
+--R   [7] ((D4 -> D5),Complex D4) -> Complex D5 from ComplexFunctions2(D4,
+--R            D5)
+--R            if D4 has COMRING and D5 has COMRING
+--R   [8] ((D5 -> D6),DirectProduct(D4,D5)) -> DirectProduct(D4,D6)
+--R            from DirectProductFunctions2(D4,D5,D6)
+--R            if D4: NNI and D5 has TYPE and D6 has TYPE
+--R   [9] ((D4 -> D5),Equation D4) -> Equation D5 from EquationFunctions2(
+--R            D4,D5)
+--R            if D4 has TYPE and D5 has TYPE
+--R   [10] ((D2 -> D2),Equation D2) -> Equation D2 from Equation D2 if D2 
+--R            has TYPE
+--R   [11] ((D4 -> D1),Kernel D4) -> D1 from ExpressionSpaceFunctions2(D4,
+--R            D1)
+--R            if D4 has ES and D1 has ES
+--R   [12] ((D -> D),Kernel D) -> D from D if D has ES
+--R   [13] ((D4 -> D5),Matrix D4) -> Matrix D5
+--R            from ExpertSystemToolsPackage2(D4,D5)
+--R            if D4 has RING and D5 has RING
+--R   [14] ((D4 -> D5),Expression D4) -> Expression D5
+--R            from ExpressionFunctions2(D4,D5)
+--R            if D4 has ORDSET and D5 has ORDSET
+--R   [15] ((D7 -> D11),FiniteDivisor(D7,D8,D9,D10)) -> FiniteDivisor(D11,
+--R            D1,D2,D3)
+--R            from FiniteDivisorFunctions2(D7,D8,D9,D10,D11,D1,D2,D3)
+--R            if D7 has FIELD and D8 has UPOLYC D7 and D9 has UPOLYC FRAC
+--R            D8 and D10 has FFCAT(D7,D8,D9) and D11 has FIELD and D1 has
+--R            UPOLYC D11 and D2 has UPOLYC FRAC D1 and D3 has FFCAT(D11,
+--R            D1,D2)
+--R   [16] ((D2 -> D2),D) -> D from D if D has FEVALAB D2 and D2 has 
+--R            SETCAT
+--R   [17] ((D5 -> D8),D4) -> D2
+--R            from FunctionFieldCategoryFunctions2(D5,D6,D7,D4,D8,D9,D1,
+--R            D2)
+--R            if D5 has UFD and D8 has UFD and D6 has UPOLYC D5 and D7 
+--R            has UPOLYC FRAC D6 and D9 has UPOLYC D8 and D2 has FFCAT(D8
+--R            ,D9,D1) and D4 has FFCAT(D5,D6,D7) and D1 has UPOLYC FRAC 
+--R            D9
+--R   [18] ((D4 -> D5),D3) -> D1 from FiniteLinearAggregateFunctions2(D4,
+--R            D3,D5,D1)
+--R            if D4 has TYPE and D5 has TYPE and D1 has FLAGG D5 and D3 
+--R            has FLAGG D4
+--R   [19] ((D2 -> D2),D) -> D from D
+--R            if D has FMCAT(D2,D3) and D2 has RING and D3 has SETCAT
+--R   [20] ((D4 -> D5),Factored D4) -> Factored D5 from FactoredFunctions2
+--R            (D4,D5)
+--R            if D4 has INTDOM and D5 has INTDOM
+--R   [21] ((D4 -> D5),Fraction D4) -> Fraction D5 from FractionFunctions2
+--R            (D4,D5)
+--R            if D4 has INTDOM and D5 has INTDOM
+--R   [22] ((D7 -> D11),FractionalIdeal(D7,D8,D9,D10)) -> FractionalIdeal(
+--R            D11,D1,D2,D3)
+--R            from FractionalIdealFunctions2(D7,D8,D9,D10,D11,D1,D2,D3)
+--R            if D7 has EUCDOM and D8 has QFCAT D7 and D9 has UPOLYC D8 
+--R            and D10 has Join(FramedAlgebra(D8,D9),RetractableTo D8) and
+--R            D11 has EUCDOM and D1 has QFCAT D11 and D2 has UPOLYC D1 
+--R            and D3 has Join(FramedAlgebra(D1,D2),RetractableTo D1)
+--R   [23] ((D4 -> D5),D3) -> D1
+--R            from FramedNonAssociativeAlgebraFunctions2(D3,D4,D1,D5)
+--R            if D4 has COMRING and D5 has COMRING and D1 has FRNAALG D5 
+--R            and D3 has FRNAALG D4
+--R   [24] ((D2 -> D2),Factored D2) -> Factored D2 from Factored D2
+--R            if D2 has INTDOM
+--R   [25] ((D4 -> D5),D3) -> D1 from FunctionSpaceFunctions2(D4,D3,D5,D1)
+--R            if D4 has Join(Ring,OrderedSet) and D5 has Join(Ring,
+--R            OrderedSet) and D1 has FS D5 and D3 has FS D4
+--R   [26] ((D4 -> D5),D3) -> D1 from FiniteSetAggregateFunctions2(D4,D3,
+--R            D5,D1)
+--R            if D4 has SETCAT and D5 has SETCAT and D1 has FSAGG D5 and 
+--R            D3 has FSAGG D4
+--R   [27] ((D2 -> D2),D) -> D from D if D has HOAGG D2 and D2 has TYPE
+--R         
+--R   [28] ((D2 -> D2),D) -> D from D
+--R            if D has IDPC(D2,D3) and D2 has SETCAT and D3 has ORDSET
+--R         
+--R   [29] ((D4 -> D5),IntegrationResult D4) -> IntegrationResult D5
+--R            from IntegrationResultFunctions2(D4,D5)
+--R            if D4 has FIELD and D5 has FIELD
+--R   [30] ((D4 -> D5),Union(Record(ratpart: D4,coeff: D4),"failed")) -> 
+--R            Union(Record(ratpart: D5,coeff: D5),"failed")
+--R            from IntegrationResultFunctions2(D4,D5)
+--R            if D4 has FIELD and D5 has FIELD
+--R   [31] ((D4 -> D1),Union(D4,"failed")) -> Union(D1,"failed")
+--R            from IntegrationResultFunctions2(D4,D1)
+--R            if D4 has FIELD and D1 has FIELD
+--R   [32] ((D4 -> D5),Union(Record(mainpart: D4,limitedlogs: List Record(
+--R            coeff: D4,logand: D4)),"failed")) -> Union(Record(mainpart: D5,
+--R            limitedlogs: List Record(coeff: D5,logand: D5)),"failed")
+--R            from IntegrationResultFunctions2(D4,D5)
+--R            if D4 has FIELD and D5 has FIELD
+--R   [33] ((D4 -> D5),InfiniteTuple D4) -> InfiniteTuple D5
+--R            from InfiniteTupleFunctions2(D4,D5)
+--R            if D4 has TYPE and D5 has TYPE
+--R   [34] (((D5,D6) -> D7),InfiniteTuple D5,InfiniteTuple D6) -> 
+--R            InfiniteTuple D7
+--R            from InfiniteTupleFunctions3(D5,D6,D7)
+--R            if D5 has TYPE and D6 has TYPE and D7 has TYPE
+--R   [35] (((D5,D6) -> D7),Stream D5,InfiniteTuple D6) -> Stream D7
+--R            from InfiniteTupleFunctions3(D5,D6,D7)
+--R            if D5 has TYPE and D6 has TYPE and D7 has TYPE
+--R   [36] (((D5,D6) -> D7),InfiniteTuple D5,Stream D6) -> Stream D7
+--R            from InfiniteTupleFunctions3(D5,D6,D7)
+--R            if D5 has TYPE and D6 has TYPE and D7 has TYPE
+--R   [37] ((D2 -> D2),InfiniteTuple D2) -> InfiniteTuple D2 from 
+--R            InfiniteTuple D2
+--R            if D2 has TYPE
+--R   [38] ((D4 -> D5),List D4) -> List D5 from ListFunctions2(D4,D5)
+--R            if D4 has TYPE and D5 has TYPE
+--R   [39] (((D5,D6) -> D7),List D5,List D6) -> List D7
+--R            from ListFunctions3(D5,D6,D7)
+--R            if D5 has TYPE and D6 has TYPE and D7 has TYPE
+--R   [40] (((D2,D2) -> D2),D,D) -> D from D if D has LNAGG D2 and D2 has 
+--R            TYPE
+--R   [41] ((D5 -> D8),D4) -> D2
+--R            from MatrixCategoryFunctions2(D5,D6,D7,D4,D8,D9,D1,D2)
+--R            if D5 has RING and D8 has RING and D6 has FLAGG D5 and D7 
+--R            has FLAGG D5 and D2 has MATCAT(D8,D9,D1) and D4 has MATCAT(
+--R            D5,D6,D7) and D9 has FLAGG D8 and D1 has FLAGG D8
+--R   [42] ((D5 -> Union(D8,"failed")),D4) -> Union(D2,"failed")
+--R            from MatrixCategoryFunctions2(D5,D6,D7,D4,D8,D9,D1,D2)
+--R            if D5 has RING and D8 has RING and D6 has FLAGG D5 and D7 
+--R            has FLAGG D5 and D2 has MATCAT(D8,D9,D1) and D4 has MATCAT(
+--R            D5,D6,D7) and D9 has FLAGG D8 and D1 has FLAGG D8
+--R   [43] ((D7 -> D8),D3) -> D1 from MPolyCatFunctions2(D4,D5,D6,D7,D8,D3
+--R            ,D1)
+--R            if D7 has RING and D8 has RING and D4 has ORDSET and D5 has
+--R            OAMONS and D1 has POLYCAT(D8,D6,D4) and D6 has OAMONS and 
+--R            D3 has POLYCAT(D7,D5,D4)
+--R   [44] ((D4 -> D5),MonoidRing(D4,D6)) -> MonoidRing(D5,D6)
+--R            from MonoidRingFunctions2(D4,D5,D6)
+--R            if D4 has RING and D5 has RING and D6 has MONOID
+--R   [45] ((D4 -> D5),D3) -> D1 from OctonionCategoryFunctions2(D3,D4,D1,
+--R            D5)
+--R            if D4 has COMRING and D5 has COMRING and D1 has OC D5 and 
+--R            D3 has OC D4
+--R   [46] ((D4 -> D5),OnePointCompletion D4) -> OnePointCompletion D5
+--R            from OnePointCompletionFunctions2(D4,D5)
+--R            if D4 has SETCAT and D5 has SETCAT
+--R   [47] ((D4 -> D5),OnePointCompletion D4,OnePointCompletion D5) -> 
+--R            OnePointCompletion D5
+--R            from OnePointCompletionFunctions2(D4,D5)
+--R            if D4 has SETCAT and D5 has SETCAT
+--R   [48] ((D4 -> D5),OrderedCompletion D4) -> OrderedCompletion D5
+--R            from OrderedCompletionFunctions2(D4,D5)
+--R            if D4 has SETCAT and D5 has SETCAT
+--R   [49] ((D4 -> D5),OrderedCompletion D4,OrderedCompletion D5,
+--R            OrderedCompletion D5) -> OrderedCompletion D5
+--R            from OrderedCompletionFunctions2(D4,D5)
+--R            if D4 has SETCAT and D5 has SETCAT
+--R   [50] ((D4 -> D5),ParametricPlaneCurve D4) -> ParametricPlaneCurve D5
+--R            from ParametricPlaneCurveFunctions2(D4,D5)
+--R            if D4 has TYPE and D5 has TYPE
+--R   [51] ((D4 -> D5),ParametricSpaceCurve D4) -> ParametricSpaceCurve D5
+--R            from ParametricSpaceCurveFunctions2(D4,D5)
+--R            if D4 has TYPE and D5 has TYPE
+--R   [52] ((D4 -> D5),ParametricSurface D4) -> ParametricSurface D5
+--R            from ParametricSurfaceFunctions2(D4,D5)
+--R            if D4 has TYPE and D5 has TYPE
+--R   [53] ((D5 -> D6),PatternMatchResult(D4,D5)) -> PatternMatchResult(D4
+--R            ,D6)
+--R            from PatternMatchResultFunctions2(D4,D5,D6)
+--R            if D4 has SETCAT and D5 has SETCAT and D6 has SETCAT
+--R   [54] ((D4 -> D5),Pattern D4) -> Pattern D5 from PatternFunctions2(D4
+--R            ,D5)
+--R            if D4 has SETCAT and D5 has SETCAT
+--R   [55] ((D4 -> D5),Polynomial D4) -> Polynomial D5
+--R            from PolynomialFunctions2(D4,D5)
+--R            if D4 has RING and D5 has RING
+--R   [56] ((D4 -> D5),PrimitiveArray D4) -> PrimitiveArray D5
+--R            from PrimitiveArrayFunctions2(D4,D5)
+--R            if D4 has TYPE and D5 has TYPE
+--R   [57] ((D4 -> D5),Point D4) -> Point D5 from PointFunctions2(D4,D5)
+--R            if D4 has RING and D5 has RING
+--R   [58] ((D4 -> D5),D3) -> D1 from QuotientFieldCategoryFunctions2(D4,
+--R            D5,D3,D1)
+--R            if D4 has INTDOM and D5 has INTDOM and D1 has QFCAT D5 and 
+--R            D3 has QFCAT D4
+--R   [59] ((D4 -> D5),D3) -> D1 from QuaternionCategoryFunctions2(D3,D4,
+--R            D1,D5)
+--R            if D4 has COMRING and D5 has COMRING and D1 has QUATCAT D5 
+--R            and D3 has QUATCAT D4
+--R   [60] (((D4,D4) -> D4),D,D) -> D from D
+--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
+--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
+--R   [61] ((D4 -> D4),D) -> D from D
+--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
+--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
+--R   [62] ((D9 -> D1),D6) -> D4
+--R            from RectangularMatrixCategoryFunctions2(D7,D8,D9,D10,D11,
+--R            D6,D1,D2,D3,D4)
+--R            if D9 has RING and D1 has RING and D7: NNI and D8: NNI and 
+--R            D10 has DIRPCAT(D8,D9) and D11 has DIRPCAT(D7,D9) and D4 
+--R            has RMATCAT(D7,D8,D1,D2,D3) and D6 has RMATCAT(D7,D8,D9,D10
+--R            ,D11) and D2 has DIRPCAT(D8,D1) and D3 has DIRPCAT(D7,D1)
+--R         
+--R   [63] ((D4 -> D5),Segment D4) -> Segment D5 from SegmentFunctions2(D4
+--R            ,D5)
+--R            if D4 has TYPE and D5 has TYPE
+--R   [64] ((D4 -> D5),Segment D4) -> List D5 from SegmentFunctions2(D4,D5
+--R            )
+--R            if D4 has ORDRING and D4 has TYPE and D5 has TYPE
+--R   [65] ((D4 -> D5),SegmentBinding D4) -> SegmentBinding D5
+--R            from SegmentBindingFunctions2(D4,D5)
+--R            if D4 has TYPE and D5 has TYPE
+--R   [66] ((D3 -> D3),D) -> D1 from D
+--R            if D has SEGXCAT(D3,D1) and D3 has ORDRING and D1 has STAGG
+--R            D3
+--R   [67] ((D4 -> D5),Stream D4) -> Stream D5 from StreamFunctions2(D4,D5
+--R            )
+--R            if D4 has TYPE and D5 has TYPE
+--R   [68] (((D5,D6) -> D7),Stream D5,Stream D6) -> Stream D7
+--R            from StreamFunctions3(D5,D6,D7)
+--R            if D5 has TYPE and D6 has TYPE and D7 has TYPE
+--R   [69] ((D4 -> D5),SparseUnivariatePolynomial D4) -> 
+--R            SparseUnivariatePolynomial D5
+--R            from SparseUnivariatePolynomialFunctions2(D4,D5)
+--R            if D4 has RING and D5 has RING
+--R   [70] (((D3,D3) -> D3),D,D) -> D from D
+--R            if D has TBAGG(D2,D3) and D2 has SETCAT and D3 has SETCAT
+--R         
+--R   [71] ((D5 -> D6),UnivariateLaurentSeries(D5,D7,D9)) -> 
+--R            UnivariateLaurentSeries(D6,D8,D1)
+--R            from UnivariateLaurentSeriesFunctions2(D5,D6,D7,D8,D9,D1)
+--R            if D5 has RING and D6 has RING and D7: SYMBOL and D9: D5 
+--R            and D1: D6 and D8: SYMBOL
+--R   [72] ((D4 -> D5),UniversalSegment D4) -> UniversalSegment D5
+--R            from UniversalSegmentFunctions2(D4,D5)
+--R            if D4 has TYPE and D5 has TYPE
+--R   [73] ((D4 -> D5),UniversalSegment D4) -> Stream D5
+--R            from UniversalSegmentFunctions2(D4,D5)
+--R            if D4 has ORDRING and D4 has TYPE and D5 has TYPE
+--R   [74] ((D5 -> D7),UnivariatePolynomial(D4,D5)) -> 
+--R            UnivariatePolynomial(D6,D7)
+--R            from UnivariatePolynomialFunctions2(D4,D5,D6,D7)
+--R            if D4: SYMBOL and D5 has RING and D7 has RING and D6: 
+--R            SYMBOL
+--R   [75] ((D4 -> D5),D3) -> D1
+--R            from UnivariatePolynomialCategoryFunctions2(D4,D3,D5,D1)
+--R            if D4 has RING and D5 has RING and D1 has UPOLYC D5 and D3 
+--R            has UPOLYC D4
+--R   [76] ((D5 -> D6),UnivariatePuiseuxSeries(D5,D7,D9)) -> 
+--R            UnivariatePuiseuxSeries(D6,D8,D1)
+--R            from UnivariatePuiseuxSeriesFunctions2(D5,D6,D7,D8,D9,D1)
+--R            if D5 has RING and D6 has RING and D7: SYMBOL and D9: D5 
+--R            and D1: D6 and D8: SYMBOL
+--R   [77] ((D4 -> D5),D3) -> D1
+--R            from UnivariateTaylorSeriesFunctions2(D4,D5,D3,D1)
+--R            if D4 has RING and D5 has RING and D1 has UTSCAT D5 and D3 
+--R            has UTSCAT D4
+--R   [78] ((D4 -> D5),Vector D4) -> Vector D5 from VectorFunctions2(D4,D5
+--R            )
+--R            if D4 has TYPE and D5 has TYPE
+--R   [79] ((D4 -> Union(D5,"failed")),Vector D4) -> Union(Vector D5,
+--R            "failed")
+--R            from VectorFunctions2(D4,D5) if D4 has TYPE and D5 has TYPE
+--R            
+--R   [80] ((D3 -> D3),D) -> D from D
+--R            if D has XFALG(D2,D3) and D2 has ORDSET and D3 has RING
+--R
+--RThere are 11 unexposed functions called map :
+--R   [1] ((D2 -> D2),AntiSymm(D2,D3)) -> AntiSymm(D2,D3) from AntiSymm(D2
+--R            ,D3)
+--R            if D2 has RING and D3: LIST SYMBOL
+--R   [2] ((Expression D2 -> Expression D2),DeRhamComplex(D2,D3)) -> 
+--R            DeRhamComplex(D2,D3)
+--R            from DeRhamComplex(D2,D3)
+--R            if D2 has Join(Ring,OrderedSet) and D3: LIST SYMBOL
+--R   [3] ((D5 -> D1),String,Kernel D5) -> D1
+--R            from ExpressionSpaceFunctions1(D5,D1)
+--R            if D5 has ES and D1 has TYPE
+--R   [4] ((D5 -> D6),D3) -> D1
+--R            from FiniteAbelianMonoidRingFunctions2(D4,D5,D3,D6,D1)
+--R            if D5 has RING and D6 has RING and D4 has OAMON and D1 has 
+--R            FAMR(D6,D4) and D3 has FAMR(D5,D4)
+--R   [5] ((D4 -> D6),D3) -> D1 from MultipleMap(D4,D5,D3,D6,D7,D1)
+--R            if D4 has INTDOM and D6 has INTDOM and D5 has UPOLYC D4 and
+--R            D1 has UPOLYC FRAC D7 and D3 has UPOLYC FRAC D5 and D7 has 
+--R            UPOLYC D6
+--R   [6] ((D4 -> D5),D3) -> D1 from MPolyCatFunctions3(D4,D5,D6,D7,D8,D3,
+--R            D1)
+--R            if D4 has ORDSET and D5 has ORDSET and D6 has OAMONS and D8
+--R            has RING and D1 has POLYCAT(D8,D7,D5) and D7 has OAMONS and
+--R            D3 has POLYCAT(D8,D6,D4)
+--R   [7] ((D2 -> D2),MonoidRing(D2,D3)) -> MonoidRing(D2,D3)
+--R            from MonoidRing(D2,D3) if D2 has RING and D3 has MONOID
+--R   [8] ((D4 -> D5),NewSparseUnivariatePolynomial D4) -> 
+--R            NewSparseUnivariatePolynomial D5
+--R            from NewSparseUnivariatePolynomialFunctions2(D4,D5)
+--R            if D4 has RING and D5 has RING
+--R   [9] ((D7 -> D2),(D8 -> D2),D5) -> D2
+--R            from PolynomialCategoryLifting(D6,D7,D8,D5,D2)
+--R            if D7 has ORDSET and D8 has RING and D6 has OAMONS and D2 
+--R            has SetCategory with 
+--R               ?+? : (%,%) -> %
+--R               ?*? : (%,%) -> %
+--R               D : (%,NonNegativeInteger) -> % and D5 has POLYCAT(
+--R            D8,D6,D7)
+--R   [10] ((Polynomial D3 -> D1),D1) -> D1 from PushVariables(D3,D4,D5,D1
+--R            )
+--R            if D3 has RING and D1 has POLYCAT(POLY D3,D4,D5) and D4 has
+--R            OAMONS and D5 has OrderedSet with 
+--R               convert : % -> Symbol
+--R               variable : Symbol -> Union(%,"failed")
+--R   [11] ((D2 -> D2),XPolynomialRing(D2,D3)) -> XPolynomialRing(D2,D3)
+--R            from XPolynomialRing(D2,D3) if D2 has RING and D3 has 
+--R            ORDMON
+--R
+--RExamples of map from AbelianMonoidRing
+--R
+--R
+--RExamples of map from AntiSymm
+--R
+--R
+--RExamples of map from TwoDimensionalArrayCategory
+--R
+--Radder(a:Integer,b:Integer):Integer == a+b 
+--Rarr1 : ARRAY2 INT := new(5,4,10) 
+--Rarr2 : ARRAY2 INT := new(3,3,10) 
+--Rmap(adder,arr1,arr2,17)
+--R
+--Radder(a:Integer,b:Integer):Integer == a+b 
+--Rarr : ARRAY2 INT := new(5,4,10) 
+--Rmap(adder,arr,arr)
+--R
+--Rarr : ARRAY2 INT := new(5,4,10) 
+--Rmap(-,arr) 
+--Rmap((x +-> x + x),arr)
+--R
+--R
+--RExamples of map from OneDimensionalArrayFunctions2
+--R
+--RT1:=OneDimensionalArrayFunctions2(Integer,Integer) 
+--Rmap(x+->x+2,[i for i in 1..10])$T1
+--R
+--R
+--RExamples of map from CartesianTensorFunctions2
+--R
+--R
+--RExamples of map from ComplexFunctions2
+--R
+--R
+--RExamples of map from DeRhamComplex
+--R
+--R
+--RExamples of map from DirectProductFunctions2
+--R
+--R
+--RExamples of map from EquationFunctions2
+--R
+--R
+--RExamples of map from Equation
+--R
+--R
+--RExamples of map from ExpressionSpaceFunctions1
+--R
+--R
+--RExamples of map from ExpressionSpaceFunctions2
+--R
+--R
+--RExamples of map from ExpressionSpace
+--R
+--R
+--RExamples of map from ExpertSystemToolsPackage2
+--R
+--R
+--RExamples of map from ExpressionFunctions2
+--R
+--R
+--RExamples of map from FiniteAbelianMonoidRingFunctions2
+--R
+--R
+--RExamples of map from FiniteDivisorFunctions2
+--R
+--R
+--RExamples of map from FullyEvalableOver
+--R
+--R
+--RExamples of map from FunctionFieldCategoryFunctions2
+--R
+--R
+--RExamples of map from FiniteLinearAggregateFunctions2
+--R
+--R
+--RExamples of map from FreeModuleCat
+--R
+--R
+--RExamples of map from FactoredFunctions2
+--R
+--R
+--RExamples of map from FractionFunctions2
+--R
+--R
+--RExamples of map from FractionalIdealFunctions2
+--R
+--R
+--RExamples of map from FramedNonAssociativeAlgebraFunctions2
+--R
+--R
+--RExamples of map from Factored
+--R
+--Rm(a:Factored Polynomial Integer):Factored Polynomial Integer == a^2 
+--Rf:=x*y^3-3*x^2*y^2+3*x^3*y-x^4 
+--Rmap(m,f) 
+--Rg:=makeFR(z,factorList f) 
+--Rmap(m,g)
+--R
+--R
+--RExamples of map from FunctionSpaceFunctions2
+--R
+--R
+--RExamples of map from FiniteSetAggregateFunctions2
+--R
+--R
+--RExamples of map from HomogeneousAggregate
+--R
+--R
+--RExamples of map from IndexedDirectProductCategory
+--R
+--R
+--RExamples of map from IntegrationResultFunctions2
+--R
+--R
+--RExamples of map from InfiniteTupleFunctions2
+--R
+--R
+--RExamples of map from InfiniteTupleFunctions3
+--R
+--R
+--RExamples of map from InfiniteTuple
+--R
+--R
+--RExamples of map from ListFunctions2
+--R
+--R
+--RExamples of map from ListFunctions3
+--R
+--R
+--RExamples of map from LinearAggregate
+--R
+--R
+--RExamples of map from MatrixCategoryFunctions2
+--R
+--R
+--RExamples of map from MultipleMap
+--R
+--R
+--RExamples of map from MPolyCatFunctions2
+--R
+--R
+--RExamples of map from MPolyCatFunctions3
+--R
+--R
+--RExamples of map from MonoidRingFunctions2
+--R
+--R
+--RExamples of map from MonoidRing
+--R
+--R
+--RExamples of map from NewSparseUnivariatePolynomialFunctions2
+--R
+--R
+--RExamples of map from OctonionCategoryFunctions2
+--R
+--R
+--RExamples of map from OnePointCompletionFunctions2
+--R
+--R
+--RExamples of map from OrderedCompletionFunctions2
+--R
+--R
+--RExamples of map from ParametricPlaneCurveFunctions2
+--R
+--R
+--RExamples of map from ParametricSpaceCurveFunctions2
+--R
+--R
+--RExamples of map from ParametricSurfaceFunctions2
+--R
+--R
+--RExamples of map from PatternMatchResultFunctions2
+--R
+--R
+--RExamples of map from PatternFunctions2
+--R
+--R
+--RExamples of map from PolynomialFunctions2
+--R
+--R
+--RExamples of map from PolynomialCategoryLifting
+--R
+--R
+--RExamples of map from PrimitiveArrayFunctions2
+--R
+--RT1:=PrimitiveArrayFunctions2(Integer,Integer) 
+--Rmap(x+->x+2,[i for i in 1..10])$T1
+--R
+--R
+--RExamples of map from PointFunctions2
+--R
+--R
+--RExamples of map from PushVariables
+--R
+--R
+--RExamples of map from QuotientFieldCategoryFunctions2
+--R
+--R
+--RExamples of map from QuaternionCategoryFunctions2
+--R
+--R
+--RExamples of map from RectangularMatrixCategory
+--R
+--R
+--RExamples of map from RectangularMatrixCategoryFunctions2
+--R
+--R
+--RExamples of map from SegmentFunctions2
+--R
+--R
+--RExamples of map from SegmentBindingFunctions2
+--R
+--R
+--RExamples of map from SegmentExpansionCategory
+--R
+--R
+--RExamples of map from StreamFunctions2
+--R
+--Rm:=[i for i in 1..] 
+--Rf(i:PositiveInteger):PositiveInteger==i**2 
+--Rmap(f,m)
+--R
+--R
+--RExamples of map from StreamFunctions3
+--R
+--Rm:=[i for i in 1..]::Stream(Integer) 
+--Rn:=[i for i in 1..]::Stream(Integer) 
+--Rf(i:Integer,j:Integer):Integer == i+j 
+--Rmap(f,m,n)
+--R
+--R
+--RExamples of map from SparseUnivariatePolynomialFunctions2
+--R
+--R
+--RExamples of map from TableAggregate
+--R
+--R
+--RExamples of map from UnivariateLaurentSeriesFunctions2
+--R
+--R
+--RExamples of map from UniversalSegmentFunctions2
+--R
+--R
+--RExamples of map from UnivariatePolynomialFunctions2
+--R
+--R
+--RExamples of map from UnivariatePolynomialCategoryFunctions2
+--R
+--R
+--RExamples of map from UnivariatePuiseuxSeriesFunctions2
+--R
+--R
+--RExamples of map from UnivariateTaylorSeriesFunctions2
+--R
+--R
+--RExamples of map from VectorFunctions2
+--R
+--R
+--RExamples of map from XFreeAlgebra
+--R
+--R
+--RExamples of map from XPolynomialRing
+--R
+--E 21
+
+--S 22 of 127
+--R)d op complete
+--R 
+--R
+--RThere are 5 exposed functions called complete :
+--R   [1] ContinuedFraction D1 -> ContinuedFraction D1 from 
+--R            ContinuedFraction D1
+--R            if D1 has EUCDOM
+--R   [2] Integer -> SymmetricPolynomial Fraction Integer from 
+--R            CycleIndicators
+--R   [3] D -> D from D if D has LZSTAGG D1 and D1 has TYPE
+--R   [4] D -> D from D if D has PADICCT D1
+--R   [5] D -> D from D
+--R            if D has PSCAT(D1,D2,D3) and D1 has RING and D2 has OAMON 
+--R            and D3 has ORDSET
+--R
+--RExamples of complete from ContinuedFraction
+--R
+--R
+--RExamples of complete from CycleIndicators
+--R
+--R
+--RExamples of complete from LazyStreamAggregate
+--R
+--Rm:=[i for i in 1..] 
+--Rn:=filterUntil(i+->i>100,m) 
+--RnumberOfComputedEntries n 
+--Rcomplete n 
+--RnumberOfComputedEntries n
+--R
+--R
+--RExamples of complete from PAdicIntegerCategory
+--R
+--R
+--RExamples of complete from PowerSeriesCategory
+--R
+--E 22
+
+--S 23 of 127
+--R)d op cyclicEqual?
+--R 
+--R
+--RThere is one exposed function called cyclicEqual? :
+--R   [1] (Tree D2,Tree D2) -> Boolean from Tree D2 if D2 has SETCAT
+--R
+--RExamples of cyclicEqual? from Tree
+--R
+--Rt1:=tree [1,2,3,4] 
+--Rt2:=tree [1,2,3,4] 
+--RcyclicEqual?(t1,t2)
+--R
+--E 23
+
+--S 24 of 127
+--R)d op ncols
+--R 
+--R
+--RThere are 2 exposed functions called ncols :
+--R   [1] D -> NonNegativeInteger from D
+--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
+--R            D2 and D4 has FLAGG D2
+--R   [2] D -> NonNegativeInteger from D
+--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
+--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
+--R
+--RExamples of ncols from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,10) 
+--Rncols(arr)
+--R
+--R
+--RExamples of ncols from RectangularMatrixCategory
+--R
+--E 24
+
+--S 25 of 127
+--R)d op inverseIntegralMatrixAtInfinity
+--R 
+--R
+--RThere is one exposed function called inverseIntegralMatrixAtInfinity :
+--R   [1]  -> Matrix Fraction D3 from D
+--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
+--R            D2 and D4 has UPOLYC FRAC D3
+--R
+--RExamples of inverseIntegralMatrixAtInfinity from FunctionFieldCategory
+--R
+--RP0 := UnivariatePolynomial(x, Integer) 
+--RP1 := UnivariatePolynomial(y, Fraction P0) 
+--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
+--RinverseIntegralMatrixAtInfinity()$R
+--R
+--E 25
+
+--S 26 of 127
+--R)d op generalizedContinuumHypothesisAssumed
+--R 
+--R
+--RThere is one exposed function called generalizedContinuumHypothesisAssumed :
+--R   [1] Boolean -> Boolean from CardinalNumber
+--R
+--RExamples of generalizedContinuumHypothesisAssumed from CardinalNumber
+--R
+--RgeneralizedContinuumHypothesisAssumed true 
+--Ra:=Aleph 0 
+--Rc:=2**a 
+--Rf:=2**c
+--R
+--E 26
+
+--S 27 of 127
+--R)d op cyclic?
+--R 
+--R
+--RThere are 2 exposed functions called cyclic? :
+--R   [1] D -> Boolean from D if D has RCAGG D2 and D2 has TYPE
+--R   [2] Tree D2 -> Boolean from Tree D2 if D2 has SETCAT
+--R
+--RExamples of cyclic? from RecursiveAggregate
+--R
+--R
+--RExamples of cyclic? from Tree
+--R
+--Rt1:=tree [1,2,3,4] 
+--Rcyclic? t1
+--R
+--E 27
+
+--S 28 of 127
+--R)d op nilFactor
+--R 
+--R
+--RThere is one exposed function called nilFactor :
+--R   [1] (D1,Integer) -> Factored D1 from Factored D1 if D1 has INTDOM
+--R         
+--R
+--RExamples of nilFactor from Factored
+--R
+--RnilFactor(24,2) 
+--RnilFactor(x-y,3)
+--R
+--E 28
+
+--S 29 of 127
+--R)d op quote
+--R 
+--R
+--RThere is one exposed function called quote :
+--R   [1]  -> Character from Character
+--R
+--RThere is one unexposed function called quote :
+--R   [1] OutputForm -> OutputForm from OutputForm
+--R
+--RExamples of quote from Character
+--R
+--Rquote()
+--R
+--R
+--RExamples of quote from OutputForm
+--R
+--E 29
+
+--S 30 of 127
+--R)d op balancedBinaryTree
+--R 
+--R
+--RThere is one exposed function called balancedBinaryTree :
+--R   [1] (NonNegativeInteger,D2) -> BalancedBinaryTree D2
+--R            from BalancedBinaryTree D2 if D2 has SETCAT
+--R
+--RExamples of balancedBinaryTree from BalancedBinaryTree
+--R
+--RbalancedBinaryTree(4, 0)
+--R
+--E 30
+
+--S 31 of 127
+--R)d op integralBasisAtInfinity
+--R 
+--R
+--RThere is one exposed function called integralBasisAtInfinity :
+--R   [1]  -> Vector D from D
+--R            if D2 has UFD and D3 has UPOLYC D2 and D4 has UPOLYC FRAC 
+--R            D3 and D has FFCAT(D2,D3,D4)
+--R
+--RExamples of integralBasisAtInfinity from FunctionFieldCategory
+--R
+--RP0 := UnivariatePolynomial(x, Integer) 
+--RP1 := UnivariatePolynomial(y, Fraction P0) 
+--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
+--RintegralBasisAtInfinity()$R
+--R
+--E 31
+
+--S 32 of 127
+--R)d op branchPointAtInfinity?
+--R 
+--R
+--RThere is one exposed function called branchPointAtInfinity? :
+--R   [1]  -> Boolean from D
+--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
+--R            D2 and D4 has UPOLYC FRAC D3
+--R
+--RExamples of branchPointAtInfinity? from FunctionFieldCategory
+--R
+--RP0 := UnivariatePolynomial(x, Integer) 
+--RP1 := UnivariatePolynomial(y, Fraction P0) 
+--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
+--RbranchPointAtInfinity?()$R 
+--RR2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4) 
+--RbranchPointAtInfinity?()$R
+--R
+--E 32
+
+--S 33 of 127
+--R)d op transpose
+--R 
+--R
+--RThere are 4 exposed functions called transpose :
+--R   [1] (CartesianTensor(D2,D3,D4),Integer,Integer) -> CartesianTensor(
+--R            D2,D3,D4)
+--R            from CartesianTensor(D2,D3,D4)
+--R            if D2: INT and D3: NNI and D4 has COMRING
+--R   [2] CartesianTensor(D1,D2,D3) -> CartesianTensor(D1,D2,D3)
+--R            from CartesianTensor(D1,D2,D3)
+--R            if D1: INT and D2: NNI and D3 has COMRING
+--R   [3] D -> D from D
+--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
+--R            D1 and D3 has FLAGG D1
+--R   [4] D1 -> D from D
+--R            if D2 has RING and D has MATCAT(D2,D1,D3) and D1 has FLAGG 
+--R            D2 and D3 has FLAGG D2
+--R
+--RThere is one unexposed function called transpose :
+--R   [1] SquareMatrix(D1,D2) -> SquareMatrix(D1,D2) from SquareMatrix(D1,
+--R            D2)
+--R            if D1: NNI and D2 has RING
+--R
+--RExamples of transpose from CartesianTensor
+--R
+--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
+--Rtm:CartesianTensor(1,2,Integer):=m 
+--Rtn:CartesianTensor(1,2,Integer):=[tm,tm] 
+--Rtranspose(tn,1,2)
+--R
+--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
+--RTm:CartesianTensor(1,2,Integer):=m 
+--Rtranspose(Tm)
+--R
+--R
+--RExamples of transpose from MatrixCategory
+--R
+--R
+--RExamples of transpose from SquareMatrix
+--R
+--E 33
+
+--S 34 of 127
+--R)d op setrest!
+--R 
+--R
+--RThere are 2 exposed functions called setrest! :
+--R   [1] (Stream D2,Integer,Stream D2) -> Stream D2 from Stream D2 if D2 
+--R            has TYPE
+--R   [2] (D,D) -> D from D
+--R            if D has shallowlyMutable and D has URAGG D1 and D1 has 
+--R            TYPE
+--R
+--RExamples of setrest! from Stream
+--R
+--Rp:=[i for i in 1..] 
+--Rq:=[i for i in 9..] 
+--Rsetrest!(p,4,q) 
+--Rp
+--R
+--R
+--RExamples of setrest! from UnaryRecursiveAggregate
+--R
+--E 34
+
+--S 35 of 127
+--R)d op **
+--R 
+--R
+--RThere are 20 exposed functions called ** :
+--R   [1] (CardinalNumber,CardinalNumber) -> CardinalNumber from 
+--R            CardinalNumber
+--R   [2] (DoubleFloat,DoubleFloat) -> DoubleFloat from DoubleFloat
+--R   [3] (D,Integer) -> D from D if D has DIVRING
+--R   [4] (D,D) -> D from D if D has ELEMFUN
+--R   [5] (Float,Float) -> Float from Float
+--R   [6] (D,NonNegativeInteger) -> D from D
+--R            if D has FS D2 and D2 has ORDSET and D2 has SGROUP
+--R   [7] (D,Integer) -> D from D if D has GROUP
+--R   [8] (PolynomialIdeals(D2,D3,D4,D5),NonNegativeInteger) -> 
+--R            PolynomialIdeals(D2,D3,D4,D5)
+--R            from PolynomialIdeals(D2,D3,D4,D5)
+--R            if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D5 
+--R            has POLYCAT(D2,D3,D4)
+--R   [9] ((D3 -> D3),NonNegativeInteger) -> (D3 -> D3) from 
+--R            MappingPackage1 D3
+--R            if D3 has SETCAT
+--R   [10] (D,Integer) -> D from D
+--R            if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG 
+--R            D2 and D4 has FLAGG D2 and D2 has FIELD
+--R   [11] (D,NonNegativeInteger) -> D from D
+--R            if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG 
+--R            D2 and D4 has FLAGG D2
+--R   [12] (ModuleOperator(D2,D3),Integer) -> ModuleOperator(D2,D3)
+--R            from ModuleOperator(D2,D3)
+--R            if D2 has RING and D3 has LMODULE D2
+--R   [13] (BasicOperator,Integer) -> ModuleOperator(D3,D4)
+--R            from ModuleOperator(D3,D4)
+--R            if D3 has RING and D4 has LMODULE D3
+--R   [14] (D,PositiveInteger) -> D from D if D has MONAD
+--R   [15] (D,NonNegativeInteger) -> D from D if D has MONADWU
+--R   [16] (D,NonNegativeInteger) -> D from D if D has MONOID
+--R   [17] (D,Fraction Integer) -> D from D if D has RADCAT
+--R   [18] (D,PositiveInteger) -> D from D if D has SGROUP
+--R   [19] (D,Integer) -> D from D
+--R            if D has SMATCAT(D2,D3,D4,D5) and D3 has RING and D4 has 
+--R            DIRPCAT(D2,D3) and D5 has DIRPCAT(D2,D3) and D3 has FIELD
+--R         
+--R   [20] (D,D1) -> D from D
+--R            if D has UTSCAT D1 and D1 has RING and D1 has FIELD
+--R
+--RThere are 19 unexposed functions called ** :
+--R   [1] (D1,Fraction Integer) -> D1 from AlgebraicFunction(D3,D1)
+--R            if D3 has RETRACT INT and D3 has Join(OrderedSet,
+--R            IntegralDomain) and D1 has FS D3
+--R   [2] (D1,D1) -> D1 from CombinatorialFunction(D2,D1)
+--R            if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS D2
+--R            
+--R   [3] (D1,Fraction Integer) -> D1
+--R            from ElementaryFunctionsUnivariateLaurentSeries(D3,D4,D1)
+--R            if D3 has FIELD and D3 has ALGEBRA FRAC INT and D4 has 
+--R            UTSCAT D3 and D1 has ULSCCAT(D3,D4)
+--R   [4] (D1,Fraction Integer) -> D1
+--R            from ElementaryFunctionsUnivariatePuiseuxSeries(D3,D4,D1,D5
+--R            )
+--R            if D3 has FIELD and D3 has ALGEBRA FRAC INT and D4 has 
+--R            ULSCAT D3 and D1 has UPXSCCA(D3,D4) and D5 has PTRANFN D4
+--R         
+--R   [5] (D1,Integer) -> FreeGroup D1 from FreeGroup D1 if D1 has SETCAT
+--R            
+--R   [6] (D1,NonNegativeInteger) -> FreeMonoid D1 from FreeMonoid D1
+--R            if D1 has SETCAT
+--R   [7] (Vector D3,Integer) -> Vector D3 from 
+--R            InnerNormalBasisFieldFunctions D3
+--R            if D3 has FFIELDC
+--R   [8] (InputForm,Integer) -> InputForm from InputForm
+--R   [9] (InputForm,NonNegativeInteger) -> InputForm from InputForm
+--R   [10] (Matrix D3,NonNegativeInteger) -> Matrix D3
+--R            from StorageEfficientMatrixOperations D3 if D3 has RING
+--R   [11] (MyExpression(D1,D2),MyExpression(D1,D2)) -> MyExpression(D1,D2
+--R            )
+--R            from MyExpression(D1,D2)
+--R            if D1: SYMBOL and D2 has Join(Ring,OrderedSet,
+--R            IntegralDomain)
+--R   [12] (D1,NonNegativeInteger) -> OrderedFreeMonoid D1
+--R            from OrderedFreeMonoid D1 if D1 has ORDSET
+--R   [13] (Operator D2,Integer) -> Operator D2 from Operator D2 if D2 has
+--R            RING
+--R   [14] (BasicOperator,Integer) -> Operator D3 from Operator D3 if D3 
+--R            has RING
+--R   [15] (OutputForm,OutputForm) -> OutputForm from OutputForm
+--R   [16] (Pattern D1,Pattern D1) -> Pattern D1 from Pattern D1 if D1 has
+--R            SETCAT
+--R   [17] (Pattern D2,NonNegativeInteger) -> Pattern D2 from Pattern D2
+--R            if D2 has SETCAT
+--R   [18] (Stream D2,Stream D2) -> Stream D2
+--R            from StreamTranscendentalFunctionsNonCommutative D2
+--R            if D2 has ALGEBRA FRAC INT
+--R   [19] (Stream D2,Stream D2) -> Stream D2
+--R            from StreamTranscendentalFunctions D2 if D2 has ALGEBRA 
+--R            FRAC INT
+--R
+--RExamples of ** from AlgebraicFunction
+--R
+--R
+--RExamples of ** from CardinalNumber
+--R
+--Rc2:=2::CardinalNumber 
+--Rc2**c2 
+--RA1:=Aleph 1 
+--RA1**c2 
+--RgeneralizedContinuumHypothesisAssumed true 
+--RA1**A1
+--R
+--R
+--RExamples of ** from CombinatorialFunction
+--R
+--R
+--RExamples of ** from DoubleFloat
+--R
+--R
+--RExamples of ** from DivisionRing
+--R
+--R
+--RExamples of ** from ElementaryFunctionsUnivariateLaurentSeries
+--R
+--R
+--RExamples of ** from ElementaryFunctionsUnivariatePuiseuxSeries
+--R
+--R
+--RExamples of ** from ElementaryFunctionCategory
+--R
+--R
+--RExamples of ** from FreeGroup
+--R
+--R
+--RExamples of ** from Float
+--R
+--R
+--RExamples of ** from FreeMonoid
+--R
+--R
+--RExamples of ** from FunctionSpace
+--R
+--R
+--RExamples of ** from Group
+--R
+--R
+--RExamples of ** from PolynomialIdeals
+--R
+--R
+--RExamples of ** from InnerNormalBasisFieldFunctions
+--R
+--R
+--RExamples of ** from InputForm
+--R
+--R
+--RExamples of ** from MappingPackage1
+--R
+--R
+--RExamples of ** from MatrixCategory
+--R
+--R
+--RExamples of ** from StorageEfficientMatrixOperations
+--R
+--R
+--RExamples of ** from ModuleOperator
+--R
+--R
+--RExamples of ** from Monad
+--R
+--R
+--RExamples of ** from MonadWithUnit
+--R
+--R
+--RExamples of ** from Monoid
+--R
+--R
+--RExamples of ** from MyExpression
+--R
+--R
+--RExamples of ** from OrderedFreeMonoid
+--R
+--R
+--RExamples of ** from Operator
+--R
+--R
+--RExamples of ** from OutputForm
+--R
+--R
+--RExamples of ** from Pattern
+--R
+--R
+--RExamples of ** from RadicalCategory
+--R
+--R
+--RExamples of ** from SemiGroup
+--R
+--R
+--RExamples of ** from SquareMatrixCategory
+--R
+--R
+--RExamples of ** from StreamTranscendentalFunctionsNonCommutative
+--R
+--R
+--RExamples of ** from StreamTranscendentalFunctions
+--R
+--R
+--RExamples of ** from UnivariateTaylorSeriesCategory
+--R
+--E 35
+
+--S 36 of 127
+--R)d op plot
+--R 
+--R
+--RThere are 12 unexposed functions called plot :
+--R   [1] (D2,Symbol,Segment DoubleFloat) -> Plot from PlotFunctions1 D2
+--R            if D2 has KONVERT INFORM
+--R   [2] (D2,D2,Symbol,Segment DoubleFloat) -> Plot from PlotFunctions1 
+--R            D2
+--R            if D2 has KONVERT INFORM
+--R   [3] (Plot3D,Segment DoubleFloat) -> Plot3D from Plot3D
+--R   [4] ((DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),(
+--R            DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),Segment 
+--R            DoubleFloat,Segment DoubleFloat,Segment DoubleFloat,Segment 
+--R            DoubleFloat) -> Plot3D
+--R            from Plot3D
+--R   [5] ((DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),(
+--R            DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),Segment 
+--R            DoubleFloat) -> Plot3D
+--R            from Plot3D
+--R   [6] (Plot,Segment DoubleFloat) -> Plot from Plot
+--R   [7] ((DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),
+--R            Segment DoubleFloat,Segment DoubleFloat,Segment DoubleFloat) -> 
+--R            Plot
+--R            from Plot
+--R   [8] ((DoubleFloat -> DoubleFloat),(DoubleFloat -> DoubleFloat),
+--R            Segment DoubleFloat) -> Plot
+--R            from Plot
+--R   [9] (List (DoubleFloat -> DoubleFloat),Segment DoubleFloat,Segment 
+--R            DoubleFloat) -> Plot
+--R            from Plot
+--R   [10] (List (DoubleFloat -> DoubleFloat),Segment DoubleFloat) -> Plot
+--R            from Plot
+--R   [11] ((DoubleFloat -> DoubleFloat),Segment DoubleFloat,Segment 
+--R            DoubleFloat) -> Plot
+--R            from Plot
+--R   [12] ((DoubleFloat -> DoubleFloat),Segment DoubleFloat) -> Plot from
+--R            Plot
+--R
+--RExamples of plot from PlotFunctions1
+--R
+--R
+--RExamples of plot from Plot3D
+--R
+--R
+--RExamples of plot from Plot
+--R
+--Rfp:=(t:DFLOAT):DFLOAT +-> sin(t) 
+--Rplot(fp,-1.0..1.0)$PLOT
+--R
+--E 36
+
+--S 37 of 127
+--R)d op factorList
+--R 
+--R
+--RThere is one exposed function called factorList :
+--R   [1] Factored D2 -> List Record(flg: Union("nil","sqfr","irred",
+--R            "prime"),fctr: D2,xpnt: Integer)
+--R            from Factored D2 if D2 has INTDOM
+--R
+--RThere is one unexposed function called factorList :
+--R   [1] (D2,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)
+--R             -> List SparseUnivariatePolynomial D2
+--R            from ChineseRemainderToolsForIntegralBases(D2,D4,D5)
+--R            if D2 has FFIELDC and D4 has UPOLYC D2 and D5 has UPOLYC D4
+--R            
+--R
+--RExamples of factorList from Factored
+--R
+--Rf:=nilFactor(x-y,3) 
+--RfactorList f
+--R
+--R
+--RExamples of factorList from ChineseRemainderToolsForIntegralBases
+--R
+--E 37
+
+--S 38 of 127
+--R)d op physicalLength
+--R 
+--R
+--RThere is one exposed function called physicalLength :
+--R   [1] FlexibleArray D2 -> NonNegativeInteger from FlexibleArray D2
+--R            if D2 has TYPE
+--R
+--RThere is one unexposed function called physicalLength :
+--R   [1] IndexedFlexibleArray(D2,D3) -> NonNegativeInteger
+--R            from IndexedFlexibleArray(D2,D3) if D2 has TYPE and D3: INT
+--R            
+--R
+--RExamples of physicalLength from FlexibleArray
+--R
+--R
+--RExamples of physicalLength from IndexedFlexibleArray
+--R
+--RT1:=IndexedFlexibleArray(Integer,20) 
+--Rt2:=flexibleArray([i for i in 1..10])$T1 
+--RphysicalLength t2
+--R
+--E 38
+
+--S 39 of 127
+--R)d op absolutelyIrreducible?
+--R 
+--R
+--RThere is one exposed function called absolutelyIrreducible? :
+--R   [1]  -> Boolean from D
+--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
+--R            D2 and D4 has UPOLYC FRAC D3
+--R
+--RThere is one unexposed function called absolutelyIrreducible? :
+--R   [1]  -> Boolean from FunctionFieldCategory&(D2,D3,D4,D5)
+--R            if D3 has UFD and D4 has UPOLYC D3 and D5 has UPOLYC FRAC 
+--R            D4 and D2 has FFCAT(D3,D4,D5)
+--R
+--RExamples of absolutelyIrreducible? from FunctionFieldCategory&
+--R
+--RP0 := UnivariatePolynomial(x, Integer) 
+--RP1 := UnivariatePolynomial(y, Fraction P0) 
+--RR2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4) 
+--RabsolutelyIrreducible?()$R2
+--R
+--R
+--RExamples of absolutelyIrreducible? from FunctionFieldCategory
+--R
+--RP0 := UnivariatePolynomial(x, Integer) 
+--RP1 := UnivariatePolynomial(y, Fraction P0) 
+--RR2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4) 
+--RabsolutelyIrreducible?()$R2
+--R
+--E 39
+
+--S 40 of 127
+--R)d op repeating?
+--R 
+--R
+--RThere is one exposed function called repeating? :
+--R   [1] (List D3,Stream D3) -> Boolean from Stream D3
+--R            if D3 has SETCAT and D3 has TYPE
+--R
+--RExamples of repeating? from Stream
+--R
+--Rm:=[1,2,3] 
+--Rn:=repeating(m) 
+--Rrepeating?(m,n)
+--R
+--E 40
+
+--S 41 of 127
+--R)d op lazy?
+--R 
+--R
+--RThere is one exposed function called lazy? :
+--R   [1] D -> Boolean from D if D has LZSTAGG D2 and D2 has TYPE
+--R
+--RExamples of lazy? from LazyStreamAggregate
+--R
+--Rm:=[i for i in 0..] 
+--Rlazy? m
+--R
+--E 41
+
+--S 42 of 127
+--R)d op ord
+--R 
+--R
+--RThere is one exposed function called ord :
+--R   [1] Character -> Integer from Character
+--R
+--RExamples of ord from Character
+--R
+--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
+--R[ord c for c in chars]
+--R
+--E 42
+
+--S 43 of 127
+--R)d op setColumn!
+--R 
+--R
+--RThere is one exposed function called setColumn! :
+--R   [1] (D,Integer,D2) -> D from D
+--R            if D has ARR2CAT(D3,D4,D2) and D3 has TYPE and D4 has FLAGG
+--R            D3 and D2 has FLAGG D3
+--R
+--RExamples of setColumn! from TwoDimensionalArrayCategory
+--R
+--RT1:=TwoDimensionalArray Integer 
+--Rarr:T1:= new(5,4,0) 
+--RT2:=OneDimensionalArray Integer 
+--Racol:=construct([1,2,3,4,5]::List(INT))$T2 
+--RsetColumn!(arr,1,acol)$T1
+--R
+--E 43
+
+--S 44 of 127
+--R)d op lowerCase?
+--R 
+--R
+--RThere is one exposed function called lowerCase? :
+--R   [1] Character -> Boolean from Character
+--R
+--RExamples of lowerCase? from Character
+--R
+--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
+--R[lowerCase? c for c in chars]
+--R
+--E 44
+
+--S 45 of 127
+--R)d op physicalLength!
+--R 
+--R
+--RThere is one exposed function called physicalLength! :
+--R   [1] (FlexibleArray D2,Integer) -> FlexibleArray D2 from 
+--R            FlexibleArray D2
+--R            if D2 has TYPE
+--R
+--RThere is one unexposed function called physicalLength! :
+--R   [1] (IndexedFlexibleArray(D2,D3),Integer) -> IndexedFlexibleArray(D2
+--R            ,D3)
+--R            from IndexedFlexibleArray(D2,D3) if D2 has TYPE and D3: INT
+--R            
+--R
+--RExamples of physicalLength! from FlexibleArray
+--R
+--R
+--RExamples of physicalLength! from IndexedFlexibleArray
+--R
+--RT1:=IndexedFlexibleArray(Integer,20) 
+--Rt2:=flexibleArray([i for i in 1..10])$T1 
+--RphysicalLength!(t2,15)
+--R
+--E 45
+
+--S 46 of 127
+--R)d op countable?
+--R 
+--R
+--RThere is one exposed function called countable? :
+--R   [1] CardinalNumber -> Boolean from CardinalNumber
+--R
+--RExamples of countable? from CardinalNumber
+--R
+--Rc2:=2::CardinalNumber 
+--Rcountable? c2 
+--RA0:=Aleph 0 
+--Rcountable? A0 
+--RA1:=Aleph 1 
+--Rcountable? A1
+--R
+--E 46
+
+--S 47 of 127
+--R)d op extend
+--R 
+--R
+--RThere are 11 exposed functions called extend :
+--R   [1] (ContinuedFraction D2,Integer) -> ContinuedFraction D2
+--R            from ContinuedFraction D2 if D2 has EUCDOM
+--R   [2] (D,Integer) -> D from D if D has LZSTAGG D2 and D2 has TYPE
+--R   [3] (D,NonNegativeInteger) -> D from D
+--R            if D has MTSCAT(D2,D3) and D2 has RING and D3 has ORDSET
+--R         
+--R   [4] (D,Integer) -> D from D if D has PADICCT D2
+--R   [5] (D,List D2) -> D from D if D has PTCAT D2 and D2 has RING
+--R   [6] (List D6,List D) -> List D from D
+--R            if D has RSETCAT(D3,D4,D5,D6) and D3 has GCDDOM and D4 has 
+--R            OAMONS and D5 has ORDSET and D6 has RPOLCAT(D3,D4,D5)
+--R   [7] (List D6,D) -> List D from D
+--R            if D6 has RPOLCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
+--R            OAMONS and D5 has ORDSET and D has RSETCAT(D3,D4,D5,D6)
+--R   [8] (D2,List D) -> List D from D
+--R            if D has RSETCAT(D3,D4,D5,D2) and D3 has GCDDOM and D4 has 
+--R            OAMONS and D5 has ORDSET and D2 has RPOLCAT(D3,D4,D5)
+--R   [9] (D2,D) -> List D from D
+--R            if D3 has GCDDOM and D4 has OAMONS and D5 has ORDSET and D2
+--R            has RPOLCAT(D3,D4,D5) and D has RSETCAT(D3,D4,D5,D2)
+--R   [10] (D,D1) -> D from D
+--R            if D has TSETCAT(D2,D3,D4,D1) and D2 has INTDOM and D3 has 
+--R            OAMONS and D4 has ORDSET and D1 has RPOLCAT(D2,D3,D4)
+--R   [11] (D,D1) -> D from D
+--R            if D has UPSCAT(D2,D1) and D2 has RING and D1 has OAMON
+--R
+--RExamples of extend from ContinuedFraction
+--R
+--R
+--RExamples of extend from LazyStreamAggregate
+--R
+--Rm:=[i for i in 0..] 
+--RnumberOfComputedEntries m 
+--Rextend(m,20) 
+--RnumberOfComputedEntries m
+--R
+--R
+--RExamples of extend from MultivariateTaylorSeriesCategory
+--R
+--R
+--RExamples of extend from PAdicIntegerCategory
+--R
+--R
+--RExamples of extend from PointCategory
+--R
+--R
+--RExamples of extend from RegularTriangularSetCategory
+--R
+--R
+--RExamples of extend from TriangularSetCategory
+--R
+--R
+--RExamples of extend from UnivariatePowerSeriesCategory
+--R
+--E 47
+
+--S 48 of 127
+--R)d op length
+--R 
+--R
+--RThere are 3 exposed functions called length :
+--R   [1] D -> D from D if D has INS
+--R   [2] D -> NonNegativeInteger from D if D has QUAGG D2 and D2 has TYPE
+--R            
+--R   [3] D -> D1 from D
+--R            if D has VECTCAT D1 and D1 has TYPE and D1 has RADCAT and 
+--R            D1 has RING
+--R
+--RThere are 6 unexposed functions called length :
+--R   [1] D2 -> D1 from GaloisGroupFactorizationUtilities(D3,D2,D1)
+--R            if D3 has RING and D1 has Join(FloatingPointSystem,
+--R            RetractableTo D3,Field,TranscendentalFunctionCategory,
+--R            ElementaryFunctionCategory) and D2 has UPOLYC D3
+--R   [2] LyndonWord D2 -> PositiveInteger from LyndonWord D2 if D2 has 
+--R            ORDSET
+--R   [3] Magma D2 -> PositiveInteger from Magma D2 if D2 has ORDSET
+--R   [4] OrderedFreeMonoid D2 -> NonNegativeInteger from 
+--R            OrderedFreeMonoid D2
+--R            if D2 has ORDSET
+--R   [5] PoincareBirkhoffWittLyndonBasis D2 -> NonNegativeInteger
+--R            from PoincareBirkhoffWittLyndonBasis D2 if D2 has ORDSET
+--R         
+--R   [6] Tuple D2 -> NonNegativeInteger from Tuple D2 if D2 has TYPE
+--R
+--RExamples of length from GaloisGroupFactorizationUtilities
+--R
+--R
+--RExamples of length from IntegerNumberSystem
+--R
+--R
+--RExamples of length from LyndonWord
+--R
+--R
+--RExamples of length from Magma
+--R
+--R
+--RExamples of length from OrderedFreeMonoid
+--R
+--R
+--RExamples of length from PoincareBirkhoffWittLyndonBasis
+--R
+--R
+--RExamples of length from QueueAggregate
+--R
+--R
+--RExamples of length from Tuple
+--R
+--Rt1:PrimitiveArray(Integer):= [i for i in 1..10] 
+--Rt2:=coerce(t1)$Tuple(Integer) 
+--Rlength(t2)
+--R
+--R
+--RExamples of length from VectorCategory
+--R
+--E 48
+
+--S 49 of 127
+--R)d op viewPosDefault
+--R 
+--R
+--RThere are 2 exposed functions called viewPosDefault :
+--R   [1]  -> List NonNegativeInteger from ViewDefaultsPackage
+--R   [2] List NonNegativeInteger -> List NonNegativeInteger
+--R            from ViewDefaultsPackage
+--R
+--RExamples of viewPosDefault from ViewDefaultsPackage
+--R
+--Rand Y position of a viewport window unless overriden explicityly, newly created viewports will have th 
+--Rand Y coordinates x, y.
+--R
+--Rand Y position of a viewport window unless overriden explicityly, newly created viewports will have this 
+--Rand Y coordinate.
+--R
+--E 49
+
+--S 50 of 127
+--R)d op groebner
+--R 
+--R
+--RThere are 4 exposed functions called groebner :
+--R   [1] List D5 -> List D5 from GroebnerPackage(D2,D3,D4,D5)
+--R            if D5 has POLYCAT(D2,D3,D4) and D2 has GCDDOM and D3 has 
+--R            OAMONS and D4 has ORDSET
+--R   [2] (List D6,String) -> List D6 from GroebnerPackage(D3,D4,D5,D6)
+--R            if D6 has POLYCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
+--R            OAMONS and D5 has ORDSET
+--R   [3] (List D6,String,String) -> List D6 from GroebnerPackage(D3,D4,D5
+--R            ,D6)
+--R            if D6 has POLYCAT(D3,D4,D5) and D3 has GCDDOM and D4 has 
+--R            OAMONS and D5 has ORDSET
+--R   [4] PolynomialIdeals(D1,D2,D3,D4) -> PolynomialIdeals(D1,D2,D3,D4)
+--R            from PolynomialIdeals(D1,D2,D3,D4)
+--R            if D1 has FIELD and D2 has OAMONS and D3 has ORDSET and D4 
+--R            has POLYCAT(D1,D2,D3)
+--R
+--RThere are 2 unexposed functions called groebner :
+--R   [1] List Polynomial D2 -> List Polynomial D2 from FGLMIfCanPackage(
+--R            D2,D3)
+--R            if D2 has GCDDOM and D3: LIST SYMBOL
+--R   [2] List NewSparseMultivariatePolynomial(D2,OrderedVariableList D3)
+--R             -> List NewSparseMultivariatePolynomial(D2,OrderedVariableList 
+--R            D3)
+--R            from LexTriangularPackage(D2,D3)
+--R            if D2 has GCDDOM and D3: LIST SYMBOL
+--R
+--RExamples of groebner from FGLMIfCanPackage
+--R
+--R
+--RExamples of groebner from GroebnerPackage
+--R
+--Rs1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36 
+--Rs2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s 
+--Rs3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2 
+--Rs4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s 
+--Rs5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3 
+--Rs6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2 
+--Rs7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000 
+--Rsn7:=[s1,s2,s3,s4,s5,s6,s7] 
+--Rgroebner(sn7,"info","redcrit")
+--R
+--Rs1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36 
+--Rs2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s 
+--Rs3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2 
+--Rs4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s 
+--Rs5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3 
+--Rs6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2 
+--Rs7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000 
+--Rsn7:=[s1,s2,s3,s4,s5,s6,s7] 
+--Rgroebner(sn7,"info") 
+--Rgroebner(sn7,"redcrit")
+--R
+--Rs1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36 
+--Rs2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s 
+--Rs3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2 
+--Rs4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s 
+--Rs5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3 
+--Rs6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2 
+--Rs7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000 
+--Rsn7:=[s1,s2,s3,s4,s5,s6,s7] 
+--Rgroebner(sn7)
+--R
+--R
+--RExamples of groebner from PolynomialIdeals
+--R
+--R
+--RExamples of groebner from LexTriangularPackage
+--R
+--E 50
+
+--S 51 of 127
+--R)d op primeFactor
+--R 
+--R
+--RThere is one exposed function called primeFactor :
+--R   [1] (D1,Integer) -> Factored D1 from Factored D1 if D1 has INTDOM
+--R         
+--R
+--RExamples of primeFactor from Factored
+--R
+--Ra:=primeFactor(3,4) 
+--RnthFlag(a,1)
+--R
+--E 51
+
+--S 52 of 127
+--R)d op map!
+--R 
+--R
+--RThere are 2 exposed functions called map! :
+--R   [1] ((D2 -> D2),D) -> D from D
+--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
+--R            D2 and D4 has FLAGG D2
+--R   [2] ((D2 -> D2),D) -> D from D
+--R            if D has shallowlyMutable and D has HOAGG D2 and D2 has 
+--R            TYPE
+--R
+--RExamples of map! from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,10) 
+--Rmap!(-,arr)
+--R
+--R
+--RExamples of map! from HomogeneousAggregate
+--R
+--E 52
+
+--S 53 of 127
+--R)d op setleaves!
+--R 
+--R
+--RThere is one exposed function called setleaves! :
+--R   [1] (BalancedBinaryTree D2,List D2) -> BalancedBinaryTree D2
+--R            from BalancedBinaryTree D2 if D2 has SETCAT
+--R
+--RExamples of setleaves! from BalancedBinaryTree
+--R
+--Rt1:=balancedBinaryTree(4, 0) 
+--Rsetleaves!(t1,[1,2,3,4])
+--R
+--E 53
+
+--S 54 of 127
+--R)d op scan
+--R 
+--R
+--RThere are 8 exposed functions called scan :
+--R   [1] (((D5,D4) -> D4),OneDimensionalArray D5,D4) -> 
+--R            OneDimensionalArray D4
+--R            from OneDimensionalArrayFunctions2(D5,D4)
+--R            if D5 has TYPE and D4 has TYPE
+--R   [2] (((D6,D4) -> D4),DirectProduct(D5,D6),D4) -> DirectProduct(D5,D4
+--R            )
+--R            from DirectProductFunctions2(D5,D6,D4)
+--R            if D5: NNI and D6 has TYPE and D4 has TYPE
+--R   [3] (((D5,D4) -> D4),D3,D4) -> D1
+--R            from FiniteLinearAggregateFunctions2(D5,D3,D4,D1)
+--R            if D5 has TYPE and D4 has TYPE and D1 has FLAGG D4 and D3 
+--R            has FLAGG D5
+--R   [4] (((D5,D4) -> D4),D3,D4) -> D1
+--R            from FiniteSetAggregateFunctions2(D5,D3,D4,D1)
+--R            if D5 has SETCAT and D4 has SETCAT and D1 has FSAGG D4 and 
+--R            D3 has FSAGG D5
+--R   [5] (((D5,D4) -> D4),List D5,D4) -> List D4 from ListFunctions2(D5,
+--R            D4)
+--R            if D5 has TYPE and D4 has TYPE
+--R   [6] (((D5,D4) -> D4),PrimitiveArray D5,D4) -> PrimitiveArray D4
+--R            from PrimitiveArrayFunctions2(D5,D4)
+--R            if D5 has TYPE and D4 has TYPE
+--R   [7] (D2,((D5,D2) -> D2),Stream D5) -> Stream D2
+--R            from StreamFunctions2(D5,D2) if D5 has TYPE and D2 has TYPE
+--R            
+--R   [8] (((D5,D4) -> D4),Vector D5,D4) -> Vector D4
+--R            from VectorFunctions2(D5,D4) if D5 has TYPE and D4 has TYPE
+--R            
+--R
+--RExamples of scan from OneDimensionalArrayFunctions2
+--R
+--RT1:=OneDimensionalArrayFunctions2(Integer,Integer) 
+--Radder(a:Integer,b:Integer):Integer == a+b 
+--Rscan(adder,[i for i in 1..10],0)$T1
+--R
+--R
+--RExamples of scan from DirectProductFunctions2
+--R
+--R
+--RExamples of scan from FiniteLinearAggregateFunctions2
+--R
+--R
+--RExamples of scan from FiniteSetAggregateFunctions2
+--R
+--R
+--RExamples of scan from ListFunctions2
+--R
+--R
+--RExamples of scan from PrimitiveArrayFunctions2
+--R
+--RT1:=PrimitiveArrayFunctions2(Integer,Integer) 
+--Radder(a:Integer,b:Integer):Integer == a+b 
+--Rscan(adder,[i for i in 1..10],0)$T1
+--R
+--R
+--RExamples of scan from StreamFunctions2
+--R
+--Rm:=[i for i in 1..]::Stream(Integer) 
+--Rf(i:Integer,j:Integer):Integer==i+j 
+--Rscan(1,f,m)
+--R
+--R
+--RExamples of scan from VectorFunctions2
+--R
+--E 54
+
+--S 55 of 127
+--R)d op alphabetic?
+--R 
+--R
+--RThere is one exposed function called alphabetic? :
+--R   [1] Character -> Boolean from Character
+--R
+--RExamples of alphabetic? from Character
+--R
+--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
+--R[alphabetic? c for c in chars]
+--R
+--E 55
+
+--S 56 of 127
+--R)d op +
+--R 
+--R
+--RThere are 12 exposed functions called + :
+--R   [1] (D,D) -> D from D if D has ABELSG
+--R   [2] (Color,Color) -> Color from Color
+--R   [3] (Database D1,Database D1) -> Database D1 from Database D1
+--R            if D1 has OrderedSet with 
+--R               ?.? : (%,Symbol) -> String
+--R               display : % -> Void
+--R               fullDisplay : % -> Void
+--R   [4] (Equation D1,D1) -> Equation D1 from Equation D1
+--R            if D1 has ABELSG and D1 has TYPE
+--R   [5] (D1,Equation D1) -> Equation D1 from Equation D1
+--R            if D1 has ABELSG and D1 has TYPE
+--R   [6] (D1,D) -> D from D
+--R            if D has FAMONC(D1,D2) and D1 has SETCAT and D2 has CABMON
+--R            
+--R   [7] (D1,FullPartialFractionExpansion(D2,D1)) -> 
+--R            FullPartialFractionExpansion(D2,D1)
+--R            from FullPartialFractionExpansion(D2,D1)
+--R            if D2 has Join(Field,CharacteristicZero) and D1 has UPOLYC 
+--R            D2
+--R   [8] (D,D) -> D from D
+--R            if D has GRMOD(D1,D2) and D1 has COMRING and D2 has ABELMON
+--R            
+--R   [9] (PolynomialIdeals(D1,D2,D3,D4),PolynomialIdeals(D1,D2,D3,D4))
+--R             -> PolynomialIdeals(D1,D2,D3,D4)
+--R            from PolynomialIdeals(D1,D2,D3,D4)
+--R            if D1 has FIELD and D2 has OAMONS and D3 has ORDSET and D4 
+--R            has POLYCAT(D1,D2,D3)
+--R   [10] ((D2 -> D3),(D2 -> D3)) -> (D2 -> D3) from MappingPackage4(D2,
+--R            D3)
+--R            if D2 has SETCAT and D3 has RING
+--R   [11] (D,D) -> D from D
+--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
+--R            D1 and D3 has FLAGG D1
+--R   [12] (D,D) -> D from D
+--R            if D has VECTCAT D1 and D1 has TYPE and D1 has ABELSG
+--R
+--RThere are 5 unexposed functions called + :
+--R   [1] (InputForm,InputForm) -> InputForm from InputForm
+--R   [2] (OutputForm,OutputForm) -> OutputForm from OutputForm
+--R   [3] (Pattern D1,Pattern D1) -> Pattern D1 from Pattern D1 if D1 has 
+--R            SETCAT
+--R   [4] (Stream D2,Stream D2) -> Stream D2 from 
+--R            StreamTaylorSeriesOperations D2
+--R            if D2 has RING
+--R   [5] (Point DoubleFloat,Point DoubleFloat) -> Point DoubleFloat
+--R            from TubePlotTools
+--R
+--RExamples of + from AbelianSemiGroup
+--R
+--R
+--RExamples of + from Color
+--R
+--R
+--RExamples of + from Database
+--R
+--R
+--RExamples of + from Equation
+--R
+--R
+--RExamples of + from FreeAbelianMonoidCategory
+--R
+--R
+--RExamples of + from FullPartialFractionExpansion
+--R
+--R
+--RExamples of + from GradedModule
+--R
+--R
+--RExamples of + from PolynomialIdeals
+--R
+--R
+--RExamples of + from InputForm
+--R
+--R
+--RExamples of + from MappingPackage4
+--R
+--Rf:=(x:INT):INT +-> 3*x 
+--Rg:=(x:INT):INT +-> 2*x+3 
+--R(f+g)(4)
+--R
+--R
+--RExamples of + from MatrixCategory
+--R
+--R
+--RExamples of + from OutputForm
+--R
+--R
+--RExamples of + from Pattern
+--R
+--R
+--RExamples of + from StreamTaylorSeriesOperations
+--R
+--R
+--RExamples of + from TubePlotTools
+--R
+--R
+--RExamples of + from VectorCategory
+--R
+--E 56
+
+--S 57 of 127
+--R)d op -
+--R 
+--R
+--RThere are 13 exposed functions called - :
+--R   [1] (D,D) -> D from D if D has ABELGRP
+--R   [2] D -> D from D if D has ABELGRP
+--R   [3] (CardinalNumber,CardinalNumber) -> Union(CardinalNumber,"failed"
+--R            )
+--R            from CardinalNumber
+--R   [4] (Database D1,Database D1) -> Database D1 from Database D1
+--R            if D1 has OrderedSet with 
+--R               ?.? : (%,Symbol) -> String
+--R               display : % -> Void
+--R               fullDisplay : % -> Void
+--R   [5] (Equation D1,D1) -> Equation D1 from Equation D1
+--R            if D1 has ABELGRP and D1 has TYPE
+--R   [6] (D1,Equation D1) -> Equation D1 from Equation D1
+--R            if D1 has ABELGRP and D1 has TYPE
+--R   [7] (D,D) -> D from D
+--R            if D has GRMOD(D1,D2) and D1 has COMRING and D2 has ABELMON
+--R            
+--R   [8] D -> D from D
+--R            if D has GRMOD(D1,D2) and D1 has COMRING and D2 has ABELMON
+--R            
+--R   [9] ((D2 -> D3),(D2 -> D3)) -> (D2 -> D3) from MappingPackage4(D2,D3
+--R            )
+--R            if D2 has SETCAT and D3 has RING
+--R   [10] D -> D from D
+--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
+--R            D1 and D3 has FLAGG D1
+--R   [11] (D,D) -> D from D
+--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
+--R            D1 and D3 has FLAGG D1
+--R   [12] (D,D) -> D from D
+--R            if D has VECTCAT D1 and D1 has TYPE and D1 has ABELGRP
+--R   [13] D -> D from D
+--R            if D has VECTCAT D1 and D1 has TYPE and D1 has ABELGRP
+--R
+--RThere are 5 unexposed functions called - :
+--R   [1] OutputForm -> OutputForm from OutputForm
+--R   [2] (OutputForm,OutputForm) -> OutputForm from OutputForm
+--R   [3] (Stream D2,Stream D2) -> Stream D2 from 
+--R            StreamTaylorSeriesOperations D2
+--R            if D2 has RING
+--R   [4] Stream D2 -> Stream D2 from StreamTaylorSeriesOperations D2
+--R            if D2 has RING
+--R   [5] (Point DoubleFloat,Point DoubleFloat) -> Point DoubleFloat
+--R            from TubePlotTools
+--R
+--RExamples of - from AbelianGroup
+--R
+--R
+--RExamples of - from CardinalNumber
+--R
+--Rc2:=2::CardinalNumber 
+--Rc2-c2 
+--RA1:=Aleph 1 
+--RA1-c2
+--R
+--R
+--RExamples of - from Database
+--R
+--R
+--RExamples of - from Equation
+--R
+--R
+--RExamples of - from GradedModule
+--R
+--R
+--RExamples of - from MappingPackage4
+--R
+--Rf:=(x:INT):INT +-> 3*x 
+--Rg:=(x:INT):INT +-> 2*x+3 
+--R(f-g)(4)
+--R
+--R
+--RExamples of - from MatrixCategory
+--R
+--R
+--RExamples of - from OutputForm
+--R
+--R
+--RExamples of - from StreamTaylorSeriesOperations
+--R
+--R
+--RExamples of - from TubePlotTools
+--R
+--R
+--RExamples of - from VectorCategory
+--R
+--E 57
+
+--S 58 of 127
+--R)d op /
+--R 
+--R
+--RThere are 13 exposed functions called / :
+--R   [1] (D,D1) -> D from D
+--R            if D has AMR(D1,D2) and D1 has RING and D2 has OAMON and D1
+--R            has FIELD
+--R   [2] (DoubleFloat,Integer) -> DoubleFloat from DoubleFloat
+--R   [3] (D,D) -> D from D
+--R            if D = EQ D1 and D1 has FIELD and D1 has TYPE or D = EQ D1 
+--R            and D1 has GROUP and D1 has TYPE
+--R   [4] (D,D) -> D from D if D has FIELD
+--R   [5] (Float,Integer) -> Float from Float
+--R   [6] (SparseMultivariatePolynomial(D2,Kernel D),
+--R            SparseMultivariatePolynomial(D2,Kernel D)) -> D
+--R            from D if D2 has INTDOM and D2 has ORDSET and D has FS D2
+--R         
+--R   [7] (D,D) -> D from D if D has GROUP
+--R   [8] (D,D1) -> D from D
+--R            if D has LIECAT D1 and D1 has COMRING and D1 has FIELD
+--R   [9] ((D2 -> Expression Integer),(D2 -> Expression Integer)) -> (D2
+--R             -> Expression Integer)
+--R            from MappingPackage4(D2,D3) if D2 has SETCAT and D3 has 
+--R            RING
+--R   [10] (D,D1) -> D from D
+--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
+--R            D1 and D3 has FLAGG D1 and D1 has FIELD
+--R   [11] (D1,D1) -> D from D if D has QFCAT D1 and D1 has INTDOM
+--R   [12] (D,D1) -> D from D
+--R            if D has RMATCAT(D2,D3,D1,D4,D5) and D1 has RING and D4 has
+--R            DIRPCAT(D3,D1) and D5 has DIRPCAT(D2,D1) and D1 has FIELD
+--R         
+--R   [13] (D,D1) -> D from D if D has VSPACE D1 and D1 has FIELD
+--R
+--RThere are 13 unexposed functions called / :
+--R   [1] (Vector D2,Vector D2) -> Vector D2
+--R            from InnerNormalBasisFieldFunctions D2 if D2 has FFIELDC
+--R         
+--R   [2] (InputForm,InputForm) -> InputForm from InputForm
+--R   [3] (D1,D2) -> LocalAlgebra(D1,D3,D2) from LocalAlgebra(D1,D3,D2)
+--R            if D3 has COMRING and D1 has ALGEBRA D3 and D2 has 
+--R            SubsetCategory(Monoid,D3)
+--R   [4] (LocalAlgebra(D2,D3,D1),D1) -> LocalAlgebra(D2,D3,D1)
+--R            from LocalAlgebra(D2,D3,D1)
+--R            if D3 has COMRING and D2 has ALGEBRA D3 and D1 has 
+--R            SubsetCategory(Monoid,D3)
+--R   [5] (D1,D2) -> Localize(D1,D3,D2) from Localize(D1,D3,D2)
+--R            if D3 has COMRING and D1 has MODULE D3 and D2 has 
+--R            SubsetCategory(Monoid,D3)
+--R   [6] (Localize(D2,D3,D1),D1) -> Localize(D2,D3,D1) from Localize(D2,
+--R            D3,D1)
+--R            if D3 has COMRING and D2 has MODULE D3 and D1 has 
+--R            SubsetCategory(Monoid,D3)
+--R   [7] (MyExpression(D1,D2),MyExpression(D1,D2)) -> MyExpression(D1,D2)
+--R            from MyExpression(D1,D2)
+--R            if D1: SYMBOL and D2 has Join(Ring,OrderedSet,
+--R            IntegralDomain)
+--R   [8] (OutputForm,OutputForm) -> OutputForm from OutputForm
+--R   [9] (OrdinaryWeightedPolynomials(D1,D2,D3,D4),
+--R            OrdinaryWeightedPolynomials(D1,D2,D3,D4)) -> Union(
+--R            OrdinaryWeightedPolynomials(D1,D2,D3,D4),"failed")
+--R            from OrdinaryWeightedPolynomials(D1,D2,D3,D4)
+--R            if D1 has FIELD and D1 has RING and D2: LIST SYMBOL and D3
+--R            : LIST NNI and D4: NNI
+--R   [10] (Pattern D1,Pattern D1) -> Pattern D1 from Pattern D1 if D1 has
+--R            SETCAT
+--R   [11] (Stream D2,Stream D2) -> Stream D2 from 
+--R            StreamTaylorSeriesOperations D2
+--R            if D2 has RING
+--R   [12] (WeightedPolynomials(D1,D2,D3,D4,D5,D6,D7),WeightedPolynomials(
+--R            D1,D2,D3,D4,D5,D6,D7)) -> Union(WeightedPolynomials(D1,D2,D3,D4,
+--R            D5,D6,D7),"failed")
+--R            from WeightedPolynomials(D1,D2,D3,D4,D5,D6,D7)
+--R            if D1 has FIELD and D1 has RING and D2 has ORDSET and D3 
+--R            has OAMONS and D5: LIST D2 and D4 has POLYCAT(D1,D3,D2) and
+--R            D6: LIST NNI and D7: NNI
+--R   [13] (XPolynomialRing(D1,D2),D1) -> XPolynomialRing(D1,D2)
+--R            from XPolynomialRing(D1,D2)
+--R            if D1 has FIELD and D1 has RING and D2 has ORDMON
+--R
+--RExamples of / from AbelianMonoidRing
+--R
+--R
+--RExamples of / from DoubleFloat
+--R
+--R
+--RExamples of / from Equation
+--R
+--R
+--RExamples of / from Field
+--R
+--R
+--RExamples of / from Float
+--R
+--R
+--RExamples of / from FunctionSpace
+--R
+--R
+--RExamples of / from Group
+--R
+--R
+--RExamples of / from InnerNormalBasisFieldFunctions
+--R
+--R
+--RExamples of / from InputForm
+--R
+--R
+--RExamples of / from LocalAlgebra
+--R
+--R
+--RExamples of / from LieAlgebra
+--R
+--R
+--RExamples of / from Localize
+--R
+--R
+--RExamples of / from MappingPackage4
+--R
+--Rp:=(x:EXPR(INT)):EXPR(INT)+->3*x 
+--Rq:=(x:EXPR(INT)):EXPR(INT)+->2*x+3 
+--R(p/q)(4) 
+--R(p/q)(x)
+--R
+--R
+--RExamples of / from MatrixCategory
+--R
+--R
+--RExamples of / from MyExpression
+--R
+--R
+--RExamples of / from OutputForm
+--R
+--R
+--RExamples of / from OrdinaryWeightedPolynomials
+--R
+--R
+--RExamples of / from Pattern
+--R
+--R
+--RExamples of / from QuotientFieldCategory
+--R
+--R
+--RExamples of / from RectangularMatrixCategory
+--R
+--R
+--RExamples of / from StreamTaylorSeriesOperations
+--R
+--R
+--RExamples of / from VectorSpace
+--R
+--R
+--RExamples of / from WeightedPolynomials
+--R
+--R
+--RExamples of / from XPolynomialRing
+--R
+--E 58
+
+--S 59 of 127
+--R)d op integralBasis
+--R 
+--R
+--RThere is one exposed function called integralBasis :
+--R   [1]  -> Vector D from D
+--R            if D2 has UFD and D3 has UPOLYC D2 and D4 has UPOLYC FRAC 
+--R            D3 and D has FFCAT(D2,D3,D4)
+--R
+--RThere are 4 unexposed functions called integralBasis :
+--R   [1]  -> Record(basis: Matrix D2,basisDen: D2,basisInv: Matrix D2)
+--R            from FunctionFieldIntegralBasis(D2,D3,D4)
+--R            if D2 has EuclideanDomain with 
+--R               squareFree : % -> Factored % and D3 has UPOLYC D2 
+--R            and D4 has FRAMALG(D2,D3)
+--R   [2]  -> Record(basis: Matrix Integer,basisDen: Integer,basisInv: 
+--R            Matrix Integer)
+--R            from NumberFieldIntegralBasis(D2,D3)
+--R            if D2 has UPOLYC INT and D3 has FRAMALG(INT,D2)
+--R   [3]  -> Record(basis: Matrix D3,basisDen: D3,basisInv: Matrix D3)
+--R            from PAdicWildFunctionFieldIntegralBasis(D2,D3,D4,D5)
+--R            if D2 has FFIELDC and D3 has UPOLYC D2 and D4 has UPOLYC D3
+--R            and D5 has MONOGEN(D3,D4)
+--R   [4]  -> Record(basis: Matrix D3,basisDen: D3,basisInv: Matrix D3)
+--R            from WildFunctionFieldIntegralBasis(D2,D3,D4,D5)
+--R            if D2 has FFIELDC and D3 has UPOLYC D2 and D4 has UPOLYC D3
+--R            and D5 has FRAMALG(D3,D4)
+--R
+--RExamples of integralBasis from FunctionFieldCategory
+--R
+--RP0 := UnivariatePolynomial(x, Integer) 
+--RP1 := UnivariatePolynomial(y, Fraction P0) 
+--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
+--RintegralBasis()$R
+--R
+--R
+--RExamples of integralBasis from FunctionFieldIntegralBasis
+--R
+--R
+--RExamples of integralBasis from NumberFieldIntegralBasis
+--R
+--R
+--RExamples of integralBasis from PAdicWildFunctionFieldIntegralBasis
+--R
+--R
+--RExamples of integralBasis from WildFunctionFieldIntegralBasis
+--R
+--E 59
+
+--S 60 of 127
+--R)d op split
+--R 
+--R
+--RThere are 8 exposed functions called split :
+--R   [1] D2 -> Factored D2 from AlgFactor D2 if D2 has UPOLYC AN
+--R   [2] (D2,BinarySearchTree D2) -> Record(less: BinarySearchTree D2,
+--R            greater: BinarySearchTree D2)
+--R            from BinarySearchTree D2 if D2 has ORDSET
+--R   [3] IntegrationResult D3 -> IntegrationResult D3
+--R            from IntegrationResultToFunction(D2,D3)
+--R            if D3 has Join(AlgebraicallyClosedFunctionSpace D2,
+--R            TranscendentalFunctionCategory) and D2 has Join(GcdDomain,
+--R            RetractableTo Integer,OrderedSet,LinearlyExplicitRingOver 
+--R            Integer)
+--R   [4] IntegrationResult Fraction Polynomial D2 -> IntegrationResult 
+--R            Fraction Polynomial D2
+--R            from IntegrationResultRFToFunction D2
+--R            if D2 has Join(GcdDomain,RetractableTo Integer,OrderedSet,
+--R            LinearlyExplicitRingOver Integer)
+--R   [5] (List Matrix D4,Vector D4) -> List List Matrix D4
+--R            from RepresentationPackage2 D4 if D4 has FIELD and D4 has 
+--R            RING
+--R   [6] (List Matrix D4,Vector Vector D4) -> List List Matrix D4
+--R            from RepresentationPackage2 D4 if D4 has FIELD and D4 has 
+--R            RING
+--R   [7] (D,CharacterClass) -> List D from D if D has SRAGG
+--R   [8] (D,Character) -> List D from D if D has SRAGG
+--R
+--RThere is one unexposed function called split :
+--R   [1] (D2,(D2 -> D2)) -> Record(normal: D2,special: D2)
+--R            from MonomialExtensionTools(D4,D2)
+--R            if D2 has UPOLYC D4 and D4 has FIELD
+--R
+--RExamples of split from AlgFactor
+--R
+--R
+--RExamples of split from BinarySearchTree
+--R
+--Rt1:=binarySearchTree [1,2,3,4] 
+--Rsplit(3,t1)
+--R
+--R
+--RExamples of split from IntegrationResultToFunction
+--R
+--R
+--RExamples of split from IntegrationResultRFToFunction
+--R
+--R
+--RExamples of split from MonomialExtensionTools
+--R
+--R
+--RExamples of split from RepresentationPackage2
+--R
+--R
+--RExamples of split from StringAggregate
+--R
+--E 60
+
+--S 61 of 127
+--R)d op qelt
+--R 
+--R
+--RThere are 3 exposed functions called qelt :
+--R   [1] (D,Integer,Integer) -> D1 from D
+--R            if D has ARR2CAT(D1,D3,D4) and D3 has FLAGG D1 and D4 has 
+--R            FLAGG D1 and D1 has TYPE
+--R   [2] (D,D2) -> D1 from D
+--R            if D has ELTAGG(D2,D1) and D2 has SETCAT and D1 has TYPE
+--R         
+--R   [3] (D,Integer,Integer) -> D1 from D
+--R            if D has RMATCAT(D3,D4,D1,D5,D6) and D5 has DIRPCAT(D4,D1) 
+--R            and D6 has DIRPCAT(D3,D1) and D1 has RING
+--R
+--RExamples of qelt from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,10) 
+--Rqelt(arr,1,1)
+--R
+--R
+--RExamples of qelt from EltableAggregate
+--R
+--R
+--RExamples of qelt from RectangularMatrixCategory
+--R
+--E 61
+
+--S 62 of 127
+--R)d op mapUp!
+--R 
+--R
+--RThere are 2 exposed functions called mapUp! :
+--R   [1] (BalancedBinaryTree D2,BalancedBinaryTree D2,((D2,D2,D2,D2) -> 
+--R            D2)) -> BalancedBinaryTree D2
+--R            from BalancedBinaryTree D2 if D2 has SETCAT
+--R   [2] (BalancedBinaryTree D1,((D1,D1) -> D1)) -> D1
+--R            from BalancedBinaryTree D1 if D1 has SETCAT
+--R
+--RExamples of mapUp! from BalancedBinaryTree
+--R
+--RT1:=BalancedBinaryTree Integer 
+--Rt2:=balancedBinaryTree(4, 0)$T1 
+--Rsetleaves!(t2,[1,2,3,4]::List(Integer)) 
+--Radder4(i:INT,j:INT,k:INT,l:INT):INT == i+j+k+l 
+--RmapUp!(t2,t2,adder4) 
+--Rt2
+--R
+--RT1:=BalancedBinaryTree Integer 
+--Rt2:=balancedBinaryTree(4, 0)$T1 
+--Rsetleaves!(t2,[1,2,3,4]::List(Integer)) 
+--Radder(a:Integer,b:Integer):Integer == a+b 
+--RmapUp!(t2,adder) 
+--Rt2
+--R
+--E 62
+
+--S 63 of 127
+--R)d op reindex
+--R 
+--R
+--RThere is one exposed function called reindex :
+--R   [1] (CartesianTensor(D2,D3,D4),List Integer) -> CartesianTensor(D2,
+--R            D3,D4)
+--R            from CartesianTensor(D2,D3,D4)
+--R            if D2: INT and D3: NNI and D4 has COMRING
+--R
+--RExamples of reindex from CartesianTensor
+--R
+--Rn:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]] 
+--Rtn:CartesianTensor(1,2,Integer):=n 
+--Rp:=product(tn,tn) 
+--Rreindex(p,[4,3,2,1])
+--R
+--E 63
+
+--S 64 of 127
+--R)d op mapDown!
+--R 
+--R
+--RThere are 2 exposed functions called mapDown! :
+--R   [1] (BalancedBinaryTree D1,D1,((D1,D1,D1) -> List D1)) -> 
+--R            BalancedBinaryTree D1
+--R            from BalancedBinaryTree D1 if D1 has SETCAT
+--R   [2] (BalancedBinaryTree D1,D1,((D1,D1) -> D1)) -> BalancedBinaryTree
+--R            D1
+--R            from BalancedBinaryTree D1 if D1 has SETCAT
+--R
+--RExamples of mapDown! from BalancedBinaryTree
+--R
+--RT1:=BalancedBinaryTree Integer 
+--Rt2:=balancedBinaryTree(4, 0)$T1 
+--Rsetleaves!(t2,[1,2,3,4]::List(Integer)) 
+--Radder3(i:Integer,j:Integer,k:Integer):List Integer == [i+j,j+k] 
+--RmapDown!(t2,4::INT,adder3) 
+--Rt2
+--R
+--RT1:=BalancedBinaryTree Integer 
+--Rt2:=balancedBinaryTree(4, 0)$T1 
+--Rsetleaves!(t2,[1,2,3,4]::List(Integer)) 
+--Radder(i:Integer,j:Integer):Integer == i+j 
+--RmapDown!(t2,4::INT,adder) 
+--Rt2
+--R
+--E 64
+
+--S 65 of 127
+--R)d op nrows
+--R 
+--R
+--RThere are 2 exposed functions called nrows :
+--R   [1] D -> NonNegativeInteger from D
+--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
+--R            D2 and D4 has FLAGG D2
+--R   [2] D -> NonNegativeInteger from D
+--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
+--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
+--R
+--RExamples of nrows from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,10) 
+--Rnrows(arr)
+--R
+--R
+--RExamples of nrows from RectangularMatrixCategory
+--R
+--E 65
+
+--S 66 of 127
+--R)d op row
+--R 
+--R
+--RThere are 2 exposed functions called row :
+--R   [1] (D,Integer) -> D1 from D
+--R            if D has ARR2CAT(D3,D1,D4) and D3 has TYPE and D4 has FLAGG
+--R            D3 and D1 has FLAGG D3
+--R   [2] (D,Integer) -> D1 from D
+--R            if D has RMATCAT(D3,D4,D5,D1,D6) and D5 has RING and D6 has
+--R            DIRPCAT(D3,D5) and D1 has DIRPCAT(D4,D5)
+--R
+--RExamples of row from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,10) 
+--Rrow(arr,1)
+--R
+--R
+--RExamples of row from RectangularMatrixCategory
+--R
+--E 66
+
+--S 67 of 127
+--R)d op ravel
+--R 
+--R
+--RThere is one exposed function called ravel :
+--R   [1] CartesianTensor(D2,D3,D4) -> List D4 from CartesianTensor(D2,D3,
+--R            D4)
+--R            if D2: INT and D3: NNI and D4 has COMRING
+--R
+--RExamples of ravel from CartesianTensor
+--R
+--Rn:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]] 
+--Rtn:CartesianTensor(1,2,Integer):=n 
+--Rravel tn
+--R
+--E 67
+
+--S 68 of 127
+--R)d op inverseIntegralMatrix
+--R 
+--R
+--RThere is one exposed function called inverseIntegralMatrix :
+--R   [1]  -> Matrix Fraction D3 from D
+--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
+--R            D2 and D4 has UPOLYC FRAC D3
+--R
+--RExamples of inverseIntegralMatrix from FunctionFieldCategory
+--R
+--RP0 := UnivariatePolynomial(x, Integer) 
+--RP1 := UnivariatePolynomial(y, Fraction P0) 
+--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
+--RinverseIntegralMatrix()$R
+--R
+--E 68
+
+--S 69 of 127
+--R)d op coerce
+--R 
+--R
+--RThere are 169 exposed functions called coerce :
+--R   [1] D1 -> D from D if D has ALGEBRA D1 and D1 has COMRING
+--R   [2] Vector D2 -> AlgebraGivenByStructuralConstants(D2,D3,D4,D5)
+--R            from AlgebraGivenByStructuralConstants(D2,D3,D4,D5)
+--R            if D2 has FIELD and D5: VECTOR MATRIX D2 and D3: PI and D4
+--R            : LIST SYMBOL
+--R   [3] SparseMultivariatePolynomial(Integer,Kernel AlgebraicNumber) -> 
+--R            AlgebraicNumber
+--R            from AlgebraicNumber
+--R   [4] D2 -> Any from AnyFunctions1 D2 if D2 has TYPE
+--R   [5] Vector FortranExpression([construct,QUOTEJINT,QUOTEX,QUOTEELAM],
+--R            [construct],MachineFloat) -> Asp10 D2
+--R            from Asp10 D2 if D2: SYMBOL
+--R   [6] Vector FortranExpression([construct],[construct,QUOTEXC],
+--R            MachineFloat) -> Asp19 D2
+--R            from Asp19 D2 if D2: SYMBOL
+--R   [7] FortranExpression([construct,QUOTEX],[construct],MachineFloat)
+--R             -> Asp1 D2
+--R            from Asp1 D2 if D2: SYMBOL
+--R   [8] Matrix FortranExpression([construct],[construct,QUOTEX,QUOTEHESS
+--R            ],MachineFloat) -> Asp20 D2
+--R            from Asp20 D2 if D2: SYMBOL
+--R   [9] FortranExpression([construct],[construct,QUOTEXC],MachineFloat)
+--R             -> Asp24 D2
+--R            from Asp24 D2 if D2: SYMBOL
+--R   [10] Vector FortranExpression([construct,QUOTEX],[construct,QUOTEY],
+--R            MachineFloat) -> Asp31 D2
+--R            from Asp31 D2 if D2: SYMBOL
+--R   [11] Vector FortranExpression([construct],[construct,QUOTEX],
+--R            MachineFloat) -> Asp35 D2
+--R            from Asp35 D2 if D2: SYMBOL
+--R   [12] Vector FortranExpression([construct,QUOTEX,QUOTEEPS],[construct
+--R            ,QUOTEY],MachineFloat) -> Asp41(D2,D3,D4)
+--R            from Asp41(D2,D3,D4) if D2: SYMBOL and D3: SYMBOL and D4: 
+--R            SYMBOL
+--R   [13] Vector FortranExpression([construct,QUOTEEPS],[construct,QUOTE
+--R            YA,QUOTEYB],MachineFloat) -> Asp42(D2,D3,D4)
+--R            from Asp42(D2,D3,D4) if D2: SYMBOL and D3: SYMBOL and D4: 
+--R            SYMBOL
+--R   [14] FortranExpression([construct],[construct,QUOTEX],MachineFloat)
+--R             -> Asp49 D2
+--R            from Asp49 D2 if D2: SYMBOL
+--R   [15] FortranExpression([construct],[construct,QUOTEX],MachineFloat)
+--R             -> Asp4 D2
+--R            from Asp4 D2 if D2: SYMBOL
+--R   [16] Vector FortranExpression([construct],[construct,QUOTEXC],
+--R            MachineFloat) -> Asp50 D2
+--R            from Asp50 D2 if D2: SYMBOL
+--R   [17] Vector FortranExpression([construct],[construct,QUOTEX],
+--R            MachineFloat) -> Asp55 D2
+--R            from Asp55 D2 if D2: SYMBOL
+--R   [18] Vector FortranExpression([construct],[construct,QUOTEX],
+--R            MachineFloat) -> Asp6 D2
+--R            from Asp6 D2 if D2: SYMBOL
+--R   [19] Vector FortranExpression([construct,QUOTEX,QUOTEY],[construct],
+--R            MachineFloat) -> Asp73 D2
+--R            from Asp73 D2 if D2: SYMBOL
+--R   [20] Matrix FortranExpression([construct,QUOTEX,QUOTEY],[construct],
+--R            MachineFloat) -> Asp74 D2
+--R            from Asp74 D2 if D2: SYMBOL
+--R   [21] Matrix FortranExpression([construct,QUOTEX],[construct],
+--R            MachineFloat) -> Asp77 D2
+--R            from Asp77 D2 if D2: SYMBOL
+--R   [22] Vector FortranExpression([construct,QUOTEX],[construct],
+--R            MachineFloat) -> Asp78 D2
+--R            from Asp78 D2 if D2: SYMBOL
+--R   [23] Vector FortranExpression([construct,QUOTEX],[construct,QUOTEY],
+--R            MachineFloat) -> Asp7 D2
+--R            from Asp7 D2 if D2: SYMBOL
+--R   [24] Matrix FortranExpression([construct,QUOTEXL,QUOTEXR,QUOTEELAM],
+--R            [construct],MachineFloat) -> Asp80 D2
+--R            from Asp80 D2 if D2: SYMBOL
+--R   [25] FortranExpression([construct,QUOTEX],[construct,QUOTEY],
+--R            MachineFloat) -> Asp9 D2
+--R            from Asp9 D2 if D2: SYMBOL
+--R   [26] BinaryExpansion -> RadixExpansion 2 from BinaryExpansion
+--R   [27] BinaryExpansion -> Fraction Integer from BinaryExpansion
+--R   [28] List CartesianTensor(D2,D3,D4) -> CartesianTensor(D2,D3,D4)
+--R            from CartesianTensor(D2,D3,D4)
+--R            if D2: INT and D3: NNI and D4 has COMRING
+--R   [29] List D4 -> CartesianTensor(D2,D3,D4) from CartesianTensor(D2,D3
+--R            ,D4)
+--R            if D4 has COMRING and D2: INT and D3: NNI
+--R   [30] SquareMatrix(D3,D4) -> CartesianTensor(D2,D3,D4)
+--R            from CartesianTensor(D2,D3,D4)
+--R            if D3: NNI and D4 has COMRING and D2: INT
+--R   [31] DirectProduct(D3,D4) -> CartesianTensor(D2,D3,D4)
+--R            from CartesianTensor(D2,D3,D4)
+--R            if D3: NNI and D4 has COMRING and D2: INT
+--R   [32] List D2 -> Database D2 from Database D2
+--R            if D2 has OrderedSet with 
+--R               ?.? : (%,Symbol) -> String
+--R               display : % -> Void
+--R               fullDisplay : % -> Void
+--R   [33] DecimalExpansion -> RadixExpansion 10 from DecimalExpansion
+--R   [34] DecimalExpansion -> Fraction Integer from DecimalExpansion
+--R   [35] DataList D2 -> List D2 from DataList D2 if D2 has ORDSET
+--R   [36] List D2 -> DataList D2 from DataList D2 if D2 has ORDSET
+--R   [37] SegmentBinding Expression D3 -> SegmentBinding Float
+--R            from DrawNumericHack D3
+--R            if D3 has Join(OrderedSet,IntegralDomain,ConvertibleTo 
+--R            Float)
+--R   [38] D1 -> D from D if D has DVARCAT D1 and D1 has ORDSET
+--R   [39] FortranCode -> OutputForm from FortranCode
+--R   [40] FortranExpression(D2,D3,D4) -> Expression D4
+--R            from FortranExpression(D2,D3,D4)
+--R            if D2: LIST SYMBOL and D3: LIST SYMBOL and D4 has FMTC
+--R   [41] D2 -> D1 from FiniteFieldHomomorphisms(D2,D3,D1)
+--R            if D3 has FFIELDC and D1 has FAXF D3 and D2 has FAXF D3
+--R   [42] D2 -> D1 from FiniteFieldHomomorphisms(D1,D3,D2)
+--R            if D3 has FFIELDC and D1 has FAXF D3 and D2 has FAXF D3
+--R   [43] D -> XRecursivePolynomial(D2,D3) from D
+--R            if D has FLALG(D2,D3) and D2 has ORDSET and D3 has COMRING
+--R            
+--R   [44] D -> XDistributedPolynomial(D2,D3) from D
+--R            if D has FLALG(D2,D3) and D2 has ORDSET and D3 has COMRING
+--R            
+--R   [45] D1 -> D from D
+--R            if D has FLALG(D1,D2) and D1 has ORDSET and D2 has COMRING
+--R            
+--R   [46] Record(localSymbols: SymbolTable,code: List FortranCode) -> D 
+--R            from D
+--R            if D has FMC
+--R   [47] FortranCode -> D from D if D has FMC
+--R   [48] List FortranCode -> D from D if D has FMC
+--R   [49] Matrix MachineFloat -> D from D if D has FMC
+--R   [50] Record(localSymbols: SymbolTable,code: List FortranCode) -> D 
+--R            from D
+--R            if D has FMFUN
+--R   [51] FortranCode -> D from D if D has FMFUN
+--R   [52] List FortranCode -> D from D if D has FMFUN
+--R   [53] D -> String from D if D has FNCAT
+--R   [54] String -> D from D if D has FNCAT
+--R   [55] D2 -> ScriptFormulaFormat from ScriptFormulaFormat1 D2 if D2 
+--R            has SETCAT
+--R   [56] OutputForm -> ScriptFormulaFormat from ScriptFormulaFormat
+--R   [57] Record(localSymbols: SymbolTable,code: List FortranCode) -> D 
+--R            from D
+--R            if D has FORTFN
+--R   [58] FortranCode -> D from D if D has FORTFN
+--R   [59] List FortranCode -> D from D if D has FORTFN
+--R   [60] Equation Expression Complex Float -> FortranProgram(D2,D3,D4,D5
+--R            )
+--R            from FortranProgram(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
+--R            void) and D4: LIST SYMBOL and D5: SYMTAB
+--R   [61] Equation Expression Float -> FortranProgram(D2,D3,D4,D5)
+--R            from FortranProgram(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
+--R            void) and D4: LIST SYMBOL and D5: SYMTAB
+--R   [62] Equation Expression Integer -> FortranProgram(D2,D3,D4,D5)
+--R            from FortranProgram(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
+--R            void) and D4: LIST SYMBOL and D5: SYMTAB
+--R   [63] Expression Complex Float -> FortranProgram(D2,D3,D4,D5)
+--R            from FortranProgram(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
+--R            void) and D4: LIST SYMBOL and D5: SYMTAB
+--R   [64] Expression Float -> FortranProgram(D2,D3,D4,D5)
+--R            from FortranProgram(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
+--R            void) and D4: LIST SYMBOL and D5: SYMTAB
+--R   [65] Expression Integer -> FortranProgram(D2,D3,D4,D5)
+--R            from FortranProgram(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
+--R            void) and D4: LIST SYMBOL and D5: SYMTAB
+--R   [66] Equation Expression MachineComplex -> FortranProgram(D2,D3,D4,
+--R            D5)
+--R            from FortranProgram(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
+--R            void) and D4: LIST SYMBOL and D5: SYMTAB
+--R   [67] Equation Expression MachineFloat -> FortranProgram(D2,D3,D4,D5)
+--R            from FortranProgram(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
+--R            void) and D4: LIST SYMBOL and D5: SYMTAB
+--R   [68] Equation Expression MachineInteger -> FortranProgram(D2,D3,D4,
+--R            D5)
+--R            from FortranProgram(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
+--R            void) and D4: LIST SYMBOL and D5: SYMTAB
+--R   [69] Expression MachineComplex -> FortranProgram(D2,D3,D4,D5)
+--R            from FortranProgram(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
+--R            void) and D4: LIST SYMBOL and D5: SYMTAB
+--R   [70] Expression MachineFloat -> FortranProgram(D2,D3,D4,D5)
+--R            from FortranProgram(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
+--R            void) and D4: LIST SYMBOL and D5: SYMTAB
+--R   [71] Expression MachineInteger -> FortranProgram(D2,D3,D4,D5)
+--R            from FortranProgram(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
+--R            void) and D4: LIST SYMBOL and D5: SYMTAB
+--R   [72] Record(localSymbols: SymbolTable,code: List FortranCode) -> 
+--R            FortranProgram(D2,D3,D4,D5)
+--R            from FortranProgram(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
+--R            void) and D4: LIST SYMBOL and D5: SYMTAB
+--R   [73] List FortranCode -> FortranProgram(D2,D3,D4,D5)
+--R            from FortranProgram(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
+--R            void) and D4: LIST SYMBOL and D5: SYMTAB
+--R   [74] FortranCode -> FortranProgram(D2,D3,D4,D5)
+--R            from FortranProgram(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3: Union(fst: FortranScalarType,void: 
+--R            void) and D4: LIST SYMBOL and D5: SYMTAB
+--R   [75] FourierComponent D3 -> FourierSeries(D2,D3) from FourierSeries(
+--R            D2,D3)
+--R            if D3 has Join(OrderedSet,AbelianGroup) and D2 has Join(
+--R            CommutativeRing,Algebra Fraction Integer)
+--R   [76] D1 -> FourierSeries(D1,D2) from FourierSeries(D1,D2)
+--R            if D1 has Join(CommutativeRing,Algebra Fraction Integer) 
+--R            and D2 has Join(OrderedSet,AbelianGroup)
+--R   [77] Fraction Polynomial Fraction D2 -> D from D
+--R            if D2 has INTDOM and D2 has ORDSET and D has FS D2
+--R   [78] Polynomial Fraction D2 -> D from D
+--R            if D2 has INTDOM and D2 has ORDSET and D has FS D2
+--R   [79] Fraction D2 -> D from D
+--R            if D2 has INTDOM and D2 has ORDSET and D has FS D2
+--R   [80] SparseMultivariatePolynomial(D2,Kernel D) -> D from D
+--R            if D2 has RING and D2 has ORDSET and D has FS D2
+--R   [81] FortranScalarType -> SExpression from FortranScalarType
+--R   [82] FortranScalarType -> Symbol from FortranScalarType
+--R   [83] Symbol -> FortranScalarType from FortranScalarType
+--R   [84] String -> FortranScalarType from FortranScalarType
+--R   [85] FortranScalarType -> FortranType from FortranType
+--R   [86] FortranType -> OutputForm from FortranType
+--R   [87] Record(localSymbols: SymbolTable,code: List FortranCode) -> D 
+--R            from D
+--R            if D has FVC
+--R   [88] FortranCode -> D from D if D has FVC
+--R   [89] List FortranCode -> D from D if D has FVC
+--R   [90] Vector MachineFloat -> D from D if D has FVC
+--R   [91] Record(localSymbols: SymbolTable,code: List FortranCode) -> D 
+--R            from D
+--R            if D has FVFUN
+--R   [92] FortranCode -> D from D if D has FVFUN
+--R   [93] List FortranCode -> D from D if D has FVFUN
+--R   [94] UnivariatePuiseuxSeries(D2,D3,D4) -> 
+--R            GeneralUnivariatePowerSeries(D2,D3,D4)
+--R            from GeneralUnivariatePowerSeries(D2,D3,D4)
+--R            if D2 has RING and D3: SYMBOL and D4: D2
+--R   [95] Variable D3 -> GeneralUnivariatePowerSeries(D2,D3,D4)
+--R            from GeneralUnivariatePowerSeries(D2,D3,D4)
+--R            if D3: SYMBOL and D2 has RING and D4: D2
+--R   [96] HexadecimalExpansion -> RadixExpansion 16 from 
+--R            HexadecimalExpansion
+--R   [97] HexadecimalExpansion -> Fraction Integer from 
+--R            HexadecimalExpansion
+--R   [98] String -> IndexCard from IndexCard
+--R   [99] List D5 -> PolynomialIdeals(D2,D3,D4,D5)
+--R            from PolynomialIdeals(D2,D3,D4,D5)
+--R            if D5 has POLYCAT(D2,D3,D4) and D2 has FIELD and D3 has 
+--R            OAMONS and D4 has ORDSET
+--R   [100] D1 -> AssociatedJordanAlgebra(D2,D1)
+--R            from AssociatedJordanAlgebra(D2,D1)
+--R            if D2 has COMRING and D1 has NAALG D2
+--R   [101] D -> D1 from D if D has KOERCE D1 and D1 has TYPE
+--R   [102] D1 -> D from D if D has LALG D1 and D1 has RING
+--R   [103] D1 -> AssociatedLieAlgebra(D2,D1) from AssociatedLieAlgebra(D2
+--R            ,D1)
+--R            if D2 has COMRING and D1 has NAALG D2
+--R   [104] ThreeDimensionalMatrix D2 -> PrimitiveArray PrimitiveArray 
+--R            PrimitiveArray D2
+--R            from ThreeDimensionalMatrix D2 if D2 has SETCAT
+--R   [105] PrimitiveArray PrimitiveArray PrimitiveArray D2 -> 
+--R            ThreeDimensionalMatrix D2
+--R            from ThreeDimensionalMatrix D2 if D2 has SETCAT
+--R   [106] D2 -> (() -> D2) from MappingPackage1 D2 if D2 has SETCAT
+--R   [107] D1 -> D from D
+--R            if D2 has RING and D has MATCAT(D2,D3,D1) and D3 has FLAGG 
+--R            D2 and D1 has FLAGG D2
+--R   [108] MachineComplex -> Complex Float from MachineComplex
+--R   [109] Complex MachineInteger -> MachineComplex from MachineComplex
+--R         
+--R   [110] Complex MachineFloat -> MachineComplex from MachineComplex
+--R   [111] Complex Integer -> MachineComplex from MachineComplex
+--R   [112] Complex Float -> MachineComplex from MachineComplex
+--R   [113] MachineInteger -> MachineFloat from MachineFloat
+--R   [114] MachineFloat -> Float from MachineFloat
+--R   [115] Expression Integer -> Expression MachineInteger from 
+--R            MachineInteger
+--R   [116] OutputForm -> String from MathMLFormat
+--R   [117] Integer -> D from D if D has NASRING
+--R   [118] Union(nia: Record(var: Symbol,fn: Expression DoubleFloat,range
+--R            : Segment OrderedCompletion DoubleFloat,abserr: DoubleFloat,
+--R            relerr: DoubleFloat),mdnia: Record(fn: Expression DoubleFloat,
+--R            range: List Segment OrderedCompletion DoubleFloat,abserr: 
+--R            DoubleFloat,relerr: DoubleFloat)) -> NumericalIntegrationProblem
+--R            from NumericalIntegrationProblem
+--R   [119] Record(fn: Expression DoubleFloat,range: List Segment 
+--R            OrderedCompletion DoubleFloat,abserr: DoubleFloat,relerr: 
+--R            DoubleFloat) -> NumericalIntegrationProblem
+--R            from NumericalIntegrationProblem
+--R   [120] Record(var: Symbol,fn: Expression DoubleFloat,range: Segment 
+--R            OrderedCompletion DoubleFloat,abserr: DoubleFloat,relerr: 
+--R            DoubleFloat) -> NumericalIntegrationProblem
+--R            from NumericalIntegrationProblem
+--R   [121] NumericalIntegrationProblem -> OutputForm
+--R            from NumericalIntegrationProblem
+--R   [122] D2 -> None from NoneFunctions1 D2 if D2 has TYPE
+--R   [123] Record(xinit: DoubleFloat,xend: DoubleFloat,fn: Vector 
+--R            Expression DoubleFloat,yinit: List DoubleFloat,intvals: List 
+--R            DoubleFloat,g: Expression DoubleFloat,abserr: DoubleFloat,relerr
+--R            : DoubleFloat) -> NumericalODEProblem
+--R            from NumericalODEProblem
+--R   [124] NumericalODEProblem -> OutputForm from NumericalODEProblem
+--R   [125] OrdinaryDifferentialRing(D2,D1,D3) -> D1
+--R            from OrdinaryDifferentialRing(D2,D1,D3)
+--R            if D1 has PDRING D2 and D2 has SETCAT and D3: D2
+--R   [126] D1 -> OrdinaryDifferentialRing(D2,D1,D3)
+--R            from OrdinaryDifferentialRing(D2,D1,D3)
+--R            if D2 has SETCAT and D3: D2 and D1 has PDRING D2
+--R   [127] Symbol -> OpenMathErrorKind from OpenMathErrorKind
+--R   [128] Union(noa: Record(fn: Expression DoubleFloat,init: List 
+--R            DoubleFloat,lb: List OrderedCompletion DoubleFloat,cf: List 
+--R            Expression DoubleFloat,ub: List OrderedCompletion DoubleFloat),
+--R            lsa: Record(lfn: List Expression DoubleFloat,init: List 
+--R            DoubleFloat)) -> NumericalOptimizationProblem
+--R            from NumericalOptimizationProblem
+--R   [129] Record(lfn: List Expression DoubleFloat,init: List DoubleFloat
+--R            ) -> NumericalOptimizationProblem
+--R            from NumericalOptimizationProblem
+--R   [130] Record(fn: Expression DoubleFloat,init: List DoubleFloat,lb: 
+--R            List OrderedCompletion DoubleFloat,cf: List Expression 
+--R            DoubleFloat,ub: List OrderedCompletion DoubleFloat) -> 
+--R            NumericalOptimizationProblem
+--R            from NumericalOptimizationProblem
+--R   [131] NumericalOptimizationProblem -> OutputForm
+--R            from NumericalOptimizationProblem
+--R   [132] Integer -> OrdSetInts from OrdSetInts
+--R   [133] Color -> Palette from Palette
+--R   [134] Polynomial AlgebraicNumber -> Expression Integer
+--R            from PolynomialAN2Expression
+--R   [135] Fraction Polynomial AlgebraicNumber -> Expression Integer
+--R            from PolynomialAN2Expression
+--R   [136] Record(pde: List Expression DoubleFloat,constraints: List 
+--R            Record(start: DoubleFloat,finish: DoubleFloat,grid: 
+--R            NonNegativeInteger,boundaryType: Integer,dStart: Matrix 
+--R            DoubleFloat,dFinish: Matrix DoubleFloat),f: List List Expression 
+--R            DoubleFloat,st: String,tol: DoubleFloat) -> NumericalPDEProblem
+--R            from NumericalPDEProblem
+--R   [137] NumericalPDEProblem -> OutputForm from NumericalPDEProblem
+--R   [138] PendantTree D2 -> Tree D2 from PendantTree D2 if D2 has SETCAT
+--R            
+--R   [139] List Permutation D2 -> PermutationGroup D2 from 
+--R            PermutationGroup D2
+--R            if D2 has SETCAT
+--R   [140] PermutationGroup D2 -> List Permutation D2 from 
+--R            PermutationGroup D2
+--R            if D2 has SETCAT
+--R   [141] List D2 -> Permutation D2 from Permutation D2 if D2 has SETCAT
+--R            
+--R   [142] List List D2 -> Permutation D2 from Permutation D2 if D2 has 
+--R            SETCAT
+--R   [143] Fraction Factored D2 -> PartialFraction D2 from 
+--R            PartialFraction D2
+--R            if D2 has EUCDOM
+--R   [144] PartialFraction D2 -> Fraction D2 from PartialFraction D2
+--R            if D2 has EUCDOM
+--R   [145] Pi -> Expression D3 from PiCoercions D3
+--R            if D3 has Join(OrderedSet,IntegralDomain)
+--R   [146] RadixExpansion D2 -> Fraction Integer from RadixExpansion D2 
+--R            if D2: INT
+--R   [147] D2 -> Void from ResolveLatticeCompletion D2 if D2 has TYPE
+--R   [148] Exit -> D1 from ResolveLatticeCompletion D1 if D1 has TYPE
+--R   [149] D1 -> D from D if D has RETRACT D1 and D1 has TYPE
+--R   [150] D2 -> Fraction Polynomial D2 from RationalFunction D2 if D2 
+--R            has INTDOM
+--R   [151] Integer -> D from D if D has RING
+--R   [152] D -> OutputForm from D if D has SPACEC D2 and D2 has RING
+--R   [153] Character -> D from D if D has SRAGG
+--R   [154] List D2 -> Stream D2 from Stream D2 if D2 has TYPE
+--R   [155] Symbol -> Switch from Switch
+--R   [156] String -> Symbol from Symbol
+--R   [157] SymbolTable -> Table(Symbol,FortranType) from SymbolTable
+--R   [158] Tableau D2 -> OutputForm from Tableau D2 if D2 has SETCAT
+--R   [159] D2 -> TexFormat from TexFormat1 D2 if D2 has SETCAT
+--R   [160] OutputForm -> TexFormat from TexFormat
+--R   [161] Polynomial D2 -> TaylorSeries D2 from TaylorSeries D2 if D2 
+--R            has RING
+--R   [162] Symbol -> TaylorSeries D2 from TaylorSeries D2 if D2 has RING
+--R            
+--R   [163] D1 -> D from D
+--R            if D2 has RING and D has ULSCCAT(D2,D1) and D1 has UTSCAT 
+--R            D2
+--R   [164] Segment D2 -> UniversalSegment D2 from UniversalSegment D2
+--R            if D2 has TYPE
+--R   [165] Variable D2 -> UnivariatePolynomial(D2,D3)
+--R            from UnivariatePolynomial(D2,D3) if D2: SYMBOL and D3 has 
+--R            RING
+--R   [166] D1 -> D from D
+--R            if D2 has RING and D has UPXSCCA(D2,D1) and D1 has ULSCAT 
+--R            D2
+--R   [167] Void -> OutputForm from Void
+--R   [168] D1 -> D from D if D has XALG D1 and D1 has RING
+--R   [169] D1 -> D from D
+--R            if D has XFALG(D1,D2) and D1 has ORDSET and D2 has RING
+--R
+--RThere are 56 unexposed functions called coerce :
+--R   [1] Vector Matrix D3 -> Vector Matrix Fraction Polynomial D3
+--R            from CoerceVectorMatrixPackage D3 if D3 has COMRING
+--R   [2] List Integer -> ExtAlgBasis from ExtAlgBasis
+--R   [3] EuclideanModularRing(D2,D1,D3,D4,D5,D6) -> D1
+--R            from EuclideanModularRing(D2,D1,D3,D4,D5,D6)
+--R            if D1 has UPOLYC D2 and D2 has COMRING and D3 has ABELMON 
+--R            and D4: ((D1,D3) -> D1) and D5: ((D3,D3) -> Union(D3,
+--R            "failed")) and D6: ((D1,D1,D3) -> Union(D1,"failed"))
+--R   [4] UnivariatePuiseuxSeries(D3,D4,D5) -> ExponentialExpansion(D2,D3,
+--R            D4,D5)
+--R            from ExponentialExpansion(D2,D3,D4,D5)
+--R            if D3 has Join(AlgebraicallyClosedField,
+--R            TranscendentalFunctionCategory,FunctionSpace D2) and D4: 
+--R            SYMBOL and D5: D3 and D2 has Join(OrderedSet,RetractableTo 
+--R            Integer,LinearlyExplicitRingOver Integer,GcdDomain)
+--R   [5] Vector Fraction Polynomial D2 -> GenericNonAssociativeAlgebra(D2
+--R            ,D3,D4,D5)
+--R            from GenericNonAssociativeAlgebra(D2,D3,D4,D5)
+--R            if D2 has COMRING and D5: VECTOR MATRIX D2 and D3: PI and 
+--R            D4: LIST SYMBOL
+--R   [6] List List Point DoubleFloat -> GraphImage from GraphImage
+--R   [7] GraphImage -> OutputForm from GraphImage
+--R   [8] SparseMultivariatePolynomial(Integer,Kernel InnerAlgebraicNumber
+--R            ) -> InnerAlgebraicNumber
+--R            from InnerAlgebraicNumber
+--R   [9] LieExponentials(D2,D3,D4) -> XPBWPolynomial(D2,D3)
+--R            from LieExponentials(D2,D3,D4)
+--R            if D2 has ORDSET and D3 has Join(CommutativeRing,Module 
+--R            Fraction Integer) and D4: PI
+--R   [10] LieExponentials(D2,D3,D4) -> XDistributedPolynomial(D2,D3)
+--R            from LieExponentials(D2,D3,D4)
+--R            if D2 has ORDSET and D3 has Join(CommutativeRing,Module 
+--R            Fraction Integer) and D4: PI
+--R   [11] LyndonWord D2 -> Magma D2 from LyndonWord D2 if D2 has ORDSET
+--R         
+--R   [12] LyndonWord D2 -> OrderedFreeMonoid D2 from LyndonWord D2
+--R            if D2 has ORDSET
+--R   [13] Magma D2 -> OrderedFreeMonoid D2 from Magma D2 if D2 has ORDSET
+--R            
+--R   [14] D1 -> MakeCachableSet D1 from MakeCachableSet D1 if D1 has 
+--R            SETCAT
+--R   [15] ModularField(D1,D2,D3,D4,D5) -> D1 from ModularField(D1,D2,D3,
+--R            D4,D5)
+--R            if D1 has COMRING and D2 has ABELMON and D3: ((D1,D2) -> D1
+--R            ) and D4: ((D2,D2) -> Union(D2,"failed")) and D5: ((D1,D1,
+--R            D2) -> Union(D1,"failed"))
+--R   [16] D1 -> ModMonic(D2,D1) from ModMonic(D2,D1)
+--R            if D2 has RING and D1 has UPOLYC D2
+--R   [17] ModuleMonomial(D2,D3,D4) -> Record(index: D2,exponent: D3)
+--R            from ModuleMonomial(D2,D3,D4)
+--R            if D2 has ORDSET and D3 has SETCAT and D4: ((Record(index: 
+--R            D2,exponent: D3),Record(index: D2,exponent: D3)) -> Boolean
+--R            )
+--R   [18] Record(index: D2,exponent: D3) -> ModuleMonomial(D2,D3,D4)
+--R            from ModuleMonomial(D2,D3,D4)
+--R            if D2 has ORDSET and D3 has SETCAT and D4: ((Record(index: 
+--R            D2,exponent: D3),Record(index: D2,exponent: D3)) -> Boolean
+--R            )
+--R   [19] ModularRing(D1,D2,D3,D4,D5) -> D1 from ModularRing(D1,D2,D3,D4,
+--R            D5)
+--R            if D1 has COMRING and D2 has ABELMON and D3: ((D1,D2) -> D1
+--R            ) and D4: ((D2,D2) -> Union(D2,"failed")) and D5: ((D1,D1,
+--R            D2) -> Union(D1,"failed"))
+--R   [20] List Record(coef: D2,monom: D3) -> MonoidRing(D2,D3)
+--R            from MonoidRing(D2,D3) if D2 has RING and D3 has MONOID
+--R   [21] Fraction MyUnivariatePolynomial(D2,D3) -> MyExpression(D2,D3)
+--R            from MyExpression(D2,D3)
+--R            if D2: SYMBOL and D3 has Join(Ring,OrderedSet,
+--R            IntegralDomain)
+--R   [22] Polynomial D3 -> MyUnivariatePolynomial(D2,D3)
+--R            from MyUnivariatePolynomial(D2,D3) if D3 has RING and D2: 
+--R            SYMBOL
+--R   [23] Variable D2 -> MyUnivariatePolynomial(D2,D3)
+--R            from MyUnivariatePolynomial(D2,D3) if D2: SYMBOL and D3 has
+--R            RING
+--R   [24] D1 -> MyUnivariatePolynomial(D2,D1) from MyUnivariatePolynomial
+--R            (D2,D1)
+--R            if D2: SYMBOL and D1 has RING
+--R   [25] Variable D2 -> UnivariateSkewPolynomial(D2,D3,D4,D5)
+--R            from UnivariateSkewPolynomial(D2,D3,D4,D5)
+--R            if D2: SYMBOL and D3 has RING and D4: AUTOMOR D3 and D5: (
+--R            D3 -> D3)
+--R   [26] Polynomial D2 -> OrdinaryWeightedPolynomials(D2,D3,D4,D5)
+--R            from OrdinaryWeightedPolynomials(D2,D3,D4,D5)
+--R            if D2 has RING and D3: LIST SYMBOL and D4: LIST NNI and D5
+--R            : NNI
+--R   [27] OrdinaryWeightedPolynomials(D2,D3,D4,D5) -> Polynomial D2
+--R            from OrdinaryWeightedPolynomials(D2,D3,D4,D5)
+--R            if D2 has RING and D3: LIST SYMBOL and D4: LIST NNI and D5
+--R            : NNI
+--R   [28] D1 -> PoincareBirkhoffWittLyndonBasis D1
+--R            from PoincareBirkhoffWittLyndonBasis D1 if D1 has ORDSET
+--R         
+--R   [29] PoincareBirkhoffWittLyndonBasis D2 -> OrderedFreeMonoid D2
+--R            from PoincareBirkhoffWittLyndonBasis D2 if D2 has ORDSET
+--R         
+--R   [30] Partition -> List Integer from Partition
+--R   [31] D1 -> ResidueRing(D2,D3,D4,D1,D5) from ResidueRing(D2,D3,D4,D1,
+--R            D5)
+--R            if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D1 
+--R            has POLYCAT(D2,D3,D4) and D5: LIST D1
+--R   [32] RectangularMatrix(D2,D3,D4) -> Matrix D4
+--R            from RectangularMatrix(D2,D3,D4)
+--R            if D2: NNI and D3: NNI and D4 has RING
+--R   [33] D1 -> SparseMultivariateTaylorSeries(D2,D3,D1)
+--R            from SparseMultivariateTaylorSeries(D2,D3,D1)
+--R            if D2 has RING and D3 has ORDSET and D1 has POLYCAT(D2,INDE
+--R            D3,D3)
+--R   [34] D1 -> SparseMultivariateTaylorSeries(D2,D1,D3)
+--R            from SparseMultivariateTaylorSeries(D2,D1,D3)
+--R            if D2 has RING and D1 has ORDSET and D3 has POLYCAT(D2,INDE
+--R            D1,D1)
+--R   [35] SquareMatrix(D2,D3) -> Matrix D3 from SquareMatrix(D2,D3)
+--R            if D2: NNI and D3 has RING
+--R   [36] D2 -> Stream D2 from StreamTaylorSeriesOperations D2 if D2 has 
+--R            RING
+--R   [37] Variable D3 -> SparseUnivariateLaurentSeries(D2,D3,D4)
+--R            from SparseUnivariateLaurentSeries(D2,D3,D4)
+--R            if D3: SYMBOL and D2 has RING and D4: D2
+--R   [38] Variable D3 -> SparseUnivariatePuiseuxSeries(D2,D3,D4)
+--R            from SparseUnivariatePuiseuxSeries(D2,D3,D4)
+--R            if D3: SYMBOL and D2 has RING and D4: D2
+--R   [39] Variable D3 -> SparseUnivariateTaylorSeries(D2,D3,D4)
+--R            from SparseUnivariateTaylorSeries(D2,D3,D4)
+--R            if D3: SYMBOL and D2 has RING and D4: D2
+--R   [40] UnivariatePolynomial(D3,D2) -> SparseUnivariateTaylorSeries(D2,
+--R            D3,D4)
+--R            from SparseUnivariateTaylorSeries(D2,D3,D4)
+--R            if D2 has RING and D3: SYMBOL and D4: D2
+--R   [41] PrimitiveArray D2 -> Tuple D2 from Tuple D2 if D2 has TYPE
+--R   [42] Variable QUOTE x -> UnivariateFormalPowerSeries D2
+--R            from UnivariateFormalPowerSeries D2 if D2 has RING
+--R   [43] UnivariatePolynomial(QUOTE x,D2) -> UnivariateFormalPowerSeries
+--R            D2
+--R            from UnivariateFormalPowerSeries D2 if D2 has RING
+--R   [44] Variable D3 -> UnivariateLaurentSeries(D2,D3,D4)
+--R            from UnivariateLaurentSeries(D2,D3,D4)
+--R            if D3: SYMBOL and D2 has RING and D4: D2
+--R   [45] Variable D3 -> UnivariatePuiseuxSeries(D2,D3,D4)
+--R            from UnivariatePuiseuxSeries(D2,D3,D4)
+--R            if D3: SYMBOL and D2 has RING and D4: D2
+--R   [46] Variable D3 -> UnivariateTaylorSeries(D2,D3,D4)
+--R            from UnivariateTaylorSeries(D2,D3,D4)
+--R            if D3: SYMBOL and D2 has RING and D4: D2
+--R   [47] UnivariatePolynomial(D3,D2) -> UnivariateTaylorSeries(D2,D3,D4)
+--R            from UnivariateTaylorSeries(D2,D3,D4)
+--R            if D2 has RING and D3: SYMBOL and D4: D2
+--R   [48] Variable D2 -> Symbol from Variable D2 if D2: SYMBOL
+--R   [49] TwoDimensionalViewport -> OutputForm from 
+--R            TwoDimensionalViewport
+--R   [50] GraphImage -> TwoDimensionalViewport from ViewportPackage
+--R   [51] D1 -> WeightedPolynomials(D2,D3,D4,D1,D5,D6,D7)
+--R            from WeightedPolynomials(D2,D3,D4,D1,D5,D6,D7)
+--R            if D2 has RING and D3 has ORDSET and D4 has OAMONS and D5: 
+--R            LIST D3 and D1 has POLYCAT(D2,D4,D3) and D6: LIST NNI and 
+--R            D7: NNI
+--R   [52] WeightedPolynomials(D2,D3,D4,D1,D5,D6,D7) -> D1
+--R            from WeightedPolynomials(D2,D3,D4,D1,D5,D6,D7)
+--R            if D1 has POLYCAT(D2,D4,D3) and D2 has RING and D3 has 
+--R            ORDSET and D4 has OAMONS and D5: LIST D3 and D6: LIST NNI 
+--R            and D7: NNI
+--R   [53] XPBWPolynomial(D2,D3) -> XRecursivePolynomial(D2,D3)
+--R            from XPBWPolynomial(D2,D3) if D2 has ORDSET and D3 has 
+--R            COMRING
+--R   [54] XPBWPolynomial(D2,D3) -> XDistributedPolynomial(D2,D3)
+--R            from XPBWPolynomial(D2,D3) if D2 has ORDSET and D3 has 
+--R            COMRING
+--R   [55] LiePolynomial(D2,D3) -> XPBWPolynomial(D2,D3)
+--R            from XPBWPolynomial(D2,D3) if D2 has ORDSET and D3 has 
+--R            COMRING
+--R   [56] D1 -> XPolynomialRing(D2,D1) from XPolynomialRing(D2,D1)
+--R            if D2 has RING and D1 has ORDMON
+--R
+--RExamples of coerce from Algebra
+--R
+--R
+--RExamples of coerce from AlgebraGivenByStructuralConstants
+--R
+--R
+--RExamples of coerce from AlgebraicNumber
+--R
+--R
+--RExamples of coerce from AnyFunctions1
+--R
+--R
+--RExamples of coerce from Asp10
+--R
+--R
+--RExamples of coerce from Asp19
+--R
+--R
+--RExamples of coerce from Asp1
+--R
+--R
+--RExamples of coerce from Asp20
+--R
+--R
+--RExamples of coerce from Asp24
+--R
+--R
+--RExamples of coerce from Asp31
+--R
+--R
+--RExamples of coerce from Asp35
+--R
+--R
+--RExamples of coerce from Asp41
+--R
+--R
+--RExamples of coerce from Asp42
+--R
+--R
+--RExamples of coerce from Asp49
+--R
+--R
+--RExamples of coerce from Asp4
+--R
+--R
+--RExamples of coerce from Asp50
+--R
+--R
+--RExamples of coerce from Asp55
+--R
+--R
+--RExamples of coerce from Asp6
+--R
+--R
+--RExamples of coerce from Asp73
+--R
+--R
+--RExamples of coerce from Asp74
+--R
+--R
+--RExamples of coerce from Asp77
+--R
+--R
+--RExamples of coerce from Asp78
+--R
+--R
+--RExamples of coerce from Asp7
+--R
+--R
+--RExamples of coerce from Asp80
+--R
+--R
+--RExamples of coerce from Asp9
+--R
+--R
+--RExamples of coerce from BinaryExpansion
+--R
+--R
+--RExamples of coerce from CartesianTensor
+--R
+--Rv:=[2,3] 
+--Rtv:CartesianTensor(1,2,Integer):=v 
+--Rtm:CartesianTensor(1,2,Integer):=[tv,tv]
+--R
+--Rv:=[2,3] 
+--Rtv:CartesianTensor(1,2,Integer):=v
+--R
+--Rv:SquareMatrix(2,Integer):=[[1,2],[3,4]] 
+--Rtv:CartesianTensor(1,2,Integer):=v
+--R
+--Rv:DirectProduct(2,Integer):=directProduct [3,4] 
+--Rtv:CartesianTensor(1,2,Integer):=v
+--R
+--R
+--RExamples of coerce from CoerceVectorMatrixPackage
+--R
+--R
+--RExamples of coerce from Database
+--R
+--R
+--RExamples of coerce from DecimalExpansion
+--R
+--R
+--RExamples of coerce from DataList
+--R
+--R
+--RExamples of coerce from DrawNumericHack
+--R
+--R
+--RExamples of coerce from DifferentialVariableCategory
+--R
+--R
+--RExamples of coerce from ExtAlgBasis
+--R
+--R
+--RExamples of coerce from EuclideanModularRing
+--R
+--R
+--RExamples of coerce from ExponentialExpansion
+--R
+--R
+--RExamples of coerce from FortranCode
+--R
+--R
+--RExamples of coerce from FortranExpression
+--R
+--R
+--RExamples of coerce from FiniteFieldHomomorphisms
+--R
+--R
+--RExamples of coerce from FreeLieAlgebra
+--R
+--R
+--RExamples of coerce from FortranMatrixCategory
+--R
+--R
+--RExamples of coerce from FortranMatrixFunctionCategory
+--R
+--R
+--RExamples of coerce from FileNameCategory
+--R
+--R
+--RExamples of coerce from ScriptFormulaFormat1
+--R
+--R
+--RExamples of coerce from ScriptFormulaFormat
+--R
+--R
+--RExamples of coerce from FortranFunctionCategory
+--R
+--R
+--RExamples of coerce from FortranProgram
+--R
+--R
+--RExamples of coerce from FourierSeries
+--R
+--R
+--RExamples of coerce from FunctionSpace
+--R
+--R
+--RExamples of coerce from FortranScalarType
+--R
+--R
+--RExamples of coerce from FortranType
+--R
+--R
+--RExamples of coerce from FortranVectorCategory
+--R
+--R
+--RExamples of coerce from FortranVectorFunctionCategory
+--R
+--R
+--RExamples of coerce from GenericNonAssociativeAlgebra
+--R
+--R
+--RExamples of coerce from GraphImage
+--R
+--R
+--RExamples of coerce from GeneralUnivariatePowerSeries
+--R
+--R
+--RExamples of coerce from HexadecimalExpansion
+--R
+--R
+--RExamples of coerce from InnerAlgebraicNumber
+--R
+--R
+--RExamples of coerce from IndexCard
+--R
+--R
+--RExamples of coerce from PolynomialIdeals
+--R
+--R
+--RExamples of coerce from AssociatedJordanAlgebra
+--R
+--R
+--RExamples of coerce from CoercibleTo
+--R
+--R
+--RExamples of coerce from LeftAlgebra
+--R
+--R
+--RExamples of coerce from LieExponentials
+--R
+--R
+--RExamples of coerce from AssociatedLieAlgebra
+--R
+--R
+--RExamples of coerce from LyndonWord
+--R
+--R
+--RExamples of coerce from ThreeDimensionalMatrix
+--R
+--R
+--RExamples of coerce from Magma
+--R
+--R
+--RExamples of coerce from MappingPackage1
+--R
+--R
+--RExamples of coerce from MatrixCategory
+--R
+--R
+--RExamples of coerce from MachineComplex
+--R
+--R
+--RExamples of coerce from MachineFloat
+--R
+--R
+--RExamples of coerce from MachineInteger
+--R
+--R
+--RExamples of coerce from MakeCachableSet
+--R
+--R
+--RExamples of coerce from MathMLFormat
+--R
+--R
+--RExamples of coerce from ModularField
+--R
+--R
+--RExamples of coerce from ModMonic
+--R
+--R
+--RExamples of coerce from ModuleMonomial
+--R
+--R
+--RExamples of coerce from ModularRing
+--R
+--R
+--RExamples of coerce from MonoidRing
+--R
+--R
+--RExamples of coerce from MyExpression
+--R
+--R
+--RExamples of coerce from MyUnivariatePolynomial
+--R
+--R
+--RExamples of coerce from NonAssociativeRing
+--R
+--R
+--RExamples of coerce from NumericalIntegrationProblem
+--R
+--R
+--RExamples of coerce from NoneFunctions1
+--R
+--R
+--RExamples of coerce from NumericalODEProblem
+--R
+--R
+--RExamples of coerce from OrdinaryDifferentialRing
+--R
+--R
+--RExamples of coerce from OpenMathErrorKind
+--R
+--R
+--RExamples of coerce from NumericalOptimizationProblem
+--R
+--R
+--RExamples of coerce from UnivariateSkewPolynomial
+--R
+--R
+--RExamples of coerce from OrdSetInts
+--R
+--R
+--RExamples of coerce from OrdinaryWeightedPolynomials
+--R
+--R
+--RExamples of coerce from Palette
+--R
+--R
+--RExamples of coerce from PolynomialAN2Expression
+--R
+--R
+--RExamples of coerce from PoincareBirkhoffWittLyndonBasis
+--R
+--R
+--RExamples of coerce from NumericalPDEProblem
+--R
+--R
+--RExamples of coerce from PendantTree
+--R
+--Rt1:=ptree([1,2,3]) 
+--Rt2:=ptree(t1,ptree([1,2,3])) 
+--Rt2::Tree List PositiveInteger
+--R
+--R
+--RExamples of coerce from PermutationGroup
+--R
+--R
+--RExamples of coerce from Permutation
+--R
+--R
+--RExamples of coerce from PartialFraction
+--R
+--R
+--RExamples of coerce from PiCoercions
+--R
+--R
+--RExamples of coerce from Partition
+--R
+--R
+--RExamples of coerce from RadixExpansion
+--R
+--R
+--RExamples of coerce from ResolveLatticeCompletion
+--R
+--R
+--RExamples of coerce from ResidueRing
+--R
+--R
+--RExamples of coerce from RetractableTo
+--R
+--R
+--RExamples of coerce from RationalFunction
+--R
+--R
+--RExamples of coerce from Ring
+--R
+--R
+--RExamples of coerce from RectangularMatrix
+--R
+--R
+--RExamples of coerce from SparseMultivariateTaylorSeries
+--R
+--R
+--RExamples of coerce from ThreeSpaceCategory
+--R
+--R
+--RExamples of coerce from SquareMatrix
+--R
+--R
+--RExamples of coerce from StringAggregate
+--R
+--R
+--RExamples of coerce from Stream
+--R
+--Rm:=[1,2,3,4,5,6,7,8,9,10,11,12] 
+--Rcoerce(m)@Stream(Integer) 
+--Rm::Stream(Integer)
+--R
+--R
+--RExamples of coerce from StreamTaylorSeriesOperations
+--R
+--R
+--RExamples of coerce from SparseUnivariateLaurentSeries
+--R
+--R
+--RExamples of coerce from SparseUnivariatePuiseuxSeries
+--R
+--R
+--RExamples of coerce from SparseUnivariateTaylorSeries
+--R
+--R
+--RExamples of coerce from Switch
+--R
+--R
+--RExamples of coerce from Symbol
+--R
+--R
+--RExamples of coerce from SymbolTable
+--R
+--R
+--RExamples of coerce from Tableau
+--R
+--R
+--RExamples of coerce from TexFormat1
+--R
+--R
+--RExamples of coerce from TexFormat
+--R
+--R
+--RExamples of coerce from TaylorSeries
+--R
+--R
+--RExamples of coerce from Tuple
+--R
+--Rt1:PrimitiveArray(Integer):= [i for i in 1..10] 
+--Rt2:=coerce(t1)$Tuple(Integer)
+--R
+--R
+--RExamples of coerce from UnivariateFormalPowerSeries
+--R
+--R
+--RExamples of coerce from UnivariateLaurentSeriesConstructorCategory
+--R
+--R
+--RExamples of coerce from UnivariateLaurentSeries
+--R
+--R
+--RExamples of coerce from UniversalSegment
+--R
+--R
+--RExamples of coerce from UnivariatePolynomial
+--R
+--R
+--RExamples of coerce from UnivariatePuiseuxSeriesConstructorCategory
+--R
+--R
+--RExamples of coerce from UnivariatePuiseuxSeries
+--R
+--R
+--RExamples of coerce from UnivariateTaylorSeries
+--R
+--R
+--RExamples of coerce from Variable
+--R
+--R
+--RExamples of coerce from TwoDimensionalViewport
+--R
+--R
+--RExamples of coerce from ViewportPackage
+--R
+--R
+--RExamples of coerce from Void
+--R
+--R
+--RExamples of coerce from WeightedPolynomials
+--R
+--R
+--RExamples of coerce from XAlgebra
+--R
+--R
+--RExamples of coerce from XFreeAlgebra
+--R
+--R
+--RExamples of coerce from XPBWPolynomial
+--R
+--R
+--RExamples of coerce from XPolynomialRing
+--R
+--E 69
+
+--S 70 of 127
+--R)d op contract
+--R 
+--R
+--RThere are 3 exposed functions called contract :
+--R   [1] (CartesianTensor(D2,D3,D4),Integer,Integer) -> CartesianTensor(
+--R            D2,D3,D4)
+--R            from CartesianTensor(D2,D3,D4)
+--R            if D2: INT and D3: NNI and D4 has COMRING
+--R   [2] (CartesianTensor(D2,D3,D4),Integer,CartesianTensor(D2,D3,D4),
+--R            Integer) -> CartesianTensor(D2,D3,D4)
+--R            from CartesianTensor(D2,D3,D4)
+--R            if D2: INT and D3: NNI and D4 has COMRING
+--R   [3] (PolynomialIdeals(Fraction Integer,DirectProduct(D4,
+--R            NonNegativeInteger),OrderedVariableList D3,
+--R            DistributedMultivariatePolynomial(D3,Fraction Integer)),List 
+--R            OrderedVariableList D3) -> PolynomialIdeals(Fraction Integer,
+--R            DirectProduct(D4,NonNegativeInteger),OrderedVariableList D3,
+--R            DistributedMultivariatePolynomial(D3,Fraction Integer))
+--R            from IdealDecompositionPackage(D3,D4)
+--R            if D3: LIST SYMBOL and D4: NNI
+--R
+--RExamples of contract from CartesianTensor
+--R
+--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
+--RTm:CartesianTensor(1,2,Integer):=m 
+--Rv:DirectProduct(2,Integer):=directProduct [3,4] 
+--RTv:CartesianTensor(1,2,Integer):=v 
+--RTmv:=contract(Tm,2,1)
+--R
+--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
+--RTm:CartesianTensor(1,2,Integer):=m 
+--Rv:DirectProduct(2,Integer):=directProduct [3,4] 
+--RTv:CartesianTensor(1,2,Integer):=v 
+--RTmv:=contract(Tm,2,Tv,1)
+--R
+--R
+--RExamples of contract from IdealDecompositionPackage
+--R
+--E 70
+
+--S 71 of 127
+--R)d op irreducibleFactor
+--R 
+--R
+--RThere is one exposed function called irreducibleFactor :
+--R   [1] (D1,Integer) -> Factored D1 from Factored D1 if D1 has INTDOM
+--R         
+--R
+--RExamples of irreducibleFactor from Factored
+--R
+--Ra:=irreducibleFactor(3,1) 
+--RnthFlag(a,1)
+--R
+--E 71
+
+--S 72 of 127
+--R)d op concat
+--R 
+--R
+--RThere are 10 exposed functions called concat :
+--R   [1] (Result,Result) -> Result from ExpertSystemToolsPackage
+--R   [2] List Result -> Result from ExpertSystemToolsPackage
+--R   [3] List D -> D from D if D has LNAGG D2 and D2 has TYPE
+--R   [4] (D,D) -> D from D if D has LNAGG D1 and D1 has TYPE
+--R   [5] (D1,D) -> D from D if D has LNAGG D1 and D1 has TYPE
+--R   [6] (D,D1) -> D from D if D has LNAGG D1 and D1 has TYPE
+--R   [7] (RoutinesTable,RoutinesTable) -> RoutinesTable from 
+--R            RoutinesTable
+--R   [8] Stream Stream D3 -> Stream D3 from StreamFunctions1 D3 if D3 has
+--R            TYPE
+--R   [9] (D1,D) -> D from D if D has URAGG D1 and D1 has TYPE
+--R   [10] (D,D) -> D from D if D has URAGG D1 and D1 has TYPE
+--R
+--RExamples of concat from ExpertSystemToolsPackage
+--R
+--R
+--RExamples of concat from LinearAggregate
+--R
+--R
+--RExamples of concat from RoutinesTable
+--R
+--R
+--RExamples of concat from StreamFunctions1
+--R
+--Rm:=[i for i in 10..] 
+--Rn:=[j for j in 1.. | prime? j] 
+--Rp:=[m,n]::Stream(Stream(PositiveInteger)) 
+--Rconcat(p)
+--R
+--R
+--RExamples of concat from UnaryRecursiveAggregate
+--R
+--E 72
+
+--S 73 of 127
+--R)d op binaryTournament
+--R 
+--R
+--RThere is one exposed function called binaryTournament :
+--R   [1] List D2 -> BinaryTournament D2 from BinaryTournament D2 if D2 
+--R            has ORDSET
+--R
+--RExamples of binaryTournament from BinaryTournament
+--R
+--RbinaryTournament [1,2,3,4]
+--R
+--E 73
+
+--S 74 of 127
+--R)d op upperCase
+--R 
+--R
+--RThere are 3 exposed functions called upperCase :
+--R   [1]  -> CharacterClass from CharacterClass
+--R   [2] Character -> Character from Character
+--R   [3] D -> D from D if D has SRAGG
+--R
+--RExamples of upperCase from CharacterClass
+--R
+--R
+--RExamples of upperCase from Character
+--R
+--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
+--R[upperCase c for c in chars]
+--R
+--R
+--RExamples of upperCase from StringAggregate
+--R
+--E 74
+
+--S 75 of 127
+--R)d op exponent
+--R 
+--R
+--RThere are 3 exposed functions called exponent :
+--R   [1] D -> Integer from D if D has FPS
+--R   [2] Factored D2 -> Integer from Factored D2 if D2 has INTDOM
+--R   [3] MachineFloat -> Integer from MachineFloat
+--R
+--RThere are 2 unexposed functions called exponent :
+--R   [1] ExponentialOfUnivariatePuiseuxSeries(D2,D3,D4) -> 
+--R            UnivariatePuiseuxSeries(D2,D3,D4)
+--R            from ExponentialOfUnivariatePuiseuxSeries(D2,D3,D4)
+--R            if D2 has Join(Field,OrderedSet) and D3: SYMBOL and D4: D2
+--R            
+--R   [2] ModuleMonomial(D2,D1,D3) -> D1 from ModuleMonomial(D2,D1,D3)
+--R            if D1 has SETCAT and D2 has ORDSET and D3: ((Record(index: 
+--R            D2,exponent: D1),Record(index: D2,exponent: D1)) -> Boolean
+--R            )
+--R
+--RExamples of exponent from ExponentialOfUnivariatePuiseuxSeries
+--R
+--R
+--RExamples of exponent from FloatingPointSystem
+--R
+--R
+--RExamples of exponent from Factored
+--R
+--Rf:=nilFactor(y-x,3) 
+--Rexponent(f)
+--R
+--R
+--RExamples of exponent from MachineFloat
+--R
+--R
+--RExamples of exponent from ModuleMonomial
+--R
+--E 75
+
+--S 76 of 127
+--R)d op setRow!
+--R 
+--R
+--RThere is one exposed function called setRow! :
+--R   [1] (D,Integer,D2) -> D from D
+--R            if D has ARR2CAT(D3,D2,D4) and D3 has TYPE and D2 has FLAGG
+--R            D3 and D4 has FLAGG D3
+--R
+--RExamples of setRow! from TwoDimensionalArrayCategory
+--R
+--RT1:=TwoDimensionalArray Integer 
+--Rarr:T1:= new(5,4,0) 
+--RT2:=OneDimensionalArray Integer 
+--Rarow:=construct([1,2,3,4]::List(INT))$T2 
+--RsetRow!(arr,1,arow)$T1
+--R
+--E 76
+
+--S 77 of 127
+--R)d op generate
+--R 
+--R
+--RThere are 4 exposed functions called generate :
+--R   [1] (NonNegativeInteger,NonNegativeInteger) -> Vector List Integer
+--R            from HallBasis
+--R   [2] ((D2 -> D2),D2) -> InfiniteTuple D2 from InfiniteTuple D2 if D2 
+--R            has TYPE
+--R   [3] ((D2 -> D2),D2) -> Stream D2 from Stream D2 if D2 has TYPE
+--R   [4] (() -> D2) -> Stream D2 from Stream D2 if D2 has TYPE
+--R
+--RExamples of generate from HallBasis
+--R
+--R
+--RExamples of generate from InfiniteTuple
+--R
+--R
+--RExamples of generate from Stream
+--R
+--Rf(x:Integer):Integer == x+10 
+--Rgenerate(f,10)
+--R
+--Rf():Integer == 1 
+--Rgenerate(f)
+--R
+--E 77
+
+--S 78 of 127
+--R)d op gcd
+--R 
+--R
+--RThere are 6 exposed functions called gcd :
+--R   [1] List D -> D from D if D has GCDDOM
+--R   [2] (D,D) -> D from D if D has GCDDOM
+--R   [3] (D1,D1,Integer) -> D1 from ModularDistinctDegreeFactorizer D1
+--R            if D1 has UPOLYC INT
+--R   [4] (NonNegativeInteger,NonNegativeInteger) -> NonNegativeInteger
+--R            from NonNegativeInteger
+--R   [5] (PositiveInteger,PositiveInteger) -> PositiveInteger
+--R            from PositiveInteger
+--R   [6] (D1,D) -> D1 from D
+--R            if D has RPOLCAT(D1,D2,D3) and D1 has RING and D2 has 
+--R            OAMONS and D3 has ORDSET and D1 has GCDDOM
+--R
+--RThere are 6 unexposed functions called gcd :
+--R   [1] List D1 -> D1 from HeuGcd D1 if D1 has UPOLYC INT
+--R   [2] (D1,D1) -> D1 from PolynomialGcdPackage(D2,D3,D4,D1)
+--R            if D2 has OAMONS and D3 has ORDSET and D4 has EUCDOM and D1
+--R            has POLYCAT(D4,D2,D3)
+--R   [3] List D1 -> D1 from PolynomialGcdPackage(D3,D4,D5,D1)
+--R            if D1 has POLYCAT(D5,D3,D4) and D3 has OAMONS and D4 has 
+--R            ORDSET and D5 has EUCDOM
+--R   [4] (SparseUnivariatePolynomial D5,SparseUnivariatePolynomial D5)
+--R             -> SparseUnivariatePolynomial D5
+--R            from PolynomialGcdPackage(D2,D3,D4,D5)
+--R            if D5 has POLYCAT(D4,D2,D3) and D2 has OAMONS and D3 has 
+--R            ORDSET and D4 has EUCDOM
+--R   [5] List SparseUnivariatePolynomial D6 -> SparseUnivariatePolynomial
+--R            D6
+--R            from PolynomialGcdPackage(D3,D4,D5,D6)
+--R            if D3 has OAMONS and D4 has ORDSET and D5 has EUCDOM and D6
+--R            has POLYCAT(D5,D3,D4)
+--R   [6] (D1,D1) -> D1 from PseudoRemainderSequence(D2,D1)
+--R            if D2 has GCDDOM and D2 has INTDOM and D1 has UPOLYC D2
+--R
+--RExamples of gcd from GcdDomain
+--R
+--R
+--RExamples of gcd from HeuGcd
+--R
+--Rgcd([671*671*x^2-1,671*671*x^2+2*671*x+1]) 
+--Rgcd([7*x^2+1,(7*x^2+1)^2])
+--R
+--R
+--RExamples of gcd from ModularDistinctDegreeFactorizer
+--R
+--R
+--RExamples of gcd from NonNegativeInteger
+--R
+--R
+--RExamples of gcd from PolynomialGcdPackage
+--R
+--R
+--RExamples of gcd from PositiveInteger
+--R
+--R
+--RExamples of gcd from PseudoRemainderSequence
+--R
+--R
+--RExamples of gcd from RecursivePolynomialCategory
+--R
+--E 78
+
+--S 79 of 127
+--R)d op binary
+--R 
+--R
+--RThere is one exposed function called binary :
+--R   [1] Fraction Integer -> BinaryExpansion from BinaryExpansion
+--R
+--RThere is one unexposed function called binary :
+--R   [1] (InputForm,List InputForm) -> InputForm from InputForm
+--R
+--RExamples of binary from BinaryExpansion
+--R
+--Rbinary(22/7)
+--R
+--R
+--RExamples of binary from InputForm
+--R
+--Ra:=[1,2,3]::List(InputForm) 
+--Rbinary(_+::InputForm,a)
+--R
+--E 79
+
+--S 80 of 127
+--R)d op expand
+--R 
+--R
+--RThere are 6 exposed functions called expand :
+--R   [1] Factored D1 -> D1 from Factored D1 if D1 has INTDOM
+--R   [2] IntegrationResult D4 -> List D4 from IntegrationResultToFunction
+--R            (D3,D4)
+--R            if D4 has Join(AlgebraicallyClosedFunctionSpace D3,
+--R            TranscendentalFunctionCategory) and D3 has Join(GcdDomain,
+--R            RetractableTo Integer,OrderedSet,LinearlyExplicitRingOver 
+--R            Integer)
+--R   [3] IntegrationResult Fraction Polynomial D3 -> List Expression D3
+--R            from IntegrationResultRFToFunction D3
+--R            if D3 has Join(GcdDomain,RetractableTo Integer,OrderedSet,
+--R            LinearlyExplicitRingOver Integer)
+--R   [4] D -> D1 from D
+--R            if D has SEGXCAT(D2,D1) and D2 has ORDRING and D1 has STAGG
+--R            D2
+--R   [5] List D -> D1 from D
+--R            if D has SEGXCAT(D3,D1) and D3 has ORDRING and D1 has STAGG
+--R            D3
+--R   [6] D1 -> D1 from TranscendentalManipulations(D2,D1)
+--R            if D2 has Join(OrderedSet,GcdDomain) and D1 has Join(
+--R            FunctionSpace D2,TranscendentalFunctionCategory)
+--R
+--RThere are 3 unexposed functions called expand :
+--R   [1] (Expression D5,PositiveInteger) -> List Expression D5
+--R            from DegreeReductionPackage(D4,D5)
+--R            if D5 has Join(IntegralDomain,OrderedSet) and D4 has RING
+--R         
+--R   [2] XPolynomial D2 -> XDistributedPolynomial(Symbol,D2) from 
+--R            XPolynomial D2
+--R            if D2 has RING
+--R   [3] XRecursivePolynomial(D2,D3) -> XDistributedPolynomial(D2,D3)
+--R            from XRecursivePolynomial(D2,D3)
+--R            if D2 has ORDSET and D3 has RING
+--R
+--RExamples of expand from DegreeReductionPackage
+--R
+--R
+--RExamples of expand from Factored
+--R
+--Rf:=nilFactor(y-x,3) 
+--Rexpand(f)
+--R
+--R
+--RExamples of expand from IntegrationResultToFunction
+--R
+--R
+--RExamples of expand from IntegrationResultRFToFunction
+--R
+--R
+--RExamples of expand from SegmentExpansionCategory
+--R
+--R
+--RExamples of expand from TranscendentalManipulations
+--R
+--R
+--RExamples of expand from XPolynomial
+--R
+--R
+--RExamples of expand from XRecursivePolynomial
+--R
+--E 80
+
+--S 81 of 127
+--R)d op filterWhile
+--R 
+--R
+--RThere are 2 exposed functions called filterWhile :
+--R   [1] ((D2 -> Boolean),InfiniteTuple D2) -> InfiniteTuple D2
+--R            from InfiniteTuple D2 if D2 has TYPE
+--R   [2] ((D2 -> Boolean),Stream D2) -> Stream D2 from Stream D2 if D2 
+--R            has TYPE
+--R
+--RExamples of filterWhile from InfiniteTuple
+--R
+--R
+--RExamples of filterWhile from Stream
+--R
+--Rm:=[i for i in 1..] 
+--Rf(x:PositiveInteger):Boolean == x < 5 
+--RfilterWhile(f,m)
+--R
+--E 81
+
+--S 82 of 127
+--R)d op filterUntil
+--R 
+--R
+--RThere are 2 exposed functions called filterUntil :
+--R   [1] ((D2 -> Boolean),InfiniteTuple D2) -> InfiniteTuple D2
+--R            from InfiniteTuple D2 if D2 has TYPE
+--R   [2] ((D2 -> Boolean),Stream D2) -> Stream D2 from Stream D2 if D2 
+--R            has TYPE
+--R
+--RExamples of filterUntil from InfiniteTuple
+--R
+--R
+--RExamples of filterUntil from Stream
+--R
+--Rm:=[i for i in 1..] 
+--Rf(x:PositiveInteger):Boolean == x < 5 
+--RfilterUntil(f,m)
+--R
+--E 82
+
+--S 83 of 127
+--R)d op select
+--R 
+--R
+--RThere are 4 exposed functions called select :
+--R   [1] ((D2 -> Boolean),D) -> D from D
+--R            if D has finiteAggregate and D has CLAGG D2 and D2 has TYPE
+--R            
+--R   [2] ((D2 -> Boolean),InfiniteTuple D2) -> InfiniteTuple D2
+--R            from InfiniteTuple D2 if D2 has TYPE
+--R   [3] ((D2 -> Boolean),D) -> D from D if D has LZSTAGG D2 and D2 has 
+--R            TYPE
+--R   [4] (D,D2) -> Union(D1,"failed") from D
+--R            if D has TSETCAT(D3,D4,D2,D1) and D3 has INTDOM and D4 has 
+--R            OAMONS and D2 has ORDSET and D1 has RPOLCAT(D3,D4,D2)
+--R
+--RThere is one unexposed function called select :
+--R   [1] (Tuple D1,NonNegativeInteger) -> D1 from Tuple D1 if D1 has TYPE
+--R            
+--R
+--RExamples of select from Collection
+--R
+--R
+--RExamples of select from InfiniteTuple
+--R
+--R
+--RExamples of select from LazyStreamAggregate
+--R
+--Rm:=[i for i in 0..] 
+--Rselect(x+->prime? x,m)
+--R
+--R
+--RExamples of select from TriangularSetCategory
+--R
+--R
+--RExamples of select from Tuple
+--R
+--Rt1:PrimitiveArray(Integer):= [i for i in 1..10] 
+--Rt2:=coerce(t1)$Tuple(Integer) 
+--Rselect(t2,3)
+--R
+--E 83
+
+--S 84 of 127
+--R)d op nthFlag
+--R 
+--R
+--RThere is one exposed function called nthFlag :
+--R   [1] (Factored D3,Integer) -> Union("nil","sqfr","irred","prime")
+--R            from Factored D3 if D3 has INTDOM
+--R
+--RExamples of nthFlag from Factored
+--R
+--Ra:=factor 9720000 
+--RnthFlag(a,2)
+--R
+--E 84
+
+--S 85 of 127
+--R)d op makeFR
+--R 
+--R
+--RThere is one exposed function called makeFR :
+--R   [1] (D1,List Record(flg: Union("nil","sqfr","irred","prime"),fctr: 
+--R            D1,xpnt: Integer)) -> Factored D1
+--R            from Factored D1 if D1 has INTDOM
+--R
+--RThere is one unexposed function called makeFR :
+--R   [1] Record(contp: Integer,factors: List Record(irr: D3,pow: Integer)
+--R            ) -> Factored D3
+--R            from GaloisGroupFactorizer D3 if D3 has UPOLYC INT
+--R
+--RExamples of makeFR from Factored
+--R
+--Rf:=nilFactor(x-y,3) 
+--Rg:=factorList f 
+--RmakeFR(z,g)
+--R
+--R
+--RExamples of makeFR from GaloisGroupFactorizer
+--R
+--E 85
+
+--S 86 of 127
+--R)d op *
+--R 
+--R
+--RThere are 33 exposed functions called * :
+--R   [1] (Integer,D) -> D from D if D has ABELGRP
+--R   [2] (NonNegativeInteger,D) -> D from D if D has ABELMON
+--R   [3] (PositiveInteger,D) -> D from D if D has ABELSG
+--R   [4] (CartesianTensor(D1,D2,D3),CartesianTensor(D1,D2,D3)) -> 
+--R            CartesianTensor(D1,D2,D3)
+--R            from CartesianTensor(D1,D2,D3)
+--R            if D1: INT and D2: NNI and D3 has COMRING
+--R   [5] (DoubleFloat,Color) -> Color from Color
+--R   [6] (PositiveInteger,Color) -> Color from Color
+--R   [7] (DenavitHartenbergMatrix D2,Point D2) -> Point D2
+--R            from DenavitHartenbergMatrix D2
+--R            if D2 has Join(Field,TranscendentalFunctionCategory)
+--R   [8] (D1,Equation D1) -> Equation D1 from Equation D1
+--R            if D1 has SGROUP and D1 has TYPE
+--R   [9] (Equation D1,D1) -> Equation D1 from Equation D1
+--R            if D1 has SGROUP and D1 has TYPE
+--R   [10] (D1,D2) -> D from D
+--R            if D has FAMONC(D2,D1) and D2 has SETCAT and D1 has CABMON
+--R            
+--R   [11] (D1,D2) -> D from D
+--R            if D has FMCAT(D1,D2) and D1 has RING and D2 has SETCAT
+--R   [12] (D,D1) -> D from D
+--R            if D has GRMOD(D1,D2) and D1 has COMRING and D2 has ABELMON
+--R            
+--R   [13] (D1,D) -> D from D
+--R            if D has GRMOD(D1,D2) and D1 has COMRING and D2 has ABELMON
+--R            
+--R   [14] (PolynomialIdeals(D1,D2,D3,D4),PolynomialIdeals(D1,D2,D3,D4))
+--R             -> PolynomialIdeals(D1,D2,D3,D4)
+--R            from PolynomialIdeals(D1,D2,D3,D4)
+--R            if D1 has FIELD and D2 has OAMONS and D3 has ORDSET and D4 
+--R            has POLYCAT(D1,D2,D3)
+--R   [15] (D1,D) -> D from D if D has LMODULE D1 and D1 has RNG
+--R   [16] ((D5 -> D6),(D4 -> D5)) -> (D4 -> D6) from MappingPackage3(D4,
+--R            D5,D6)
+--R            if D4 has SETCAT and D5 has SETCAT and D6 has SETCAT
+--R   [17] ((D2 -> D3),(D2 -> D3)) -> (D2 -> D3) from MappingPackage4(D2,
+--R            D3)
+--R            if D2 has SETCAT and D3 has RING
+--R   [18] (D1,D) -> D1 from D
+--R            if D has MATCAT(D2,D1,D3) and D2 has RING and D1 has FLAGG 
+--R            D2 and D3 has FLAGG D2
+--R   [19] (D,D1) -> D1 from D
+--R            if D has MATCAT(D2,D3,D1) and D2 has RING and D3 has FLAGG 
+--R            D2 and D1 has FLAGG D2
+--R   [20] (Integer,D) -> D from D
+--R            if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG 
+--R            D2 and D4 has FLAGG D2
+--R   [21] (D,D1) -> D from D
+--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
+--R            D1 and D3 has FLAGG D1
+--R   [22] (D1,D) -> D from D
+--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
+--R            D1 and D3 has FLAGG D1
+--R   [23] (D,D) -> D from D
+--R            if D has MATCAT(D1,D2,D3) and D1 has RING and D2 has FLAGG 
+--R            D1 and D3 has FLAGG D1
+--R   [24] (D,D) -> D from D if D has MONAD
+--R   [25] (D,D1) -> D from D if D has RMODULE D1 and D1 has RNG
+--R   [26] (D,D) -> D from D if D has SGROUP
+--R   [27] (D1,D) -> D1 from D
+--R            if D has SMATCAT(D2,D3,D1,D4) and D3 has RING and D1 has 
+--R            DIRPCAT(D2,D3) and D4 has DIRPCAT(D2,D3)
+--R   [28] (D,D1) -> D1 from D
+--R            if D has SMATCAT(D2,D3,D4,D1) and D3 has RING and D4 has 
+--R            DIRPCAT(D2,D3) and D1 has DIRPCAT(D2,D3)
+--R   [29] (D,D1) -> D from D
+--R            if D has VECTCAT D1 and D1 has TYPE and D1 has MONOID
+--R   [30] (D1,D) -> D from D
+--R            if D has VECTCAT D1 and D1 has TYPE and D1 has MONOID
+--R   [31] (Integer,D) -> D from D
+--R            if D has VECTCAT D2 and D2 has TYPE and D2 has ABELGRP
+--R   [32] (D1,D) -> D from D
+--R            if D has XFALG(D1,D2) and D1 has ORDSET and D2 has RING
+--R   [33] (D,D1) -> D from D
+--R            if D has XFALG(D2,D1) and D2 has ORDSET and D1 has RING
+--R
+--RThere are 24 unexposed functions called * :
+--R   [1] (FreeGroup D1,D1) -> FreeGroup D1 from FreeGroup D1 if D1 has 
+--R            SETCAT
+--R   [2] (D1,FreeGroup D1) -> FreeGroup D1 from FreeGroup D1 if D1 has 
+--R            SETCAT
+--R   [3] (D1,D2) -> FreeModule1(D2,D1) from FreeModule1(D2,D1)
+--R            if D2 has RING and D1 has ORDSET
+--R   [4] (FreeMonoid D1,D1) -> FreeMonoid D1 from FreeMonoid D1 if D1 has
+--R            SETCAT
+--R   [5] (D1,FreeMonoid D1) -> FreeMonoid D1 from FreeMonoid D1 if D1 has
+--R            SETCAT
+--R   [6] (D1,GeneralModulePolynomial(D2,D3,D4,D5,D6,D1)) -> 
+--R            GeneralModulePolynomial(D2,D3,D4,D5,D6,D1)
+--R            from GeneralModulePolynomial(D2,D3,D4,D5,D6,D1)
+--R            if D2: LIST SYMBOL and D3 has COMRING and D5 has DIRPCAT(# 
+--R            D2,NNI) and D6: ((Record(index: D4,exponent: D5),Record(
+--R            index: D4,exponent: D5)) -> Boolean) and D4 has ORDSET and 
+--R            D1 has POLYCAT(D3,D5,OVAR D2)
+--R   [7] (Vector D2,Vector D2) -> Vector D2
+--R            from InnerNormalBasisFieldFunctions D2 if D2 has FFIELDC
+--R         
+--R   [8] (InputForm,InputForm) -> InputForm from InputForm
+--R   [9] (InnerTaylorSeries D2,Integer) -> InnerTaylorSeries D2
+--R            from InnerTaylorSeries D2 if D2 has RING
+--R   [10] (InnerTaylorSeries D1,D1) -> InnerTaylorSeries D1
+--R            from InnerTaylorSeries D1 if D1 has RING
+--R   [11] (D1,InnerTaylorSeries D1) -> InnerTaylorSeries D1
+--R            from InnerTaylorSeries D1 if D1 has RING
+--R   [12] (Magma D1,Magma D1) -> Magma D1 from Magma D1 if D1 has ORDSET
+--R            
+--R   [13] (MyExpression(D1,D2),MyExpression(D1,D2)) -> MyExpression(D1,D2
+--R            )
+--R            from MyExpression(D1,D2)
+--R            if D1: SYMBOL and D2 has Join(Ring,OrderedSet,
+--R            IntegralDomain)
+--R   [14] (OrderedFreeMonoid D1,D1) -> OrderedFreeMonoid D1
+--R            from OrderedFreeMonoid D1 if D1 has ORDSET
+--R   [15] (D1,OrderedFreeMonoid D1) -> OrderedFreeMonoid D1
+--R            from OrderedFreeMonoid D1 if D1 has ORDSET
+--R   [16] (OutputForm,OutputForm) -> OutputForm from OutputForm
+--R   [17] (Pattern D1,Pattern D1) -> Pattern D1 from Pattern D1 if D1 has
+--R            SETCAT
+--R   [18] (D2,Vector D3) -> Vector D3 from PseudoRemainderSequence(D2,D3)
+--R            if D3 has UPOLYC D2 and D2 has INTDOM
+--R   [19] (D1,SparseMultivariateTaylorSeries(D2,D3,D1)) -> 
+--R            SparseMultivariateTaylorSeries(D2,D3,D1)
+--R            from SparseMultivariateTaylorSeries(D2,D3,D1)
+--R            if D2 has RING and D3 has ORDSET and D1 has POLYCAT(D2,INDE
+--R            D3,D3)
+--R   [20] (Stream D2,Stream D2) -> Stream D2 from 
+--R            StreamTaylorSeriesOperations D2
+--R            if D2 has RING
+--R   [21] (D2,Stream D2) -> Stream D2 from StreamTaylorSeriesOperations 
+--R            D2
+--R            if D2 has RING
+--R   [22] (Stream D2,D2) -> Stream D2 from StreamTaylorSeriesOperations 
+--R            D2
+--R            if D2 has RING
+--R   [23] (DoubleFloat,Point DoubleFloat) -> Point DoubleFloat from 
+--R            TubePlotTools
+--R   [24] (XPolynomialRing(D1,D2),D1) -> XPolynomialRing(D1,D2)
+--R            from XPolynomialRing(D1,D2) if D1 has RING and D2 has 
+--R            ORDMON
+--R
+--RExamples of * from AbelianGroup
+--R
+--R
+--RExamples of * from AbelianMonoid
+--R
+--R
+--RExamples of * from AbelianSemiGroup
+--R
+--R
+--RExamples of * from CartesianTensor
+--R
+--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
+--RTm:CartesianTensor(1,2,Integer):=m 
+--Rv:DirectProduct(2,Integer):=directProduct [3,4] 
+--RTv:CartesianTensor(1,2,Integer):=v 
+--RTm*Tv
+--R
+--R
+--RExamples of * from Color
+--R
+--R
+--RExamples of * from DenavitHartenbergMatrix
+--R
+--R
+--RExamples of * from Equation
+--R
+--R
+--RExamples of * from FreeAbelianMonoidCategory
+--R
+--R
+--RExamples of * from FreeGroup
+--R
+--R
+--RExamples of * from FreeModule1
+--R
+--R
+--RExamples of * from FreeModuleCat
+--R
+--R
+--RExamples of * from FreeMonoid
+--R
+--R
+--RExamples of * from GeneralModulePolynomial
+--R
+--R
+--RExamples of * from GradedModule
+--R
+--R
+--RExamples of * from PolynomialIdeals
+--R
+--R
+--RExamples of * from InnerNormalBasisFieldFunctions
+--R
+--R
+--RExamples of * from InputForm
+--R
+--R
+--RExamples of * from InnerTaylorSeries
+--R
+--R
+--RExamples of * from LeftModule
+--R
+--R
+--RExamples of * from Magma
+--R
+--R
+--RExamples of * from MappingPackage3
+--R
+--R
+--RExamples of * from MappingPackage4
+--R
+--Rf:=(x:INT):INT +-> 3*x 
+--Rg:=(x:INT):INT +-> 2*x+3 
+--R(f*g)(4)
+--R
+--R
+--RExamples of * from MatrixCategory
+--R
+--R
+--RExamples of * from Monad
+--R
+--R
+--RExamples of * from MyExpression
+--R
+--R
+--RExamples of * from OrderedFreeMonoid
+--R
+--R
+--RExamples of * from OutputForm
+--R
+--R
+--RExamples of * from Pattern
+--R
+--R
+--RExamples of * from PseudoRemainderSequence
+--R
+--R
+--RExamples of * from RightModule
+--R
+--R
+--RExamples of * from SemiGroup
+--R
+--R
+--RExamples of * from SquareMatrixCategory
+--R
+--R
+--RExamples of * from SparseMultivariateTaylorSeries
+--R
+--R
+--RExamples of * from StreamTaylorSeriesOperations
+--R
+--R
+--RExamples of * from TubePlotTools
+--R
+--R
+--RExamples of * from VectorCategory
+--R
+--R
+--RExamples of * from XFreeAlgebra
+--R
+--R
+--RExamples of * from XPolynomialRing
+--R
+--E 86
+
+--S 87 of 127
+--R)d op numberOfComponents
+--R 
+--R
+--RThere are 2 exposed functions called numberOfComponents :
+--R   [1]  -> NonNegativeInteger from D
+--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
+--R            D2 and D4 has UPOLYC FRAC D3
+--R   [2] D -> NonNegativeInteger from D if D has SPACEC D2 and D2 has 
+--R            RING
+--R
+--RThere is one unexposed function called numberOfComponents :
+--R   [1]  -> NonNegativeInteger from FunctionFieldCategory&(D2,D3,D4,D5)
+--R            if D3 has UFD and D4 has UPOLYC D3 and D5 has UPOLYC FRAC 
+--R            D4 and D2 has FFCAT(D3,D4,D5)
+--R
+--RExamples of numberOfComponents from FunctionFieldCategory&
+--R
+--RP0 := UnivariatePolynomial(x, Integer) 
+--RP1 := UnivariatePolynomial(y, Fraction P0) 
+--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
+--RnumberOfComponents()$R
+--R
+--R
+--RExamples of numberOfComponents from FunctionFieldCategory
+--R
+--RP0 := UnivariatePolynomial(x, Integer) 
+--RP1 := UnivariatePolynomial(y, Fraction P0) 
+--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
+--RnumberOfComponents()$R
+--R
+--R
+--RExamples of numberOfComponents from ThreeSpaceCategory
+--R
+--E 87
+
+--S 88 of 127
+--R)d op tree
+--R 
+--R
+--RThere are 3 exposed functions called tree :
+--R   [1] D1 -> Tree D1 from Tree D1 if D1 has SETCAT
+--R   [2] List D2 -> Tree D2 from Tree D2 if D2 has SETCAT
+--R   [3] (D1,List Tree D1) -> Tree D1 from Tree D1 if D1 has SETCAT
+--R
+--RExamples of tree from Tree
+--R
+--Rtree 6
+--R
+--Rtree [1,2,3,4]
+--R
+--Rt1:=tree [1,2,3,4] 
+--Rtree(5,[t1])
+--R
+--E 88
+
+--S 89 of 127
+--R)d op Aleph
+--R 
+--R
+--RThere is one exposed function called Aleph :
+--R   [1] NonNegativeInteger -> CardinalNumber from CardinalNumber
+--R
+--RExamples of Aleph from CardinalNumber
+--R
+--RA0:=Aleph 0
+--R
+--E 89
+
+--S 90 of 127
+--R)d op unit
+--R 
+--R
+--RThere are 3 exposed functions called unit :
+--R   [1] List Float -> DrawOption from DrawOption
+--R   [2]  -> Union(D,"failed") from D
+--R            if D has FINAALG D1 and D1 has INTDOM and D1 has COMRING
+--R         
+--R   [3] Factored D1 -> D1 from Factored D1 if D1 has INTDOM
+--R
+--RExamples of unit from DrawOption
+--R
+--R
+--RExamples of unit from FiniteRankNonAssociativeAlgebra
+--R
+--R
+--RExamples of unit from Factored
+--R
+--Rf:=x*y^3-3*x^2*y^2+3*x^3*y-x^4 
+--Runit f 
+--Rg:=makeFR(z,factorList f) 
+--Runit g
+--R
+--E 90
+
+--S 91 of 127
+--R)d op frst
+--R 
+--R
+--RThere is one exposed function called frst :
+--R   [1] D -> D1 from D if D has LZSTAGG D1 and D1 has TYPE
+--R
+--RExamples of frst from LazyStreamAggregate
+--R
+--Rm:=[i for i in 0..] 
+--Rfrst m
+--R
+--E 91
+
+--S 92 of 127
+--R)d op product
+--R 
+--R
+--RThere are 4 exposed functions called product :
+--R   [1] (CartesianTensor(D1,D2,D3),CartesianTensor(D1,D2,D3)) -> 
+--R            CartesianTensor(D1,D2,D3)
+--R            from CartesianTensor(D1,D2,D3)
+--R            if D1: INT and D2: NNI and D3 has COMRING
+--R   [2] (D,SegmentBinding D) -> D from D if D has COMBOPC
+--R   [3] (D,Symbol) -> D from D if D has COMBOPC
+--R   [4] (D,D) -> D from D
+--R            if D has GRALG(D1,D2) and D1 has COMRING and D2 has ABELMON
+--R            
+--R
+--RThere are 3 unexposed functions called product :
+--R   [1] (D1,Symbol) -> D1 from CombinatorialFunction(D3,D1)
+--R            if D3 has Join(OrderedSet,IntegralDomain) and D1 has FS D3
+--R            
+--R   [2] (D1,SegmentBinding D1) -> D1 from CombinatorialFunction(D3,D1)
+--R            if D1 has FS D3 and D3 has Join(OrderedSet,IntegralDomain)
+--R            
+--R   [3] (XPBWPolynomial(D2,D3),XPBWPolynomial(D2,D3),NonNegativeInteger)
+--R             -> XPBWPolynomial(D2,D3)
+--R            from XPBWPolynomial(D2,D3) if D2 has ORDSET and D3 has 
+--R            COMRING
+--R
+--RExamples of product from CartesianTensor
+--R
+--Rm:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]] 
+--RTm:CartesianTensor(1,2,Integer):=m 
+--Rn:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]] 
+--RTn:CartesianTensor(1,2,Integer):=n 
+--RTmn:=product(Tm,Tn)
+--R
+--R
+--RExamples of product from CombinatorialFunction
+--R
+--R
+--RExamples of product from CombinatorialOpsCategory
+--R
+--R
+--RExamples of product from GradedAlgebra
+--R
+--R
+--RExamples of product from XPBWPolynomial
+--R
+--E 92
+
+--S 93 of 127
+--R)d op fill!
+--R 
+--R
+--RThere are 2 exposed functions called fill! :
+--R   [1] (D,D1) -> D from D
+--R            if D has ARR2CAT(D1,D2,D3) and D1 has TYPE and D2 has FLAGG
+--R            D1 and D3 has FLAGG D1
+--R   [2] (D,D1) -> D from D
+--R            if D has shallowlyMutable and D has IXAGG(D2,D1) and D2 has
+--R            SETCAT and D1 has TYPE
+--R
+--RExamples of fill! from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,0) 
+--Rfill!(arr,10)
+--R
+--R
+--RExamples of fill! from IndexedAggregate
+--R
+--E 93
+
+--S 94 of 127
+--R)d op upperCase?
+--R 
+--R
+--RThere is one exposed function called upperCase? :
+--R   [1] Character -> Boolean from Character
+--R
+--RExamples of upperCase? from Character
+--R
+--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
+--R[upperCase? c for c in chars]
+--R
+--E 94
+
+--S 95 of 127
+--R)d op integralMatrixAtInfinity
+--R 
+--R
+--RThere is one exposed function called integralMatrixAtInfinity :
+--R   [1]  -> Matrix Fraction D3 from D
+--R            if D has FFCAT(D2,D3,D4) and D2 has UFD and D3 has UPOLYC 
+--R            D2 and D4 has UPOLYC FRAC D3
+--R
+--RExamples of integralMatrixAtInfinity from FunctionFieldCategory
+--R
+--RP0 := UnivariatePolynomial(x, Integer) 
+--RP1 := UnivariatePolynomial(y, Fraction P0) 
+--RR := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20) 
+--RintegralMatrixAtInfinity()$R
+--R
+--E 95
+
+--S 96 of 127
+--R)d op finite?
+--R 
+--R
+--RThere are 3 exposed functions called finite? :
+--R   [1] CardinalNumber -> Boolean from CardinalNumber
+--R   [2] OnePointCompletion D2 -> Boolean from OnePointCompletion D2
+--R            if D2 has SETCAT
+--R   [3] OrderedCompletion D2 -> Boolean from OrderedCompletion D2
+--R            if D2 has SETCAT
+--R
+--RExamples of finite? from CardinalNumber
+--R
+--Rc2:=2::CardinalNumber 
+--Rfinite? c2 
+--RA0:=Aleph 0 
+--Rfinite? A0
+--R
+--R
+--RExamples of finite? from OnePointCompletion
+--R
+--R
+--RExamples of finite? from OrderedCompletion
+--R
+--E 96
+
+--S 97 of 127
+--R)d op rank
+--R 
+--R
+--RThere are 8 exposed functions called rank :
+--R   [1] CartesianTensor(D2,D3,D4) -> NonNegativeInteger
+--R            from CartesianTensor(D2,D3,D4)
+--R            if D2: INT and D3: NNI and D4 has COMRING
+--R   [2]  -> PositiveInteger from D if D has FINAALG D2 and D2 has 
+--R            COMRING
+--R   [3]  -> PositiveInteger from D
+--R            if D has FINRALG(D2,D3) and D2 has COMRING and D3 has 
+--R            UPOLYC D2
+--R   [4] (Matrix D4,Vector D4) -> NonNegativeInteger
+--R            from LinearSystemMatrixPackage1 D4 if D4 has FIELD
+--R   [5] (D2,D3) -> NonNegativeInteger
+--R            from LinearSystemMatrixPackage(D4,D5,D3,D2)
+--R            if D4 has FIELD and D5 has FiniteLinearAggregate D4 with 
+--R                 shallowlyMutable and D3 has FiniteLinearAggregate D4
+--R            with 
+--R                 shallowlyMutable and D2 has MATCAT(D4,D5,D3)
+--R   [6] D -> NonNegativeInteger from D
+--R            if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG 
+--R            D2 and D4 has FLAGG D2 and D2 has INTDOM
+--R   [7] D2 -> NonNegativeInteger from MatrixLinearAlgebraFunctions(D3,D4
+--R            ,D5,D2)
+--R            if D3 has INTDOM and D3 has COMRING and D4 has FLAGG D3 and
+--R            D5 has FLAGG D3 and D2 has MATCAT(D3,D4,D5)
+--R   [8] D -> NonNegativeInteger from D
+--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
+--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4) and D4 has INTDOM
+--R            
+--R
+--RThere are 2 unexposed functions called rank :
+--R   [1]  -> PositiveInteger from ComplexCategory&(D2,D3)
+--R            if D3 has COMRING and D2 has COMPCAT D3
+--R   [2] D2 -> NonNegativeInteger
+--R            from InnerMatrixLinearAlgebraFunctions(D3,D4,D5,D2)
+--R            if D3 has FIELD and D4 has FLAGG D3 and D5 has FLAGG D3 and
+--R            D2 has MATCAT(D3,D4,D5)
+--R
+--RExamples of rank from CartesianTensor
+--R
+--RCT:=CARTEN(1,2,Integer) 
+--Rt0:CT:=8 
+--Rrank t0
+--R
+--R
+--RExamples of rank from ComplexCategory&
+--R
+--R
+--RExamples of rank from FiniteRankNonAssociativeAlgebra
+--R
+--R
+--RExamples of rank from FiniteRankAlgebra
+--R
+--R
+--RExamples of rank from InnerMatrixLinearAlgebraFunctions
+--R
+--R
+--RExamples of rank from LinearSystemMatrixPackage1
+--R
+--R
+--RExamples of rank from LinearSystemMatrixPackage
+--R
+--R
+--RExamples of rank from MatrixCategory
+--R
+--R
+--RExamples of rank from MatrixLinearAlgebraFunctions
+--R
+--R
+--RExamples of rank from RectangularMatrixCategory
+--R
+--E 97
+
+--S 98 of 127
+--R)d op numberOfComputedEntries
+--R 
+--R
+--RThere is one exposed function called numberOfComputedEntries :
+--R   [1] D -> NonNegativeInteger from D if D has LZSTAGG D2 and D2 has 
+--R            TYPE
+--R
+--RExamples of numberOfComputedEntries from LazyStreamAggregate
+--R
+--Rm:=[i for i in 0..] 
+--RnumberOfComputedEntries m
+--R
+--E 98
+
+--S 99 of 127
+--R)d op groebnerFactorize
+--R 
+--R
+--RThere are 4 exposed functions called groebnerFactorize :
+--R   [1] (List D6,List D6) -> List List D6
+--R            from GroebnerFactorizationPackage(D3,D4,D5,D6)
+--R            if D3 has Join(EuclideanDomain,CharacteristicZero) and D4 
+--R            has OAMONS and D5 has ORDSET and D6 has POLYCAT(D3,D4,D5)
+--R         
+--R   [2] (List D7,List D7,Boolean) -> List List D7
+--R            from GroebnerFactorizationPackage(D4,D5,D6,D7)
+--R            if D4 has Join(EuclideanDomain,CharacteristicZero) and D5 
+--R            has OAMONS and D6 has ORDSET and D7 has POLYCAT(D4,D5,D6)
+--R         
+--R   [3] List D6 -> List List D6 from GroebnerFactorizationPackage(D3,D4,
+--R            D5,D6)
+--R            if D3 has Join(EuclideanDomain,CharacteristicZero) and D4 
+--R            has OAMONS and D5 has ORDSET and D6 has POLYCAT(D3,D4,D5)
+--R         
+--R   [4] (List D7,Boolean) -> List List D7
+--R            from GroebnerFactorizationPackage(D4,D5,D6,D7)
+--R            if D4 has Join(EuclideanDomain,CharacteristicZero) and D5 
+--R            has OAMONS and D6 has ORDSET and D7 has POLYCAT(D4,D5,D6)
+--R         
+--R
+--RExamples of groebnerFactorize from GroebnerFactorizationPackage
+--R
+--Rmfzn : SQMATRIX(6,DMP([x,y,z],Fraction INT)) := ++X [ [0,1,1,1,1,1], [1,0,1,8/3,x,8/3], [1,1,0,1,8/3,y], ++X [1,8/3,1,0,1,8/3], [1,x,8/3,1,0,1], [1,8/3,y,8/3,1,0] ] 
+--Req := determinant mfzn 
+--RgroebnerFactorize ++X [eq,eval(eq, [x,y,z],[y,z,x]), eval(eq,[x,y,z],[z,x,y])]
+--R
+--E 99
+
+--S 100 of 127
+--R)d op lowerCase
+--R 
+--R
+--RThere are 3 exposed functions called lowerCase :
+--R   [1]  -> CharacterClass from CharacterClass
+--R   [2] Character -> Character from Character
+--R   [3] D -> D from D if D has SRAGG
+--R
+--RExamples of lowerCase from CharacterClass
+--R
+--R
+--RExamples of lowerCase from Character
+--R
+--Rchars := [char "a", char "A", char "X", char "8", char "+"] 
+--R[lowerCase c for c in chars]
+--R
+--R
+--RExamples of lowerCase from StringAggregate
+--R
+--E 100
+
+--S 101 of 127
+--R)d op showAllElements
+--R 
+--R
+--RThere is one exposed function called showAllElements :
+--R   [1] Stream D2 -> OutputForm from Stream D2
+--R            if D2 has SETCAT and D2 has TYPE
+--R
+--RExamples of showAllElements from Stream
+--R
+--Rm:=[1,2,3,4,5,6,7,8,9,10,11,12] 
+--Rn:=m::Stream(PositiveInteger) 
+--RshowAllElements n
+--R
+--E 101
+
+--S 102 of 127
+--R)d op maxColIndex
+--R 
+--R
+--RThere are 2 exposed functions called maxColIndex :
+--R   [1] D -> Integer from D
+--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
+--R            D2 and D4 has FLAGG D2
+--R   [2] D -> Integer from D
+--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
+--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
+--R
+--RExamples of maxColIndex from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,10) 
+--RmaxColIndex(arr)
+--R
+--R
+--RExamples of maxColIndex from RectangularMatrixCategory
+--R
+--E 102
+
+--S 103 of 127
+--R)d op minRowIndex
+--R 
+--R
+--RThere are 2 exposed functions called minRowIndex :
+--R   [1] D -> Integer from D
+--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
+--R            D2 and D4 has FLAGG D2
+--R   [2] D -> Integer from D
+--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
+--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
+--R
+--RExamples of minRowIndex from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,10) 
+--RminRowIndex(arr)
+--R
+--R
+--RExamples of minRowIndex from RectangularMatrixCategory
+--R
+--E 103
+
+--S 104 of 127
+--R)d op space
+--R 
+--R
+--RThere are 2 exposed functions called space :
+--R   [1]  -> Character from Character
+--R   [2] ThreeSpace DoubleFloat -> DrawOption from DrawOption
+--R
+--RThere is one unexposed function called space :
+--R   [1] List DrawOption -> ThreeSpace DoubleFloat from 
+--R            DrawOptionFunctions0
+--R
+--RExamples of space from Character
+--R
+--Rspace()
+--R
+--R
+--RExamples of space from DrawOptionFunctions0
+--R
+--R
+--RExamples of space from DrawOption
+--R
+--E 104
+
+--S 105 of 127
+--R)d op remove
+--R 
+--R
+--RThere are 5 exposed functions called remove :
+--R   [1] (D1,D) -> D from D
+--R            if D has finiteAggregate and D has CLAGG D1 and D1 has TYPE
+--R            and D1 has SETCAT
+--R   [2] ((D2 -> Boolean),D) -> D from D
+--R            if D has finiteAggregate and D has CLAGG D2 and D2 has TYPE
+--R            
+--R   [3] ((D2 -> Boolean),D) -> D from D if D has LZSTAGG D2 and D2 has 
+--R            TYPE
+--R   [4] ((D3 -> Boolean),Multiset D3,Integer) -> Multiset D3 from 
+--R            Multiset D3
+--R            if D3 has SETCAT
+--R   [5] (D1,Multiset D1,Integer) -> Multiset D1 from Multiset D1
+--R            if D1 has SETCAT
+--R
+--RThere is one unexposed function called remove :
+--R   [1] (SplittingNode(D2,D3),SplittingTree(D2,D3)) -> SplittingTree(D2,
+--R            D3)
+--R            from SplittingTree(D2,D3)
+--R            if D2 has Join(SetCategory,Aggregate) and D3 has Join(
+--R            SetCategory,Aggregate)
+--R
+--RExamples of remove from Collection
+--R
+--R
+--RExamples of remove from LazyStreamAggregate
+--R
+--Rm:=[i for i in 1..] 
+--Rf(i:PositiveInteger):Boolean == even? i 
+--Rremove(f,m)
+--R
+--R
+--RExamples of remove from Multiset
+--R
+--R
+--RExamples of remove from SplittingTree
+--R
+--E 105
+
+--S 106 of 127
+--R)d op factors
+--R 
+--R
+--RThere is one exposed function called factors :
+--R   [1] Factored D2 -> List Record(factor: D2,exponent: Integer)
+--R            from Factored D2 if D2 has INTDOM
+--R
+--RThere are 3 unexposed functions called factors :
+--R   [1] FreeGroup D2 -> List Record(gen: D2,exp: Integer) from FreeGroup
+--R            D2
+--R            if D2 has SETCAT
+--R   [2] FreeMonoid D2 -> List Record(gen: D2,exp: NonNegativeInteger)
+--R            from FreeMonoid D2 if D2 has SETCAT
+--R   [3] OrderedFreeMonoid D2 -> List Record(gen: D2,exp: 
+--R            NonNegativeInteger)
+--R            from OrderedFreeMonoid D2 if D2 has ORDSET
+--R
+--RExamples of factors from FreeGroup
+--R
+--R
+--RExamples of factors from FreeMonoid
+--R
+--R
+--RExamples of factors from Factored
+--R
+--Rf:=x*y^3-3*x^2*y^2+3*x^3*y-x^4 
+--Rfactors f 
+--Rg:=makeFR(z,factorList f) 
+--Rfactors g
+--R
+--R
+--RExamples of factors from OrderedFreeMonoid
+--R
+--E 106
+
+--S 107 of 127
+--R)d op output
+--R 
+--R
+--RThere are 4 exposed functions called output :
+--R   [1] String -> Void from OutputPackage
+--R   [2] OutputForm -> Void from OutputPackage
+--R   [3] (String,OutputForm) -> Void from OutputPackage
+--R   [4] (Integer,Stream D3) -> Void from Stream D3
+--R            if D3 has SETCAT and D3 has TYPE
+--R
+--RExamples of output from OutputPackage
+--R
+--R
+--RExamples of output from Stream
+--R
+--Rm:=[1,2,3] 
+--Rn:=repeating(m) 
+--Routput(5,n)
+--R
+--E 107
+
+--S 108 of 127
+--R)d op binarySearchTree
+--R 
+--R
+--RThere is one exposed function called binarySearchTree :
+--R   [1] List D2 -> BinarySearchTree D2 from BinarySearchTree D2 if D2 
+--R            has ORDSET
+--R
+--RExamples of binarySearchTree from BinarySearchTree
+--R
+--RbinarySearchTree [1,2,3,4]
+--R
+--E 108
+
+--S 109 of 127
+--R)d op char
+--R 
+--R
+--RThere are 2 exposed functions called char :
+--R   [1] String -> Character from Character
+--R   [2] Integer -> Character from Character
+--R
+--RExamples of char from Character
+--R
+--R[char c for c in ["a","A","X","8","+"]]
+--R
+--R[char c for c in [97,65,88,56,43]]
+--R
+--E 109
+
+--S 110 of 127
+--R)d op shrinkable
+--R 
+--R
+--RThere is one exposed function called shrinkable :
+--R   [1] Boolean -> Boolean from FlexibleArray D2 if D2 has TYPE
+--R
+--RThere is one unexposed function called shrinkable :
+--R   [1] Boolean -> Boolean from IndexedFlexibleArray(D2,D3)
+--R            if D2 has TYPE and D3: INT
+--R
+--RExamples of shrinkable from FlexibleArray
+--R
+--R
+--RExamples of shrinkable from IndexedFlexibleArray
+--R
+--RT1:=IndexedFlexibleArray(Integer,20) 
+--Rshrinkable(false)$T1
+--R
+--E 110
+
+--S 111 of 127
+--R)d op rst
+--R 
+--R
+--RThere is one exposed function called rst :
+--R   [1] D -> D from D if D has LZSTAGG D1 and D1 has TYPE
+--R
+--RExamples of rst from LazyStreamAggregate
+--R
+--Rm:=[i for i in 0..] 
+--Rrst m
+--R
+--E 111
+
+--S 112 of 127
+--R)d op flexibleArray
+--R 
+--R
+--RThere is one exposed function called flexibleArray :
+--R   [1] List D2 -> FlexibleArray D2 from FlexibleArray D2 if D2 has TYPE
+--R            
+--R
+--RThere is one unexposed function called flexibleArray :
+--R   [1] List D2 -> IndexedFlexibleArray(D2,D3) from IndexedFlexibleArray
+--R            (D2,D3)
+--R            if D2 has TYPE and D3: INT
+--R
+--RExamples of flexibleArray from FlexibleArray
+--R
+--R
+--RExamples of flexibleArray from IndexedFlexibleArray
+--R
+--RT1:=IndexedFlexibleArray(Integer,20) 
+--RflexibleArray([i for i in 1..10])$T1
+--R
+--E 112
+
+--S 113 of 127
+--R)d op setelt
+--R 
+--R
+--RThere are 12 exposed functions called setelt :
+--R   [1] (D,Integer,Integer,D1) -> D1 from D
+--R            if D has ARR2CAT(D1,D3,D4) and D1 has TYPE and D3 has FLAGG
+--R            D1 and D4 has FLAGG D1
+--R   [2] (D,right,D) -> D from D
+--R            if D has shallowlyMutable and D has BRAGG D2 and D2 has 
+--R            TYPE
+--R   [3] (D,left,D) -> D from D
+--R            if D has shallowlyMutable and D has BRAGG D2 and D2 has 
+--R            TYPE
+--R   [4] (D,D2,D1) -> D1 from D
+--R            if D has shallowlyMutable and D has ELTAGG(D2,D1) and D2 
+--R            has SETCAT and D1 has TYPE
+--R   [5] (Library,Symbol,Any) -> Any from Library
+--R   [6] (D,UniversalSegment Integer,D1) -> D1 from D
+--R            if D has shallowlyMutable and D has LNAGG D1 and D1 has 
+--R            TYPE
+--R   [7] (D,List Integer,List Integer,D) -> D from D
+--R            if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG 
+--R            D2 and D4 has FLAGG D2
+--R   [8] (D,value,D1) -> D1 from D
+--R            if D has shallowlyMutable and D has RCAGG D1 and D1 has 
+--R            TYPE
+--R   [9] (D,D2,D1) -> D1 from D
+--R            if D has TBAGG(D2,D1) and D2 has SETCAT and D1 has SETCAT
+--R         
+--R   [10] (D,last,D1) -> D1 from D
+--R            if D has shallowlyMutable and D has URAGG D1 and D1 has 
+--R            TYPE
+--R   [11] (D,rest,D) -> D from D
+--R            if D has shallowlyMutable and D has URAGG D2 and D2 has 
+--R            TYPE
+--R   [12] (D,first,D1) -> D1 from D
+--R            if D has shallowlyMutable and D has URAGG D1 and D1 has 
+--R            TYPE
+--R
+--RThere is one unexposed function called setelt :
+--R   [1] (Reference D1,D1) -> D1 from Reference D1 if D1 has TYPE
+--R
+--RExamples of setelt from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,0) 
+--Rsetelt(arr,1,1,17)
+--R
+--R
+--RExamples of setelt from BinaryRecursiveAggregate
+--R
+--R
+--RExamples of setelt from EltableAggregate
+--R
+--R
+--RExamples of setelt from Library
+--R
+--R
+--RExamples of setelt from LinearAggregate
+--R
+--R
+--RExamples of setelt from MatrixCategory
+--R
+--R
+--RExamples of setelt from RecursiveAggregate
+--R
+--R
+--RExamples of setelt from Reference
+--R
+--R
+--RExamples of setelt from TableAggregate
+--R
+--R
+--RExamples of setelt from UnaryRecursiveAggregate
+--R
+--E 113
+
+--S 114 of 127
+--R)d op cyclicParents
+--R 
+--R
+--RThere is one exposed function called cyclicParents :
+--R   [1] Tree D2 -> List Tree D2 from Tree D2 if D2 has SETCAT
+--R
+--RExamples of cyclicParents from Tree
+--R
+--Rt1:=tree [1,2,3,4] 
+--RcyclicParents t1
+--R
+--E 114
+
+--S 115 of 127
+--R)d op explicitEntries?
+--R 
+--R
+--RThere is one exposed function called explicitEntries? :
+--R   [1] D -> Boolean from D if D has LZSTAGG D2 and D2 has TYPE
+--R
+--RExamples of explicitEntries? from LazyStreamAggregate
+--R
+--Rm:=[i for i in 0..] 
+--RexplicitEntries? m
+--R
+--E 115
+
+--S 116 of 127
+--R)d op column
+--R 
+--R
+--RThere are 2 exposed functions called column :
+--R   [1] (D,Integer) -> D1 from D
+--R            if D has ARR2CAT(D3,D4,D1) and D3 has TYPE and D4 has FLAGG
+--R            D3 and D1 has FLAGG D3
+--R   [2] (D,Integer) -> D1 from D
+--R            if D has RMATCAT(D3,D4,D5,D6,D1) and D5 has RING and D6 has
+--R            DIRPCAT(D4,D5) and D1 has DIRPCAT(D3,D5)
+--R
+--RExamples of column from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,10) 
+--Rcolumn(arr,1)
+--R
+--R
+--RExamples of column from RectangularMatrixCategory
+--R
+--E 116
+
+--S 117 of 127
+--R)d op reduce
+--R 
+--R
+--RThere are 19 exposed functions called reduce :
+--R   [1] AlgebraicNumber -> AlgebraicNumber from AlgebraicNumber
+--R   [2] (((D4,D1) -> D1),OneDimensionalArray D4,D1) -> D1
+--R            from OneDimensionalArrayFunctions2(D4,D1)
+--R            if D4 has TYPE and D1 has TYPE
+--R   [3] (((D1,D1) -> D1),D,D1,D1) -> D1 from D
+--R            if D1 has SETCAT and D has finiteAggregate and D has CLAGG 
+--R            D1 and D1 has TYPE
+--R   [4] (((D1,D1) -> D1),D,D1) -> D1 from D
+--R            if D has finiteAggregate and D has CLAGG D1 and D1 has TYPE
+--R            
+--R   [5] (((D1,D1) -> D1),D) -> D1 from D
+--R            if D has finiteAggregate and D has CLAGG D1 and D1 has TYPE
+--R            
+--R   [6] (((D5,D1) -> D1),DirectProduct(D4,D5),D1) -> D1
+--R            from DirectProductFunctions2(D4,D5,D1)
+--R            if D4: NNI and D5 has TYPE and D1 has TYPE
+--R   [7] Expression D1 -> Expression D1 from Expression D1
+--R            if D1 has INTDOM and D1 has ORDSET
+--R   [8] D -> D from D
+--R            if D has FDIVCAT(D1,D2,D3,D4) and D1 has FIELD and D2 has 
+--R            UPOLYC D1 and D3 has UPOLYC FRAC D2 and D4 has FFCAT(D1,D2,
+--R            D3)
+--R   [9] (((D4,D1) -> D1),D3,D1) -> D1
+--R            from FiniteLinearAggregateFunctions2(D4,D3,D1,D5)
+--R            if D4 has TYPE and D1 has TYPE and D3 has FLAGG D4 and D5 
+--R            has FLAGG D1
+--R   [10] (((D4,D1) -> D1),D3,D1) -> D1
+--R            from FiniteSetAggregateFunctions2(D4,D3,D1,D5)
+--R            if D4 has SETCAT and D1 has SETCAT and D3 has FSAGG D4 and 
+--R            D5 has FSAGG D1
+--R   [11] (((D4,D1) -> D1),List D4,D1) -> D1 from ListFunctions2(D4,D1)
+--R            if D4 has TYPE and D1 has TYPE
+--R   [12] (((D5,D2) -> D2),D4,D2) -> D2
+--R            from MatrixCategoryFunctions2(D5,D6,D7,D4,D2,D8,D9,D1)
+--R            if D5 has RING and D2 has RING and D6 has FLAGG D5 and D7 
+--R            has FLAGG D5 and D8 has FLAGG D2 and D9 has FLAGG D2 and D4
+--R            has MATCAT(D5,D6,D7) and D1 has MATCAT(D2,D8,D9)
+--R   [13] Fraction D3 -> Union(D,"failed") from D
+--R            if D3 has UPOLYC D2 and D2 has FIELD and D2 has COMRING and
+--R            D has MONOGEN(D2,D3)
+--R   [14] D1 -> D from D
+--R            if D2 has COMRING and D has MONOGEN(D2,D1) and D1 has 
+--R            UPOLYC D2
+--R   [15] (((D4,D1) -> D1),PrimitiveArray D4,D1) -> D1
+--R            from PrimitiveArrayFunctions2(D4,D1)
+--R            if D4 has TYPE and D1 has TYPE
+--R   [16] (((D9,D4) -> D4),D6,D4) -> D4
+--R            from RectangularMatrixCategoryFunctions2(D7,D8,D9,D10,D11,
+--R            D6,D4,D1,D2,D3)
+--R            if D9 has RING and D4 has RING and D7: NNI and D8: NNI and 
+--R            D10 has DIRPCAT(D8,D9) and D11 has DIRPCAT(D7,D9) and D1 
+--R            has DIRPCAT(D8,D4) and D2 has DIRPCAT(D7,D4) and D6 has 
+--R            RMATCAT(D7,D8,D9,D10,D11) and D3 has RMATCAT(D7,D8,D4,D1,D2
+--R            )
+--R   [17] (D1,((D4,D1) -> D1),Stream D4) -> D1 from StreamFunctions2(D4,
+--R            D1)
+--R            if D4 has TYPE and D1 has TYPE
+--R   [18] (D1,D,((D1,D1) -> D1),((D1,D1) -> Boolean)) -> D1 from D
+--R            if D has TSETCAT(D4,D5,D6,D1) and D4 has INTDOM and D5 has 
+--R            OAMONS and D6 has ORDSET and D1 has RPOLCAT(D4,D5,D6)
+--R   [19] (((D4,D1) -> D1),Vector D4,D1) -> D1 from VectorFunctions2(D4,
+--R            D1)
+--R            if D4 has TYPE and D1 has TYPE
+--R
+--RThere are 7 unexposed functions called reduce :
+--R   [1] SparseUnivariatePolynomial D3 -> Record(pol: 
+--R            SparseUnivariatePolynomial D3,deg: PositiveInteger)
+--R            from DegreeReductionPackage(D3,D4)
+--R            if D3 has RING and D4 has Join(IntegralDomain,OrderedSet)
+--R         
+--R   [2] (D1,D2) -> EuclideanModularRing(D3,D1,D2,D4,D5,D6)
+--R            from EuclideanModularRing(D3,D1,D2,D4,D5,D6)
+--R            if D3 has COMRING and D1 has UPOLYC D3 and D2 has ABELMON 
+--R            and D4: ((D1,D2) -> D1) and D5: ((D2,D2) -> Union(D2,
+--R            "failed")) and D6: ((D1,D1,D2) -> Union(D1,"failed"))
+--R   [3] InnerAlgebraicNumber -> InnerAlgebraicNumber from 
+--R            InnerAlgebraicNumber
+--R   [4] (D1,D2) -> ModularField(D1,D2,D3,D4,D5)
+--R            from ModularField(D1,D2,D3,D4,D5)
+--R            if D1 has COMRING and D2 has ABELMON and D3: ((D1,D2) -> D1
+--R            ) and D4: ((D2,D2) -> Union(D2,"failed")) and D5: ((D1,D1,
+--R            D2) -> Union(D1,"failed"))
+--R   [5] D1 -> ModMonic(D2,D1) from ModMonic(D2,D1)
+--R            if D2 has RING and D1 has UPOLYC D2
+--R   [6] (D1,D2) -> ModularRing(D1,D2,D3,D4,D5) from ModularRing(D1,D2,D3
+--R            ,D4,D5)
+--R            if D1 has COMRING and D2 has ABELMON and D3: ((D1,D2) -> D1
+--R            ) and D4: ((D2,D2) -> Union(D2,"failed")) and D5: ((D1,D1,
+--R            D2) -> Union(D1,"failed"))
+--R   [7] D1 -> ResidueRing(D2,D3,D4,D1,D5) from ResidueRing(D2,D3,D4,D1,
+--R            D5)
+--R            if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D1 
+--R            has POLYCAT(D2,D3,D4) and D5: LIST D1
+--R
+--RExamples of reduce from AlgebraicNumber
+--R
+--R
+--RExamples of reduce from OneDimensionalArrayFunctions2
+--R
+--RT1:=OneDimensionalArrayFunctions2(Integer,Integer) 
+--Radder(a:Integer,b:Integer):Integer == a+b 
+--Rreduce(adder,[i for i in 1..10],0)$T1
+--R
+--R
+--RExamples of reduce from Collection
+--R
+--Rreduce(+,[C[i]*x**i for i in 1..5])
+--R
+--R
+--RExamples of reduce from DegreeReductionPackage
+--R
+--R
+--RExamples of reduce from DirectProductFunctions2
+--R
+--R
+--RExamples of reduce from EuclideanModularRing
+--R
+--R
+--RExamples of reduce from Expression
+--R
+--R
+--RExamples of reduce from FiniteDivisorCategory
+--R
+--R
+--RExamples of reduce from FiniteLinearAggregateFunctions2
+--R
+--R
+--RExamples of reduce from FiniteSetAggregateFunctions2
+--R
+--R
+--RExamples of reduce from InnerAlgebraicNumber
+--R
+--R
+--RExamples of reduce from ListFunctions2
+--R
+--R
+--RExamples of reduce from MatrixCategoryFunctions2
+--R
+--R
+--RExamples of reduce from ModularField
+--R
+--R
+--RExamples of reduce from ModMonic
+--R
+--R
+--RExamples of reduce from ModularRing
+--R
+--R
+--RExamples of reduce from MonogenicAlgebra
+--R
+--R
+--RExamples of reduce from PrimitiveArrayFunctions2
+--R
+--RT1:=PrimitiveArrayFunctions2(Integer,Integer) 
+--Radder(a:Integer,b:Integer):Integer == a+b 
+--Rreduce(adder,[i for i in 1..10],0)$T1
+--R
+--R
+--RExamples of reduce from ResidueRing
+--R
+--R
+--RExamples of reduce from RectangularMatrixCategoryFunctions2
+--R
+--R
+--RExamples of reduce from StreamFunctions2
+--R
+--Rm:=[i for i in 1..300]::Stream(Integer) 
+--Rf(i:Integer,j:Integer):Integer==i+j 
+--Rreduce(1,f,m)
+--R
+--R
+--RExamples of reduce from TriangularSetCategory
+--R
+--R
+--RExamples of reduce from VectorFunctions2
+--R
+--E 117
+
+--S 118 of 127
+--R)d op new
+--R 
+--R
+--RThere are 7 exposed functions called new :
+--R   [1] (NonNegativeInteger,NonNegativeInteger,D2) -> D from D
+--R            if D2 has TYPE and D has ARR2CAT(D2,D3,D4) and D3 has FLAGG
+--R            D2 and D4 has FLAGG D2
+--R   [2] (String,String,String) -> D from D if D has FNCAT
+--R   [3]  -> ScriptFormulaFormat from ScriptFormulaFormat
+--R   [4] (NonNegativeInteger,D2) -> D from D
+--R            if D has LNAGG D2 and D2 has TYPE
+--R   [5] Symbol -> Symbol from Symbol
+--R   [6]  -> Symbol from Symbol
+--R   [7]  -> TexFormat from TexFormat
+--R
+--RThere are 4 unexposed functions called new :
+--R   [1]  -> SubSpaceComponentProperty from SubSpaceComponentProperty
+--R   [2]  -> PatternMatchListResult(D1,D2,D3)
+--R            from PatternMatchListResult(D1,D2,D3)
+--R            if D2 has SETCAT and D1 has SETCAT and D3 has LSAGG D2
+--R   [3]  -> PatternMatchResult(D1,D2) from PatternMatchResult(D1,D2)
+--R            if D1 has SETCAT and D2 has SETCAT
+--R   [4]  -> SubSpace(D1,D2) from SubSpace(D1,D2) if D1: PI and D2 has 
+--R            RING
+--R
+--RExamples of new from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,0)
+--R
+--R
+--RExamples of new from SubSpaceComponentProperty
+--R
+--R
+--RExamples of new from FileNameCategory
+--R
+--R
+--RExamples of new from ScriptFormulaFormat
+--R
+--R
+--RExamples of new from LinearAggregate
+--R
+--R
+--RExamples of new from PatternMatchListResult
+--R
+--R
+--RExamples of new from PatternMatchResult
+--R
+--R
+--RExamples of new from SubSpace
+--R
+--R
+--RExamples of new from Symbol
+--R
+--R
+--RExamples of new from TexFormat
+--R
+--E 118
+
+--S 119 of 127
+--R)d op insertRoot!
+--R 
+--R
+--RThere is one exposed function called insertRoot! :
+--R   [1] (D1,BinarySearchTree D1) -> BinarySearchTree D1
+--R            from BinarySearchTree D1 if D1 has ORDSET
+--R
+--RExamples of insertRoot! from BinarySearchTree
+--R
+--Rt1:=binarySearchTree [1,2,3,4] 
+--RinsertRoot!(5,t1)
+--R
+--E 119
+
+--S 120 of 127
+--R)d op maxRowIndex
+--R 
+--R
+--RThere are 2 exposed functions called maxRowIndex :
+--R   [1] D -> Integer from D
+--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
+--R            D2 and D4 has FLAGG D2
+--R   [2] D -> Integer from D
+--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
+--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
+--R
+--RExamples of maxRowIndex from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,10) 
+--RmaxRowIndex(arr)
+--R
+--R
+--RExamples of maxRowIndex from RectangularMatrixCategory
+--R
+--E 120
+
+--S 121 of 127
+--R)d op escape
+--R 
+--R
+--RThere is one exposed function called escape :
+--R   [1]  -> Character from Character
+--R
+--RExamples of escape from Character
+--R
+--Rescape()
+--R
+--E 121
+
+--S 122 of 127
+--R)d op nthExponent
+--R 
+--R
+--RThere is one exposed function called nthExponent :
+--R   [1] (Factored D2,Integer) -> Integer from Factored D2 if D2 has 
+--R            INTDOM
+--R
+--RExamples of nthExponent from Factored
+--R
+--Ra:=factor 9720000 
+--RnthExponent(a,2)
+--R
+--E 122
+
+--S 123 of 127
+--R)d op parts
+--R 
+--R
+--RThere are 2 exposed functions called parts :
+--R   [1] D -> List D2 from D
+--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
+--R            D2 and D4 has FLAGG D2
+--R   [2] D -> List D2 from D
+--R            if D has finiteAggregate and D has HOAGG D2 and D2 has TYPE
+--R            
+--R
+--RExamples of parts from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,10) 
+--Rparts(arr)
+--R
+--R
+--RExamples of parts from HomogeneousAggregate
+--R
+--E 123
+
+--S 124 of 127
+--R)d op elt
+--R 
+--R
+--RThere are 47 exposed functions called elt :
+--R   [1] (D,Integer,Integer,D1) -> D1 from D
+--R            if D has ARR2CAT(D1,D3,D4) and D1 has TYPE and D3 has FLAGG
+--R            D1 and D4 has FLAGG D1
+--R   [2] (D,Integer,Integer) -> D1 from D
+--R            if D has ARR2CAT(D1,D3,D4) and D3 has FLAGG D1 and D4 has 
+--R            FLAGG D1 and D1 has TYPE
+--R   [3] (D,right) -> D from D if D has BRAGG D2 and D2 has TYPE
+--R   [4] (D,left) -> D from D if D has BRAGG D2 and D2 has TYPE
+--R   [5] (CartesianTensor(D3,D4,D1),List Integer) -> D1
+--R            from CartesianTensor(D3,D4,D1)
+--R            if D1 has COMRING and D3: INT and D4: NNI
+--R   [6] (CartesianTensor(D3,D4,D1),Integer,Integer,Integer,Integer) -> 
+--R            D1
+--R            from CartesianTensor(D3,D4,D1)
+--R            if D1 has COMRING and D3: INT and D4: NNI
+--R   [7] (CartesianTensor(D3,D4,D1),Integer,Integer,Integer) -> D1
+--R            from CartesianTensor(D3,D4,D1)
+--R            if D1 has COMRING and D3: INT and D4: NNI
+--R   [8] (CartesianTensor(D3,D4,D1),Integer,Integer) -> D1
+--R            from CartesianTensor(D3,D4,D1)
+--R            if D1 has COMRING and D3: INT and D4: NNI
+--R   [9] (CartesianTensor(D3,D4,D1),Integer) -> D1
+--R            from CartesianTensor(D3,D4,D1)
+--R            if D1 has COMRING and D3: INT and D4: NNI
+--R   [10] CartesianTensor(D2,D3,D1) -> D1 from CartesianTensor(D2,D3,D1)
+--R            if D1 has COMRING and D2: INT and D3: NNI
+--R   [11] (Database D3,Symbol) -> DataList String from Database D3
+--R            if D3 has OrderedSet with 
+--R               ?.? : (%,Symbol) -> String
+--R               display : % -> Void
+--R               fullDisplay : % -> Void
+--R   [12] (Database D2,QueryEquation) -> Database D2 from Database D2
+--R            if D2 has OrderedSet with 
+--R               ?.? : (%,Symbol) -> String
+--R               display : % -> Void
+--R               fullDisplay : % -> Void
+--R   [13] (DataList D3,count) -> NonNegativeInteger from DataList D3
+--R            if D3 has ORDSET
+--R   [14] (DataList D2,sort) -> DataList D2 from DataList D2 if D2 has 
+--R            ORDSET
+--R   [15] (DataList D2,unique) -> DataList D2 from DataList D2 if D2 has 
+--R            ORDSET
+--R   [16] (D,D2) -> D1 from D
+--R            if D has ELTAB(D2,D1) and D2 has SETCAT and D1 has TYPE
+--R   [17] (D,D2,D1) -> D1 from D
+--R            if D has ELTAGG(D2,D1) and D2 has SETCAT and D1 has TYPE
+--R         
+--R   [18] (BasicOperator,List D) -> D from D if D has ES
+--R   [19] (BasicOperator,D,D,D,D) -> D from D if D has ES
+--R   [20] (BasicOperator,D,D,D) -> D from D if D has ES
+--R   [21] (BasicOperator,D,D) -> D from D if D has ES
+--R   [22] (BasicOperator,D) -> D from D if D has ES
+--R   [23] (D,D1,D1) -> D1 from D
+--R            if D has FFCAT(D1,D2,D3) and D1 has UFD and D2 has UPOLYC 
+--R            D1 and D3 has UPOLYC FRAC D2
+--R   [24] (D,Integer) -> D1 from D if D has FRNAALG D1 and D1 has COMRING
+--R            
+--R   [25] (IndexCard,Symbol) -> String from IndexCard
+--R   [26] (Library,Symbol) -> Any from Library
+--R   [27] (D,UniversalSegment Integer) -> D from D
+--R            if D has LNAGG D2 and D2 has TYPE
+--R   [28] (ThreeDimensionalMatrix D1,NonNegativeInteger,
+--R            NonNegativeInteger,NonNegativeInteger) -> D1
+--R            from ThreeDimensionalMatrix D1 if D1 has SETCAT
+--R   [29] (D,List Integer,List Integer) -> D from D
+--R            if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG 
+--R            D2 and D4 has FLAGG D2
+--R   [30] (D,D1) -> D1 from D if D has PERMCAT D1 and D1 has SETCAT
+--R   [31] (PermutationGroup D3,NonNegativeInteger) -> Permutation D3
+--R            from PermutationGroup D3 if D3 has SETCAT
+--R   [32] (QuadraticForm(D3,D1),DirectProduct(D3,D1)) -> D1
+--R            from QuadraticForm(D3,D1) if D3: PI and D1 has FIELD
+--R   [33] (D,value) -> D1 from D if D has RCAGG D1 and D1 has TYPE
+--R   [34] (D,Integer,Integer,D1) -> D1 from D
+--R            if D has RMATCAT(D3,D4,D1,D5,D6) and D1 has RING and D5 has
+--R            DIRPCAT(D4,D1) and D6 has DIRPCAT(D3,D1)
+--R   [35] (D,Integer,Integer) -> D1 from D
+--R            if D has RMATCAT(D3,D4,D1,D5,D6) and D5 has DIRPCAT(D4,D1) 
+--R            and D6 has DIRPCAT(D3,D1) and D1 has RING
+--R   [36] (RewriteRule(D3,D4,D1),D1,PositiveInteger) -> D1
+--R            from RewriteRule(D3,D4,D1)
+--R            if D3 has SETCAT and D4 has Join(Ring,PatternMatchable D3,
+--R            OrderedSet,ConvertibleTo Pattern D3) and D1 has Join(
+--R            FunctionSpace D4,PatternMatchable D3,ConvertibleTo Pattern 
+--R            D3)
+--R   [37] (Ruleset(D3,D4,D1),D1,PositiveInteger) -> D1 from Ruleset(D3,D4
+--R            ,D1)
+--R            if D3 has SETCAT and D4 has Join(Ring,PatternMatchable D3,
+--R            OrderedSet,ConvertibleTo Pattern D3) and D1 has Join(
+--R            FunctionSpace D4,PatternMatchable D3,ConvertibleTo Pattern 
+--R            D3)
+--R   [38] (D,List Integer) -> D from D
+--R            if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3 
+--R            has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
+--R            SETCAT
+--R   [39] (D,Integer) -> D from D
+--R            if D has SEXCAT(D2,D3,D4,D5,D6) and D2 has SETCAT and D3 
+--R            has SETCAT and D4 has SETCAT and D5 has SETCAT and D6 has 
+--R            SETCAT
+--R   [40] (D,D) -> D from D if D has SRAGG
+--R   [41] (Symbol,List OutputForm) -> Symbol from Symbol
+--R   [42] (Fraction D,D1) -> D1 from D
+--R            if D has UPOLYC D1 and D1 has RING and D1 has FIELD
+--R   [43] (Fraction D,Fraction D) -> Fraction D from D
+--R            if D has UPOLYC D2 and D2 has RING and D2 has INTDOM
+--R   [44] (D,D2) -> D1 from D
+--R            if D has UPSCAT(D1,D2) and D2 has OAMON and D1 has RING
+--R   [45] (D,last) -> D1 from D if D has URAGG D1 and D1 has TYPE
+--R   [46] (D,rest) -> D from D if D has URAGG D2 and D2 has TYPE
+--R   [47] (D,first) -> D1 from D if D has URAGG D1 and D1 has TYPE
+--R
+--RThere are 4 unexposed functions called elt :
+--R   [1] (EuclideanModularRing(D2,D1,D3,D4,D5,D6),D1) -> D1
+--R            from EuclideanModularRing(D2,D1,D3,D4,D5,D6)
+--R            if D2 has COMRING and D1 has UPOLYC D2 and D3 has ABELMON 
+--R            and D4: ((D1,D3) -> D1) and D5: ((D3,D3) -> Union(D3,
+--R            "failed")) and D6: ((D1,D1,D3) -> Union(D1,"failed"))
+--R   [2] (OutputForm,List OutputForm) -> OutputForm from OutputForm
+--R   [3] (BasicOperator,List Pattern D3) -> Pattern D3 from Pattern D3
+--R            if D3 has SETCAT
+--R   [4] Reference D1 -> D1 from Reference D1 if D1 has TYPE
+--R
+--RExamples of elt from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,10) 
+--Relt(arr,1,1,6) 
+--Relt(arr,1,10,6)
+--R
+--Rarr : ARRAY2 INT := new(5,4,10) 
+--Relt(arr,1,1)
+--R
+--R
+--RExamples of elt from BinaryRecursiveAggregate
+--R
+--R
+--RExamples of elt from CartesianTensor
+--R
+--Rv:=[2,3] 
+--Rtv:CartesianTensor(1,2,Integer):=v 
+--Rtm:CartesianTensor(1,2,Integer):=[tv,tv] 
+--Rtn:CartesianTensor(1,2,Integer):=[tm,tm] 
+--Rtp:CartesianTensor(1,2,Integer):=[tn,tn] 
+--Rtq:CartesianTensor(1,2,Integer):=[tp,tp] 
+--Relt(tq,[2,2,2,2,2])
+--R
+--Rv:=[2,3] 
+--Rtv:CartesianTensor(1,2,Integer):=v 
+--Rtm:CartesianTensor(1,2,Integer):=[tv,tv] 
+--Rtn:CartesianTensor(1,2,Integer):=[tm,tm] 
+--Rtp:CartesianTensor(1,2,Integer):=[tn,tn] 
+--Relt(tp,2,2,2,2) 
+--Rtp[2,2,2,2]
+--R
+--Rv:=[2,3] 
+--Rtv:CartesianTensor(1,2,Integer):=v 
+--Rtm:CartesianTensor(1,2,Integer):=[tv,tv] 
+--Rtn:CartesianTensor(1,2,Integer):=[tm,tm] 
+--Relt(tn,2,2,2) 
+--Rtn[2,2,2]
+--R
+--Rv:=[2,3] 
+--Rtv:CartesianTensor(1,2,Integer):=v 
+--Rtm:CartesianTensor(1,2,Integer):=[tv,tv] 
+--Relt(tm,2,2) 
+--Rtm[2,2]
+--R
+--Rv:=[2,3] 
+--Rtv:CartesianTensor(1,2,Integer):=v 
+--Relt(tv,2) 
+--Rtv[2]
+--R
+--Rtv:CartesianTensor(1,2,Integer):=8 
+--Relt(tv) 
+--Rtv[]
+--R
+--R
+--RExamples of elt from Database
+--R
+--R
+--RExamples of elt from DataList
+--R
+--R
+--RExamples of elt from Eltable
+--R
+--R
+--RExamples of elt from EltableAggregate
+--R
+--R
+--RExamples of elt from EuclideanModularRing
+--R
+--R
+--RExamples of elt from ExpressionSpace
+--R
+--R
+--RExamples of elt from FunctionFieldCategory
+--R
+--R
+--RExamples of elt from FramedNonAssociativeAlgebra
+--R
+--R
+--RExamples of elt from IndexCard
+--R
+--R
+--RExamples of elt from Library
+--R
+--R
+--RExamples of elt from LinearAggregate
+--R
+--R
+--RExamples of elt from ThreeDimensionalMatrix
+--R
+--R
+--RExamples of elt from MatrixCategory
+--R
+--R
+--RExamples of elt from OutputForm
+--R
+--R
+--RExamples of elt from Pattern
+--R
+--R
+--RExamples of elt from PermutationCategory
+--R
+--R
+--RExamples of elt from PermutationGroup
+--R
+--R
+--RExamples of elt from QuadraticForm
+--R
+--R
+--RExamples of elt from RecursiveAggregate
+--R
+--R
+--RExamples of elt from Reference
+--R
+--R
+--RExamples of elt from RectangularMatrixCategory
+--R
+--R
+--RExamples of elt from RewriteRule
+--R
+--R
+--RExamples of elt from Ruleset
+--R
+--R
+--RExamples of elt from SExpressionCategory
+--R
+--R
+--RExamples of elt from StringAggregate
+--R
+--R
+--RExamples of elt from Symbol
+--R
+--R
+--RExamples of elt from UnivariatePolynomialCategory
+--R
+--R
+--RExamples of elt from UnivariatePowerSeriesCategory
+--R
+--R
+--RExamples of elt from UnaryRecursiveAggregate
+--R
+--E 123
+
+--S 125 of 127
+--R)d op minColIndex
+--R 
+--R
+--RThere are 2 exposed functions called minColIndex :
+--R   [1] D -> Integer from D
+--R            if D has ARR2CAT(D2,D3,D4) and D2 has TYPE and D3 has FLAGG
+--R            D2 and D4 has FLAGG D2
+--R   [2] D -> Integer from D
+--R            if D has RMATCAT(D2,D3,D4,D5,D6) and D4 has RING and D5 has
+--R            DIRPCAT(D3,D4) and D6 has DIRPCAT(D2,D4)
+--R
+--RExamples of minColIndex from TwoDimensionalArrayCategory
+--R
+--Rarr : ARRAY2 INT := new(5,4,10) 
+--RminColIndex(arr)
+--R
+--R
+--RExamples of minColIndex from RectangularMatrixCategory
+--R
+--E 125
+
+--S 126 of 127
+--R)d op numberOfFactors
+--R 
+--R
+--RThere is one exposed function called numberOfFactors :
+--R   [1] Factored D2 -> NonNegativeInteger from Factored D2 if D2 has 
+--R            INTDOM
+--R
+--RThere is one unexposed function called numberOfFactors :
+--R   [1] List Record(factor: D3,degree: Integer) -> NonNegativeInteger
+--R            from GaloisGroupFactorizer D3 if D3 has UPOLYC INT
+--R
+--RExamples of numberOfFactors from Factored
+--R
+--Ra:=factor 9720000 
+--RnumberOfFactors a
+--R
+--R
+--RExamples of numberOfFactors from GaloisGroupFactorizer
+--R
+--E 126
+
+--S 127 of 127
+--R)d op cyclicCopy
+--R 
+--R
+--RThere is one exposed function called cyclicCopy :
+--R   [1] Tree D1 -> Tree D1 from Tree D1 if D1 has SETCAT
+--R
+--RExamples of cyclicCopy from Tree
+--R
+--Rt1:=tree [1,2,3,4] 
+--RcyclicCopy t1
+--R
+--E 127
+
+)spool 
+)lisp (bye)
+ 
+@
+\eject
+\begin{thebibliography}{99}
+\bibitem{1} nothing
+\end{thebibliography}
+\end{document}
diff --git a/src/input/frame.input.pamphlet b/src/input/frame.input.pamphlet
new file mode 100644
index 0000000..75ce1a2
--- /dev/null
+++ b/src/input/frame.input.pamphlet
@@ -0,0 +1,212 @@
+\documentclass{article}
+\usepackage{axiom}
+\begin{document}
+\title{\$SPAD/src/input frame.input}
+\author{Timothy Daly}
+\maketitle
+\begin{abstract}
+\end{abstract}
+\eject
+\tableofcontents
+\eject
+\section{License}
+<<license>>=
+--Copyright The Numerical Algorithms Group Limited 1991.
+@
+<<*>>=
+)spool frame.output
+)set message test on
+)set message auto off
+)clear all
+ 
+--S 1 of 24
+)frame new testframe
+--R 
+--E 1
+
+--S 2 of 24
+)frame names
+--R 
+--R   The names of the existing frames are:
+--R            testframe 
+--R            initial 
+--R      The current frame is the first one listed.
+--E 2
+
+--S 3 of 24
+)frame next
+--R 
+--E 3
+
+--S 4 of 24
+)frame names
+--R 
+--R   The names of the existing frames are:
+--R            initial 
+--R            testframe 
+--R      The current frame is the first one listed.
+--E 4
+
+--S 5 of 24
+)frame next
+--R 
+--E 5
+
+--S 6 of 24
+)frame names
+--R 
+--R   The names of the existing frames are:
+--R            testframe 
+--R            initial 
+--R      The current frame is the first one listed.
+--E 6
+
+--S 7 of 24
+)frame next
+--R 
+--E 7
+
+--S 8 of 24
+)frame drop
+--R 
+--E 8
+
+--S 9 of 24
+)frame names
+--R 
+--R   The names of the existing frames are:
+--R            testframe 
+--R      The current frame is the first one listed.
+--E 9
+
+--S 10 of 24
+)frame new testframe2
+--R 
+--E 10
+
+--S 11 of 24
+a:=1
+--R 
+--R
+--R   (1)  1
+--R                                                        Type: PositiveInteger
+--E 11
+
+--S 12 of 24
+)frame names
+--R 
+--R   The names of the existing frames are:
+--R            testframe2 
+--R            testframe 
+--R      The current frame is the first one listed.
+--E 12
+
+--S 13 of 24
+)frame next
+--R 
+--E 13
+
+--S 14 of 24
+a
+--R 
+--R
+--R   (1)  a
+--R                                                             Type: Variable a
+--E 14
+
+--S 15 of 24
+)frame import testframe2 a
+--R 
+--R   Import from frame testframe2 is complete. Please issue )display all 
+--R      if you wish to see the contents of the current frame.
+--E 15
+
+--S 16 of 24
+)display all
+--R 
+--RProperties of % :
+--R   Value (has type Variable a):  a
+--RProperties of %e :
+--R   This is a system-defined macro.
+--R   macro %e () == exp(1)
+--RProperties of %i :
+--R   This is a system-defined macro.
+--R   macro %i () == complex(0,1)
+--RProperties of %infinity :
+--R   This is a system-defined macro.
+--R   macro %infinity () == infinity()
+--RProperties of %minusInfinity :
+--R   This is a system-defined macro.
+--R   macro %minusInfinity () == minusInfinity()
+--RProperties of %pi :
+--R   This is a system-defined macro.
+--R   macro %pi () == pi()
+--RProperties of %plusInfinity :
+--R   This is a system-defined macro.
+--R   macro %plusInfinity () == plusInfinity()
+--RProperties of SF :
+--R   This is a system-defined macro.
+--R   macro SF () == DoubleFloat()
+--RProperties of a :
+--R   Value (has type PositiveInteger):  1
+--E 16
+
+--S 17 of 24
+a
+--R 
+--R
+--R   (2)  1
+--R                                                        Type: PositiveInteger
+--E 17
+
+--S 18 of 24
+)set message prompt frame
+--R 
+--E 18
+
+--S 19 of 24
+)frame next
+--R 
+--E 19
+
+--S 20 of 24
+)frame next
+--R 
+--E 20
+
+--S 21 of 24
+)frame next
+--R 
+--E 21
+
+--S 22 of 24
+)frame names
+--R 
+--R   The names of the existing frames are:
+--R            testframe2 
+--R            testframe 
+--R      The current frame is the first one listed.
+--E 22
+
+--S 23 of 24
+)frame drop testframe2
+--R 
+--E 23
+
+--S 24 of 24
+)frame names
+--R 
+--R   The names of the existing frames are:
+--R            testframe 
+--R      The current frame is the first one listed.
+--E 24
+
+)spool 
+)lisp (bye)
+ 
+@
+\eject
+\begin{thebibliography}{99}
+\bibitem{1} nothing
+\end{thebibliography}
+\end{document}
diff --git a/src/interp/i-map.boot.pamphlet b/src/interp/i-map.boot.pamphlet
index cdfbef4..97c825b 100644
--- a/src/interp/i-map.boot.pamphlet
+++ b/src/interp/i-map.boot.pamphlet
@@ -62,7 +62,7 @@ SETANDFILEQ($specialMapNameSuffix, NIL)
 makeInternalMapName(userName,numArgs,numMms,extraPart) ==
   name := CONCAT('"*",STRINGIMAGE numArgs,'";",
     object2String userName,'";",STRINGIMAGE numMms,'";",
-      object2String frameName first $interpreterFrameRing )
+      object2String FRAMENAME first $interpreterFrameRing )
   if extraPart then name := CONCAT(name,'";",extraPart)
   if $specialMapNameSuffix then
     name := CONCAT(name,'";",$specialMapNameSuffix)



From MAILER-DAEMON Sun Feb 22 01:33:00 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lb7tc-0007Iz-Eg
	for mharc-axiom-developer@gnu.org; Sun, 22 Feb 2009 01:33:00 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lb7ta-0007I3-Vx
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 01:32:59 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lb7tY-0007Fo-OQ
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 01:32:58 -0500
Received: from [199.232.76.173] (port=45139 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lb7tY-0007FX-CX
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 01:32:56 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:51370
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Lb7tY-0005DQ-0M
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 01:32:56 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1M6Wsug024892;
	Sun, 22 Feb 2009 00:32:54 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1M6WsWi024889;
	Sun, 22 Feb 2009 00:32:54 -0600
Date: Sun, 22 Feb 2009 00:32:54 -0600
Message-Id: <200902220632.n1M6WsWi024889@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090221.01.tpd.patch (remove bookvol5 dvi
	creation)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 22 Feb 2009 06:32:59 -0000

There is no need to create the bookvol5 dvi during interpreter build
as the final pdf is created later.

=====================================================================
diff --git a/src/interp/Makefile.pamphlet b/src/interp/Makefile.pamphlet
index 5404c64..3586ffb 100644
--- a/src/interp/Makefile.pamphlet
+++ b/src/interp/Makefile.pamphlet
@@ -451,7 +451,7 @@ DOCFILES=${DOC}/alql.boot.dvi \
 	 ${DOC}/i-analy.boot.dvi ${DOC}/i-code.boot.dvi \
 	 ${DOC}/i-coerce.boot.dvi ${DOC}/i-coerfn.boot.dvi \
 	 ${DOC}/i-eval.boot.dvi ${DOC}/i-funsel.boot.dvi \
-	 ${BOOK}/bookvol5.dvi ${DOC}/i-intern.boot.dvi \
+	 ${DOC}/i-intern.boot.dvi \
 	 ${DOC}/i-map.boot.dvi ${DOC}/incl.boot.dvi \
 	 ${DOC}/info.boot.dvi ${DOC}/interop.boot.dvi \
 	 ${DOC}/intfile.boot.dvi \



From MAILER-DAEMON Sun Feb 22 13:23:25 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LbIz7-0003RW-PO
	for mharc-axiom-developer@gnu.org; Sun, 22 Feb 2009 13:23:25 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LbIz5-0003RL-7s
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 13:23:23 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LbIz2-0003R9-Rl
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 13:23:21 -0500
Received: from [199.232.76.173] (port=47215 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LbIz2-0003R6-ME
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 13:23:20 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:55649
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LbIz2-0005Cl-C2
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 13:23:20 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1MINGug021413;
	Sun, 22 Feb 2009 12:23:16 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1MINGGr021409;
	Sun, 22 Feb 2009 12:23:16 -0600
Date: Sun, 22 Feb 2009 12:23:16 -0600
Message-Id: <200902221823.n1MINGGr021409@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090221.02.tpd.patch (add Scott Morrison's
	original hypertex plan)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 22 Feb 2009 18:23:23 -0000

Scott Morrison did the original work on hypertex. He sent an image
from his notebook showing the original design notes. The page contains
references to Clifton (Williamson), Barry (Trager), Steven (Watt),
(Steve) Gortler and Stephen Buchwold. 

The early Scratchpad graphics work was done in X10 and there was
a steep learning curve for X11. As is clear from the notes, Scott
was asked to figure out a lot of low level details like Font handling
(a pain in X11) as well as high level details like the active area
representation. 

Given that this was all required before the idea of web browsers
arrived on the scene, Scott did some incredible design work. Hypertex
allows embedded graphics, which become "live" when clicked. It allows
"tear off pages" (e.g. open-new-window in firefox). It allows search
activities. It has adjustable fonts. It could be run standalone or
in connection with Axiom. It has a page format that was very close to
latex in syntax and semantics (much better than html). It allowed user
defined page tags (ala XML). It ran as a separate, parallel process.

Some days you have to be impressed.

Tim



From MAILER-DAEMON Sun Feb 22 13:41:31 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LbJGd-0004lS-LS
	for mharc-axiom-developer@gnu.org; Sun, 22 Feb 2009 13:41:31 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LbJGb-0004ib-1b
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 13:41:29 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LbJGY-0004i0-HG
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 13:41:27 -0500
Received: from [199.232.76.173] (port=41408 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LbJGY-0004hs-BQ
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 13:41:26 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:48936
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LbJGX-0008Qe-Rk
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 13:41:26 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1MIfOug027854;
	Sun, 22 Feb 2009 12:41:24 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1MIfO2v027845;
	Sun, 22 Feb 2009 12:41:24 -0600
Date: Sun, 22 Feb 2009 12:41:24 -0600
Message-Id: <200902221841.n1MIfO2v027845@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090222.01.tpd.patch (add Stephen Buchwald to
	credits)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 22 Feb 2009 18:41:29 -0000

Add Stephen Buchwald to credits. His name was found in the design
notes for hypertex from Scott Morrison.

======================================================================
diff --git a/changelog b/changelog
index ae7a9c5..a73b55d 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,7 @@
+20090222 tpd src/axiom-website/patches.html 20090222.01.tpd.patch
+20090222 tpd src/interp/setq.lisp Stephen Buchwald to credits
+20090222 tpd readme add Stephen Buchwald to credits
+20090222 scm Stephen Buchwald
 20090221 tpd src/axiom-website/patches.html 20090221.02.tpd.patch
 20090221 tpd books/ps/bookvol7 add Scott Morrison's original hypertex plan
 20090221 tpd books/ps/hypertexplan.eps scaled image for bookvol7
diff --git a/readme b/readme
index a468845..d01e42e 100644
--- a/readme
+++ b/readme
@@ -195,8 +195,8 @@ at the axiom command prompt will prettyprint the list.
 "Jay Belanger           David Bindel           Fred Blair"
 "Vladimir Bondarenko    Mark Botch"
 "Alexandre Bouyer       Peter A. Broadbery     Martin Brock"
-"Manuel Bronstein       Florian Bundschuh      Luanne Burns"
-"William Burge"
+"Manuel Bronstein       Stephen Buchwald       Florian Bundschuh"
+"Luanne Burns           William Burge"
 "Quentin Carpent        Robert Caviness        Bruce Char"
 "Ondrej Certik          Cheekai Chin           David V. Chudnovsky"
 "Gregory V. Chudnovsky  Josh Cohen             Christophe Conil"
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index cd6539d..a861a06 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -953,5 +953,7 @@ regression test )d op, )frame<br/>
 remove bookvol5 dvi creation<br/>
 <a href="patches/20090221.02.tpd.patch">20090221.02.tpd.patch</a>
 add Scott Morrison's original hypertex plan<br/>
+<a href="patches/20090222.01.tpd.patch">20090222.01.tpd.patch</a>
+add Stephen Buchwald to credits<br/>
  </body>
 </html>
diff --git a/src/interp/setq.lisp.pamphlet b/src/interp/setq.lisp.pamphlet
index f395d21..f97be83 100644
--- a/src/interp/setq.lisp.pamphlet
+++ b/src/interp/setq.lisp.pamphlet
@@ -594,8 +594,8 @@
 "Jay Belanger           David Bindel           Fred Blair"
 "Vladimir Bondarenko    Mark Botch"
 "Alexandre Bouyer       Peter A. Broadbery     Martin Brock"
-"Manuel Bronstein       Florian Bundschuh      Luanne Burns"
-"William Burge"
+"Manuel Bronstein       Stephen Buchwald       Florian Bundschuh"
+"Luanne Burns           William Burge"
 "Quentin Carpent        Robert Caviness        Bruce Char"
 "Ondrej Certik          Cheekai Chin           David V. Chudnovsky"
 "Gregory V. Chudnovsky  Josh Cohen             Christophe Conil"



From MAILER-DAEMON Sun Feb 22 21:32:49 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LbQcj-0007a7-DV
	for mharc-axiom-developer@gnu.org; Sun, 22 Feb 2009 21:32:49 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LbQcg-0007a1-LN
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 21:32:46 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LbQce-0007Zp-Lc
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 21:32:45 -0500
Received: from [199.232.76.173] (port=59249 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LbQce-0007Zm-Fn
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 21:32:44 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:38782
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LbQcd-0007gI-RS
	for axiom-developer@nongnu.org; Sun, 22 Feb 2009 21:32:44 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1N2Wfug005796;
	Sun, 22 Feb 2009 20:32:42 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1N2Wd5t005791;
	Sun, 22 Feb 2009 20:32:39 -0600
Date: Sun, 22 Feb 2009 20:32:39 -0600
Message-Id: <200902230232.n1N2Wd5t005791@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 
	20090222.02.tpd.patch (bookvol10.3 add regression, help, ...)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 23 Feb 2009 02:32:47 -0000

This patch is the start of a deeper documentation effort for the algebra.
More operations are documented by extending the inherited signatures in
domains to include documentation strings. With this change

stack,  pop!, extract!, push!, insert!, inspect, top, depth, less?,
more?, size?, bag, empty?, empty, sample, copy, eq?, map, map!, =, ~=,
every?, any?, count, #, parts, members, and member? all now show explicit
examples for Stack as part of the )display operation command.

In addition, a new help file and a new regression test file was created.

This technique will be extended to additional domains.

Tim

========================================================================
diff --git a/books/bookvol10.3.pamphlet b/books/bookvol10.3.pamphlet
index 8f77e34..23ee487 100644
--- a/books/bookvol10.3.pamphlet
+++ b/books/bookvol10.3.pamphlet
@@ -1595,6 +1595,150 @@ Any(): SetCategory with
 @
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{domain ASTACK ArrayStack}
+<<ArrayStack.input>>=
+)sys rm -f ArrayStack.output
+)spool ArrayStack.output
+)set message test on
+)set message auto off
+)clear all
+
+--S 1 of 44
+a:Stack INT:= stack [1,2,3,4,5]
+--R 
+--R
+--R   (1)  [1,2,3,4,5]
+--R                                                          Type: Stack Integer
+--E 1
+
+--S 2 of 44
+pop! a
+--R 
+--R
+--R   (2)  1
+--R                                                        Type: PositiveInteger
+--E 2
+
+--S 3 of 44
+a
+--R 
+--R
+--R   (3)  [2,3,4,5]
+--R                                                          Type: Stack Integer
+--E 3
+
+--S 4 of 44
+push!(9,a)
+--R 
+--R
+--R   (4)  9
+--R                                                        Type: PositiveInteger
+--E 4
+
+--S 5 of 44
+a
+--R 
+--R
+--R   (5)  [9,2,3,4,5]
+--R                                                          Type: Stack Integer
+--E 5
+
+--S 6 of 44
+empty? a
+--R 
+--R
+--R   (6)  false
+--R                                                                Type: Boolean
+--E 6
+
+--S 7 of 44
+b:=empty()$(Stack INT)
+--R 
+--R
+--R   (7)  []
+--R                                                          Type: Stack Integer
+--E 7
+
+--S 8 of 44
+empty? b
+--R 
+--R
+--R   (8)  true
+--R                                                                Type: Boolean
+--E 8
+
+)spool
+)lisp (bye)
+ 
+@
+<<Stack.help>>=
+====================================================================
+Stack examples
+====================================================================
+
+A Stack object is represented as a list ordered by last-in, first-out.
+It operates like a pile of books, where the "next" book is the one
+on the top of the pile.
+
+Here we create a stack of integers from a list. Notice that the
+order in the list is the order in the stack.
+
+   a:Stack INT:= stack [1,2,3,4,5]
+
+      (1)  [1,2,3,4,5]
+
+We can remove the top of the stack using pop!:
+
+   pop! a
+
+      (2)  1
+
+Notice that the use of pop! is destructive (destructive operations
+in Axiom usually end with ! to indicate that the underylying data
+structure is changed).
+
+   a
+
+      (3)  [2,3,4,5]
+
+Next we push a new element on top of the stack:
+
+   push!(9,a)
+
+      (4)  9
+
+Again, the push! operation is destructive so the stack is changed:
+
+   a
+
+      (5)  [9,2,3,4,5]
+
+We can ask if the stack is empty (boolean predicates in Axiom 
+generally end in a question mark):
+
+   empty? a
+
+      (6)  false
+
+We can create a new, empty stack:
+
+   b:=empty()$(Stack INT)
+
+      (7)  []
+
+And we can ask if b is empty:
+
+   empty? b
+
+      (8)  true
+
+See Also:
+o )show Stack
+o )show ArrayStack
+o )show Queue
+o )show Dequeue
+o )show Heap
+
+@
 \pagehead{ArrayStack}{ASTACK}
 \pagepic{ps/v103arraystack.ps}{ASTACK}{1.00}
 {\bf See}\\
@@ -89375,6 +89519,566 @@ SquareMatrix(ndim,R): Exports == Implementation where
 @
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{domain STACK Stack}
+<<Stack.input>>=
+-- stack.spad.pamphlet Stack.input
+)sys rm -f Stack.output
+)spool Stack.output
+)set message test on
+)set message auto off
+)clear all
+
+--S 1 of 41
+a:Stack INT:= stack [1,2,3,4,5]
+--R
+--R   (1)  [1,2,3,4,5]
+--R                                                          Type: Stack Integer
+--E 1
+
+--S 2 of 41
+pop! a
+--R
+--R   (2)  1
+--R                                                        Type: PositiveInteger
+--E 2
+
+--S 3 of 41
+a
+--R
+--R   (3)  [2,3,4,5]
+--R                                                          Type: Stack Integer
+--E 3
+
+--S 4 of 41
+extract! a
+--R
+--R   (4)  2
+--R                                                        Type: PositiveInteger
+--E 4
+
+--S 5 of 41
+a
+--R
+--R   (5)  [3,4,5]
+--R                                                          Type: Stack Integer
+--E 5
+
+--S 6 of 41
+push!(9,a)
+--R
+--R   (6)  9
+--R                                                        Type: PositiveInteger
+--E 6
+
+--S 7 of 41
+a
+--R
+--R   (7)  [9,3,4,5]
+--R                                                          Type: Stack Integer
+--E 7
+
+--S 8 of 41
+insert!(8,a)
+--R
+--R   (8)  [8,9,3,4,5]
+--R                                                          Type: Stack Integer
+--E 8
+
+--S 9 of 41
+a
+--R
+--R   (9)  [8,9,3,4,5]
+--R                                                          Type: Stack Integer
+--E 9
+
+--S 10 of 41
+inspect a
+--R
+--R   (10)  8
+--R                                                        Type: PositiveInteger
+--E 10
+
+--S 11 of 41
+empty? a
+--R
+--R   (11)  false
+--R                                                                Type: Boolean
+--E 11
+
+--S 12 of 41
+top a
+--R
+--R   (12)  8
+--R                                                        Type: PositiveInteger
+--E 12
+
+--S 13 of 41
+depth a
+--R
+--R   (13)  5
+--R                                                        Type: PositiveInteger
+--E 13
+
+--S 14 of 41
+#a
+--R
+--R   (14)  5
+--R                                                        Type: PositiveInteger
+--E 14
+
+--S 15 of 41
+less?(a,9)
+--R
+--R   (15)  true
+--R                                                                Type: Boolean
+--E 15
+
+--S 16 of 41
+more?(a,9)
+--R
+--R   (16)  false
+--R                                                                Type: Boolean
+--E 16
+
+--S 17 of 41
+size?(a,#a)
+--R
+--R   (17)  true
+--R                                                                Type: Boolean
+--E 17
+
+--S 18 of 41
+size?(a,9)
+--R
+--R   (18)  false
+--R                                                                Type: Boolean
+--E 18
+
+--S 19 of 41
+parts a
+--R
+--R   (19)  [8,9,3,4,5]
+--R                                                           Type: List Integer
+--E 19
+
+--S 20 of 41
+bag([1,2,3,4,5])$Stack(INT)
+--R
+--R   (20)  [5,4,3,2,1]
+--R                                                          Type: Stack Integer
+--E 20
+
+--S 21 of 41
+b:=empty()$(Stack INT)
+--R
+--R   (21)  []
+--R                                                          Type: Stack Integer
+--E 21
+
+--S 22 of 41
+empty? b
+--R
+--R   (22)  true
+--R                                                                Type: Boolean
+--E 22
+
+--S 23 of 41
+sample()$Stack(INT)
+--R
+--R   (23)  []
+--R                                                          Type: Stack Integer
+--E 23
+
+--S 24 of 41
+c:=copy a
+--R
+--R   (24)  [8,9,3,4,5]
+--R                                                          Type: Stack Integer
+--E 24
+
+--S 25 of 41
+eq?(a,c)
+--R
+--R   (25)  false
+--R                                                                Type: Boolean
+--E 25
+
+--S 26 of 41
+eq?(a,a)
+--R
+--R   (26)  true
+--R                                                                Type: Boolean
+--E 26
+
+--S 27 of 41
+(a=c)@Boolean
+--R
+--R   (27)  true
+--R                                                                Type: Boolean
+--E 27
+
+--S 28 of 41
+(a=a)@Boolean
+--R
+--R   (28)  true
+--R                                                                Type: Boolean
+--E 28
+
+--S 29 of 41
+a~=c
+--R
+--R   (29)  false
+--R                                                                Type: Boolean
+--E 29
+
+--S 30 of 41
+any?(x+->(x=4),a)
+--R
+--R   (30)  true
+--R                                                                Type: Boolean
+--E 30
+
+--S 31 of 41
+any?(x+->(x=11),a)
+--R
+--R   (31)  false
+--R                                                                Type: Boolean
+--E 31
+
+--S 32 of 41
+every?(x+->(x=11),a)
+--R
+--R   (32)  false
+--R                                                                Type: Boolean
+--E 32
+
+--S 33 of 41
+count(4,a)
+--R
+--R   (33)  1
+--R                                                        Type: PositiveInteger
+--E 33
+
+--S 34 of 41
+count(x+->(x>2),a)
+--R
+--R   (34)  5
+--R                                                        Type: PositiveInteger
+--E 34
+
+--S 35 of 41
+map(x+->x+10,a)
+--R
+--R   (35)  [18,19,13,14,15]
+--R                                                          Type: Stack Integer
+--E 35
+
+--S 36 of 41
+a
+--R
+--R   (36)  [8,9,3,4,5]
+--R                                                          Type: Stack Integer
+--E 36
+
+--S 37 of 41
+map!(x+->x+10,a)
+--R
+--R   (37)  [18,19,13,14,15]
+--R                                                          Type: Stack Integer
+--E 37
+
+--S 38 of 41
+a
+--R
+--R   (38)  [18,19,13,14,15]
+--R                                                          Type: Stack Integer
+--E 38
+
+--S 39 of 41
+members a
+--R
+--R   (39)  [18,19,13,14,15]
+--R                                                           Type: List Integer
+--E 39
+
+--S 40 of 41
+member?(14,a)
+--R
+--R   (40)  true
+--R                                                                Type: Boolean
+--E 40
+
+--S 41 of 41
+)show Stack
+--R Stack S: SetCategory  is a domain constructor
+--R Abbreviation for Stack is STACK 
+--R This constructor is exposed in this frame.
+--R Issue )edit bookvol10.3.spad.pamphlet to see algebra source code for STACK 
+--R
+--R------------------------------- Operations --------------------------------
+--R bag : List S -> %                     copy : % -> %
+--R depth : % -> NonNegativeInteger       empty : () -> %
+--R empty? : % -> Boolean                 eq? : (%,%) -> Boolean
+--R extract! : % -> S                     insert! : (S,%) -> %
+--R inspect : % -> S                      map : ((S -> S),%) -> %
+--R pop! : % -> S                         push! : (S,%) -> S
+--R sample : () -> %                      stack : List S -> %
+--R top : % -> S                         
+--R #? : % -> NonNegativeInteger if $ has finiteAggregate
+--R ?=? : (%,%) -> Boolean if S has SETCAT
+--R any? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
+--R coerce : % -> OutputForm if S has SETCAT
+--R count : (S,%) -> NonNegativeInteger if $ has finiteAggregate and S has SETCAT
+--R count : ((S -> Boolean),%) -> NonNegativeInteger if $ has finiteAggregate
+--R eval : (%,List S,List S) -> % if S has EVALAB S and S has SETCAT
+--R eval : (%,S,S) -> % if S has EVALAB S and S has SETCAT
+--R eval : (%,Equation S) -> % if S has EVALAB S and S has SETCAT
+--R eval : (%,List Equation S) -> % if S has EVALAB S and S has SETCAT
+--R every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
+--R hash : % -> SingleInteger if S has SETCAT
+--R latex : % -> String if S has SETCAT
+--R less? : (%,NonNegativeInteger) -> Boolean
+--R map! : ((S -> S),%) -> % if $ has shallowlyMutable
+--R member? : (S,%) -> Boolean if $ has finiteAggregate and S has SETCAT
+--R members : % -> List S if $ has finiteAggregate
+--R more? : (%,NonNegativeInteger) -> Boolean
+--R parts : % -> List S if $ has finiteAggregate
+--R size? : (%,NonNegativeInteger) -> Boolean
+--R ?~=? : (%,%) -> Boolean if S has SETCAT
+--R
+--E 41
+)spool
+)lisp (bye)
+ 
+@
+<<Stack.help>>=
+====================================================================
+Stack examples
+====================================================================
+
+A Stack object is represented as a list ordered by last-in, first-out.
+It operates like a pile of books, where the "next" book is the one
+on the top of the pile.
+
+Here we create a stack of integers from a list. Notice that the
+order in the list is the order in the stack.
+
+   a:Stack INT:= stack [1,2,3,4,5]
+      [1,2,3,4,5]
+
+We can remove the top of the stack using pop!:
+
+   pop! a
+      1
+
+Notice that the use of pop! is destructive (destructive operations
+in Axiom usually end with ! to indicate that the underylying data
+structure is changed).
+
+   a
+      [2,3,4,5]
+
+The extract! operation is another name for the pop! operation and
+has the same effect. This operation treats the stack as a BagAggregate:
+
+o   extract! a
+      2
+
+and you can see that it also has destructively modified the stack:
+
+   a
+      [3,4,5]
+
+Next we push a new element on top of the stack:
+
+   push!(9,a)
+      9
+
+Again, the push! operation is destructive so the stack is changed:
+
+   a
+      [9,2,3,4,5]
+
+Another name for push! is insert!, which treats the stack as a BagAggregate:
+
+   insert!(8,a)
+      [8,9,3,4,5]
+
+and it modifies the stack:
+
+   a
+      [8,9,3,4,5]
+
+The inspect function returns the top of the stack without modification,
+viewed as a BagAggregate:
+
+   inspect a
+      8
+
+The empty? operation returns true only if there are no element on the
+stack, otherwise it returns false:
+
+   empty? a
+      false
+
+The top operation returns the top of stack without modification, viewed
+as a Stack:
+
+   top a
+      8
+
+The depth operation returns the number of elements on the stack:
+
+   depth a
+      5
+
+which is the same as the # (length) operation:
+
+   #a
+       5
+
+The less? predicate will compare the stack length to an integer:
+
+   less?(a,9)
+        true
+
+The more? predicate will compare the stack length to an integer:
+
+   more?(a,9)
+        false
+
+The size? operation will compare the stack length to an integer:
+
+   size?(a,#a)
+        true
+
+and since the last computation must alwasy be true we try:
+
+   size?(a,9)
+        false
+
+The parts function will return  the stack as a list of its elements:
+
+   parts a
+        [8,9,3,4,5]
+
+If we have a BagAggregate of elements we can use it to construct a stack.
+Notice that the elements are pushed in reverse order:
+
+   bag([1,2,3,4,5])$Stack(INT)
+        [5,4,3,2,1]
+
+The empty function will construct an empty stack of a given type:
+
+   b:=empty()$(Stack INT)
+        []
+
+and the empty? predicate allows us to find out if a stack is empty:
+
+   empty? b
+        true
+
+The sample function returns a sample, empty stack:
+
+   sample()$Stack(INT)
+        []
+
+We can copy a stack and it does not share storage so subsequent
+modifications of the original stack will not affect the copy:
+
+   c:=copy a
+        [8,9,3,4,5]
+
+The eq? function is only true if the lists are the same reference,
+so even though c is a copy of a, they are not the same:
+
+   eq?(a,c)
+        false
+
+However, a clearly shares a reference with itself:
+
+   eq?(a,a)
+        true
+
+But we can compare a and c for equality:
+
+   (a=c)@Boolean
+        true
+
+and clearly a is equal to itself:
+
+   (a=a)@Boolean
+        true
+
+and since a and c are equal, they are clearly NOT not-equal:
+
+   a~=c
+        false
+
+We can use the any? function to see if a predicate is true for any element:
+
+   any?(x+->(x=4),a)
+        true
+
+or false for every element:
+
+   any?(x+->(x=11),a)
+        false
+
+We can use the every? function to check every element satisfies a predicate:
+
+   every?(x+->(x=11),a)
+        false
+
+We can count the elements that are equal to an argument of this type:
+
+   count(4,a)
+        1
+
+or we can count against a boolean function:
+
+   count(x+->(x>2),a)
+        5
+
+You can also map a function over every element, returning a new stack:
+
+   map(x+->x+10,a)
+        [18,19,13,14,15]
+
+Notice that the orignal stack is unchanged:
+
+   a
+        [8,9,3,4,5]
+
+You can use map! to map a function over every element and change
+the original stack since map! is destructive:
+
+   map!(x+->x+10,a)
+       [18,19,13,14,15]
+
+Notice that the orignal stack has been changed:
+
+   a
+       [18,19,13,14,15]
+
+The member function can also get the element of the stack as a list:
+
+   members a
+       [18,19,13,14,15]
+
+and using member? we can test if the stack holds a given element:
+
+   member?(14,a)
+       true
+
+See Also:
+o )show Stack
+o )show ArrayStack
+o )show Queue
+o )show Dequeue
+o )show Heap
+o )show BagAggregate
+
+@
 \pagehead{Stack}{STACK}
 \pagepic{ps/v103stack.ps}{STACK}{1.00}
 {\bf See}\\
@@ -89421,9 +90125,9 @@ SquareMatrix(ndim,R): Exports == Implementation where
 
 <<domain STACK Stack>>=
 )abbrev domain STACK Stack
-++ Author: Michael Monagan and Stephen Watt
+++ Author: Michael Monagan, Stephen Watt, Timothy Daly
 ++ Date Created:June 86 and July 87
-++ Date Last Updated:Feb 92
+++ Date Last Updated:Feb 09
 ++ Basic Operations:
 ++ Related Domains:
 ++ Also See:
@@ -89441,7 +90145,132 @@ Stack(S:SetCategory): StackAggregate S with
       ++ stack([x,y,...,z]) creates a stack with first (top)
       ++ element x, second element y,...,and last element z.
       ++
-      ++E a:Stack INT:= stack [1,2,3,4,5]
+      ++X a:Stack INT:= stack [1,2,3,4,5]
+
+ -- Inherited Signatures repeated for examples documentation
+
+    pop_! : % -> S
+      ++
+      ++X a:Stack INT:= stack [1,2,3,4,5]
+      ++X pop! a
+      ++X a
+    extract_! : % -> S
+      ++
+      ++X a:Stack INT:= stack [1,2,3,4,5]
+      ++X extract! a
+      ++X a
+    push_! : (S,%) -> S
+      ++
+      ++X a:Stack INT:= stack [1,2,3,4,5]
+      ++X push! a
+      ++X a
+    insert_! : (S,%) -> %
+      ++
+      ++X a:Stack INT:= stack [1,2,3,4,5]
+      ++X insert! a
+      ++X a
+    inspect : % -> S
+      ++
+      ++X a:Stack INT:= stack [1,2,3,4,5]
+      ++X inspect a
+    top : % -> S
+      ++
+      ++X a:Stack INT:= stack [1,2,3,4,5]
+      ++X top a
+    depth : % -> NonNegativeInteger
+      ++
+      ++X a:Stack INT:= stack [1,2,3,4,5]
+      ++X depth a
+    less? : (%,NonNegativeInteger) -> Boolean
+      ++
+      ++X a:Stack INT:= stack [1,2,3,4,5]
+      ++X less?(a,9)
+    more? : (%,NonNegativeInteger) -> Boolean
+      ++
+      ++X a:Stack INT:= stack [1,2,3,4,5]
+      ++X more?(a,9)
+    size? : (%,NonNegativeInteger) -> Boolean
+      ++
+      ++X a:Stack INT:= stack [1,2,3,4,5]
+      ++X size?(a,5)
+    bag : List S -> %
+      ++
+      ++X bag([1,2,3,4,5])$Stack(INT)
+    empty? : % -> Boolean
+      ++
+      ++X a:Stack INT:= stack [1,2,3,4,5]
+      ++X empty? a
+    empty : () -> %
+      ++
+      ++X b:=empty()$(Stack INT)
+    sample : () -> %
+      ++
+      ++X sample()$Stack(INT)
+    copy : % -> %
+      ++
+      ++X a:Stack INT:= stack [1,2,3,4,5]
+      ++X copy a
+    eq? : (%,%) -> Boolean
+      ++
+      ++X a:Stack INT:= stack [1,2,3,4,5]
+      ++X b:=copy a
+      ++X eq?(a,b)
+    map :  ((S -> S),%) -> %
+      ++
+      ++X a:Stack INT:= stack [1,2,3,4,5]
+      ++X map(x+->x+10,a)
+      ++X a
+    if $ has shallowlyMutable then
+      map! :  ((S -> S),%) -> %
+        ++
+        ++X a:Stack INT:= stack [1,2,3,4,5]
+        ++X map!(x+->x+10,a)
+        ++X a
+    if S has SetCategory then
+      "=": (%,%) -> Boolean
+        ++
+        ++X a:Stack INT:= stack [1,2,3,4,5]
+        ++X b:Stack INT:= stack [1,2,3,4,5]
+        ++X (a=b)@Boolean
+      "~=" : (%,%) -> Boolean
+        ++
+        ++X a:Stack INT:= stack [1,2,3,4,5]
+        ++X b:=copy a
+        ++X (a~=b)
+    if % has finiteAggregate then
+      every? : ((S -> Boolean),%) -> Boolean
+        ++
+        ++X a:Stack INT:= stack [1,2,3,4,5]
+        ++X every?(x+->(x=4),a)
+      any? : ((S -> Boolean),%) -> Boolean
+        ++
+        ++X a:Stack INT:= stack [1,2,3,4,5]
+        ++X any?(x+->(x=4),a)
+      count :  ((S -> Boolean),%) -> NonNegativeInteger
+        ++
+        ++X a:Stack INT:= stack [1,2,3,4,5]
+        ++X count(x+->(x>2),a)
+      _# : % -> NonNegativeInteger
+        ++
+        ++X a:Stack INT:= stack [1,2,3,4,5]
+        ++X #a
+      parts : % -> List S
+        ++
+        ++X a:Stack INT:= stack [1,2,3,4,5]
+        ++X parts a
+      members : % -> List S
+        ++
+        ++X a:Stack INT:= stack [1,2,3,4,5]
+        ++X members a
+    if % has finiteAggregate and S has SetCategory then
+      member? : (S,%) -> Boolean
+        ++
+        ++X a:Stack INT:= stack [1,2,3,4,5]
+        ++X member?(3,a)
+      count : (S,%) -> NonNegativeInteger
+        ++
+        ++X a:Stack INT:= stack [1,2,3,4,5]
+        ++X count(4,a)
 
   == add
     Rep := Reference List S
@@ -89465,6 +90294,9 @@ Stack(S:SetCategory): StackAggregate S with
     empty() == ref nil()$List(S)
     empty? s == null deref s
     stack s == ref copy s
+    parts s == copy deref s
+    map(f,s) == ref map(f,deref s)
+    map!(f,s) == ref map!(f,deref s)
 
 @
 <<STACK.dotabb>>=
diff --git a/changelog b/changelog
index a73b55d..0cf904a 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,6 @@
+20090222 tpd src/axiom-website/patches.html 20090222.02.tpd.patch
+20090222 tpd src/interp/Makefile add regression, help for Stack
+20090222 tpd books/bookvol10.3 add regression, help, examples for Stack
 20090222 tpd src/axiom-website/patches.html 20090222.01.tpd.patch
 20090222 tpd src/interp/setq.lisp Stephen Buchwald to credits
 20090222 tpd readme add Stephen Buchwald to credits
diff --git a/src/algebra/Makefile.pamphlet b/src/algebra/Makefile.pamphlet
index 952fd83..841a1c1 100644
--- a/src/algebra/Makefile.pamphlet
+++ b/src/algebra/Makefile.pamphlet
@@ -16459,7 +16459,7 @@ SPADHELP=\
  ${HELP}/SegmentBinding.help \
  ${HELP}/Set.help                    ${HELP}/SingleInteger.help \
  ${HELP}/SparseTable.help            ${HELP}/SquareMatrix.help \
- ${HELP}/SquareFreeRegularTriangularSet.help \
+ ${HELP}/SquareFreeRegularTriangularSet.help ${HELP}/Stack.help \
  ${HELP}/Stream.help                 ${HELP}/String.help \
  ${HELP}/StringTable.help            ${HELP}/Symbol.help \
  ${HELP}/Table.help                  ${HELP}/TextFile.help \
@@ -16525,7 +16525,7 @@ REGRESS=\
  RomanNumeral.regress           Segment.regress \
  Set.regress                    SingleInteger.regress \
  SparseTable.regress            SquareMatrix.regress \
- SquareFreeRegularTriangularSet.regress \
+ SquareFreeRegularTriangularSet.regress Stack.regress \
  Stream.regress                 String.regress \
  StringTable.regress            Symbol.regress \
  Table.regress                  TextFile.regress \
@@ -17408,6 +17408,15 @@ ${HELP}/SquareFreeRegularTriangularSet.help: ${BOOKS}/bookvol10.3.pamphlet
             >${INPUT}/SquareFreeRegularTriangularSet.input
 	@echo "SquareFreeRegularTriangularSet (SREGSET)" >>${HELPFILE}
 
+${HELP}/Stack.help: ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7078 create Stack.help from ${BOOKS}/bookvol10.3.pamphlet
+	@${TANGLE} -R"Stack.help" ${BOOKS}/bookvol10.3.pamphlet \
+           >${HELP}/Stack.help
+	@-cp ${HELP}/Stack.help ${HELP}/STREAM.help
+	@${TANGLE} -R"Stack.input" ${BOOKS}/bookvol10.3.pamphlet \
+            >${INPUT}/Stack.input
+	@echo "Stack (STACK)" >>${HELPFILE}
+
 ${HELP}/Stream.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo 7078 create Stream.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Stream.help" ${BOOKS}/bookvol10.3.pamphlet \
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index a861a06..a8c96df 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -955,5 +955,7 @@ remove bookvol5 dvi creation<br/>
 add Scott Morrison's original hypertex plan<br/>
 <a href="patches/20090222.01.tpd.patch">20090222.01.tpd.patch</a>
 add Stephen Buchwald to credits<br/>
+<a href="patches/20090222.02.tpd.patch">20090222.02.tpd.patch</a>
+bookvol10.3 add regression, help, examples for Stack<br/>
  </body>
 </html>



From MAILER-DAEMON Mon Feb 23 06:19:51 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LbYql-0001pf-5R
	for mharc-axiom-developer@gnu.org; Mon, 23 Feb 2009 06:19:51 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LbYqj-0001oZ-Ex
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 06:19:49 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LbYqf-0001lZ-US
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 06:19:48 -0500
Received: from [199.232.76.173] (port=46624 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LbYqf-0001lJ-O8
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 06:19:45 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:53867
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LbYqe-0002QL-Vs
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 06:19:45 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1NBJgug007061;
	Mon, 23 Feb 2009 05:19:42 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1NBJg0O007056;
	Mon, 23 Feb 2009 05:19:42 -0600
Date: Mon, 23 Feb 2009 05:19:42 -0600
Message-Id: <200902231119.n1NBJg0O007056@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090222.04.tpd.patch (bookvol10.3 Add ...
	ArrayStack docs)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 23 Feb 2009 11:19:49 -0000

Add regression test for ArrayStack.
Add help file for ArrayStack.

Fix stack representation bug in ArrayStack
Fix missing function implementations in ArrayStack, Stack.
Fix bugs 7172-7178

Tim

=======================================================================
diff --git a/books/bookvol10.3.pamphlet b/books/bookvol10.3.pamphlet
index 23ee487..c232fc0 100644
--- a/books/bookvol10.3.pamphlet
+++ b/books/bookvol10.3.pamphlet
@@ -1596,6 +1596,7 @@ Any(): SetCategory with
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{domain ASTACK ArrayStack}
 <<ArrayStack.input>>=
+-- stack.spad.pamphlet Stack.input
 )sys rm -f ArrayStack.output
 )spool ArrayStack.output
 )set message test on
@@ -1603,11 +1604,11 @@ Any(): SetCategory with
 )clear all
 
 --S 1 of 44
-a:Stack INT:= stack [1,2,3,4,5]
+a:ArrayStack INT:= arrayStack [1,2,3,4,5]
 --R 
 --R
 --R   (1)  [1,2,3,4,5]
---R                                                          Type: Stack Integer
+--R                                                     Type: ArrayStack Integer
 --E 1
 
 --S 2 of 44
@@ -1623,14 +1624,14 @@ a
 --R 
 --R
 --R   (3)  [2,3,4,5]
---R                                                          Type: Stack Integer
+--R                                                     Type: ArrayStack Integer
 --E 3
 
 --S 4 of 44
-push!(9,a)
+extract! a
 --R 
 --R
---R   (4)  9
+--R   (4)  2
 --R                                                        Type: PositiveInteger
 --E 4
 
@@ -1638,98 +1639,578 @@ push!(9,a)
 a
 --R 
 --R
---R   (5)  [9,2,3,4,5]
---R                                                          Type: Stack Integer
+--R   (5)  [3,4,5]
+--R                                                     Type: ArrayStack Integer
 --E 5
 
 --S 6 of 44
-empty? a
+push!(9,a)
 --R 
 --R
---R   (6)  false
---R                                                                Type: Boolean
+--R   (6)  9
+--R                                                        Type: PositiveInteger
 --E 6
 
 --S 7 of 44
-b:=empty()$(Stack INT)
+a
 --R 
 --R
---R   (7)  []
---R                                                          Type: Stack Integer
+--R   (7)  [9,3,4,5]
+--R                                                     Type: ArrayStack Integer
 --E 7
 
 --S 8 of 44
+insert!(8,a)
+--R 
+--R
+--R   (8)  [8,9,3,4,5]
+--R                                                     Type: ArrayStack Integer
+--E 8
+
+--S 9 of 44
+a
+--R 
+--R
+--R   (9)  [8,9,3,4,5]
+--R                                                     Type: ArrayStack Integer
+--E 9
+
+--S 10 of 44
+inspect a
+--R 
+--R
+--R   (10)  8
+--R                                                        Type: PositiveInteger
+--E 10
+
+--S 11 of 44
+empty? a
+--R 
+--R
+--R   (11)  false
+--R                                                                Type: Boolean
+--E 11
+
+--S 12 of 44
+top a
+--R 
+--R
+--R   (12)  8
+--R                                                        Type: PositiveInteger
+--E 12
+
+--S 13 of 44
+depth a
+--R 
+--R
+--R   (13)  5
+--R                                                        Type: PositiveInteger
+--E 13
+
+--S 14 of 44
+#a
+--R 
+--R
+--R   (14)  5
+--R                                                        Type: PositiveInteger
+--E 14
+
+--S 15 of 44
+less?(a,9)
+--R 
+--R
+--R   (15)  true
+--R                                                                Type: Boolean
+--E 15
+
+--S 16 of 44
+more?(a,9)
+--R 
+--R
+--R   (16)  false
+--R                                                                Type: Boolean
+--E 16
+
+--S 17 of 44
+size?(a,#a)
+--R 
+--R
+--R   (17)  true
+--R                                                                Type: Boolean
+--E 17
+
+--S 18 of 44
+size?(a,9)
+--R 
+--R
+--R   (18)  false
+--R                                                                Type: Boolean
+--E 18
+
+--S 19 of 44
+parts a
+--R 
+--R
+--R   (19)  [8,9,3,4,5]
+--R                                                           Type: List Integer
+--E 19
+
+--S 20 of 44
+bag([1,2,3,4,5])$ArrayStack(INT)
+--R 
+--R
+--R   (20)  [5,4,3,2,1]
+--R                                                     Type: ArrayStack Integer
+--E 20
+
+--S 21 of 44
+b:=empty()$(ArrayStack INT)
+--R 
+--R
+--R   (21)  []
+--R                                                     Type: ArrayStack Integer
+--E 21
+
+--S 22 of 44
 empty? b
 --R 
 --R
---R   (8)  true
+--R   (22)  true
 --R                                                                Type: Boolean
---E 8
+--E 22
+
+--S 23 of 44
+sample()$ArrayStack(INT)
+--R 
+--R
+--R   (23)  []
+--R                                                     Type: ArrayStack Integer
+--E 23
+
+--S 24 of 44
+c:=copy a
+--R 
+--R
+--R   (24)  [8,9,3,4,5]
+--R                                                     Type: ArrayStack Integer
+--E 24
+
+--S 25 of 44
+eq?(a,c)
+--R 
+--R
+--R   (25)  false
+--R                                                                Type: Boolean
+--E 25
+
+--S 26 of 44
+eq?(a,a)
+--R 
+--R
+--R   (26)  true
+--R                                                                Type: Boolean
+--E 26
+
+--S 27 of 44
+(a=c)@Boolean
+--R 
+--R
+--R   (27)  true
+--R                                                                Type: Boolean
+--E 27
+
+--S 28 of 44
+(a=a)@Boolean
+--R 
+--R
+--R   (28)  true
+--R                                                                Type: Boolean
+--E 28
+
+--S 29 of 44
+a~=c
+--R 
+--R
+--R   (29)  false
+--R                                                                Type: Boolean
+--E 29
+
+--S 30 of 44
+any?(x+->(x=4),a)
+--R 
+--R
+--R   (30)  true
+--R                                                                Type: Boolean
+--E 30
+
+--S 31 of 44
+any?(x+->(x=11),a)
+--R 
+--R
+--R   (31)  false
+--R                                                                Type: Boolean
+--E 31
+
+--S 32 of 44
+every?(x+->(x=11),a)
+--R 
+--R
+--R   (32)  false
+--R                                                                Type: Boolean
+--E 32
+
+--S 33 of 44
+count(4,a)
+--R 
+--R
+--R   (33)  1
+--R                                                        Type: PositiveInteger
+--E 33
+
+--S 34 of 44
+count(x+->(x>2),a)
+--R 
+--R
+--R   (34)  5
+--R                                                        Type: PositiveInteger
+--E 34
+
+--S 35 of 44
+map(x+->x+10,a)
+--R 
+--R
+--R   (35)  [18,19,13,14,15]
+--R                                                     Type: ArrayStack Integer
+--E 35
+
+--S 36 of 44
+a
+--R 
+--R
+--R   (36)  [8,9,3,4,5]
+--R                                                     Type: ArrayStack Integer
+--E 36
+
+--S 37 of 44
+map!(x+->x+10,a)
+--R 
+--R
+--R   (37)  [18,19,13,14,15]
+--R                                                     Type: ArrayStack Integer
+--E 37
+
+--S 38 of 44
+a
+--R 
+--R
+--R   (38)  [18,19,13,14,15]
+--R                                                     Type: ArrayStack Integer
+--E 38
+
+--S 39 of 44
+members a
+--R 
+--R
+--R   (39)  [18,19,13,14,15]
+--R                                                           Type: List Integer
+--E 39
+
+--S 40 of 44
+member?(14,a)
+--R 
+--R
+--R   (40)  true
+--R                                                                Type: Boolean
+--E 40
+
+--S 41 of 44
+coerce a
+--R 
+--R
+--R   (41)  [18,19,13,14,15]
+--R                                                             Type: OutputForm
+--E 41
+
+--S 42 of 44
+hash a
+--R 
+--R
+--R   (42)  0
+--R                                                          Type: SingleInteger
+--E 42
+
+--S 43 of 44
+latex a
+--R 
+--R
+--R   (43)  "\mbox{\bf Unimplemented}"
+--R                                                                 Type: String
+--E 43
+
+--S 44 of 44
+)show ArrayStack
+--R 
+--R ArrayStack S: SetCategory  is a domain constructor
+--R Abbreviation for ArrayStack is ASTACK 
+--R This constructor is exposed in this frame.
+--R Issue )edit bookvol10.3.spad.pamphlet to see algebra source code for ASTACK 
+--R
+--R------------------------------- Operations --------------------------------
+--R arrayStack : List S -> %              bag : List S -> %
+--R copy : % -> %                         depth : % -> NonNegativeInteger
+--R empty : () -> %                       empty? : % -> Boolean
+--R eq? : (%,%) -> Boolean                extract! : % -> S
+--R insert! : (S,%) -> %                  inspect : % -> S
+--R map : ((S -> S),%) -> %               pop! : % -> S
+--R push! : (S,%) -> S                    sample : () -> %
+--R top : % -> S                         
+--R #? : % -> NonNegativeInteger if $ has finiteAggregate
+--R ?=? : (%,%) -> Boolean if S has SETCAT
+--R any? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
+--R coerce : % -> OutputForm if S has SETCAT
+--R count : (S,%) -> NonNegativeInteger if $ has finiteAggregate and S has SETCAT
+--R count : ((S -> Boolean),%) -> NonNegativeInteger if $ has finiteAggregate
+--R eval : (%,List S,List S) -> % if S has EVALAB S and S has SETCAT
+--R eval : (%,S,S) -> % if S has EVALAB S and S has SETCAT
+--R eval : (%,Equation S) -> % if S has EVALAB S and S has SETCAT
+--R eval : (%,List Equation S) -> % if S has EVALAB S and S has SETCAT
+--R every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
+--R hash : % -> SingleInteger if S has SETCAT
+--R latex : % -> String if S has SETCAT
+--R less? : (%,NonNegativeInteger) -> Boolean
+--R map! : ((S -> S),%) -> % if $ has shallowlyMutable
+--R member? : (S,%) -> Boolean if $ has finiteAggregate and S has SETCAT
+--R members : % -> List S if $ has finiteAggregate
+--R more? : (%,NonNegativeInteger) -> Boolean
+--R parts : % -> List S if $ has finiteAggregate
+--R size? : (%,NonNegativeInteger) -> Boolean
+--R ?~=? : (%,%) -> Boolean if S has SETCAT
+--R
+--E 44
 
 )spool
 )lisp (bye)
  
 @
-<<Stack.help>>=
+<<ArrayStack.help>>=
 ====================================================================
-Stack examples
+ArrayStack examples
 ====================================================================
 
-A Stack object is represented as a list ordered by last-in, first-out.
+An ArrayStack object is represented as a list ordered by last-in, first-out.
 It operates like a pile of books, where the "next" book is the one
-on the top of the pile.
+on the top of the pile. 
 
-Here we create a stack of integers from a list. Notice that the
+Here we create an array stack of integers from a list. Notice that the
 order in the list is the order in the stack.
 
-   a:Stack INT:= stack [1,2,3,4,5]
-
-      (1)  [1,2,3,4,5]
+   a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      [1,2,3,4,5]
 
 We can remove the top of the stack using pop!:
 
    pop! a
-
-      (2)  1
+      1
 
 Notice that the use of pop! is destructive (destructive operations
 in Axiom usually end with ! to indicate that the underylying data
 structure is changed).
 
    a
+      [2,3,4,5]
+
+The extract! operation is another name for the pop! operation and
+has the same effect. This operation treats the stack as a BagAggregate:
+
+   extract! a
+      2
+
+and you can see that it also has destructively modified the stack:
 
-      (3)  [2,3,4,5]
+   a
+      [3,4,5]
 
 Next we push a new element on top of the stack:
 
    push!(9,a)
-
-      (4)  9
+      9
 
 Again, the push! operation is destructive so the stack is changed:
 
    a
+      [9,3,4,5]
 
-      (5)  [9,2,3,4,5]
+Another name for push! is insert!, which treats the stack as a BagAggregate:
 
-We can ask if the stack is empty (boolean predicates in Axiom 
-generally end in a question mark):
+   insert!(8,a)
+      [8,9,3,4,5]
+
+and it modifies the stack:
+
+   a
+      [8,9,3,4,5]
+
+The inspect function returns the top of the stack without modification,
+viewed as a BagAggregate:
+
+   inspect a
+      8
+
+The empty? operation returns true only if there are no element on the
+stack, otherwise it returns false:
 
    empty? a
+      false
 
-      (6)  false
+The top operation returns the top of stack without modification, viewed
+as a Stack:
 
-We can create a new, empty stack:
+   top a
+      8
 
-   b:=empty()$(Stack INT)
+The depth operation returns the number of elements on the stack:
+
+   depth a
+      5
+
+which is the same as the # (length) operation:
+
+   #a
+       5
 
-      (7)  []
+The less? predicate will compare the stack length to an integer:
+
+   less?(a,9)
+        true
+
+The more? predicate will compare the stack length to an integer:
 
-And we can ask if b is empty:
+   more?(a,9)
+        false
+
+The size? operation will compare the stack length to an integer:
+
+   size?(a,#a)
+        true
+
+and since the last computation must alwasy be true we try:
+
+   size?(a,9)
+        false
+
+The parts function will return  the stack as a list of its elements:
+
+   parts a
+        [8,9,3,4,5]
+
+If we have a BagAggregate of elements we can use it to construct a stack.
+Notice that the elements are pushed in reverse order:
+
+   bag([1,2,3,4,5])$ArrayStack(INT)
+        [5,4,3,2,1]
+
+The empty function will construct an empty stack of a given type:
+
+   b:=empty()$(ArrayStack INT)
+        []
+
+and the empty? predicate allows us to find out if a stack is empty:
 
    empty? b
+        true
+
+The sample function returns a sample, empty stack:
 
-      (8)  true
+   sample()$ArrayStack(INT)
+        []
+
+We can copy a stack and it does not share storage so subsequent
+modifications of the original stack will not affect the copy:
+
+   c:=copy a
+        [8,9,3,4,5]
+
+The eq? function is only true if the lists are the same reference,
+so even though c is a copy of a, they are not the same:
+
+   eq?(a,c)
+        false
+
+However, a clearly shares a reference with itself:
+
+   eq?(a,a)
+        true
+
+But we can compare a and c for equality:
+
+   (a=c)@Boolean
+        true
+
+and clearly a is equal to itself:
+
+   (a=a)@Boolean
+        true
+
+and since a and c are equal, they are clearly NOT not-equal:
+
+   a~=c
+        false
+
+We can use the any? function to see if a predicate is true for any element:
+
+   any?(x+->(x=4),a)
+        true
+
+or false for every element:
+
+   any?(x+->(x=11),a)
+        false
+
+We can use the every? function to check every element satisfies a predicate:
+
+   every?(x+->(x=11),a)
+        false
+
+We can count the elements that are equal to an argument of this type:
+
+   count(4,a)
+        1
+
+or we can count against a boolean function:
+
+   count(x+->(x>2),a)
+        5
+
+You can also map a function over every element, returning a new stack:
+
+   map(x+->x+10,a)
+        [18,19,13,14,15]
+
+Notice that the orignal stack is unchanged:
+
+   a
+        [8,9,3,4,5]
+
+You can use map! to map a function over every element and change
+the original stack since map! is destructive:
+
+   map!(x+->x+10,a)
+       [18,19,13,14,15]
+o
+Notice that the orignal stack has been changed:
+
+   a
+       [18,19,13,14,15]
+
+The member function can also get the element of the stack as a list:
+
+   members a
+       [18,19,13,14,15]
+
+and using member? we can test if the stack holds a given element:
+
+   member?(14,a)
+       true
 
 See Also:
 o )show Stack
@@ -1737,6 +2218,7 @@ o )show ArrayStack
 o )show Queue
 o )show Dequeue
 o )show Heap
+o )show BagAggregate
 
 @
 \pagehead{ArrayStack}{ASTACK}
@@ -1785,7 +2267,7 @@ o )show Heap
 
 <<domain ASTACK ArrayStack>>=
 )abbrev domain ASTACK ArrayStack
-++ Author: Michael Monagan and Stephen Watt
+++ Author: Michael Monagan, Stephen Watt, Timothy Daly
 ++ Date Created:June 86 and July 87
 ++ Date Last Updated:Feb 92
 ++ Basic Operations:
@@ -1807,6 +2289,143 @@ ArrayStack(S:SetCategory): StackAggregate(S) with
       ++
       ++E c:ArrayStack INT:= arrayStack [1,2,3,4,5]
 
+ -- Inherited Signatures repeated for examples documentation
+
+    pop_! : % -> S
+      ++
+      ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++X pop! a
+      ++X a
+    extract_! : % -> S
+      ++
+      ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++X extract! a
+      ++X a
+    push_! : (S,%) -> S
+      ++
+      ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++X push! a
+      ++X a
+    insert_! : (S,%) -> %
+      ++
+      ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++X insert! a
+      ++X a
+    inspect : % -> S
+      ++
+      ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++X inspect a
+    top : % -> S
+      ++
+      ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++X top a
+    depth : % -> NonNegativeInteger
+      ++
+      ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++X depth a
+    less? : (%,NonNegativeInteger) -> Boolean
+      ++
+      ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++X less?(a,9)
+    more? : (%,NonNegativeInteger) -> Boolean
+      ++
+      ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++X more?(a,9)
+    size? : (%,NonNegativeInteger) -> Boolean
+      ++
+      ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++X size?(a,5)
+    bag : List S -> %
+      ++
+      ++X bag([1,2,3,4,5])$ArrayStack(INT)
+    empty? : % -> Boolean
+      ++
+      ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++X empty? a
+    empty : () -> %
+      ++
+      ++X b:=empty()$(ArrayStack INT)
+    sample : () -> %
+      ++
+      ++X sample()$ArrayStack(INT)
+    copy : % -> %
+      ++
+      ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++X copy a
+    eq? : (%,%) -> Boolean
+      ++
+      ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++X b:=copy a
+      ++X eq?(a,b)
+    map :  ((S -> S),%) -> %
+      ++
+      ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++X map(x+->x+10,a)
+      ++X a
+    if $ has shallowlyMutable then
+      map! :  ((S -> S),%) -> %
+        ++
+        ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+        ++X map!(x+->x+10,a)
+        ++X a
+    if S has SetCategory then
+      latex : % -> String
+        ++
+        ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+        ++X latex a
+      hash : % -> SingleInteger
+        ++
+        ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+        ++X hash a
+      coerce : % -> OutputForm
+        ++
+        ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+        ++X coerce a
+      "=": (%,%) -> Boolean
+        ++
+        ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+        ++X b:ArrayStack INT:= arrayStack [1,2,3,4,5]
+        ++X (a=b)@Boolean
+      "~=" : (%,%) -> Boolean
+        ++
+        ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+        ++X b:=copy a
+        ++X (a~=b)
+    if % has finiteAggregate then
+      every? : ((S -> Boolean),%) -> Boolean
+        ++
+        ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+        ++X every?(x+->(x=4),a)
+      any? : ((S -> Boolean),%) -> Boolean
+        ++
+        ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+        ++X any?(x+->(x=4),a)
+      count :  ((S -> Boolean),%) -> NonNegativeInteger
+        ++
+        ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+        ++X count(x+->(x>2),a)
+      _# : % -> NonNegativeInteger
+        ++
+        ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+        ++X #a
+      parts : % -> List S
+        ++
+        ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+        ++X parts a
+      members : % -> List S
+        ++
+        ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+        ++X members a
+    if % has finiteAggregate and S has SetCategory then
+      member? : (S,%) -> Boolean
+        ++
+        ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+        ++X member?(3,a)
+      count : (S,%) -> NonNegativeInteger
+        ++
+        ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
+        ++X count(4,a)
+
   == add
     Rep := IndexedFlexibleArray(S,0)
  
@@ -1826,13 +2445,18 @@ ArrayStack(S:SetCategory): StackAggregate(S) with
     push_!(e,s) == (concat(e,s); e)
     pop_! s ==
         if empty? s then error "empty stack"
-        m := maxIndex s
-        r := s.m
-        delete_!(s,m)
+        r := s.0
+        delete_!(s,0)
         r
-    top s == if empty? s then error "empty stack" else s.maxIndex(s)
+    top s == if empty? s then error "empty stack" else s.0
     arrayStack l == construct(l)$Rep
     empty() == new(0,0 pretend S)
+    parts s == [s.i for i in 0..#s-1]::List(S)
+    map(f,s) == construct [f(s.i) for i in 0..#s-1]
+    map!(f,s) == ( for i in 0..#s-1 repeat qsetelt!(s,i,f(s.i)) ; s )
+    inspect(s) ==  
+        if empty? s then error "empty stack"
+        qelt(s,0)
 
 @
 <<ASTACK.dotabb>>=
@@ -89527,287 +90151,311 @@ SquareMatrix(ndim,R): Exports == Implementation where
 )set message auto off
 )clear all
 
---S 1 of 41
+--S 1 of 44
 a:Stack INT:= stack [1,2,3,4,5]
 --R
 --R   (1)  [1,2,3,4,5]
 --R                                                          Type: Stack Integer
 --E 1
 
---S 2 of 41
+--S 2 of 44
 pop! a
 --R
 --R   (2)  1
 --R                                                        Type: PositiveInteger
 --E 2
 
---S 3 of 41
+--S 3 of 44
 a
 --R
 --R   (3)  [2,3,4,5]
 --R                                                          Type: Stack Integer
 --E 3
 
---S 4 of 41
+--S 4 of 44
 extract! a
 --R
 --R   (4)  2
 --R                                                        Type: PositiveInteger
 --E 4
 
---S 5 of 41
+--S 5 of 44
 a
 --R
 --R   (5)  [3,4,5]
 --R                                                          Type: Stack Integer
 --E 5
 
---S 6 of 41
+--S 6 of 44
 push!(9,a)
 --R
 --R   (6)  9
 --R                                                        Type: PositiveInteger
 --E 6
 
---S 7 of 41
+--S 7 of 44
 a
 --R
 --R   (7)  [9,3,4,5]
 --R                                                          Type: Stack Integer
 --E 7
 
---S 8 of 41
+--S 8 of 44
 insert!(8,a)
 --R
 --R   (8)  [8,9,3,4,5]
 --R                                                          Type: Stack Integer
 --E 8
 
---S 9 of 41
+--S 9 of 44
 a
 --R
 --R   (9)  [8,9,3,4,5]
 --R                                                          Type: Stack Integer
 --E 9
 
---S 10 of 41
+--S 10 of 44
 inspect a
 --R
 --R   (10)  8
 --R                                                        Type: PositiveInteger
 --E 10
 
---S 11 of 41
+--S 11 of 44
 empty? a
 --R
 --R   (11)  false
 --R                                                                Type: Boolean
 --E 11
 
---S 12 of 41
+--S 12 of 44
 top a
 --R
 --R   (12)  8
 --R                                                        Type: PositiveInteger
 --E 12
 
---S 13 of 41
+--S 13 of 44
 depth a
 --R
 --R   (13)  5
 --R                                                        Type: PositiveInteger
 --E 13
 
---S 14 of 41
+--S 14 of 44
 #a
 --R
 --R   (14)  5
 --R                                                        Type: PositiveInteger
 --E 14
 
---S 15 of 41
+--S 15 of 44
 less?(a,9)
 --R
 --R   (15)  true
 --R                                                                Type: Boolean
 --E 15
 
---S 16 of 41
+--S 16 of 44
 more?(a,9)
 --R
 --R   (16)  false
 --R                                                                Type: Boolean
 --E 16
 
---S 17 of 41
+--S 17 of 44
 size?(a,#a)
 --R
 --R   (17)  true
 --R                                                                Type: Boolean
 --E 17
 
---S 18 of 41
+--S 18 of 44
 size?(a,9)
 --R
 --R   (18)  false
 --R                                                                Type: Boolean
 --E 18
 
---S 19 of 41
+--S 19 of 44
 parts a
 --R
 --R   (19)  [8,9,3,4,5]
 --R                                                           Type: List Integer
 --E 19
 
---S 20 of 41
+--S 20 of 44
 bag([1,2,3,4,5])$Stack(INT)
 --R
 --R   (20)  [5,4,3,2,1]
 --R                                                          Type: Stack Integer
 --E 20
 
---S 21 of 41
+--S 21 of 44
 b:=empty()$(Stack INT)
 --R
 --R   (21)  []
 --R                                                          Type: Stack Integer
 --E 21
 
---S 22 of 41
+--S 22 of 44
 empty? b
 --R
 --R   (22)  true
 --R                                                                Type: Boolean
 --E 22
 
---S 23 of 41
+--S 23 of 44
 sample()$Stack(INT)
 --R
 --R   (23)  []
 --R                                                          Type: Stack Integer
 --E 23
 
---S 24 of 41
+--S 24 of 44
 c:=copy a
 --R
 --R   (24)  [8,9,3,4,5]
 --R                                                          Type: Stack Integer
 --E 24
 
---S 25 of 41
+--S 25 of 44
 eq?(a,c)
 --R
 --R   (25)  false
 --R                                                                Type: Boolean
 --E 25
 
---S 26 of 41
+--S 26 of 44
 eq?(a,a)
 --R
 --R   (26)  true
 --R                                                                Type: Boolean
 --E 26
 
---S 27 of 41
+--S 27 of 44
 (a=c)@Boolean
 --R
 --R   (27)  true
 --R                                                                Type: Boolean
 --E 27
 
---S 28 of 41
+--S 28 of 44
 (a=a)@Boolean
 --R
 --R   (28)  true
 --R                                                                Type: Boolean
 --E 28
 
---S 29 of 41
+--S 29 of 44
 a~=c
 --R
 --R   (29)  false
 --R                                                                Type: Boolean
 --E 29
 
---S 30 of 41
+--S 30 of 44
 any?(x+->(x=4),a)
 --R
 --R   (30)  true
 --R                                                                Type: Boolean
 --E 30
 
---S 31 of 41
+--S 31 of 44
 any?(x+->(x=11),a)
 --R
 --R   (31)  false
 --R                                                                Type: Boolean
 --E 31
 
---S 32 of 41
+--S 32 of 44
 every?(x+->(x=11),a)
 --R
 --R   (32)  false
 --R                                                                Type: Boolean
 --E 32
 
---S 33 of 41
+--S 33 of 44
 count(4,a)
 --R
 --R   (33)  1
 --R                                                        Type: PositiveInteger
 --E 33
 
---S 34 of 41
+--S 34 of 44
 count(x+->(x>2),a)
 --R
 --R   (34)  5
 --R                                                        Type: PositiveInteger
 --E 34
 
---S 35 of 41
+--S 35 of 44
 map(x+->x+10,a)
 --R
 --R   (35)  [18,19,13,14,15]
 --R                                                          Type: Stack Integer
 --E 35
 
---S 36 of 41
+--S 36 of 44
 a
 --R
 --R   (36)  [8,9,3,4,5]
 --R                                                          Type: Stack Integer
 --E 36
 
---S 37 of 41
+--S 37 of 44
 map!(x+->x+10,a)
 --R
 --R   (37)  [18,19,13,14,15]
 --R                                                          Type: Stack Integer
 --E 37
 
---S 38 of 41
+--S 38 of 44
 a
 --R
 --R   (38)  [18,19,13,14,15]
 --R                                                          Type: Stack Integer
 --E 38
 
---S 39 of 41
+--S 39 of 44
 members a
 --R
 --R   (39)  [18,19,13,14,15]
 --R                                                           Type: List Integer
 --E 39
 
---S 40 of 41
+--S 40 of 44
 member?(14,a)
 --R
 --R   (40)  true
 --R                                                                Type: Boolean
 --E 40
 
---S 41 of 41
+--S 41 of 44
+coerce a
+--R 
+--R
+--R   (41)  [18,19,13,14,15]
+--R                                                             Type: OutputForm
+--E 41
+
+--S 42 of 44
+hash a
+--R 
+--R
+--R   (42)  0
+--R                                                          Type: SingleInteger
+--E 42
+
+--S 43 of 44
+latex a
+--R 
+--R
+--R   (43)  "\mbox{\bf Unimplemented}"
+--R                                                                 Type: String
+--E 43
+
+--S 44 of 44
 )show Stack
 --R Stack S: SetCategory  is a domain constructor
 --R Abbreviation for Stack is STACK 
@@ -89845,7 +90493,7 @@ member?(14,a)
 --R size? : (%,NonNegativeInteger) -> Boolean
 --R ?~=? : (%,%) -> Boolean if S has SETCAT
 --R
---E 41
+--E 44
 )spool
 )lisp (bye)
  
@@ -89880,7 +90528,7 @@ structure is changed).
 The extract! operation is another name for the pop! operation and
 has the same effect. This operation treats the stack as a BagAggregate:
 
-o   extract! a
+   extract! a
       2
 
 and you can see that it also has destructively modified the stack:
@@ -90227,6 +90875,18 @@ Stack(S:SetCategory): StackAggregate S with
         ++X map!(x+->x+10,a)
         ++X a
     if S has SetCategory then
+      latex : % -> String
+        ++
+        ++X a:Stack INT:= stack [1,2,3,4,5]
+        ++X latex a
+      hash : % -> SingleInteger
+        ++
+        ++X a:Stack INT:= stack [1,2,3,4,5]
+        ++X hash a
+      coerce : % -> OutputForm
+        ++
+        ++X a:Stack INT:= stack [1,2,3,4,5]
+        ++X coerce a
       "=": (%,%) -> Boolean
         ++
         ++X a:Stack INT:= stack [1,2,3,4,5]
diff --git a/changelog b/changelog
index 53741f2..140b82f 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,7 @@
+20090222 tpd src/axiom-website/patches.html 20090222.04.tpd.patch
+20090222 tpd src/interp/Makefile add regression, help for ArrayStack
+20090222 tpd books/bookvol10.3 add regression, help, examples for ArrayStack
+20090222 tpd books/bookvol10.3 fix bugs 7172-7178
 20090222 tpd src/axiom-website/patches.html 20090222.03.tpd.patch
 20090222 tpd books/bookvol10.2 add documentation
 20090222 tpd books/ps/v102algebrahierarchy.ps added
diff --git a/src/algebra/Makefile.pamphlet b/src/algebra/Makefile.pamphlet
index 841a1c1..4ed8ac9 100644
--- a/src/algebra/Makefile.pamphlet
+++ b/src/algebra/Makefile.pamphlet
@@ -16411,6 +16411,7 @@ This keeps the regression test list in the algebra Makefile.
 HELPFILE=${INT}/doc/help.helplist
 
 SPADHELP=\
+ ${HELP}/ArrayStack.help \
  ${HELP}/AssociationList.help        ${HELP}/BalancedBinaryTree.help \
  ${HELP}/BasicOperator.help          ${HELP}/BinaryExpansion.help \
  ${HELP}/BinarySearchTree.help       ${HELP}/CardinalNumber.help \
@@ -16479,6 +16480,7 @@ is put into a int/Makefile.algebra and then executed by make.
 TESTSYS=  ${OBJ}/${SYS}/bin/interpsys
 
 REGRESS=\
+ ArrayStack.regress \
  AssociationList.regress        BalancedBinaryTree.regress \
  BasicOperator.regress          BinaryExpansion.regress \
  BinarySearchTree.regress       CardinalNumber.regress \
@@ -16560,6 +16562,15 @@ all: ${REGRESS}
 	@echo algebra test cases complete.
 @
 <<spadhelp>>=
+${HELP}/ArrayStack.help: ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7078 create ArrayStack.help from ${BOOKS}/bookvol10.3.pamphlet
+	@${TANGLE} -R"ArrayStack.help" ${BOOKS}/bookvol10.3.pamphlet \
+           >${HELP}/ArrayStack.help
+	@cp ${HELP}/ArrayStack.help ${HELP}/ASTACK.help
+	@${TANGLE} -R"ArrayStack.input" ${BOOKS}/bookvol10.3.pamphlet \
+            >${INPUT}/ArrayStack.input
+	@echo "ArrayStack (ASTACK)" >>${HELPFILE}
+
 ${HELP}/AssociationList.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo 7000 create AssociationList.help from \
            ${BOOKS}/bookvol10.3.pamphlet
@@ -17412,7 +17423,7 @@ ${HELP}/Stack.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo 7078 create Stack.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Stack.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Stack.help
-	@-cp ${HELP}/Stack.help ${HELP}/STREAM.help
+	@-cp ${HELP}/Stack.help ${HELP}/STACK.help
 	@${TANGLE} -R"Stack.input" ${BOOKS}/bookvol10.3.pamphlet \
             >${INPUT}/Stack.input
 	@echo "Stack (STACK)" >>${HELPFILE}
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index eaaedd1..03f2830 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -959,5 +959,7 @@ add Stephen Buchwald to credits<br/>
 bookvol10.3 add regression, help, examples for Stack<br/>
 <a href="patches/20090222.03.tpd.patch">20090222.03.tpd.patch</a>
 bookvol10.2 add documentation<br/>
+<a href="patches/20090222.04.tpd.patch">20090222.04.tpd.patch</a>
+bookvol10.3 add regression, help, examples for ArrayStack<br/>
  </body>
 </html>



From MAILER-DAEMON Mon Feb 23 13:41:17 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lbfjw-0001Bn-P9
	for mharc-axiom-developer@gnu.org; Mon, 23 Feb 2009 13:41:16 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lbfjv-0001BD-1O
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 13:41:15 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lbfjt-0001A3-3R
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 13:41:14 -0500
Received: from [199.232.76.173] (port=56357 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lbfjs-00019n-U3
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 13:41:12 -0500
Received: from tvwna-ip-b-35.princeton.org ([66.180.185.126]:55940
	helo=localhost.princeton.org)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <camm@maguirefamily.org>)
	id 1Lbfjs-0002Nh-AD
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 13:41:12 -0500
Received: from camm by localhost.princeton.org with local (Exim 4.69)
	(envelope-from <camm@maguirefamily.org>)
	id 1LbfjT-0004Iz-L1; Mon, 23 Feb 2009 13:40:47 -0500
To: daly@axiom-developer.org,axiom-developer@nongnu.org
From: Camm Maguire <camm@maguirefamily.org>
Date: Mon, 23 Feb 2009 13:40:47 -0500
In-Reply-To: <200902220708.n1M78vt15122@localhost.localdomain> (root's message
	of "Sun\, 22 Feb 2009 02\:08\:57 -0500")
Message-ID: <87vdr1ate8.fsf_-_@maguirefamily.org>
User-Agent: Gnus/5.11 (Gnus v5.11) Emacs/22.2 (gnu/linux)
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: quoted-printable
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: 
Subject: [Axiom-developer] Build failure on sparc:
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 23 Feb 2009 18:41:15 -0000

Hi Tim!  I've getting a value stack overflow on certain architectuures
when trying to compile EXPEXPAN.spad.  I seem to remember this from
previous discussions, but have forgotten the details.  Does this ring
a bell?  Please post to the list, as I cannot get home email until
this evening.

Take care,

root <daly@axiom-developer.org> writes:

> Camm,
>
> Sorry for the lag. I'm here and I saw your note but work has captured my
> attention. I'll look at it this sunday. Thanks for looking at this.
> It is completely embarrassing that the standard debian/ubuntu distro
> of Axiom was broken out of the box.
>
>
> I did get the following bug report:
>
> =3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
>
> ** Bug watch added: Debian Bug tracker #500997
>    http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=3D500997
>
> ** Also affects: axiom (Debian) via
>    http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=3D500997
>    Importance: Unknown
>        Status: Unknown
>
> --=20
> FTBFS: axiom_20050901-9ubuntu1 on hardy/i386
> https://bugs.launchpad.net/bugs/163603
> You received this bug notification because you are a direct subscriber
> of a duplicate bug.
>
> Status in =E2=80=9Caxiom=E2=80=9D source package in Ubuntu: Confirmed
> Status in =E2=80=9Caxiom=E2=80=9D source package in Debian: Unknown
>
> Bug description:
> -----BEGIN PGP SIGNED MESSAGE-----
> Hash: SHA1
>
>  affects ubuntu/axiom
>  tag ftbfs
>
> This package failed to build from source.  Please see the attached build
> log for details.
>
> Kind regards,
> Philipp Kern
>
>
>
>

--=20
Camm Maguire			     		    camm@maguirefamily.org
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
"The earth is but one country, and mankind its citizens."  --  Baha'u'llah



From MAILER-DAEMON Mon Feb 23 17:04:36 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lbiui-0000uc-Cp
	for mharc-axiom-developer@gnu.org; Mon, 23 Feb 2009 17:04:36 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lbiuf-0000tc-Io
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 17:04:33 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lbiub-0000t3-Mj
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 17:04:31 -0500
Received: from [199.232.76.173] (port=41214 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lbiub-0000sy-7p
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 17:04:29 -0500
Received: from mx-7.zoominternet.net ([24.154.1.26]:53438
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Lbiua-0006GF-Cn
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 17:04:28 -0500
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=37mPLz1kAAAA:8 a=dnHdxFoCI7Sca3R7XYEA:9
	a=RW4K9h3krJVou9XOx_MpIwSQ88MA:4 a=1zdcI9LUXH8A:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.45] ([24.154.1.45:33058] helo=pop-2.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 23/B0-13570-66D13A94; Mon, 23 Feb 2009 17:04:22 -0500
Received: (qmail 23354 invoked from network); 23 Feb 2009 22:04:23 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-2.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 23 Feb 2009 22:04:23 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n1NMoBR23993;
	Mon, 23 Feb 2009 17:50:11 -0500
Date: Mon, 23 Feb 2009 17:50:11 -0500
Message-Id: <200902232250.n1NMoBR23993@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: camm@maguirefamily.org
In-reply-to: <87vdr1ate8.fsf_-_@maguirefamily.org> (message from Camm Maguire
	on Mon, 23 Feb 2009 13:40:47 -0500)
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Build failure on sparc:
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 23 Feb 2009 22:04:34 -0000

EXPEXPAN is the most complex of the algebra compiles.
It does compile on all of my platforms, which includes about 1 dozen
(see http://axiom-developer.org/axiom-website/download.html)

What platforms fail?

Tim



From MAILER-DAEMON Mon Feb 23 20:06:38 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lblks-000058-1p
	for mharc-axiom-developer@gnu.org; Mon, 23 Feb 2009 20:06:38 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lblkp-0008U3-GB
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 20:06:35 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lblkn-0008SJ-Tt
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 20:06:34 -0500
Received: from [199.232.76.173] (port=60845 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lblkn-0008S6-QS
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 20:06:33 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:50290
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Lblkn-0004Dl-2p
	for axiom-developer@nongnu.org; Mon, 23 Feb 2009 20:06:33 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1O16Vug020625;
	Mon, 23 Feb 2009 19:06:31 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1O16Vp8020620;
	Mon, 23 Feb 2009 19:06:31 -0600
Date: Mon, 23 Feb 2009 19:06:31 -0600
Message-Id: <200902240106.n1O16Vp8020620@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090223.01.tpd.patch (bookvol10.3 add .... Queue
	documentation)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 24 Feb 2009 01:06:35 -0000

Add regression tests, a help page, and )d op example documentation
for Queue

=====================================================================
diff --git a/books/bookvol10.3.pamphlet b/books/bookvol10.3.pamphlet
index c232fc0..3a34055 100644
--- a/books/bookvol10.3.pamphlet
+++ b/books/bookvol10.3.pamphlet
@@ -2304,12 +2304,12 @@ ArrayStack(S:SetCategory): StackAggregate(S) with
     push_! : (S,%) -> S
       ++
       ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
-      ++X push! a
+      ++X push!(9,a)
       ++X a
     insert_! : (S,%) -> %
       ++
       ++X a:ArrayStack INT:= arrayStack [1,2,3,4,5]
-      ++X insert! a
+      ++X insert!(8,a)
       ++X a
     inspect : % -> S
       ++
@@ -75215,6 +75215,660 @@ QueryEquation(): Exports == Implementation where
 @
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{domain QUEUE Queue}
+<<Queue.input>>=
+)sys rm -f Queue.output
+)spool Queue.output
+)set message test on
+)set message auto off
+)clear all
+
+--S 1 of 46
+a:Queue INT:= queue [1,2,3,4,5]
+--R 
+--R
+--R   (1)  [1,2,3,4,5]
+--R                                                          Type: Queue Integer
+--E 1
+
+--S 2 of 46
+dequeue! a
+--R 
+--R
+--R   (2)  1
+--R                                                        Type: PositiveInteger
+--E 2
+
+--S 3 of 46
+a
+--R 
+--R
+--R   (3)  [2,3,4,5]
+--R                                                          Type: Queue Integer
+--E 3
+
+--S 4 of 46
+extract! a
+--R 
+--R
+--R   (4)  2
+--R                                                        Type: PositiveInteger
+--E 4
+
+--S 5 of 46
+a
+--R 
+--R
+--R   (5)  [3,4,5]
+--R                                                          Type: Queue Integer
+--E 5
+
+--S 6 of 46
+enqueue!(9,a)
+--R 
+--R
+--R   (6)  9
+--R                                                        Type: PositiveInteger
+--E 6
+
+--S 7 of 46
+a
+--R 
+--R
+--R   (7)  [3,4,5,9]
+--R                                                          Type: Queue Integer
+--E 7
+
+--S 8 of 46
+insert!(8,a)
+--R 
+--R
+--R   (8)  [3,4,5,9,8]
+--R                                                          Type: Queue Integer
+--E 8
+
+--S 9 of 46
+a
+--R 
+--R
+--R   (9)  [3,4,5,9,8]
+--R                                                          Type: Queue Integer
+--E 9
+
+--S 10 of 46
+inspect a
+--R 
+--R
+--R   (10)  3
+--R                                                        Type: PositiveInteger
+--E 10
+
+--S 11 of 46
+empty? a
+--R 
+--R
+--R   (11)  false
+--R                                                                Type: Boolean
+--E 11
+
+--S 12 of 46
+front a
+--R 
+--R
+--R   (12)  3
+--R                                                        Type: PositiveInteger
+--E 12
+
+--S 13 of 46
+back a
+--R 
+--R
+--R   (13)  8
+--R                                                        Type: PositiveInteger
+--E 13
+
+--S 14 of 46
+rotate! a
+--R 
+--R
+--R   (14)  [4,5,9,8,3]
+--R                                                          Type: Queue Integer
+--E 14
+
+--S 15 of 46
+#a
+--R 
+--R
+--R   (15)  5
+--R                                                        Type: PositiveInteger
+--E 15
+
+--S 16 of 46
+length a
+--R 
+--R
+--R   (16)  5
+--R                                                        Type: PositiveInteger
+--E 16
+
+--S 17 of 46
+less?(a,9)
+--R 
+--R
+--R   (17)  true
+--R                                                                Type: Boolean
+--E 17
+
+--S 18 of 46
+more?(a,9)
+--R 
+--R
+--R   (18)  false
+--R                                                                Type: Boolean
+--E 18
+
+--S 19 of 46
+size?(a,#a)
+--R 
+--R
+--R   (19)  true
+--R                                                                Type: Boolean
+--E 19
+
+--S 20 of 46
+size?(a,9)
+--R 
+--R
+--R   (20)  false
+--R                                                                Type: Boolean
+--E 20
+
+--S 21 of 46
+parts a
+--R 
+--R
+--R   (21)  [4,5,9,8,3]
+--R                                                           Type: List Integer
+--E 21
+
+--S 22 of 46
+bag([1,2,3,4,5])$Queue(INT)
+--R 
+--R
+--R   (22)  [1,2,3,4,5]
+--R                                                          Type: Queue Integer
+--E 22
+
+--S 23 of 46
+b:=empty()$(Queue INT)
+--R 
+--R
+--R   (23)  []
+--R                                                          Type: Queue Integer
+--E 23
+
+--S 24 of 46
+empty? b
+--R 
+--R
+--R   (24)  true
+--R                                                                Type: Boolean
+--E 24
+
+--S 25 of 46
+sample()$Queue(INT)
+--R 
+--R
+--R   (25)  []
+--R                                                          Type: Queue Integer
+--E 25
+
+--S 26 of 46
+c:=copy a
+--R 
+--R
+--R   (26)  [4,5,9,8,3]
+--R                                                          Type: Queue Integer
+--E 26
+
+--S 27 of 46
+eq?(a,c)
+--R 
+--R
+--R   (27)  false
+--R                                                                Type: Boolean
+--E 27
+
+--S 28 of 46
+eq?(a,a)
+--R 
+--R
+--R   (28)  true
+--R                                                                Type: Boolean
+--E 28
+
+--S 29 of 46
+(a=c)@Boolean
+--R 
+--R
+--R   (29)  true
+--R                                                                Type: Boolean
+--E 29
+
+--S 30 of 46
+(a=a)@Boolean
+--R 
+--R
+--R   (30)  true
+--R                                                                Type: Boolean
+--E 30
+
+--S 31 of 46
+a~=c
+--R 
+--R
+--R   (31)  false
+--R                                                                Type: Boolean
+--E 31
+
+--S 32 of 46
+any?(x+->(x=4),a)
+--R 
+--R
+--R   (32)  true
+--R                                                                Type: Boolean
+--E 32
+
+--S 33 of 46
+any?(x+->(x=11),a)
+--R 
+--R
+--R   (33)  false
+--R                                                                Type: Boolean
+--E 33
+
+--S 34 of 46
+every?(x+->(x=11),a)
+--R 
+--R
+--R   (34)  false
+--R                                                                Type: Boolean
+--E 34
+
+--S 35 of 46
+count(4,a)
+--R 
+--R
+--R   (35)  1
+--R                                                        Type: PositiveInteger
+--E 35
+
+--S 36 of 46
+count(x+->(x>2),a)
+--R 
+--R
+--R   (36)  5
+--R                                                        Type: PositiveInteger
+--E 36
+
+--S 37 of 46
+map(x+->x+10,a)
+--R 
+--R
+--R   (37)  [14,15,19,18,13]
+--R                                                          Type: Queue Integer
+--E 37
+
+--S 38 of 46
+a
+--R 
+--R
+--R   (38)  [4,5,9,8,3]
+--R                                                          Type: Queue Integer
+--E 38
+
+--S 39 of 46
+map!(x+->x+10,a)
+--R 
+--R
+--R   (39)  [14,15,19,18,13]
+--R                                                          Type: Queue Integer
+--E 39
+
+--S 40 of 46
+a
+--R 
+--R
+--R   (40)  [14,15,19,18,13]
+--R                                                          Type: Queue Integer
+--E 40
+
+--S 41 of 46
+members a
+--R 
+--R
+--R   (41)  [14,15,19,18,13]
+--R                                                           Type: List Integer
+--E 41
+
+--S 42 of 46
+member?(14,a)
+--R 
+--R
+--R   (42)  true
+--R                                                                Type: Boolean
+--E 42
+
+--S 43 of 46
+coerce a
+--R 
+--R
+--R   (43)  [14,15,19,18,13]
+--R                                                             Type: OutputForm
+--E 43
+
+--S 44 of 46
+hash a
+--R 
+--R
+--R   (44)  0
+--R                                                          Type: SingleInteger
+--E 44
+
+--S 45 of 46
+latex a
+--R 
+--R
+--R   (45)  "\mbox{\bf Unimplemented}"
+--R                                                                 Type: String
+--E 45
+
+--S 46 of 46
+)show Queue
+--R 
+--R Queue S: SetCategory  is a domain constructor
+--R Abbreviation for Queue is QUEUE 
+--R This constructor is exposed in this frame.
+--R Issue )edit bookvol10.3.spad.pamphlet to see algebra source code for QUEUE 
+--R
+--R------------------------------- Operations --------------------------------
+--R back : % -> S                         bag : List S -> %
+--R copy : % -> %                         dequeue! : % -> S
+--R empty : () -> %                       empty? : % -> Boolean
+--R enqueue! : (S,%) -> S                 eq? : (%,%) -> Boolean
+--R extract! : % -> S                     front : % -> S
+--R insert! : (S,%) -> %                  inspect : % -> S
+--R length : % -> NonNegativeInteger      map : ((S -> S),%) -> %
+--R queue : List S -> %                   rotate! : % -> %
+--R sample : () -> %                     
+--R #? : % -> NonNegativeInteger if $ has finiteAggregate
+--R ?=? : (%,%) -> Boolean if S has SETCAT
+--R any? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
+--R coerce : % -> OutputForm if S has SETCAT
+--R count : (S,%) -> NonNegativeInteger if $ has finiteAggregate and S has SETCAT
+--R count : ((S -> Boolean),%) -> NonNegativeInteger if $ has finiteAggregate
+--R eval : (%,List S,List S) -> % if S has EVALAB S and S has SETCAT
+--R eval : (%,S,S) -> % if S has EVALAB S and S has SETCAT
+--R eval : (%,Equation S) -> % if S has EVALAB S and S has SETCAT
+--R eval : (%,List Equation S) -> % if S has EVALAB S and S has SETCAT
+--R every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
+--R hash : % -> SingleInteger if S has SETCAT
+--R latex : % -> String if S has SETCAT
+--R less? : (%,NonNegativeInteger) -> Boolean
+--R map! : ((S -> S),%) -> % if $ has shallowlyMutable
+--R member? : (S,%) -> Boolean if $ has finiteAggregate and S has SETCAT
+--R members : % -> List S if $ has finiteAggregate
+--R more? : (%,NonNegativeInteger) -> Boolean
+--R parts : % -> List S if $ has finiteAggregate
+--R size? : (%,NonNegativeInteger) -> Boolean
+--R ?~=? : (%,%) -> Boolean if S has SETCAT
+--R
+--E 46
+ 
+
+)spool
+)lisp (bye)
+ 
+@
+<<Queue.help>>=
+====================================================================
+Queue examples
+====================================================================
+
+A Queue object is represented as a list ordered by first-in, first-out.
+It operates like a line of people, where the "next" person is the one
+at the front of the line.
+
+Here we create an queue of integers from a list. Notice that the
+order in the list is the order in the queue.
+
+   a:Queue INT:= queue [1,2,3,4,5]
+      [1,2,3,4,5]
+
+We can remove the top of the queue using dequeue!:
+
+   dequeue! a
+      1
+
+Notice that the use of dequeue! is destructive (destructive operations
+in Axiom usually end with ! to indicate that the underylying data
+structure is changed).
+
+   a
+      [2,3,4,5]
+
+The extract! operation is another name for the pop! operation and
+has the same effect. This operation treats the queue as a BagAggregate:
+
+   extract! a
+      2
+
+and you can see that it also has destructively modified the queue:
+
+   a
+      [3,4,5]
+
+Next we use enqueue! to add a new element to the end of the queue:
+
+   push!(9,a)
+      9
+
+Again, the push! operation is destructive so the queue is changed:
+
+   a
+      [3,4,5,9]
+
+Another name for enqueue! is insert!, which treats the queue as a 
+BagAggregate:
+
+   insert!(8,a)
+      [3,4,5,9,8]
+
+and it modifies the queue:
+
+   a
+      [3,4,5,9,8]
+
+The inspect function returns the top of the queue without modification,
+viewed as a BagAggregate:
+
+   inspect a
+      8
+
+The empty? operation returns true only if there are no element on the
+queue, otherwise it returns false:
+
+   empty? a
+      false
+
+The front operation returns the front of the queue without modification:
+
+   front a
+      3
+
+The back operation returns the back of the queue without modification:
+
+   back a
+      8
+
+The rotate! operation moves the item at the front of the queue to the
+back of the queue:
+
+   rotate! a
+      [4,5,9,8,3]
+
+The # (length) operation:
+
+   #a
+       5
+
+The length operation does the same thing:
+
+   length a
+       5
+
+The less? predicate will compare the queue length to an integer:
+
+   less?(a,9)
+        true
+
+The more? predicate will compare the queue length to an integer:
+
+   more?(a,9)
+        false
+
+The size? operation will compare the queue length to an integer:
+
+   size?(a,#a)
+        true
+
+and since the last computation must alwasy be true we try:
+
+   size?(a,9)
+        false
+
+The parts function will return  the queue as a list of its elements:
+
+   parts a
+        [8,9,3,4,5]
+
+If we have a BagAggregate of elements we can use it to construct a queue:
+
+   bag([1,2,3,4,5])$Queue(INT)
+        [1,2,3,4,5]
+
+The empty function will construct an empty queue of a given type:
+
+   b:=empty()$(Queue INT)
+        []
+
+and the empty? predicate allows us to find out if a queue is empty:
+
+   empty? b
+        true
+
+The sample function returns a sample, empty queue:
+
+   sample()$Queue(INT)
+        []
+
+We can copy a queue and it does not share storage so subsequent
+modifications of the original queue will not affect the copy:
+
+   c:=copy a
+        [4,5,9,8,3]
+
+The eq? function is only true if the lists are the same reference,
+so even though c is a copy of a, they are not the same:
+
+   eq?(a,c)
+        false
+
+However, a clearly shares a reference with itself:
+
+   eq?(a,a)
+        true
+
+But we can compare a and c for equality:
+
+   (a=c)@Boolean
+        true
+
+and clearly a is equal to itself:
+
+   (a=a)@Boolean
+        true
+
+and since a and c are equal, they are clearly NOT not-equal:
+
+   a~=c
+        false
+
+We can use the any? function to see if a predicate is true for any element:
+
+   any?(x+->(x=4),a)
+        true
+
+or false for every element:
+
+   any?(x+->(x=11),a)
+        false
+
+We can use the every? function to check every element satisfies a predicate:
+
+   every?(x+->(x=11),a)
+        false
+
+We can count the elements that are equal to an argument of this type:
+
+   count(4,a)
+        1
+
+or we can count against a boolean function:
+
+   count(x+->(x>2),a)
+        5
+
+You can also map a function over every element, returning a new queue:
+
+   map(x+->x+10,a)
+        [14,15,19,18,13]
+
+Notice that the orignal queue is unchanged:
+
+   a
+        [4,5,9,8,3]
+
+You can use map! to map a function over every element and change
+the original queue since map! is destructive:
+
+   map!(x+->x+10,a)
+       [14,15,19,18,13]
+o
+Notice that the orignal queue has been changed:
+
+   a
+       [14,15,19,18,13]
+
+The member function can also get the element of the queue as a list:
+
+   members a
+       [18,19,13,14,15]
+
+and using member? we can test if the queue holds a given element:
+
+   member?(14,a)
+       true
+
+
+See Also:
+o )show Stack
+o )show ArrayStack
+o )show Queue
+o )show Dequeue
+o )show Heap
+o )show BagAggregate
+
+@
 \pagehead{Queue}{QUEUE}
 \pagepic{ps/v103queue.ps}{QUEUE}{1.00}
 {\bf See}\\
@@ -75285,6 +75939,151 @@ Queue(S:SetCategory): QueueAggregate S with
       ++
       ++E e:Queue INT:= queue [1,2,3,4,5]
 
+ -- Inherited Signatures repeated for examples documentation
+
+    dequeue_! : % -> S
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X dequeue! a
+      ++X a
+    extract_! : % -> S
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X extract! a
+      ++X a
+    enqueue_! : (S,%) -> S
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X enqueue! (9,a)
+      ++X a
+    insert_! : (S,%) -> %
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X insert! (8,a)
+      ++X a
+    inspect : % -> S
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X inspect a
+    front : % -> S
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X front a
+    back : % -> S
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X back a
+    rotate_! : % -> %
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X rotate! a
+    length : % -> NonNegativeInteger
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X length a
+    less? : (%,NonNegativeInteger) -> Boolean
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X less?(a,9)
+    more? : (%,NonNegativeInteger) -> Boolean
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X more?(a,9)
+    size? : (%,NonNegativeInteger) -> Boolean
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X size?(a,5)
+    bag : List S -> %
+      ++
+      ++X bag([1,2,3,4,5])$Queue(INT)
+    empty? : % -> Boolean
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X empty? a
+    empty : () -> %
+      ++
+      ++X b:=empty()$(Queue INT)
+    sample : () -> %
+      ++
+      ++X sample()$Queue(INT)
+    copy : % -> %
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X copy a
+    eq? : (%,%) -> Boolean
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X b:=copy a
+      ++X eq?(a,b)
+    map :  ((S -> S),%) -> %
+      ++
+      ++X a:Queue INT:= queue [1,2,3,4,5]
+      ++X map(x+->x+10,a)
+      ++X a
+    if $ has shallowlyMutable then
+      map! :  ((S -> S),%) -> %
+        ++
+        ++X a:Queue INT:= queue [1,2,3,4,5]
+        ++X map!(x+->x+10,a)
+        ++X a
+    if S has SetCategory then
+      latex : % -> String
+        ++
+        ++X a:Queue INT:= queue [1,2,3,4,5]
+        ++X latex a
+      hash : % -> SingleInteger
+        ++
+        ++X a:Queue INT:= queue [1,2,3,4,5]
+        ++X hash a
+      coerce : % -> OutputForm
+        ++
+        ++X a:Queue INT:= queue [1,2,3,4,5]
+        ++X coerce a
+      "=": (%,%) -> Boolean
+        ++
+        ++X a:Queue INT:= queue [1,2,3,4,5]
+        ++X b:Queue INT:= queue [1,2,3,4,5]
+        ++X (a=b)@Boolean
+      "~=" : (%,%) -> Boolean
+        ++
+        ++X a:Queue INT:= queue [1,2,3,4,5]
+        ++X b:=copy a
+        ++X (a~=b)
+    if % has finiteAggregate then
+      every? : ((S -> Boolean),%) -> Boolean
+        ++
+        ++X a:Queue INT:= queue [1,2,3,4,5]
+        ++X every?(x+->(x=4),a)
+      any? : ((S -> Boolean),%) -> Boolean
+        ++
+        ++X a:Queue INT:= queue [1,2,3,4,5]
+        ++X any?(x+->(x=4),a)
+      count :  ((S -> Boolean),%) -> NonNegativeInteger
+        ++
+        ++X a:Queue INT:= queue [1,2,3,4,5]
+        ++X count(x+->(x>2),a)
+      _# : % -> NonNegativeInteger
+        ++
+        ++X a:Queue INT:= queue [1,2,3,4,5]
+        ++X #a
+      parts : % -> List S
+        ++
+        ++X a:Queue INT:= queue [1,2,3,4,5]
+        ++X parts a
+      members : % -> List S
+        ++
+        ++X a:Queue INT:= queue [1,2,3,4,5]
+        ++X members a
+    if % has finiteAggregate and S has SetCategory then
+      member? : (S,%) -> Boolean
+        ++
+        ++X a:Queue INT:= queue [1,2,3,4,5]
+        ++X member?(3,a)
+      count : (S,%) -> NonNegativeInteger
+        ++
+        ++X a:Queue INT:= queue [1,2,3,4,5]
+        ++X count(4,a)
+
   == Stack S add
     Rep := Reference List S
     lastTail==> LAST$Lisp
@@ -90810,12 +91609,12 @@ Stack(S:SetCategory): StackAggregate S with
     push_! : (S,%) -> S
       ++
       ++X a:Stack INT:= stack [1,2,3,4,5]
-      ++X push! a
+      ++X push!(9,a)
       ++X a
     insert_! : (S,%) -> %
       ++
       ++X a:Stack INT:= stack [1,2,3,4,5]
-      ++X insert! a
+      ++X insert!(8,a)
       ++X a
     inspect : % -> S
       ++
diff --git a/changelog b/changelog
index 140b82f..1bc3146 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,6 @@
+20090223 tpd src/axiom-website/patches.html 20090223.01.tpd.patch
+20090223 tpd src/interp/Makefile add regression, help for Queue
+20090223 tpd books/bookvol10.3 add regression, help, examples for Queue
 20090222 tpd src/axiom-website/patches.html 20090222.04.tpd.patch
 20090222 tpd src/interp/Makefile add regression, help for ArrayStack
 20090222 tpd books/bookvol10.3 add regression, help, examples for ArrayStack
diff --git a/src/algebra/Makefile.pamphlet b/src/algebra/Makefile.pamphlet
index 4ed8ac9..c0ad0df 100644
--- a/src/algebra/Makefile.pamphlet
+++ b/src/algebra/Makefile.pamphlet
@@ -16454,6 +16454,7 @@ SPADHELP=\
  ${HELP}/PartialFraction.help \
  ${HELP}/Permanent.help              ${HELP}/Permutation.help \
  ${HELP}/Polynomial.help             ${HELP}/Quaternion.help \
+ ${HELP}/Queue.help \
  ${HELP}/RadixExpansion.help         ${HELP}/RealClosure.help \
  ${HELP}/RealSolvePackage.help       ${HELP}/RegularTriangularSet.help \
  ${HELP}/RomanNumeral.help           ${HELP}/Segment.help \
@@ -16522,6 +16523,7 @@ REGRESS=\
  Permanent.regress              Permutation.regress \
  PlaneAlgebraicCurvePlot.regress Plot.regress \
  Polynomial.regress             Quaternion.regress \
+ Queue.regress \
  RadixExpansion.regress         RealClosure.regress \
  RealSolvePackage.regress       RegularTriangularSet.regress \
  RomanNumeral.regress           Segment.regress \
@@ -17302,6 +17304,15 @@ ${HELP}/Quaternion.help: ${BOOKS}/bookvol10.3.pamphlet
             >${INPUT}/Quaternion.input
 	@echo "Quaternion (QUAT)" >>${HELPFILE}
 
+${HELP}/Queue.help: ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7078 create Queue.help from ${BOOKS}/bookvol10.3.pamphlet
+	@${TANGLE} -R"Queue.help" ${BOOKS}/bookvol10.3.pamphlet \
+           >${HELP}/Queue.help
+	@-cp ${HELP}/Queue.help ${HELP}/QUEUE.help
+	@${TANGLE} -R"Queue.input" ${BOOKS}/bookvol10.3.pamphlet \
+            >${INPUT}/Queue.input
+	@echo "Queue (QUEUE)" >>${HELPFILE}
+
 ${HELP}/RadixExpansion.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo 7067 create RadixExpansion.help from \
            ${BOOKS}/bookvol10.3.pamphlet
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 03f2830..0ed5c8f 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -961,5 +961,7 @@ bookvol10.3 add regression, help, examples for Stack<br/>
 bookvol10.2 add documentation<br/>
 <a href="patches/20090222.04.tpd.patch">20090222.04.tpd.patch</a>
 bookvol10.3 add regression, help, examples for ArrayStack<br/>
+<a href="patches/20090223.01.tpd.patch">20090223.01.tpd.patch</a>
+bookvol10.3 add regression, help, examples for Queue<br/>
  </body>
 </html>



From MAILER-DAEMON Tue Feb 24 07:32:55 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LbwT1-0006iW-Gz
	for mharc-axiom-developer@gnu.org; Tue, 24 Feb 2009 07:32:55 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LbwSz-0006hd-99
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 07:32:53 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LbwSx-0006gT-GI
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 07:32:52 -0500
Received: from [199.232.76.173] (port=46537 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LbwSx-0006gJ-B5
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 07:32:51 -0500
Received: from mail10.dslextreme.com ([66.51.199.98]:58528)
	by monty-python.gnu.org with smtp (Exim 4.60)
	(envelope-from <camm@maguirefamily.org>) id 1LbwSw-0006Ou-Rg
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 07:32:51 -0500
Received: (qmail 9018 invoked from network); 24 Feb 2009 12:31:49 -0000
Received: from unknown (HELO wisdom.m.enhanced.com) (141.150.251.63)
	by mail10.dslextreme.com with (AES256-SHA encrypted) SMTP;
	Tue, 24 Feb 2009 04:31:49 -0800
Received: from love.m.enhanced.com ([192.168.3.9] helo=localhost)
	by wisdom.m.enhanced.com with esmtp (Exim 4.63)
	(envelope-from <camm@maguirefamily.org>)
	id 1LbwRf-0005Qn-Gz; Tue, 24 Feb 2009 07:31:31 -0500
Received: from camm by localhost with local (Exim 4.69)
	(envelope-from <camm@maguirefamily.org>)
	id 1Lbo0s-0001dm-Ps; Mon, 23 Feb 2009 22:31:18 -0500
To: daly@axiom-developer.org
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
From: Camm Maguire <camm@maguirefamily.org>
Date: Mon, 23 Feb 2009 22:31:18 -0500
In-Reply-To: <200902232250.n1NMoBR23993@localhost.localdomain> (root's message
	of "Mon\, 23 Feb 2009 17\:50\:11 -0500")
Message-ID: <87mycccxyx.fsf@maguirefamily.org>
User-Agent: Gnus/5.11 (Gnus v5.11) Emacs/22.2 (gnu/linux)
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6 (newer, 3)
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Build failure on sparc:
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 24 Feb 2009 12:32:53 -0000

Greetings!  Debian sparc for starters.  You can check
https://buildd.debian.org/build.php?pkg=axiom for the current status
on the others if desired.  I'll add an automatic cat of the trace file
on the autobuilders to facilitate investigation, as shell access for
each of this machines is alas spotty.

Had you received a sparc fail to build error before, as I think I
recall?  This obviously should not be a platform specific issue.

Could you please refresh my memory how one escapes to a lisp prompt,
and then gets back to the axiom prompt?  I have the failure setup on a
test machine.

Take care,

root <daly@axiom-developer.org> writes:

> EXPEXPAN is the most complex of the algebra compiles.
> It does compile on all of my platforms, which includes about 1 dozen
> (see http://axiom-developer.org/axiom-website/download.html)
>
> What platforms fail?
>
> Tim
>
>
>
>

-- 
Camm Maguire			     		    camm@maguirefamily.org
==========================================================================
"The earth is but one country, and mankind its citizens."  --  Baha'u'llah



From MAILER-DAEMON Tue Feb 24 07:48:48 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LbwiN-0004oP-AG
	for mharc-axiom-developer@gnu.org; Tue, 24 Feb 2009 07:48:47 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LbwiK-0004o0-3P
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 07:48:44 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LbwiH-0004nL-30
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 07:48:42 -0500
Received: from [199.232.76.173] (port=51081 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LbwiG-0004nB-PP
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 07:48:40 -0500
Received: from mx-7.zoominternet.net ([24.154.1.26]:45399
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LbwiG-0001jL-GA
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 07:48:40 -0500
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=-PNlk0EzVzvYiGGsQ9cA:9 a=zHPM07WzgValXGJkZwNSiunQ3HYA:4
	a=_I8u8z9Hh0wA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.44] ([24.154.1.44:59954] helo=pop-1.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 74/16-13570-A9CE3A94; Tue, 24 Feb 2009 07:48:26 -0500
Received: (qmail 14583 invoked from network); 24 Feb 2009 12:48:30 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-1.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 24 Feb 2009 12:48:30 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n1ODYSI24715;
	Tue, 24 Feb 2009 08:34:28 -0500
Date: Tue, 24 Feb 2009 08:34:28 -0500
Message-Id: <200902241334.n1ODYSI24715@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: camm@maguirefamily.org
In-reply-to: <87mycccxyx.fsf@maguirefamily.org> (message from Camm Maguire on
	Mon, 23 Feb 2009 22:31:18 -0500)
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
	<87mycccxyx.fsf@maguirefamily.org>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Build failure on sparc:
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 24 Feb 2009 12:48:45 -0000

>Could you please refresh my memory how one escapes to a lisp prompt,
>and then gets back to the axiom prompt?  I have the failure setup on a
>test machine.

)lisp sexpr......

or 
)fin  <== leave top level axiom prompt for lisp prompt
(restart) <= restart axiom




From MAILER-DAEMON Tue Feb 24 12:37:58 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lc1EE-0006U1-1n
	for mharc-axiom-developer@gnu.org; Tue, 24 Feb 2009 12:37:58 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lc1EA-0006N0-Ob
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:37:54 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lc1E6-0006GN-P9
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:37:51 -0500
Received: from [199.232.76.173] (port=47678 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lc1E6-0006G9-H5
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:37:50 -0500
Received: from tvwna-ip-b-35.princeton.org ([66.180.185.126]:46875
	helo=localhost.princeton.org)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <camm@maguirefamily.org>)
	id 1Lc1E6-0001UM-15
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:37:50 -0500
Received: from camm by localhost.princeton.org with local (Exim 4.69)
	(envelope-from <camm@maguirefamily.org>)
	id 1Lc1Dk-00039v-Qq; Tue, 24 Feb 2009 12:37:28 -0500
To: daly@axiom-developer.org
From: Camm Maguire <camm@maguirefamily.org>
Date: Tue, 24 Feb 2009 12:37:28 -0500
In-Reply-To: <200902232250.n1NMoBR23993@localhost.localdomain> (root's message
	of "Mon\, 23 Feb 2009 17\:50\:11 -0500")
Message-ID: <87skm34tyf.fsf_-_@maguirefamily.org>
User-Agent: Gnus/5.11 (Gnus v5.11) Emacs/22.2 (gnu/linux)
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Howto enable lisp break
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 24 Feb 2009 17:37:56 -0000

Greetings, Tim, and thanks!  One last question -- how does one get the
lisp break to halt execution preserving the stack, as opposed to
reporting a system error and returning to the axiom prompt?  Please
drop a note to this list, as I'm not at home.

Take care,

root <daly@axiom-developer.org> writes:

> EXPEXPAN is the most complex of the algebra compiles.
> It does compile on all of my platforms, which includes about 1 dozen
> (see http://axiom-developer.org/axiom-website/download.html)
>
> What platforms fail?
>
> Tim
>
>
> _______________________________________________
> Axiom-developer mailing list
> Axiom-developer@nongnu.org
> http://lists.nongnu.org/mailman/listinfo/axiom-developer
>
>
>
>

-- 
Camm Maguire			     		    camm@maguirefamily.org
==========================================================================
"The earth is but one country, and mankind its citizens."  --  Baha'u'llah



From MAILER-DAEMON Tue Feb 24 12:42:21 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lc1IT-0002xd-B6
	for mharc-axiom-developer@gnu.org; Tue, 24 Feb 2009 12:42:21 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lc1IS-0002xH-AT
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:42:20 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lc1IP-0002w3-Aa
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:42:19 -0500
Received: from [199.232.76.173] (port=41440 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lc1IP-0002vx-6s
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:42:17 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:49570
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Lc1IN-00025Y-Ve
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:42:17 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1OHgEug005825;
	Tue, 24 Feb 2009 11:42:14 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1OHgExf005822;
	Tue, 24 Feb 2009 11:42:14 -0600
Date: Tue, 24 Feb 2009 11:42:14 -0600
Message-Id: <200902241742.n1OHgExf005822@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090224.01.tpd.patch (bookvol10.3 add Dequeue
	documentation)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 24 Feb 2009 17:42:20 -0000

Add regression, help, and examples documentation for Dequeue.
Fix missing functions.

==================================================================
diff --git a/books/bookvol10.3.pamphlet b/books/bookvol10.3.pamphlet
index 3a34055..bff1070 100644
--- a/books/bookvol10.3.pamphlet
+++ b/books/bookvol10.3.pamphlet
@@ -18635,6 +18635,885 @@ DenavitHartenbergMatrix(R): Exports == Implementation where
 @
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{domain DEQUEUE Dequeue}
+<<Dequeue.input>>=
+)sys rm -f Dequeue.output
+)spool Dequeue.output
+)set message test on
+)set message auto off
+)clear all
+
+--S 1 of 63
+a:Dequeue INT:= dequeue [1,2,3,4,5]
+--R 
+--R
+--R   (1)  [1,2,3,4,5]
+--R                                                        Type: Dequeue Integer
+--E 1
+
+--S 2 of 63
+dequeue! a
+--R 
+--R
+--R   (2)  1
+--R                                                        Type: PositiveInteger
+--E 2
+
+--S 3 of 63
+a
+--R 
+--R
+--R   (3)  [2,3,4,5]
+--R                                                        Type: Dequeue Integer
+--E 3
+
+--S 4 of 63
+extract! a
+--R 
+--R
+--R   (4)  2
+--R                                                        Type: PositiveInteger
+--E 4
+
+--S 5 of 63
+a
+--R 
+--R
+--R   (5)  [3,4,5]
+--R                                                        Type: Dequeue Integer
+--E 5
+
+--S 6 of 63
+enqueue!(9,a)
+--R 
+--R
+--R   (6)  9
+--R                                                        Type: PositiveInteger
+--E 6
+
+--S 7 of 63
+a
+--R 
+--R
+--R   (7)  [3,4,5,9]
+--R                                                        Type: Dequeue Integer
+--E 7
+
+--S 8 of 63
+insert!(8,a)
+--R 
+--R
+--R   (8)  [3,4,5,9,8]
+--R                                                        Type: Dequeue Integer
+--E 8
+
+--S 9 of 63
+a
+--R 
+--R
+--R   (9)  [3,4,5,9,8]
+--R                                                        Type: Dequeue Integer
+--E 9
+
+--S 10 of 63
+front a
+--R 
+--R
+--R   (10)  3
+--R                                                        Type: PositiveInteger
+--E 10
+
+--S 11 of 63
+back a
+--R 
+--R
+--R   (11)  8
+--R                                                        Type: PositiveInteger
+--E 11
+
+--S 12 of 63
+bottom! a
+--R 
+--R
+--R   (12)  8
+--R                                                        Type: PositiveInteger
+--E 12
+
+--S 13 of 63
+a
+--R 
+--R
+--R   (13)  [3,4,5,9]
+--R                                                        Type: Dequeue Integer
+--E 13
+
+--S 14 of 63
+depth a
+--R 
+--R
+--R   (14)  4
+--R                                                        Type: PositiveInteger
+--E 14
+
+--S 15 of 63
+height a
+--R 
+--R
+--R   (15)  4
+--R                                                        Type: PositiveInteger
+--E 15
+
+--S 16 of 63
+insertBottom!(6,a)
+--R 
+--R
+--R   (16)  6
+--R                                                        Type: PositiveInteger
+--E 16
+
+--S 17 of 63
+a
+--R 
+--R
+--R   (17)  [3,4,5,9,6]
+--R                                                        Type: Dequeue Integer
+--E 17
+
+--S 18 of 63
+extractBottom! a
+--R 
+--R
+--R   (18)  6
+--R                                                        Type: PositiveInteger
+--E 18
+
+--S 19 of 63
+a
+--R 
+--R
+--R   (19)  [3,4,5,9]
+--R                                                        Type: Dequeue Integer
+--E 19
+
+--S 20 of 63
+insertTop!(7,a)
+--R 
+--R
+--R   (20)  7
+--R                                                        Type: PositiveInteger
+--E 20
+
+--S 21 of 63
+a
+--R 
+--R
+--R   (21)  [7,3,4,5,9]
+--R                                                        Type: Dequeue Integer
+--E 21
+
+--S 22 of 63
+extractTop! a
+--R 
+--R
+--R   (22)  7
+--R                                                        Type: PositiveInteger
+--E 22
+
+--S 23 of 63
+a
+--R 
+--R
+--R   (23)  [3,4,5,9]
+--R                                                        Type: Dequeue Integer
+--E 23
+
+--S 24 of 63
+top a
+--R 
+--R
+--R   (24)  3
+--R                                                        Type: PositiveInteger
+--E 24
+
+--S 25 of 63
+a
+--R 
+--R
+--R   (25)  [3,4,5,9]
+--R                                                        Type: Dequeue Integer
+--E 25
+
+--S 26 of 63
+top! a
+--R 
+--R
+--R   (26)  3
+--R                                                        Type: PositiveInteger
+--E 26
+
+--S 27 of 63
+a
+--R 
+--R
+--R   (27)  [4,5,9]
+--R                                                        Type: Dequeue Integer
+--E 27
+
+--S 28 of 63
+reverse! a
+--R 
+--R
+--R   (28)  [9,5,4]
+--R                                                        Type: Dequeue Integer
+--E 28
+
+--S 29 of 63
+rotate! a
+--R 
+--R
+--R   (29)  [5,4,9]
+--R                                                        Type: Dequeue Integer
+--E 29
+
+--S 30 of 63
+inspect a
+--R 
+--R
+--R   (30)  5
+--R                                                        Type: PositiveInteger
+--E 30
+
+--S 31 of 63
+empty? a
+--R 
+--R
+--R   (31)  false
+--R                                                                Type: Boolean
+--E 31
+
+--S 32 of 63
+#a
+--R 
+--R
+--R   (32)  3
+--R                                                        Type: PositiveInteger
+--E 32
+
+--S 33 of 63
+length a
+--R 
+--R
+--R   (33)  3
+--R                                                        Type: PositiveInteger
+--E 33
+
+--S 34 of 63
+less?(a,9)
+--R 
+--R
+--R   (34)  true
+--R                                                                Type: Boolean
+--E 34
+
+--S 35 of 63
+more?(a,9)
+--R 
+--R
+--R   (35)  false
+--R                                                                Type: Boolean
+--E 35
+
+--S 36 of 63
+size?(a,#a)
+--R 
+--R
+--R   (36)  true
+--R                                                                Type: Boolean
+--E 36
+
+--S 37 of 63
+size?(a,9)
+--R 
+--R
+--R   (37)  false
+--R                                                                Type: Boolean
+--E 37
+
+--S 38 of 63
+parts a
+--R 
+--R
+--R   (38)  [5,4,9]
+--R                                                           Type: List Integer
+--E 38
+
+--S 39 of 63
+bag([1,2,3,4,5])$Dequeue(INT)
+--R 
+--R
+--R   (39)  [1,2,3,4,5]
+--R                                                        Type: Dequeue Integer
+--E 39
+
+--S 40 of 63
+b:=empty()$(Dequeue INT)
+--R 
+--R
+--R   (40)  []
+--R                                                        Type: Dequeue Integer
+--E 40
+
+--S 41 of 63
+empty? b
+--R 
+--R
+--R   (41)  true
+--R                                                                Type: Boolean
+--E 41
+
+--S 42 of 63
+sample()$Dequeue(INT)
+--R 
+--R
+--R   (42)  []
+--R                                                        Type: Dequeue Integer
+--E 42
+
+--S 43 of 63
+c:=copy a
+--R 
+--R
+--R   (43)  [5,4,9]
+--R                                                        Type: Dequeue Integer
+--E 43
+
+--S 44 of 63
+eq?(a,c)
+--R 
+--R
+--R   (44)  false
+--R                                                                Type: Boolean
+--E 44
+
+--S 45 of 63
+eq?(a,a)
+--R 
+--R
+--R   (45)  true
+--R                                                                Type: Boolean
+--E 45
+
+--S 46 of 63
+(a=c)@Boolean
+--R 
+--R
+--R   (46)  true
+--R                                                                Type: Boolean
+--E 46
+
+--S 47 of 63
+(a=a)@Boolean
+--R 
+--R
+--R   (47)  true
+--R                                                                Type: Boolean
+--E 47
+
+--S 48 of 63
+a~=c
+--R 
+--R
+--R   (48)  false
+--R                                                                Type: Boolean
+--E 48
+
+--S 49 of 63
+any?(x+->(x=4),a)
+--R 
+--R
+--R   (49)  true
+--R                                                                Type: Boolean
+--E 49
+
+--S 50 of 63
+any?(x+->(x=11),a)
+--R 
+--R
+--R   (50)  false
+--R                                                                Type: Boolean
+--E 50
+
+--S 51 of 63
+every?(x+->(x=11),a)
+--R 
+--R
+--R   (51)  false
+--R                                                                Type: Boolean
+--E 51
+
+--S 52 of 63
+count(4,a)
+--R 
+--R
+--R   (52)  1
+--R                                                        Type: PositiveInteger
+--E 52
+
+--S 53 of 63
+count(x+->(x>2),a)
+--R 
+--R
+--R   (53)  3
+--R                                                        Type: PositiveInteger
+--E 53
+
+--S 54 of 63
+map(x+->x+10,a)
+--R 
+--R
+--R   (54)  [15,14,19]
+--R                                                        Type: Dequeue Integer
+--E 54
+
+--S 55 of 63
+a
+--R 
+--R
+--R   (55)  [5,4,9]
+--R                                                        Type: Dequeue Integer
+--E 55
+
+--S 56 of 63
+map!(x+->x+10,a)
+--R 
+--R
+--R   (56)  [15,14,19]
+--R                                                        Type: Dequeue Integer
+--E 56
+
+--S 57 of 63
+a
+--R 
+--R
+--R   (57)  [15,14,19]
+--R                                                        Type: Dequeue Integer
+--E 57
+
+--S 58 of 63
+members a
+--R 
+--R
+--R   (58)  [15,14,19]
+--R                                                           Type: List Integer
+--E 58
+
+--S 59 of 63
+member?(14,a)
+--R 
+--R
+--R   (59)  true
+--R                                                                Type: Boolean
+--E 59
+
+--S 60 of 63
+coerce a
+--R 
+--R
+--R   (60)  [15,14,19]
+--R                                                             Type: OutputForm
+--E 60
+
+--S 61 of 63
+hash a
+--R 
+--R
+--R   (61)  0
+--R                                                          Type: SingleInteger
+--E 61
+
+--S 62 of 63
+latex a
+--R 
+--R
+--R   (62)  "\mbox{\bf Unimplemented}"
+--R                                                                 Type: String
+--E 62
+
+--S 63 of 63
+)show Dequeue
+--R 
+--R Dequeue S: SetCategory  is a domain constructor
+--R Abbreviation for Dequeue is DEQUEUE 
+--R This constructor is exposed in this frame.
+--R Issue )edit bookvol10.3.spad.pamphlet to see algebra source code for DEQUEUE 
+--R
+--R------------------------------- Operations --------------------------------
+--R back : % -> S                         bag : List S -> %
+--R bottom! : % -> S                      copy : % -> %
+--R depth : % -> NonNegativeInteger       dequeue : List S -> %
+--R dequeue : () -> %                     dequeue! : % -> S
+--R empty : () -> %                       empty? : % -> Boolean
+--R enqueue! : (S,%) -> S                 eq? : (%,%) -> Boolean
+--R extract! : % -> S                     extractBottom! : % -> S
+--R extractTop! : % -> S                  front : % -> S
+--R height : % -> NonNegativeInteger      insert! : (S,%) -> %
+--R insertBottom! : (S,%) -> S            insertTop! : (S,%) -> S
+--R inspect : % -> S                      length : % -> NonNegativeInteger
+--R map : ((S -> S),%) -> %               pop! : % -> S
+--R push! : (S,%) -> S                    reverse! : % -> %
+--R rotate! : % -> %                      sample : () -> %
+--R top : % -> S                          top! : % -> S
+--R #? : % -> NonNegativeInteger if $ has finiteAggregate
+--R ?=? : (%,%) -> Boolean if S has SETCAT
+--R any? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
+--R coerce : % -> OutputForm if S has SETCAT
+--R count : (S,%) -> NonNegativeInteger if $ has finiteAggregate and S has SETCAT
+--R count : ((S -> Boolean),%) -> NonNegativeInteger if $ has finiteAggregate
+--R eval : (%,List S,List S) -> % if S has EVALAB S and S has SETCAT
+--R eval : (%,S,S) -> % if S has EVALAB S and S has SETCAT
+--R eval : (%,Equation S) -> % if S has EVALAB S and S has SETCAT
+--R eval : (%,List Equation S) -> % if S has EVALAB S and S has SETCAT
+--R every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
+--R hash : % -> SingleInteger if S has SETCAT
+--R latex : % -> String if S has SETCAT
+--R less? : (%,NonNegativeInteger) -> Boolean
+--R map! : ((S -> S),%) -> % if $ has shallowlyMutable
+--R member? : (S,%) -> Boolean if $ has finiteAggregate and S has SETCAT
+--R members : % -> List S if $ has finiteAggregate
+--R more? : (%,NonNegativeInteger) -> Boolean
+--R parts : % -> List S if $ has finiteAggregate
+--R size? : (%,NonNegativeInteger) -> Boolean
+--R ?~=? : (%,%) -> Boolean if S has SETCAT
+--R
+--E 63
+
+)spool
+)lisp (bye)
+ 
+@
+<<Dequeue.help>>=
+====================================================================
+Dequeue examples
+====================================================================
+
+A Dequeue is a double-ended queue so elements can be added to 
+either end.
+
+Here we create an dequeue of integers from a list. Notice that the
+order in the list is the order in the dequeue.
+
+   a:Dequeue INT:= dequeue [1,2,3,4,5]
+      [1,2,3,4,5]
+
+We can remove the top of the dequeue using dequeue!:
+
+   dequeue! a
+      1
+
+Notice that the use of dequeue! is destructive (destructive operations
+in Axiom usually end with ! to indicate that the underylying data
+structure is changed).
+
+   a
+      [2,3,4,5]
+
+The extract! operation is another name for the dequeue! operation and
+has the same effect. This operation treats the dequeue as a BagAggregate:
+
+   extract! a
+      2
+
+and you can see that it also has destructively modified the dequeue:
+
+   a
+      [3,4,5]
+
+Next we use enqueue! to add a new element to the end of the dequeue:
+
+   enqueue!(9,a)
+      9
+
+Again, the enqueue! operation is destructive so the dequeue is changed:
+
+   a
+      [3,4,5,9]
+
+Another name for enqueue! is insert!, which treats the dequeue as a 
+BagAggregate:
+
+   insert!(8,a)
+      [3,4,5,9,8]
+
+and it modifies the dequeue:
+
+   a
+      [3,4,5,9,8]
+
+The front operation returns the item at the front of the dequeue:
+
+   front a
+      3
+
+The back operation returns the item at the back of the dequeue:
+
+   back a
+      8
+
+The bottom! operation returns the item at the back of the dequeue:
+
+   bottom! a
+      8
+
+and it modifies the dequeue:
+
+   a
+      [3,4,5,9]
+
+The depth function returns the number of elements in the dequeue:
+
+   depth a
+      4
+
+The height function returns the number of elements in the dequeue:
+
+   height a
+      4
+
+The insertBottom! function adds the element at the end:
+
+   insertBottom!(6,a)
+      6
+
+and it modifies the dequeue:
+
+   a
+      [3,4,5,9,6]
+
+The extractBottom! function removes the element at the end:
+
+   extractBottom! a
+      6
+
+and it modifies the dequeue:
+
+   a
+      [3,4,5,9]
+
+The insertTop! function adds the element at the top:
+
+   insertTop!(7,a)
+      7
+
+and it modifies the dequeue:
+
+   a
+      [7,3,4,5,9]
+
+The extractTop! function adds the element at the top:
+
+   extractTop! a
+      7
+
+and it modifies the dequeue:
+
+   a
+      [3,4,5,9]
+
+The top function returns the top element:
+
+   top a
+      3
+
+and it does not modifies the dequeue:
+
+   a
+      [3,4,5,9]
+
+The top! function returns the top element:
+
+   top! a
+      3
+
+and it modifies the dequeue:
+
+   a
+      [4,5,9]
+
+The reverse! operation destructively reverses the elements of the dequeue:
+
+   reverse! a
+      [9,5,4]
+
+The rotate! operation moves the top element to the bottom:
+
+   rotate! a
+      [5,4,9]
+
+
+The inspect function returns the top of the dequeue without modification,
+viewed as a BagAggregate:
+
+   inspect a
+      5
+
+The empty? operation returns true only if there are no element on the
+dequeue, otherwise it returns false:
+
+   empty? a
+      false
+
+The # (length) operation:
+
+   #a
+       3
+
+The length operation does the same thing:
+
+   length a
+       3
+
+The less? predicate will compare the dequeue length to an integer:
+
+   less?(a,9)
+        true
+
+The more? predicate will compare the dequeue length to an integer:
+
+   more?(a,9)
+        false
+
+The size? operation will compare the dequeue length to an integer:
+
+   size?(a,#a)
+        true
+
+and since the last computation must alwasy be true we try:
+
+   size?(a,9)
+        false
+
+The parts function will return  the dequeue as a list of its elements:
+
+   parts a
+        [5,4,9]
+
+If we have a BagAggregate of elements we can use it to construct a dequeue:
+
+   bag([1,2,3,4,5])$Dequeue(INT)
+        [1,2,3,4,5]
+
+The empty function will construct an empty dequeue of a given type:
+
+   b:=empty()$(Dequeue INT)
+        []
+
+and the empty? predicate allows us to find out if a dequeue is empty:
+
+   empty? b
+        true
+
+The sample function returns a sample, empty dequeue:
+
+   sample()$Dequeue(INT)
+        []
+
+We can copy a dequeue and it does not share storage so subsequent
+modifications of the original dequeue will not affect the copy:
+
+   c:=copy a
+        [5,4,9]
+
+The eq? function is only true if the lists are the same reference,
+so even though c is a copy of a, they are not the same:
+
+   eq?(a,c)
+        false
+
+However, a clearly shares a reference with itself:
+
+   eq?(a,a)
+        true
+
+But we can compare a and c for equality:
+
+   (a=c)@Boolean
+        true
+
+and clearly a is equal to itself:
+
+   (a=a)@Boolean
+        true
+
+and since a and c are equal, they are clearly NOT not-equal:
+
+   a~=c
+        false
+
+We can use the any? function to see if a predicate is true for any element:
+
+   any?(x+->(x=4),a)
+        true
+
+or false for every element:
+
+   any?(x+->(x=11),a)
+        false
+
+We can use the every? function to check every element satisfies a predicate:
+
+   every?(x+->(x=11),a)
+        false
+
+We can count the elements that are equal to an argument of this type:
+
+   count(4,a)
+        1
+
+or we can count against a boolean function:
+
+   count(x+->(x>2),a)
+        3
+
+You can also map a function over every element, returning a new dequeue:
+
+   map(x+->x+10,a)
+        [15,14,19]
+
+Notice that the orignal dequeue is unchanged:
+
+   a
+        [5,4,9]
+
+You can use map! to map a function over every element and change
+the original dequeue since map! is destructive:
+
+   map!(x+->x+10,a)
+       [15,14,19]
+
+Notice that the orignal dequeue has been changed:
+
+   a
+       [15,14,19]
+
+The member function can also get the element of the dequeue as a list:
+
+   members a
+       [15,14,19]
+
+and using member? we can test if the dequeue holds a given element:
+
+   member?(14,a)
+       true
+
+
+See Also:
+o )show Stack
+o )show ArrayStack
+o )show Queue
+o )show Dequeue
+o )show Heap
+o )show BagAggregate
+
+@
 \pagehead{Dequeue}{DEQUEUE}
 \pagepic{ps/v103dequeue.ps}{DEQUEUE}{1.00}
 {\bf See}\\
@@ -18711,18 +19590,222 @@ DenavitHartenbergMatrix(R): Exports == Implementation where
 --% Dequeue and Heap data types
  
 Dequeue(S:SetCategory): DequeueAggregate S with
-     dequeue: List S -> %
-       ++ dequeue([x,y,...,z]) creates a dequeue with first (top or front)
-       ++ element x, second element y,...,and last (bottom or back) element z.
-       ++
-       ++E g:Dequeue INT:= dequeue [1,2,3,4,5]
+    dequeue: List S -> %
+      ++ dequeue([x,y,...,z]) creates a dequeue with first (top or front)
+      ++ element x, second element y,...,and last (bottom or back) element z.
+      ++
+      ++E g:Dequeue INT:= dequeue [1,2,3,4,5]
+
+ -- Inherited Signatures repeated for examples documentation
+
+    dequeue_! : % -> S
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X dequeue! a
+      ++X a
+    extract_! : % -> S
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X extract! a
+      ++X a
+    enqueue_! : (S,%) -> S
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X enqueue! (9,a)
+      ++X a
+    insert_! : (S,%) -> %
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X insert! (8,a)
+      ++X a
+    inspect : % -> S
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X inspect a
+    front : % -> S
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X front a
+    back : % -> S
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X back a
+    rotate_! : % -> %
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X rotate! a
+    length : % -> NonNegativeInteger
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X length a
+    less? : (%,NonNegativeInteger) -> Boolean
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X less?(a,9)
+    more? : (%,NonNegativeInteger) -> Boolean
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X more?(a,9)
+    size? : (%,NonNegativeInteger) -> Boolean
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X size?(a,5)
+    bag : List S -> %
+      ++
+      ++X bag([1,2,3,4,5])$Dequeue(INT)
+    empty? : % -> Boolean
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X empty? a
+    empty : () -> %
+      ++
+      ++X b:=empty()$(Dequeue INT)
+    sample : () -> %
+      ++
+      ++X sample()$Dequeue(INT)
+    copy : % -> %
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X copy a
+    eq? : (%,%) -> Boolean
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X b:=copy a
+      ++X eq?(a,b)
+    map :  ((S -> S),%) -> %
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X map(x+->x+10,a)
+      ++X a
+    depth : % -> NonNegativeInteger       
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X depth a
+    dequeue : () -> %                     
+      ++
+      ++X a:Dequeue INT:= dequeue ()
+    height : % -> NonNegativeInteger      
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X height a
+    top : % -> S                         
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X top a
+    bottom_! : % -> S
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X bottom! a
+      ++X a
+    extractBottom_! : % -> S
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X extractBottom! a
+      ++X a
+    extractTop_! : % -> S 
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X extractTop! a
+      ++X a
+    insertBottom_! : (S,%) -> S           
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X insertBottom! a
+      ++X a
+    insertTop_! : (S,%) -> S
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X insertTop! a
+      ++X a
+    pop_! : % -> S
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X pop! a
+      ++X a
+    push_! : (S,%) -> S                   
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X push! a
+      ++X a
+    reverse_! : % -> %
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X reverse! a
+      ++X a
+    top_! : % -> S
+      ++
+      ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+      ++X top! a
+      ++X a
+    if $ has shallowlyMutable then
+      map! :  ((S -> S),%) -> %
+        ++
+        ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+        ++X map!(x+->x+10,a)
+        ++X a
+    if S has SetCategory then
+      latex : % -> String
+        ++
+        ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+        ++X latex a
+      hash : % -> SingleInteger
+        ++
+        ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+        ++X hash a
+      coerce : % -> OutputForm
+        ++
+        ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+        ++X coerce a
+      "=": (%,%) -> Boolean
+        ++
+        ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+        ++X b:Dequeue INT:= dequeue [1,2,3,4,5]
+        ++X (a=b)@Boolean
+      "~=" : (%,%) -> Boolean
+        ++
+        ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+        ++X b:=copy a
+        ++X (a~=b)
+    if % has finiteAggregate then
+      every? : ((S -> Boolean),%) -> Boolean
+        ++
+        ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+        ++X every?(x+->(x=4),a)
+      any? : ((S -> Boolean),%) -> Boolean
+        ++
+        ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+        ++X any?(x+->(x=4),a)
+      count :  ((S -> Boolean),%) -> NonNegativeInteger
+        ++
+        ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+        ++X count(x+->(x>2),a)
+      _# : % -> NonNegativeInteger
+        ++
+        ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+        ++X #a
+      parts : % -> List S
+        ++
+        ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+        ++X parts a
+      members : % -> List S
+        ++
+        ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+        ++X members a
+    if % has finiteAggregate and S has SetCategory then
+      member? : (S,%) -> Boolean
+        ++
+        ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+        ++X member?(3,a)
+      count : (S,%) -> NonNegativeInteger
+        ++
+        ++X a:Dequeue INT:= dequeue [1,2,3,4,5]
+        ++X count(4,a)
 
   == Queue S add
     Rep := Reference List S
-    bottom_! d ==
-         if empty? d then error "empty dequeue" else last deref d
+    bottom! d == extractBottom! d
     dequeue d == ref copy d
-    extractBottom_! d ==
+    extractBottom! d ==
         if empty? d then error "empty dequeue"
         p := deref d
         n := maxIndex p
@@ -18734,19 +19817,22 @@ Dequeue(S:SetCategory): DequeueAggregate S with
         r := first rest q
         q.rest := []
         r
-    extractTop_! d ==
+    top! d == extractTop! d
+    extractTop! d ==
+        if empty? d then error "empty dequeue"
         e := top d
         setref(d,rest deref d)
         e
     height d == # deref d
-    insertTop_!(e,d) == (setref(d,cons(e,deref d)); e)
+    depth d == # deref d
+    insertTop!(e,d) == (setref(d,cons(e,deref d)); e)
     lastTail==> LAST$Lisp
-    insertBottom_!(e,d) ==
+    insertBottom!(e,d) ==
         if empty? d then setref(d, list e)
         else lastTail.(deref d).rest := list e
         e
     top d == if empty? d then error "empty dequeue" else first deref d
-    reverse_! d == (setref(d,reverse deref d); d)
+    reverse! d == (setref(d,reverse deref d); d)
 
 @
 <<DEQUEUE.dotabb>>=
diff --git a/changelog b/changelog
index 1bc3146..ec8432f 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,6 @@
+20090224 tpd src/axiom-website/patches.html 20090224.01.tpd.patch
+20090224 tpd src/interp/Makefile add regression, help for Dequeue
+20090224 tpd books/bookvol10.3 add regression, help, examples for Dequeue
 20090223 tpd src/axiom-website/patches.html 20090223.01.tpd.patch
 20090223 tpd src/interp/Makefile add regression, help for Queue
 20090223 tpd books/bookvol10.3 add regression, help, examples for Queue
diff --git a/src/algebra/Makefile.pamphlet b/src/algebra/Makefile.pamphlet
index c0ad0df..bcf1252 100644
--- a/src/algebra/Makefile.pamphlet
+++ b/src/algebra/Makefile.pamphlet
@@ -16419,7 +16419,8 @@ SPADHELP=\
  ${HELP}/CharacterClass.help         ${HELP}/CliffordAlgebra.help \
  ${HELP}/Complex.help                ${HELP}/ContinuedFraction.help \
  ${HELP}/CycleIndicators.help        ${HELP}/DeRhamComplex.help \
- ${HELP}/DecimalExpansion.help       ${HELP}/DoubleFloat.help \
+ ${HELP}/DecimalExpansion.help       ${HELP}/Dequeue.help \
+ ${HELP}/DoubleFloat.help \
  ${HELP}/EqTable.help                ${HELP}/Equation.help \
  ${HELP}/Expression.help \
  ${HELP}/DistributedMultivariatePolynomial.help \
@@ -16489,7 +16490,8 @@ REGRESS=\
  CharacterClass.regress         CliffordAlgebra.regress \
  Complex.regress                ContinuedFraction.regress \
  CycleIndicators.regress        DeRhamComplex.regress \
- DecimalExpansion.regress       DoubleFloat.regress \
+ DecimalExpansion.regress       Dequeue.regress \
+ DoubleFloat.regress \
  DistributedMultivariatePolynomial.regress \
  EqTable.regress                Equation.regress \
  Expression.regress \
@@ -16565,7 +16567,7 @@ all: ${REGRESS}
 @
 <<spadhelp>>=
 ${HELP}/ArrayStack.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7078 create ArrayStack.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7000 create ArrayStack.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"ArrayStack.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/ArrayStack.help
 	@cp ${HELP}/ArrayStack.help ${HELP}/ASTACK.help
@@ -16574,7 +16576,7 @@ ${HELP}/ArrayStack.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "ArrayStack (ASTACK)" >>${HELPFILE}
 
 ${HELP}/AssociationList.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7000 create AssociationList.help from \
+	@echo 7001 create AssociationList.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"AssociationList.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/AssociationList.help
@@ -16584,7 +16586,7 @@ ${HELP}/AssociationList.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "AssociationList (ALIST)" >>${HELPFILE}
 
 ${HELP}/BalancedBinaryTree.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7001 create BalancedBinaryTree.help from \
+	@echo 7002 create BalancedBinaryTree.help from \
             ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"BalancedBinaryTree.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/BalancedBinaryTree.help
@@ -16594,7 +16596,7 @@ ${HELP}/BalancedBinaryTree.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "BalancedBinaryTree (BBTREE)" >>${HELPFILE}
 
 ${HELP}/BasicOperator.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7002 create BasicOperator.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7003 create BasicOperator.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"BasicOperator.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/BasicOperator.help
 	@cp ${HELP}/BasicOperator.help ${HELP}/BOP.help
@@ -16603,7 +16605,7 @@ ${HELP}/BasicOperator.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "BasicOperator (BOP)" >>${HELPFILE}
 
 ${HELP}/BinaryExpansion.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7003 create BinaryExpansion.help from \
+	@echo 7004 create BinaryExpansion.help from \
             ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"BinaryExpansion.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/BinaryExpansion.help
@@ -16613,7 +16615,7 @@ ${HELP}/BinaryExpansion.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "BinaryExpansion (BINARY)" >>${HELPFILE}
 
 ${HELP}/BinarySearchTree.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7004 create BinarySearchTree.help from \
+	@echo 7005 create BinarySearchTree.help from \
             ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"BinarySearchTree.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/BinarySearchTree.help
@@ -16623,7 +16625,7 @@ ${HELP}/BinarySearchTree.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "BinarySearchTree (BSTREE)" >>${HELPFILE}
 
 ${HELP}/CardinalNumber.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7005 create CardinalNumber.help from \
+	@echo 7006 create CardinalNumber.help from \
                 ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"CardinalNumber.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/CardinalNumber.help
@@ -16633,7 +16635,7 @@ ${HELP}/CardinalNumber.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "CardinalNumber (CARD)" >>${HELPFILE}
 
 ${HELP}/CartesianTensor.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7006 create CartesianTensor.help from \
+	@echo 7007 create CartesianTensor.help from \
              ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"CartesianTensor.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/CartesianTensor.help
@@ -16643,7 +16645,7 @@ ${HELP}/CartesianTensor.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "CartesianTensor (CARTEN)" >>${HELPFILE}
 
 ${HELP}/Character.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7007 create Character.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7008 create Character.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Character.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/Character.help
 	@cp ${HELP}/Character.help ${HELP}/CHAR.help
@@ -16652,7 +16654,7 @@ ${HELP}/Character.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Character (CHAR)" >>${HELPFILE}
 
 ${HELP}/CharacterClass.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7008 create CharacterClass.help from \
+	@echo 7009 create CharacterClass.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"CharacterClass.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/CharacterClass.help
@@ -16662,7 +16664,7 @@ ${HELP}/CharacterClass.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "CharacterClass (CCLASS)" >>${HELPFILE}
 
 ${HELP}/CliffordAlgebra.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7009 create CliffordAlgebra.help from \
+	@echo 7010 create CliffordAlgebra.help from \
           ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"CliffordAlgebra.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/CliffordAlgebra.help
@@ -16672,7 +16674,7 @@ ${HELP}/CliffordAlgebra.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "CliffordAlgebra (CLIF)" >>${HELPFILE}
 
 ${HELP}/Complex.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7010 create Complex.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7011 create Complex.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Complex.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/Complex.help
 	@-cp ${HELP}/Complex.help ${HELP}/COMPLEX.help
@@ -16681,7 +16683,7 @@ ${HELP}/Complex.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Complex (COMPLEX)" >>${HELPFILE}
 
 ${HELP}/ContinuedFraction.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7011 create ContinuedFraction.help from \
+	@echo 7012 create ContinuedFraction.help from \
             ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"ContinuedFraction.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/ContinuedFraction.help
@@ -16691,7 +16693,7 @@ ${HELP}/ContinuedFraction.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "ContinuedFraction (CONTFRAC)" >>${HELPFILE}
 
 ${HELP}/CycleIndicators.help: ${BOOKS}/bookvol10.4.pamphlet
-	@echo 7012 create CycleIndicators.help from \
+	@echo 7013 create CycleIndicators.help from \
             ${BOOKS}/bookvol10.4.pamphlet
 	@${TANGLE} -R"CycleIndicators.help" ${BOOKS}/bookvol10.4.pamphlet \
             >${HELP}/CycleIndicators.help
@@ -16701,7 +16703,7 @@ ${HELP}/CycleIndicators.help: ${BOOKS}/bookvol10.4.pamphlet
 	@echo "CycleIndicators (CYCLES)" >>${HELPFILE}
 
 ${HELP}/DeRhamComplex.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7013 create DeRhamComplex.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7014 create DeRhamComplex.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"DeRhamComplex.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/DeRhamComplex.help
 	@cp ${HELP}/DeRhamComplex.help ${HELP}/DERHAM.help
@@ -16710,7 +16712,7 @@ ${HELP}/DeRhamComplex.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "DeRhamComplex (DERHAM)" >>${HELPFILE}
 
 ${HELP}/DecimalExpansion.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7014 create DecimalExpansion.help from \
+	@echo 7015 create DecimalExpansion.help from \
             ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"DecimalExpansion.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/DecimalExpansion.help
@@ -16719,9 +16721,18 @@ ${HELP}/DecimalExpansion.help: ${BOOKS}/bookvol10.3.pamphlet
             >${INPUT}/DecimalExpansion.input
 	@echo "DecimalExpansion (DECIMAL)" >>${HELPFILE}
 
+${HELP}/Dequeue.help: ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7016 create Dequeue.help from ${BOOKS}/bookvol10.3.pamphlet
+	@${TANGLE} -R"Dequeue.help" ${BOOKS}/bookvol10.3.pamphlet \
+           >${HELP}/Dequeue.help
+	@-cp ${HELP}/Dequeue.help ${HELP}/DEQUEUE.help
+	@${TANGLE} -R"Dequeue.input" ${BOOKS}/bookvol10.3.pamphlet \
+            >${INPUT}/Dequeue.input
+	@echo "Dequeue (DEQUEUE)" >>${HELPFILE}
+
 ${HELP}/DistributedMultivariatePolynomial.help: \
             ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7015 create DistributedMultivariatePolynomial.help \
+	@echo 7017 create DistributedMultivariatePolynomial.help \
             from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"DistributedMultivariatePolynomial.help" \
            ${BOOKS}/bookvol10.3.pamphlet \
@@ -16733,7 +16744,7 @@ ${HELP}/DistributedMultivariatePolynomial.help: \
 	@echo "DistributedMultivariatePolynomial (DMP)" >>${HELPFILE}
 
 ${HELP}/DoubleFloat.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7016 create DoubleFloat.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7018 create DoubleFloat.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"DoubleFloat.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/DoubleFloat.help
 	@cp ${HELP}/DoubleFloat.help ${HELP}/DFLOAT.help
@@ -16742,7 +16753,7 @@ ${HELP}/DoubleFloat.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "DoubleFloat (DFLOAT)" >>${HELPFILE}
 
 ${HELP}/EqTable.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7017 create EqTable.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7019 create EqTable.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"EqTable.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/EqTable.help
 	@cp ${HELP}/EqTable.help ${HELP}/EQTBL.help
@@ -16751,7 +16762,7 @@ ${HELP}/EqTable.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "EqTable (EQTBL)" >>${HELPFILE}
 
 ${HELP}/Equation.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7018 create Equation.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7020 create Equation.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Equation.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/Equation.help
 	@cp ${HELP}/Equation.help ${HELP}/EQ.help
@@ -16760,7 +16771,7 @@ ${HELP}/Equation.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Equation (EQ)" >>${HELPFILE}
 
 ${HELP}/EuclideanGroebnerBasisPackage.help: ${BOOKS}/bookvol10.4.pamphlet
-	@echo 7020 create EuclideanGroebnerBasisPackage.help from \
+	@echo 7021 create EuclideanGroebnerBasisPackage.help from \
             ${BOOKS}/bookvol10.4.pamphlet
 	@${TANGLE} -R"EuclideanGroebnerBasisPackage.help" \
             ${BOOKS}/bookvol10.4.pamphlet \
@@ -16772,7 +16783,7 @@ ${HELP}/EuclideanGroebnerBasisPackage.help: ${BOOKS}/bookvol10.4.pamphlet
 	@echo "EuclideanGroebnerBasisPackage (GBEUCLID)" >>${HELPFILE}
 
 ${HELP}/Expression.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7018 create Expression.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7022 create Expression.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Expression.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/Expression.help
 	@cp ${HELP}/Expression.help ${HELP}/EXPR.help
@@ -16781,7 +16792,7 @@ ${HELP}/Expression.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Expression (EXPR)" >>${HELPFILE}
 
 ${HELP}/Factored.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7019 create Factored.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7023 create Factored.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Factored.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/Factored.help
 	@cp ${HELP}/Factored.help ${HELP}/FR.help
@@ -16790,7 +16801,7 @@ ${HELP}/Factored.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Factored (FR)" >>${HELPFILE}
 
 ${HELP}/FactoredFunctions2.help: ${BOOKS}/bookvol10.4.pamphlet
-	@echo 7020 create FactoredFunctions2.help from \
+	@echo 7024 create FactoredFunctions2.help from \
             ${BOOKS}/bookvol10.4.pamphlet
 	@${TANGLE} -R"FactoredFunctions2.help" ${BOOKS}/bookvol10.4.pamphlet \
             >${HELP}/FactoredFunctions2.help
@@ -16800,7 +16811,7 @@ ${HELP}/FactoredFunctions2.help: ${BOOKS}/bookvol10.4.pamphlet
 	@echo "FactoredFunctions2 (FR2)" >>${HELPFILE}
 
 ${HELP}/File.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7021 create File.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7025 create File.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"File.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/File.help
 	@-cp ${HELP}/File.help ${HELP}/FILE.help
@@ -16809,7 +16820,7 @@ ${HELP}/File.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "File (FILE)" >>${HELPFILE}
 
 ${HELP}/FileName.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7022 create FileName.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7026 create FileName.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"FileName.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/FileName.help
 	@cp ${HELP}/FileName.help ${HELP}/FNAME.help
@@ -16818,7 +16829,7 @@ ${HELP}/FileName.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "FileName (FNAME)" >>${HELPFILE}
 
 ${HELP}/FlexibleArray.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7023 create FlexibleArray.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7027 create FlexibleArray.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"FlexibleArray.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/FlexibleArray.help
 	@cp ${HELP}/FlexibleArray.help ${HELP}/FARRAY.help
@@ -16827,7 +16838,7 @@ ${HELP}/FlexibleArray.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "FlexibleArray (FARRAY)" >>${HELPFILE}
 
 ${HELP}/Float.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7024 create Float.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7028 create Float.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Float.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Float.help
 	@-cp ${HELP}/Float.help ${HELP}/FLOAT.help
@@ -16836,7 +16847,7 @@ ${HELP}/Float.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Float (FLOAT)" >>${HELPFILE}
 
 ${HELP}/Fraction.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7025 create Fraction.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7029 create Fraction.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Fraction.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/Fraction.help
 	@cp ${HELP}/Fraction.help ${HELP}/FRAC.help
@@ -16845,7 +16856,7 @@ ${HELP}/Fraction.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Fraction (FRAC)" >>${HELPFILE}
 
 ${HELP}/FullPartialFractionExpansion.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7026 create FullPartialFractionExpansion.help from \
+	@echo 7030 create FullPartialFractionExpansion.help from \
             ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"FullPartialFractionExpansion.help" \
             ${BOOKS}/bookvol10.3.pamphlet \
@@ -16858,7 +16869,7 @@ ${HELP}/FullPartialFractionExpansion.help: ${BOOKS}/bookvol10.3.pamphlet
 
 ${HELP}/GeneralDistributedMultivariatePolynomial.help: \
             ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7027 create GeneralDistributedMultivariatePolynomial.help \
+	@echo 7031 create GeneralDistributedMultivariatePolynomial.help \
             from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"GeneralDistributedMultivariatePolynomial.help" \
            ${BOOKS}/bookvol10.3.pamphlet \
@@ -16871,7 +16882,7 @@ ${HELP}/GeneralDistributedMultivariatePolynomial.help: \
 	@echo "GeneralDistributedMultivariatePolynomial (GDMP)" >>${HELPFILE}
 
 ${HELP}/GeneralSparseTable.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7028 create GeneralSparseTable.help from \
+	@echo 7032 create GeneralSparseTable.help from \
             ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"GeneralSparseTable.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/GeneralSparseTable.help
@@ -16881,7 +16892,7 @@ ${HELP}/GeneralSparseTable.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "GeneralSparseTable (GSTBL)" >>${HELPFILE}
 
 ${HELP}/GroebnerFactorizationPackage.help: ${BOOKS}/bookvol10.4.pamphlet
-	@echo 7029 create GroebnerFactorizationPackage.help \
+	@echo 7033 create GroebnerFactorizationPackage.help \
             from ${BOOKS}/bookvol10.4.pamphlet
 	@${TANGLE} -R"GroebnerFactorizationPackage.help" \
            ${BOOKS}/bookvol10.4.pamphlet \
@@ -16893,7 +16904,7 @@ ${HELP}/GroebnerFactorizationPackage.help: ${BOOKS}/bookvol10.4.pamphlet
 	@echo "GroebnerFactorizationPackage (GBF)" >>${HELPFILE}
 
 ${HELP}/GroebnerPackage.help: ${BOOKS}/bookvol10.4.pamphlet
-	@echo 7020 create GroebnerPackage.help from \
+	@echo 7034 create GroebnerPackage.help from \
             ${BOOKS}/bookvol10.4.pamphlet
 	@${TANGLE} -R"GroebnerPackage.help" ${BOOKS}/bookvol10.4.pamphlet \
             >${HELP}/GroebnerPackage.help
@@ -16903,7 +16914,7 @@ ${HELP}/GroebnerPackage.help: ${BOOKS}/bookvol10.4.pamphlet
 	@echo "GroebnerPackage (GB)" >>${HELPFILE}
 
 ${HELP}/Heap.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7030 create Heap.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7035 create Heap.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Heap.help" ${BOOKS}/bookvol10.3.pamphlet \
              >${HELP}/Heap.help
 	@-cp ${HELP}/Heap.help ${HELP}/HEAP.help
@@ -16912,7 +16923,7 @@ ${HELP}/Heap.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Heap (HEAP)" >>${HELPFILE}
 
 ${HELP}/HexadecimalExpansion.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7031 create HexadecimalExpansion.help \
+	@echo 7036 create HexadecimalExpansion.help \
             from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"HexadecimalExpansion.help" \
            ${BOOKS}/bookvol10.3.pamphlet \
@@ -16924,7 +16935,7 @@ ${HELP}/HexadecimalExpansion.help: ${BOOKS}/bookvol10.3.pamphlet
 
 ${HELP}/HomogeneousDistributedMultivariatePolynomial.help: \
             ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7032 create HomogeneousDistributedMultivariatePolynomial.help \
+	@echo 7037 create HomogeneousDistributedMultivariatePolynomial.help \
             from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"HomogeneousDistributedMultivariatePolynomial.help" \
            ${BOOKS}/bookvol10.3.pamphlet \
@@ -16938,7 +16949,7 @@ ${HELP}/HomogeneousDistributedMultivariatePolynomial.help: \
             >>${HELPFILE}
 
 ${HELP}/Integer.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7033 create Integer.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7038 create Integer.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Integer.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Integer.help
 	@cp ${HELP}/Integer.help ${HELP}/INT.help
@@ -16947,7 +16958,7 @@ ${HELP}/Integer.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Integer (INT)" >>${HELPFILE}
 
 ${HELP}/IntegerLinearDependence.help: ${BOOKS}/bookvol10.4.pamphlet
-	@echo 7034 create IntegerLinearDependence.help from \
+	@echo 7039 create IntegerLinearDependence.help from \
            ${BOOKS}/bookvol10.4.pamphlet
 	@${TANGLE} -R"IntegerLinearDependence.help" \
            ${BOOKS}/bookvol10.4.pamphlet \
@@ -16959,7 +16970,7 @@ ${HELP}/IntegerLinearDependence.help: ${BOOKS}/bookvol10.4.pamphlet
 	@echo "IntegerLinearDependence (ZLINDEP)" >>${HELPFILE}
 
 ${HELP}/IntegerNumberTheoryFunctions.help: ${BOOKS}/bookvol10.4.pamphlet
-	@echo 7035 create IntegerNumberTheoryFunctions.help \
+	@echo 7040 create IntegerNumberTheoryFunctions.help \
             from ${BOOKS}/bookvol10.4.pamphlet
 	@${TANGLE} -R"IntegerNumberTheoryFunctions.help" \
            ${BOOKS}/bookvol10.4.pamphlet \
@@ -16972,7 +16983,7 @@ ${HELP}/IntegerNumberTheoryFunctions.help: ${BOOKS}/bookvol10.4.pamphlet
 	@echo "IntegerNumberTheoryFunctions (INTHEORY)" >>${HELPFILE}
 
 ${HELP}/Kernel.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7036 create Kernel.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7041 create Kernel.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Kernel.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Kernel.help
 	@-cp ${HELP}/Kernel.help ${HELP}/KERNEL.help
@@ -16981,7 +16992,7 @@ ${HELP}/Kernel.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Kernel (KERNEL)" >>${HELPFILE}
 
 ${HELP}/KeyedAccessFile.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7037 create KeyedAccessFile.help from \
+	@echo 7042 create KeyedAccessFile.help from \
               ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"KeyedAccessFile.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/KeyedAccessFile.help
@@ -16991,7 +17002,7 @@ ${HELP}/KeyedAccessFile.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "KeyedAccessFile (KAFILE)" >>${HELPFILE}
 
 ${HELP}/LexTriangularPackage.help: ${BOOKS}/bookvol10.4.pamphlet
-	@echo 7038 create LexTriangularPackage.help from \
+	@echo 7043 create LexTriangularPackage.help from \
            ${BOOKS}/bookvol10.4.pamphlet
 	@${TANGLE} -R"LexTriangularPackage.help" \
            ${BOOKS}/bookvol10.4.pamphlet \
@@ -17003,7 +17014,7 @@ ${HELP}/LexTriangularPackage.help: ${BOOKS}/bookvol10.4.pamphlet
 	@echo "LexTriangularPackage (LEXTRIPK)" >>${HELPFILE}
 
 ${HELP}/Library.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7039 create Library.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7044 create Library.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Library.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Library.help
 	@cp ${HELP}/Library.help ${HELP}/LIB.help
@@ -17012,7 +17023,7 @@ ${HELP}/Library.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Library (LIB)" >>${HELPFILE}
 
 ${HELP}/LieExponentials.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7040 create LieExponentials.help from \
+	@echo 7045 create LieExponentials.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"LieExponentials.help" \
            ${BOOKS}/bookvol10.3.pamphlet \
@@ -17024,7 +17035,7 @@ ${HELP}/LieExponentials.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "LieExponentials (LEXP)" >>${HELPFILE}
 
 ${HELP}/LiePolynomial.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7041 create LiePolynomial.help from \
+	@echo 7046 create LiePolynomial.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"LiePolynomial.help" \
            ${BOOKS}/bookvol10.3.pamphlet \
@@ -17036,7 +17047,7 @@ ${HELP}/LiePolynomial.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "LiePolynomial (LPOLY)" >>${HELPFILE}
 
 ${HELP}/LinearOrdinaryDifferentialOperator.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7042 create LinearOrdinaryDifferentialOperator.help \
+	@echo 7047 create LinearOrdinaryDifferentialOperator.help \
            from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"LinearOrdinaryDifferentialOperator.help" \
           ${BOOKS}/bookvol10.3.pamphlet \
@@ -17049,7 +17060,7 @@ ${HELP}/LinearOrdinaryDifferentialOperator.help: ${BOOKS}/bookvol10.3.pamphlet
 
 ${HELP}/LinearOrdinaryDifferentialOperator1.help: \
       ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7043 create LinearOrdinaryDifferentialOperator1.help \
+	@echo 7048 create LinearOrdinaryDifferentialOperator1.help \
            from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"LinearOrdinaryDifferentialOperator1.help" \
           ${BOOKS}/bookvol10.3.pamphlet \
@@ -17062,7 +17073,7 @@ ${HELP}/LinearOrdinaryDifferentialOperator1.help: \
 
 ${HELP}/LinearOrdinaryDifferentialOperator2.help: \
      ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7044 create LinearOrdinaryDifferentialOperator2.help \
+	@echo 7049 create LinearOrdinaryDifferentialOperator2.help \
            from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"LinearOrdinaryDifferentialOperator2.help" \
           ${BOOKS}/bookvol10.3.pamphlet \
@@ -17074,7 +17085,7 @@ ${HELP}/LinearOrdinaryDifferentialOperator2.help: \
 	@echo "LinearOrdinaryDifferentialOperator2 (LODO2)" >>${HELPFILE}
 
 ${HELP}/List.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7045 create List.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7050 create List.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"List.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/List.help
 	@-cp ${HELP}/List.help ${HELP}/LIST.help
@@ -17083,7 +17094,7 @@ ${HELP}/List.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "List (LIST)" >>${HELPFILE}
 
 ${HELP}/LyndonWord.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7046 create LyndonWord.help from \
+	@echo 7051 create LyndonWord.help from \
             ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"LyndonWord.help" \
             ${BOOKS}/bookvol10.3.pamphlet \
@@ -17095,7 +17106,7 @@ ${HELP}/LyndonWord.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "LyndonWord (LWORD)" >>${HELPFILE}
 
 ${HELP}/Magma.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7047 create Magma.help from \
+	@echo 7052 create Magma.help from \
             ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Magma.help" \
             ${BOOKS}/bookvol10.3.pamphlet \
@@ -17107,7 +17118,7 @@ ${HELP}/Magma.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Magma (MAGMA)" >>${HELPFILE}
 
 ${HELP}/MakeFunction.help: ${BOOKS}/bookvol10.4.pamphlet
-	@echo 7048 create MakeFunction.help from ${BOOKS}/bookvol10.4.pamphlet
+	@echo 7053 create MakeFunction.help from ${BOOKS}/bookvol10.4.pamphlet
 	@${TANGLE} -R"MakeFunction.help" ${BOOKS}/bookvol10.4.pamphlet \
            >${HELP}/MakeFunction.help
 	@cp ${HELP}/MakeFunction.help ${HELP}/MKFUNC.help
@@ -17116,7 +17127,7 @@ ${HELP}/MakeFunction.help: ${BOOKS}/bookvol10.4.pamphlet
 	@echo "MakeFunction (MKFUNC)" >>${HELPFILE}
 
 ${HELP}/MappingPackage1.help: ${BOOKS}/bookvol10.4.pamphlet
-	@echo 7049 create MappingPackage1.help from \
+	@echo 7054 create MappingPackage1.help from \
            ${BOOKS}/bookvol10.4.pamphlet
 	@${TANGLE} -R"MappingPackage1.help" ${BOOKS}/bookvol10.4.pamphlet \
            >${HELP}/MappingPackage1.help
@@ -17126,7 +17137,7 @@ ${HELP}/MappingPackage1.help: ${BOOKS}/bookvol10.4.pamphlet
 	@echo "MappingPackage1 (MAPPKG1)" >>${HELPFILE}
 
 ${HELP}/MappingPackage2.help: ${BOOKS}/bookvol10.4.pamphlet
-	@echo 7050 create MappingPackage2.help from \
+	@echo 7055 create MappingPackage2.help from \
            ${BOOKS}/bookvol10.4.pamphlet
 	@${TANGLE} -R"MappingPackage2.help" ${BOOKS}/bookvol10.4.pamphlet \
            >${HELP}/MappingPackage2.help
@@ -17136,7 +17147,7 @@ ${HELP}/MappingPackage2.help: ${BOOKS}/bookvol10.4.pamphlet
 	@echo "MappingPackage2 (MAPPKG2)" >>${HELPFILE}
 
 ${HELP}/MappingPackage3.help: ${BOOKS}/bookvol10.4.pamphlet
-	@echo 7051 create MappingPackage3.help from \
+	@echo 7056 create MappingPackage3.help from \
            ${BOOKS}/bookvol10.4.pamphlet
 	@${TANGLE} -R"MappingPackage3.help" ${BOOKS}/bookvol10.4.pamphlet \
            >${HELP}/MappingPackage3.help
@@ -17146,7 +17157,7 @@ ${HELP}/MappingPackage3.help: ${BOOKS}/bookvol10.4.pamphlet
 	@echo "MappingPackage3 (MAPPKG3)" >>${HELPFILE}
 
 ${HELP}/Matrix.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7052 create Matrix.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7057 create Matrix.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Matrix.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Matrix.help
 	@-cp ${HELP}/Matrix.help ${HELP}/MATRIX.help
@@ -17155,7 +17166,7 @@ ${HELP}/Matrix.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Matrix (MATRIX)" >>${HELPFILE}
 
 ${HELP}/Multiset.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7053 create Multiset.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7058 create Multiset.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Multiset.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Multiset.help
 	@cp ${HELP}/Multiset.help ${HELP}/MSET.help
@@ -17164,7 +17175,7 @@ ${HELP}/Multiset.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Multiset (MSET)" >>${HELPFILE}
 
 ${HELP}/MultivariatePolynomial.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7054 create MultivariatePolynomial.help from \
+	@echo 7059 create MultivariatePolynomial.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"MultivariatePolynomial.help" \
            ${BOOKS}/bookvol10.3.pamphlet \
@@ -17176,7 +17187,7 @@ ${HELP}/MultivariatePolynomial.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "MultivariatePolynomial (MPOLY)" >>${HELPFILE}
 
 ${HELP}/None.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7055 create None.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7060 create None.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"None.help" ${BOOKS}/bookvol10.3.pamphlet \
              >${HELP}/None.help
 	@-cp ${HELP}/None.help ${HELP}/NONE.help
@@ -17185,7 +17196,7 @@ ${HELP}/None.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "None (NONE)" >>${HELPFILE}
 
 ${HELP}/Octonion.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7056 create Octonion.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7061 create Octonion.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Octonion.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Octonion.help
 	@cp ${HELP}/Octonion.help ${HELP}/OCT.help
@@ -17194,7 +17205,7 @@ ${HELP}/Octonion.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Octonion (OCT)" >>${HELPFILE}
 
 ${HELP}/OneDimensionalArray.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7057 create OneDimensionalArray.help from \
+	@echo 7062 create OneDimensionalArray.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"OneDimensionalArray.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/OneDimensionalArray.help
@@ -17205,7 +17216,7 @@ ${HELP}/OneDimensionalArray.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "OneDimensionalArray (ARRAY1)" >>${HELPFILE}
 
 ${HELP}/Operator.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7058 create Operator.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7063 create Operator.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Operator.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Operator.help
 	@cp ${HELP}/Operator.help ${HELP}/OP.help
@@ -17214,7 +17225,7 @@ ${HELP}/Operator.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Operator (OP)" >>${HELPFILE}
 
 ${HELP}/OrderedVariableList.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7059 create OrderedVariableList.help from \
+	@echo 7064 create OrderedVariableList.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"OrderedVariableList.help" \
            ${BOOKS}/bookvol10.3.pamphlet \
@@ -17226,7 +17237,7 @@ ${HELP}/OrderedVariableList.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "OrderedVariableList (OVAR)" >>${HELPFILE}
 
 ${HELP}/OrderlyDifferentialPolynomial.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7060 create OrderlyDifferentialPolynomial.help from \
+	@echo 7065 create OrderlyDifferentialPolynomial.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"OrderlyDifferentialPolynomial.help" \
            ${BOOKS}/bookvol10.3.pamphlet \
@@ -17238,7 +17249,7 @@ ${HELP}/OrderlyDifferentialPolynomial.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "OrderlyDifferentialPolynomial (ODPOL)" >>${HELPFILE}
 
 ${HELP}/PartialFraction.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7061 create PartialFraction.help from \
+	@echo 7066 create PartialFraction.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"PartialFraction.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/PartialFraction.help
@@ -17248,7 +17259,7 @@ ${HELP}/PartialFraction.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "PartialFraction (PFR)" >>${HELPFILE}
 
 ${HELP}/Permanent.help: ${BOOKS}/bookvol10.4.pamphlet
-	@echo 7062 create Permanent.help from ${BOOKS}/bookvol10.4.pamphlet
+	@echo 7067 create Permanent.help from ${BOOKS}/bookvol10.4.pamphlet
 	@${TANGLE} -R"Permanent.help" ${BOOKS}/bookvol10.4.pamphlet \
            >${HELP}/Permanent.help
 	@cp ${HELP}/Permanent.help ${HELP}/PERMAN.help
@@ -17257,7 +17268,7 @@ ${HELP}/Permanent.help: ${BOOKS}/bookvol10.4.pamphlet
 	@echo "Permanent (PERMAN)" >>${HELPFILE}
 
 ${HELP}/Permutation.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7063 create Permutation.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7068 create Permutation.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Permutation.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Permutation.help
 	@cp ${HELP}/Permutation.help ${HELP}/PERM.help
@@ -17266,7 +17277,7 @@ ${HELP}/Permutation.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Permutation (PERM)" >>${HELPFILE}
 
 ${HELP}/PlaneAlgebraicCurvePlot.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7064 create PlaneAlgebraicCurvePlot.help from \
+	@echo 7069 create PlaneAlgebraicCurvePlot.help from \
             ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"PlaneAlgebraicCurvePlot.help" \
           ${BOOKS}/bookvol10.3.pamphlet \
@@ -17278,7 +17289,7 @@ ${HELP}/PlaneAlgebraicCurvePlot.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "PlaneAlgebraicCurvePlot (ACPLOT)" >>${HELPFILE}
 
 ${HELP}/Plot.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7064 create Plot.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7070 create Plot.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Plot.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/Plot.help
 	@-cp ${HELP}/Plot.help ${HELP}/PLOT.help
@@ -17287,7 +17298,7 @@ ${HELP}/Plot.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Plot (PLOT)" >>${HELPFILE}
 
 ${HELP}/Polynomial.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7065 create Polynomial.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7071 create Polynomial.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Polynomial.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Polynomial.help
 	@cp ${HELP}/Polynomial.help ${HELP}/POLY.help
@@ -17296,7 +17307,7 @@ ${HELP}/Polynomial.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Polynomial (POLY)" >>${HELPFILE}
 
 ${HELP}/Quaternion.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7066 create Quaternion.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7072 create Quaternion.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Quaternion.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Quaternion.help
 	@cp ${HELP}/Quaternion.help ${HELP}/QUAT.help
@@ -17305,7 +17316,7 @@ ${HELP}/Quaternion.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Quaternion (QUAT)" >>${HELPFILE}
 
 ${HELP}/Queue.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7078 create Queue.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7073 create Queue.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Queue.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Queue.help
 	@-cp ${HELP}/Queue.help ${HELP}/QUEUE.help
@@ -17314,7 +17325,7 @@ ${HELP}/Queue.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Queue (QUEUE)" >>${HELPFILE}
 
 ${HELP}/RadixExpansion.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7067 create RadixExpansion.help from \
+	@echo 7074 create RadixExpansion.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"RadixExpansion.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/RadixExpansion.help
@@ -17324,7 +17335,7 @@ ${HELP}/RadixExpansion.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "RadixExpansion (RADIX)" >>${HELPFILE}
 
 ${HELP}/RealClosure.help: ${BOOKS}/bookvol10.3.pamphlet 
-	@echo 7068 create RealClosure.help from ${BOOKS}/bookvol10.3.pamphlet 
+	@echo 7075 create RealClosure.help from ${BOOKS}/bookvol10.3.pamphlet 
 	@${TANGLE} -R"RealClosure.help" ${BOOKS}/bookvol10.3.pamphlet  \
            >${HELP}/RealClosure.help
 	@cp ${HELP}/RealClosure.help ${HELP}/RECLOS.help
@@ -17333,7 +17344,7 @@ ${HELP}/RealClosure.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "RealClosure (RECLOS)" >>${HELPFILE}
 
 ${HELP}/RealSolvePackage.help: ${BOOKS}/bookvol10.4.pamphlet 
-	@echo 7069 create RealSolvePackage.help from \
+	@echo 7076 create RealSolvePackage.help from \
           ${BOOKS}/bookvol10.4.pamphlet 
 	@${TANGLE} -R"RealSolvePackage.help" ${BOOKS}/bookvol10.4.pamphlet  \
            >${HELP}/RealSolvePackage.help
@@ -17343,7 +17354,7 @@ ${HELP}/RealSolvePackage.help: ${BOOKS}/bookvol10.4.pamphlet
 	@echo "RealSolvePackage (REALSOLV)" >>${HELPFILE}
 
 ${HELP}/RegularTriangularSet.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7070 create RegularTriangularSet.help from \
+	@echo 7077 create RegularTriangularSet.help from \
           ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"RegularTriangularSet.help" \
           ${BOOKS}/bookvol10.3.pamphlet \
@@ -17355,7 +17366,7 @@ ${HELP}/RegularTriangularSet.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "RegularTriangularSet (REGSET)" >>${HELPFILE}
 
 ${HELP}/RomanNumeral.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7071 create RomanNumeral.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7078 create RomanNumeral.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"RomanNumeral.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/RomanNumeral.help
 	@cp ${HELP}/RomanNumeral.help ${HELP}/ROMAN.help
@@ -17364,7 +17375,7 @@ ${HELP}/RomanNumeral.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "RomanNumeral (ROMAN)" >>${HELPFILE}
 
 ${HELP}/Segment.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7072 create Segment.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7079 create Segment.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Segment.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Segment.help
 	@cp ${HELP}/Segment.help ${HELP}/SEG.help
@@ -17373,7 +17384,7 @@ ${HELP}/Segment.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Segment (SEG)" >>${HELPFILE}
 
 ${HELP}/SegmentBinding.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7072 create SegmentBinding.help from \
+	@echo 7080 create SegmentBinding.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"SegmentBinding.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/SegmentBinding.help
@@ -17383,7 +17394,7 @@ ${HELP}/SegmentBinding.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "SegmentBinding (SEGBIND)" >>${HELPFILE}
 
 ${HELP}/Set.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7073 create Set.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7081 create Set.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Set.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Set.help
 	@-cp ${HELP}/Set.help ${HELP}/SET.help
@@ -17392,7 +17403,7 @@ ${HELP}/Set.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Set (SET)" >>${HELPFILE}
 
 ${HELP}/SingleInteger.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7074 create SingleInteger.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7082 create SingleInteger.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"SingleInteger.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/SingleInteger.help
 	@cp ${HELP}/SingleInteger.help ${HELP}/SINT.help
@@ -17401,7 +17412,7 @@ ${HELP}/SingleInteger.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "SingleInteger (SINT)" >>${HELPFILE}
 
 ${HELP}/SparseTable.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7075 create SparseTable.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7083 create SparseTable.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"SparseTable.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/SparseTable.help
 	@cp ${HELP}/SparseTable.help ${HELP}/STBL.help
@@ -17410,7 +17421,7 @@ ${HELP}/SparseTable.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "SparseTable (STBL)" >>${HELPFILE}
 
 ${HELP}/SquareMatrix.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7076 create SquareMatrix.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7084 create SquareMatrix.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"SquareMatrix.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/SquareMatrix.help
 	@cp ${HELP}/SquareMatrix.help ${HELP}/SQMATRIX.help
@@ -17419,7 +17430,7 @@ ${HELP}/SquareMatrix.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "SquareMatrix (SQMATRIX)" >>${HELPFILE}
 
 ${HELP}/SquareFreeRegularTriangularSet.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7077 create SquareFreeRegularTriangularSet.help from \
+	@echo 7085 create SquareFreeRegularTriangularSet.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"SquareFreeRegularTriangularSet.help" \
            ${BOOKS}/bookvol10.3.pamphlet \
@@ -17431,7 +17442,7 @@ ${HELP}/SquareFreeRegularTriangularSet.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "SquareFreeRegularTriangularSet (SREGSET)" >>${HELPFILE}
 
 ${HELP}/Stack.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7078 create Stack.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7086 create Stack.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Stack.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Stack.help
 	@-cp ${HELP}/Stack.help ${HELP}/STACK.help
@@ -17440,7 +17451,7 @@ ${HELP}/Stack.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Stack (STACK)" >>${HELPFILE}
 
 ${HELP}/Stream.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7078 create Stream.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7087 create Stream.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Stream.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Stream.help
 	@-cp ${HELP}/Stream.help ${HELP}/STREAM.help
@@ -17449,7 +17460,7 @@ ${HELP}/Stream.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Stream (STREAM)" >>${HELPFILE}
 
 ${HELP}/String.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7079 create String.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7088 create String.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"String.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/String.help
 	@-cp ${HELP}/String.help ${HELP}/STRING.help
@@ -17458,7 +17469,7 @@ ${HELP}/String.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "String (STRING)" >>${HELPFILE}
 
 ${HELP}/StringTable.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7080 create StringTable.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7089 create StringTable.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"StringTable.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/StringTable.help
 	@cp ${HELP}/StringTable.help ${HELP}/STRTBL.help
@@ -17467,7 +17478,7 @@ ${HELP}/StringTable.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "StringTable (STRTBL)" >>${HELPFILE}
 
 ${HELP}/Symbol.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7081 create Symbol.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7090 create Symbol.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Symbol.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Symbol.help
 	@-cp ${HELP}/Symbol.help ${HELP}/SYMBOL.help
@@ -17476,7 +17487,7 @@ ${HELP}/Symbol.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Symbol (SYMBOL)" >>${HELPFILE}
 
 ${HELP}/Table.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7082 create Table.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7091 create Table.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Table.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Table.help
 	@-cp ${HELP}/Table.help ${HELP}/TABLE.help
@@ -17485,7 +17496,7 @@ ${HELP}/Table.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Table (TABLE)" >>${HELPFILE}
 
 ${HELP}/TextFile.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7083 create TextFile.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7092 create TextFile.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"TextFile.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/TextFile.help
 	@-cp ${HELP}/TextFile.help ${HELP}/TEXTFILE.help
@@ -17494,7 +17505,7 @@ ${HELP}/TextFile.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "TextFile (TEXTFILE)" >>${HELPFILE}
 
 ${HELP}/TwoDimensionalArray.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7084 create TwoDimensionalArray.help from \
+	@echo 7093 create TwoDimensionalArray.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"TwoDimensionalArray.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/TwoDimensionalArray.help
@@ -17505,7 +17516,7 @@ ${HELP}/TwoDimensionalArray.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "TwoDimensionalArray (ARRAY2)" >>${HELPFILE}
 
 ${HELP}/TwoDimensionalViewport.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7085 create TwoDimensionalViewport.help from \
+	@echo 7094 create TwoDimensionalViewport.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"TwoDimensionalViewport.help" \
            ${BOOKS}/bookvol10.3.pamphlet \
@@ -17515,7 +17526,7 @@ ${HELP}/TwoDimensionalViewport.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "TwoDimensionalViewport (VIEW2D)" >>${HELPFILE}
 
 ${HELP}/UnivariatePolynomial.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7086 create UnivariatePolynomial.help from \
+	@echo 7095 create UnivariatePolynomial.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"UnivariatePolynomial.help" \
           ${BOOKS}/bookvol10.3.pamphlet \
@@ -17527,7 +17538,7 @@ ${HELP}/UnivariatePolynomial.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "UnivariatePolynomial (UP)" >>${HELPFILE}
 
 ${HELP}/UniversalSegment.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7087 create UniversalSegment.help from \
+	@echo 7096 create UniversalSegment.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"UniversalSegment.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/UniversalSegment.help
@@ -17537,7 +17548,7 @@ ${HELP}/UniversalSegment.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "UniversalSegment (UNISEG)" >>${HELPFILE}
 
 ${HELP}/Vector.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7088 create Vector.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7097 create Vector.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Vector.help" ${BOOKS}/bookvol10.3.pamphlet \
            >${HELP}/Vector.help
 	@-cp ${HELP}/Vector.help ${HELP}/VECTOR.help
@@ -17546,7 +17557,7 @@ ${HELP}/Vector.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Vector (VECTOR)" >>${HELPFILE}
 
 ${HELP}/Void.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7089 create Void.help from ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7098 create Void.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Void.help" ${BOOKS}/bookvol10.3.pamphlet \
             >${HELP}/Void.help
 	@-cp ${HELP}/Void.help ${HELP}/VOID.help
@@ -17555,7 +17566,7 @@ ${HELP}/Void.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "Void (VOID)" >>${HELPFILE}
 
 ${HELP}/WuWenTsunTriangularSet.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7090 create WuWenTsunTriangularSet.help from \
+	@echo 7099 create WuWenTsunTriangularSet.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"WuWenTsunTriangularSet.help" \
            ${BOOKS}/bookvol10.3.pamphlet \
@@ -17567,7 +17578,7 @@ ${HELP}/WuWenTsunTriangularSet.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "WuWenTsunTriangularSet (WUTSET)" >>${HELPFILE}
 
 ${HELP}/XPBWPolynomial.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7091 create XPBWPolynomial.help from \
+	@echo 7100 create XPBWPolynomial.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"XPBWPolynomial.help" \
            ${BOOKS}/bookvol10.3.pamphlet \
@@ -17579,7 +17590,7 @@ ${HELP}/XPBWPolynomial.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "XPBWPolynomial (XPBWPOLY)" >>${HELPFILE}
 
 ${HELP}/XPolynomial.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7092 create XPolynomial.help from \
+	@echo 7101 create XPolynomial.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"XPolynomial.help"  \
            ${BOOKS}/bookvol10.3.pamphlet \
@@ -17591,7 +17602,7 @@ ${HELP}/XPolynomial.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "XPolynomial (XPOLY)" >>${HELPFILE}
 
 ${HELP}/XPolynomialRing.help: ${BOOKS}/bookvol10.3.pamphlet
-	@echo 7093 create XPolynomialRing.help from \
+	@echo 7102 create XPolynomialRing.help from \
            ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"XPolynomialRing.help" \
            ${BOOKS}/bookvol10.3.pamphlet \
@@ -17603,7 +17614,7 @@ ${HELP}/XPolynomialRing.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo "XPolynomialRing (XPR)" >>${HELPFILE}
 
 ${HELP}/ZeroDimensionalSolvePackage.help: ${BOOKS}/bookvol10.4.pamphlet
-	@echo 7094 create ZeroDimensionalSolvePackage.help from \
+	@echo 7103 create ZeroDimensionalSolvePackage.help from \
            ${BOOKS}/bookvol10.4.pamphlet
 	@${TANGLE} -R"ZeroDimensionalSolvePackage.help" \
            ${BOOKS}/bookvol10.4.pamphlet \
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 0ed5c8f..564aaaf 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -963,5 +963,7 @@ bookvol10.2 add documentation<br/>
 bookvol10.3 add regression, help, examples for ArrayStack<br/>
 <a href="patches/20090223.01.tpd.patch">20090223.01.tpd.patch</a>
 bookvol10.3 add regression, help, examples for Queue<br/>
+<a href="patches/20090224.01.tpd.patch">20090224.01.tpd.patch</a>
+bookvol10.3 add regression, help, examples for Dequeue<br/>
  </body>
 </html>



From MAILER-DAEMON Tue Feb 24 12:43:17 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lc1JN-0003Of-Nz
	for mharc-axiom-developer@gnu.org; Tue, 24 Feb 2009 12:43:17 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lc1JL-0003NM-Qw
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:43:15 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lc1JI-0003Kk-C5
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:43:14 -0500
Received: from [199.232.76.173] (port=41458 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lc1JI-0003KZ-76
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:43:12 -0500
Received: from mx-7.zoominternet.net ([24.154.1.26]:57297
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Lc1JH-0002Aj-UH
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:43:12 -0500
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=un-WU1JydrZsmtlY0tgA:9 a=xDE2cUhHmqY2FUmsW-yU6ajEqmQA:4
	a=ghpsziEcTmYA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.44] ([24.154.1.44:58405] helo=pop-1.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 9D/42-13570-E9134A94; Tue, 24 Feb 2009 12:42:54 -0500
Received: (qmail 5772 invoked from network); 24 Feb 2009 17:42:59 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-1.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 24 Feb 2009 17:42:59 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n1OIT1d24836;
	Tue, 24 Feb 2009 13:29:01 -0500
Date: Tue, 24 Feb 2009 13:29:01 -0500
Message-Id: <200902241829.n1OIT1d24836@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: camm@maguirefamily.org
In-reply-to: <87skm34tyf.fsf_-_@maguirefamily.org> (message from Camm Maguire
	on Tue, 24 Feb 2009 12:37:28 -0500)
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
	<87skm34tyf.fsf_-_@maguirefamily.org>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Howto enable lisp break
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 24 Feb 2009 17:43:16 -0000

)set break break 

will cause Axiom to drop into a lisp break loop rather than returning
to the top level.



From MAILER-DAEMON Tue Feb 24 12:44:13 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lc1KG-0003un-Ve
	for mharc-axiom-developer@gnu.org; Tue, 24 Feb 2009 12:44:13 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lc1KF-0003to-Oq
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:44:11 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lc1KE-0003sU-C0
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:44:11 -0500
Received: from [199.232.76.173] (port=38715 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lc1KE-0003sR-5k
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:44:10 -0500
Received: from mx-8.zoominternet.net ([24.154.1.27]:45431
	helo=cm-2.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Lc1KD-0002IG-SM
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 12:44:09 -0500
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=BGWtflarwu46sGWnLuAA:9 a=Al1uF7iOWf54vhdTwy4KNLavnJUA:4
	a=XF7b4UCPwd8A:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.47] ([24.154.1.47:34784] helo=pop-4.zoominternet.net)
	by mx-8.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 82/AD-09796-AD134A94; Tue, 24 Feb 2009 12:43:54 -0500
Received: (qmail 907 invoked from network); 24 Feb 2009 17:43:57 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-4.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 24 Feb 2009 17:43:57 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n1OITxN24840;
	Tue, 24 Feb 2009 13:29:59 -0500
Date: Tue, 24 Feb 2009 13:29:59 -0500
Message-Id: <200902241829.n1OITxN24840@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: camm@maguirefamily.org
In-reply-to: <87skm34tyf.fsf_-_@maguirefamily.org> (message from Camm Maguire
	on Tue, 24 Feb 2009 12:37:28 -0500)
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
	<87skm34tyf.fsf_-_@maguirefamily.org>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Howto enable lisp break
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 24 Feb 2009 17:44:11 -0000

The key place where I'm finding build problems is on OSX 10.4
Do you know what is required to get GCL to build there?

Tim



From MAILER-DAEMON Tue Feb 24 13:43:15 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lc2FO-0006BN-Va
	for mharc-axiom-developer@gnu.org; Tue, 24 Feb 2009 13:43:15 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lc2FM-0006AL-Pu
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 13:43:12 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lc2FK-00069U-V7
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 13:43:12 -0500
Received: from [199.232.76.173] (port=58007 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43)
	id 1Lc2FK-00069K-Kh; Tue, 24 Feb 2009 13:43:10 -0500
Received: from tvwna-ip-b-35.princeton.org ([66.180.185.126]:56551
	helo=localhost.princeton.org)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <camm@maguirefamily.org>)
	id 1Lc2FI-0005mB-Kj; Tue, 24 Feb 2009 13:43:10 -0500
Received: from camm by localhost.princeton.org with local (Exim 4.69)
	(envelope-from <camm@maguirefamily.org>)
	id 1Lc2Ew-0003TK-FG; Tue, 24 Feb 2009 13:42:46 -0500
To: daly@axiom-developer.org
From: Camm Maguire <camm@maguirefamily.org>
Date: Tue, 24 Feb 2009 13:42:46 -0500
In-Reply-To: <200902232250.n1NMoBR23993@localhost.localdomain> (root's message
	of "Mon\, 23 Feb 2009 17\:50\:11 -0500")
Message-ID: <87wsbf3cd5.fsf_-_@maguirefamily.org>
User-Agent: Gnus/5.11 (Gnus v5.11) Emacs/22.2 (gnu/linux)
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org, gcl-devel@gnu.org
Subject: [Axiom-developer] Debian axiom build failures
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 24 Feb 2009 18:43:13 -0000

Greetings!  It appears we have two

1) sparc only mprotect failure to reliably trigger segfaults on
writing to read-only pages.  Will disable sgc on sparc until this is
fixed.

2) several others with the same error below.  Can you offer advise
here?  I take it the macro table is not supposed to be in place yet,
and this warning is supposed to appear.  I have this error setup on a
Debian machine, so any suggestions can be tested.  Again, please post
to the list as I am not at home.



)co REPSQ.spad
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/apply.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/c-doc.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/c-util.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/profile.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/category.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/compiler.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/define.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/functor.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/info.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/iterator.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/modemap.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/nruncomp.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/package.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/htcheck.
Warning: macro table not found
   Compiling AXIOM source code from file REPSQ.spad using old system 
      compiler.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/parsing.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/bootlex.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/def.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/fnewmeta.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/metalex.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/parse.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/postpar.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/postprop.
   Loading /home/camm/axiom-20081101/mnt/linux/autoload/preparse.
   No option begins with (|package| (repsq |repeatedsquaring|)) .
 
   >> System error:
   The function |boot| is undefined.

(1) -> 

Take care,
-- 
Camm Maguire			     		    camm@maguirefamily.org
==========================================================================
"The earth is but one country, and mankind its citizens."  --  Baha'u'llah



From MAILER-DAEMON Tue Feb 24 17:35:30 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lc5sA-0006c9-O4
	for mharc-axiom-developer@gnu.org; Tue, 24 Feb 2009 17:35:30 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lc5s8-0006at-Fg
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 17:35:28 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lc5s6-0006Zy-J2
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 17:35:27 -0500
Received: from [199.232.76.173] (port=43314 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lc5s6-0006Zu-CY
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 17:35:26 -0500
Received: from mx-7.zoominternet.net ([24.154.1.26]:33086
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Lc5s5-0001AW-Hv
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 17:35:26 -0500
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=J-d--svQD2Bn2ag2SwsA:9 a=HKhPUaL4Mp24sbRMKD3rFwDDIy4A:4
	a=8b0TY1xhFYQA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.45] ([24.154.1.45:47967] helo=pop-2.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 7C/94-13570-92674A94; Tue, 24 Feb 2009 17:35:21 -0500
Received: (qmail 12733 invoked from network); 24 Feb 2009 22:35:22 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-2.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 24 Feb 2009 22:35:22 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n1ONLAd24972;
	Tue, 24 Feb 2009 18:21:10 -0500
Date: Tue, 24 Feb 2009 18:21:10 -0500
Message-Id: <200902242321.n1ONLAd24972@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: camm@maguirefamily.org
In-reply-to: <87wsbf3cd5.fsf_-_@maguirefamily.org> (message from Camm Maguire
	on Tue, 24 Feb 2009 13:42:46 -0500)
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
	<87wsbf3cd5.fsf_-_@maguirefamily.org>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org, gcl-devel@gnu.org
Subject: [Axiom-developer] Re: Debian axiom build failures
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 24 Feb 2009 22:35:28 -0000

Camm,

>   Loading /home/camm/axiom-20081101/mnt/linux/autoload/htcheck.
>Warning: macro table not found

What sources are you using? This bug was fixed a while ago.

Tim




From MAILER-DAEMON Tue Feb 24 20:54:17 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lc8yW-0006uD-Uj
	for mharc-axiom-developer@gnu.org; Tue, 24 Feb 2009 20:54:16 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lc8yV-0006rS-BD
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 20:54:15 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lc8yT-0006nt-6N
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 20:54:14 -0500
Received: from [199.232.76.173] (port=40839 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lc8yT-0006nb-17
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 20:54:13 -0500
Received: from mail10.dslextreme.com ([66.51.199.98]:56691)
	by monty-python.gnu.org with smtp (Exim 4.60)
	(envelope-from <camm@maguirefamily.org>) id 1Lc8yS-0006WV-FV
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 20:54:12 -0500
Received: (qmail 12651 invoked from network); 25 Feb 2009 01:53:49 -0000
Received: from unknown (HELO wisdom.m.enhanced.com) (141.150.251.63)
	by mail10.dslextreme.com with (AES256-SHA encrypted) SMTP;
	Tue, 24 Feb 2009 17:53:49 -0800
Received: from love.m.enhanced.com ([192.168.3.9] helo=localhost)
	by wisdom.m.enhanced.com with esmtp (Exim 4.63)
	(envelope-from <camm@maguirefamily.org>) id 1Lc8xn-0006PQ-5e
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 20:53:31 -0500
Received: from camm by localhost.princeton.org with local (Exim 4.69)
	(envelope-from <camm@maguirefamily.org>)
	id 1Lc7M6-0007Sr-Ap; Tue, 24 Feb 2009 19:10:30 -0500
To: daly@axiom-developer.org
From: Camm Maguire <camm@maguirefamily.org>
Date: Tue, 24 Feb 2009 19:10:30 -0500
In-Reply-To: <200902232250.n1NMoBR23993@localhost.localdomain> (root's message
	of "Mon\, 23 Feb 2009 17\:50\:11 -0500")
Message-ID: <87skm32x6x.fsf_-_@maguirefamily.org>
User-Agent: Gnus/5.11 (Gnus v5.11) Emacs/22.2 (gnu/linux)
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6 (newer, 3)
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Debian axiom build failures
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 25 Feb 2009 01:54:15 -0000

Greetings!  I'm using the gold sources, nov 2008.

Thanks so much!
-- 
Camm Maguire			     		    camm@maguirefamily.org
==========================================================================
"The earth is but one country, and mankind its citizens."  --  Baha'u'llah



From MAILER-DAEMON Tue Feb 24 22:09:45 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LcA9Z-0003ui-8N
	for mharc-axiom-developer@gnu.org; Tue, 24 Feb 2009 22:09:45 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LcA9X-0003u1-Gk
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 22:09:43 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LcA9W-0003tB-Jx
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 22:09:43 -0500
Received: from [199.232.76.173] (port=59408 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LcA9W-0003t3-EK
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 22:09:42 -0500
Received: from mx-8.zoominternet.net ([24.154.1.27]:49376
	helo=cm-2.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LcA9W-0006in-4l
	for axiom-developer@nongnu.org; Tue, 24 Feb 2009 22:09:42 -0500
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=-AcZthU2CKQz1FXQiMcA:9 a=uFxVlRnfwX2sjQAo0po-iw2-2JoA:4
	a=XF7b4UCPwd8A:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.46] ([24.154.1.46:38046] helo=pop-3.zoominternet.net)
	by mx-8.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id B5/32-09796-D66B4A94; Tue, 24 Feb 2009 22:09:33 -0500
Received: (qmail 23276 invoked from network); 25 Feb 2009 03:09:34 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-3.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 25 Feb 2009 03:09:34 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n1P3tQm25134;
	Tue, 24 Feb 2009 22:55:26 -0500
Date: Tue, 24 Feb 2009 22:55:26 -0500
Message-Id: <200902250355.n1P3tQm25134@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: camm@maguirefamily.org
In-reply-to: <87skm32x6x.fsf_-_@maguirefamily.org> (message from Camm Maguire
	on Tue, 24 Feb 2009 19:10:30 -0500)
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
	<87skm32x6x.fsf_-_@maguirefamily.org>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Debian axiom build failures
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 25 Feb 2009 03:09:43 -0000

Thoses gold sources certainly compile on other platforms so I'm not sure
the failure lives in the Axiom source code.

What version of GCL are you using? (See the top level Makefile and search
for GCLVERSION

Some platforms are sensitive to the version used.

There are 4 version, the gcl 2.6.7, gcl2.6.8pre, gcl2.6.8pre2, and
gcl2.6.8pre3

The "pre" versions are various snapshots of gcl2.6.8pre over time.
Some platforms require one version, others require a different one.

Tim



From MAILER-DAEMON Wed Feb 25 10:32:02 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LcLju-00057U-7r
	for mharc-axiom-developer@gnu.org; Wed, 25 Feb 2009 10:32:02 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LcLjs-00055Y-I6
	for axiom-developer@nongnu.org; Wed, 25 Feb 2009 10:32:00 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LcLjr-00053n-39
	for axiom-developer@nongnu.org; Wed, 25 Feb 2009 10:31:59 -0500
Received: from [199.232.76.173] (port=38396 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LcLjq-00053d-Qi
	for axiom-developer@nongnu.org; Wed, 25 Feb 2009 10:31:58 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:45983
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LcLjq-0006jo-8R
	for axiom-developer@nongnu.org; Wed, 25 Feb 2009 10:31:58 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1PFVuug027677;
	Wed, 25 Feb 2009 09:31:56 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1PFVrb3027665;
	Wed, 25 Feb 2009 09:31:53 -0600
Date: Wed, 25 Feb 2009 09:31:53 -0600
Message-Id: <200902251531.n1PFVrb3027665@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090225.01.tpd.patch (bookvol10.3 Add .... Heap
	documentation)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 25 Feb 2009 15:32:00 -0000

Add regression tests for Heap.
Update help page for Heap.
Add Examples for Heap.

======================================================================
diff --git a/books/bookvol10.3.pamphlet b/books/bookvol10.3.pamphlet
index bff1070..69c7c2e 100644
--- a/books/bookvol10.3.pamphlet
+++ b/books/bookvol10.3.pamphlet
@@ -41392,74 +41392,387 @@ HashTable(Key, Entry, hashfn): Exports == Implementation where
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{domain HEAP Heap}
 <<Heap.input>>=
--- bags.spad.pamphlet Heap.input
 )sys rm -f Heap.output
 )spool Heap.output
 )set message test on
 )set message auto off
 )clear all
---S 1 of 8
-h := heap [-4,9,11,2,7,-7]
+
+--S 1 of 42
+a:Heap INT:= heap [1,2,3,4,5]
 --R 
 --R
---R   (1)  [11,7,9,- 4,2,- 7]
+--R   (1)  [5,4,2,1,3]
 --R                                                           Type: Heap Integer
 --E 1
 
---S 2 of 8
-insert!(3,h)
+--S 2 of 42
+bag([1,2,3,4,5])$Heap(INT)
 --R 
 --R
---R   (2)  [11,7,9,- 4,2,- 7,3]
+--R   (2)  [5,4,3,1,2]
 --R                                                           Type: Heap Integer
 --E 2
 
---S 3 of 8
-extract! h
+--S 3 of 42
+c:=copy a
 --R 
 --R
---R   (3)  11
---R                                                        Type: PositiveInteger
+--R   (3)  [5,4,2,1,3]
+--R                                                           Type: Heap Integer
 --E 3
 
---S 4 of 8
-h
+--S 4 of 42
+empty? a
 --R 
 --R
---R   (4)  [9,7,3,- 4,2,- 7]
---R                                                           Type: Heap Integer
+--R   (4)  false
+--R                                                                Type: Boolean
 --E 4
 
---S 5 of 8
+--S 5 of 42
+b:=empty()$(Heap INT)
+--R 
+--R
+--R   (5)  []
+--R                                                           Type: Heap Integer
+--E 5
+
+--S 6 of 42
+empty? b
+--R 
+--R
+--R   (6)  true
+--R                                                                Type: Boolean
+--E 6
+
+--S 7 of 42
+eq?(a,c)
+--R 
+--R
+--R   (7)  false
+--R                                                                Type: Boolean
+--E 7
+
+--S 8 of 42
+extract! a
+--R 
+--R
+--R   (8)  5
+--R                                                        Type: PositiveInteger
+--E 8
+
+--S 8 of 42
+h:=heap [17,-4,9,-11,2,7,-7]
+--R 
+--R
+--R   (9)  [17,2,9,- 11,- 4,7,- 7]
+--R                                                           Type: Heap Integer
+--E 8
+
+--S 9 of 42
 [extract!(h) while not empty?(h)]
 --R 
 --R
---R   (5)  [9,7,3,2,- 4,- 7]
+--R   (10)  [17,9,7,2,- 4,- 7,- 11]
 --R                                                           Type: List Integer
---E 5
+--E 9
 
---S 6 of 8
+--S 10 of 42
 heapsort(x) == (empty? x => []; cons(extract!(x),heapsort x))
 --R 
 --R                                                                   Type: Void
---E 6
+--E 10
 
---S 7 of 8
-h1 := heap [17,-4,9,-11,2,7,-7]
+--S 11 of 42
+h1 := heapsort heap [17,-4,9,-11,2,7,-7]
+--R 
+--R   Compiling function heapsort with type Heap Integer -> List Integer 
+--R
+--R   (12)  [17,9,7,2,- 4,- 7,- 11]
+--R                                                           Type: List Integer
+--E 11
+
+--S 12 of 42
+(a=c)@Boolean
+--R 
+--R
+--R   (13)  false
+--R                                                                Type: Boolean
+--E 12
+
+--S 13 of 42
+(a~=c)
+--R 
+--R
+--R   (14)  true
+--R                                                                Type: Boolean
+--E 13
+
+--S 14 of 42
+a
 --R 
 --R
---R   (7)  [17,2,9,- 11,- 4,7,- 7]
+--R   (15)  [4,3,2,1]
 --R                                                           Type: Heap Integer
---E 7
+--E 14
 
---S 8 of 8
-heapsort h1
+--S 15 of 42
+inspect a
+--R 
+--R
+--R   (16)  4
+--R                                                        Type: PositiveInteger
+--E 15
+
+--S 16 of 42
+insert!(9,a)
+--R 
+--R
+--R   (17)  [9,4,2,1,3]
+--R                                                           Type: Heap Integer
+--E 16
+
+--S 17 of 42
+map(x+->x+10,a)
+--R 
+--R
+--R   (18)  [19,14,12,11,13]
+--R                                                           Type: Heap Integer
+--E 17
+
+--S 18 of 42
+a
+--R 
+--R
+--R   (19)  [9,4,2,1,3]
+--R                                                           Type: Heap Integer
+--E 18
+
+--S 19 of 42
+map!(x+->x+10,a)
+--R 
+--R
+--R   (20)  [19,14,12,11,13]
+--R                                                           Type: Heap Integer
+--E 19
+
+--S 20 of 42
+a
 --R 
---R   Compiling function heapsort with type Heap Integer -> List Integer 
 --R
---R   (8)  [17,9,7,2,- 4,- 7,- 11]
+--R   (21)  [19,14,12,11,13]
+--R                                                           Type: Heap Integer
+--E 20
+
+--S 21 of 42
+max a
+--R 
+--R
+--R   (22)  19
+--R                                                        Type: PositiveInteger
+--E 21
+
+--S 22 of 42
+merge(a,c)
+--R 
+--R
+--R   (23)  [19,14,12,11,13,5,4,2,1,3]
+--R                                                           Type: Heap Integer
+--E 22
+
+--S 23 of 42
+a
+--R 
+--R
+--R   (24)  [19,14,12,11,13]
+--R                                                           Type: Heap Integer
+--E 23
+
+--S 24 of 42
+merge!(a,c)
+--R 
+--R
+--R   (25)  [19,14,12,11,13,5,4,2,1,3]
+--R                                                           Type: Heap Integer
+--E 24
+
+--S 25 of 42
+a
+--R 
+--R
+--R   (26)  [19,14,12,11,13,5,4,2,1,3]
+--R                                                           Type: Heap Integer
+--E 25
+
+--S 26 of 42
+c
+--R 
+--R
+--R   (27)  [5,4,2,1,3]
+--R                                                           Type: Heap Integer
+--E 26
+
+--S 27 of 42
+sample()$Heap(INT)
+--R 
+--R
+--R   (28)  []
+--R                                                           Type: Heap Integer
+--E 27
+
+--S 28 of 42
+#a
+--R 
+--R
+--R   (29)  10
+--R                                                        Type: PositiveInteger
+--E 28
+
+--S 29 of 42
+any?(x+->(x=14),a)
+--R 
+--R
+--R   (30)  true
+--R                                                                Type: Boolean
+--E 29
+
+--S 30 of 42
+every?(x+->(x=11),a)
+--R 
+--R
+--R   (31)  false
+--R                                                                Type: Boolean
+--E 30
+
+--S 31 of 42
+parts a
+--R 
+--R
+--R   (32)  [19,14,12,11,13,5,4,2,1,3]
 --R                                                           Type: List Integer
---E 8
+--E 31
+
+--S 32 of 42
+size?(a,9)
+--R 
+--R
+--R   (33)  false
+--R                                                                Type: Boolean
+--E 32
+
+--S 33 of 42
+more?(a,9)
+--R 
+--R
+--R   (34)  true
+--R                                                                Type: Boolean
+--E 33
+
+--S 34 of 42
+less?(a,9)
+--R 
+--R
+--R   (35)  false
+--R                                                                Type: Boolean
+--E 34
+
+--S 35 of 42
+members a
+--R 
+--R
+--R   (36)  [19,14,12,11,13,5,4,2,1,3]
+--R                                                           Type: List Integer
+--E 35
+
+--S 36 of 42
+member?(14,a)
+--R 
+--R
+--R   (37)  true
+--R                                                                Type: Boolean
+--E 36
+
+--S 37 of 42
+latex a
+--R 
+--R
+--R   (38)  "\mbox{\bf Unimplemented}"
+--R                                                                 Type: String
+--E 37
+
+--S 38 of 42
+hash a
+--R 
+--R
+--R   (39)  0
+--R                                                          Type: SingleInteger
+--E 38
+
+--S 39 of 42
+count(14,a)
+--R 
+--R
+--R   (40)  1
+--R                                                        Type: PositiveInteger
+--E 39
+
+--S 40 of 42
+count(x+->(x>13),a)
+--R 
+--R
+--R   (41)  2
+--R                                                        Type: PositiveInteger
+--E 40
+
+--S 41 of 42
+coerce a
+--R 
+--R
+--R   (42)  [19,14,12,11,13,5,4,2,1,3]
+--R                                                             Type: OutputForm
+--E 41
+
+--S 42 of 42
+)show Heap
+--R 
+--R Heap S: OrderedSet  is a domain constructor
+--R Abbreviation for Heap is HEAP 
+--R This constructor is exposed in this frame.
+--R Issue )edit bookvol10.3.spad.pamphlet to see algebra source code for HEAP 
+--R
+--R------------------------------- Operations --------------------------------
+--R bag : List S -> %                     copy : % -> %
+--R empty : () -> %                       empty? : % -> Boolean
+--R eq? : (%,%) -> Boolean                extract! : % -> S
+--R heap : List S -> %                    insert! : (S,%) -> %
+--R inspect : % -> S                      map : ((S -> S),%) -> %
+--R max : % -> S                          merge : (%,%) -> %
+--R merge! : (%,%) -> %                   sample : () -> %
+--R #? : % -> NonNegativeInteger if $ has finiteAggregate
+--R ?=? : (%,%) -> Boolean if S has SETCAT
+--R any? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
+--R coerce : % -> OutputForm if S has SETCAT
+--R count : (S,%) -> NonNegativeInteger if $ has finiteAggregate and S has SETCAT
+--R count : ((S -> Boolean),%) -> NonNegativeInteger if $ has finiteAggregate
+--R eval : (%,List S,List S) -> % if S has EVALAB S and S has SETCAT
+--R eval : (%,S,S) -> % if S has EVALAB S and S has SETCAT
+--R eval : (%,Equation S) -> % if S has EVALAB S and S has SETCAT
+--R eval : (%,List Equation S) -> % if S has EVALAB S and S has SETCAT
+--R every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
+--R hash : % -> SingleInteger if S has SETCAT
+--R latex : % -> String if S has SETCAT
+--R less? : (%,NonNegativeInteger) -> Boolean
+--R map! : ((S -> S),%) -> % if $ has shallowlyMutable
+--R member? : (S,%) -> Boolean if $ has finiteAggregate and S has SETCAT
+--R members : % -> List S if $ has finiteAggregate
+--R more? : (%,NonNegativeInteger) -> Boolean
+--R parts : % -> List S if $ has finiteAggregate
+--R size? : (%,NonNegativeInteger) -> Boolean
+--R ?~=? : (%,%) -> Boolean if S has SETCAT
+--R
+--E 42
+
 )spool
 )lisp (bye)
 @
@@ -41474,29 +41787,45 @@ element.  The implementation represents heaps as flexible arrays The
 representation and algorithms give complexity of O(log(n)) for
 insertion and extractions, and O(n) for construction.
 
-Create a heap of six elements.
+Create a heap of five elements:
 
-  h := heap [-4,9,11,2,7,-7]
-    [11,7,9,- 4,2,- 7]
-                      Type: Heap Integer
+   a:Heap INT:= heap [1,2,3,4,5]
+        [5,4,2,1,3]
 
-Use insert! to add an element.
+Use bag to convert a Bag into a Heap:
 
-  insert!(3,h)
-    [11,7,9,- 4,2,- 7,3]
-                      Type: Heap Integer
+   bag([1,2,3,4,5])$Heap(INT)
+        [5,4,3,1,2]
 
-The operation extract! removes and returns the maximum element.
+The operation copy can be used to copy a Heap:
 
-  extract! h
-    11
-                      Type: PositiveInteger
+   c:=copy a
+        [5,4,2,1,3]
 
-The internal structure of h has been appropriately adjusted.
+Use empty? to check if the heap is empty:
 
-  h
-    [9,7,3,- 4,2,- 7]
-                      Type: Heap Integer
+   empty? a
+        false
+
+Use empty to create a new, empty heap:
+ 
+   b:=empty()$(Heap INT)
+        []
+
+and we can see that the newly created heap is empty:
+
+   empty? b
+        true
+
+The eq? function compares the reference of one heap to another:
+
+   eq?(a,c)
+        false
+
+The extract! function removes largest element of the heap:
+
+   extract! a
+        5
 
 Now extract! elements repeatedly until none are left, collecting
 the elements in a list.
@@ -41522,9 +41851,151 @@ Apply heapsort to present elements in order.
     [17,9,7,2,- 4,- 7,- 11]
                       Type: List Integer
 
+Heaps can be compared with =
+
+   (a=c)@Boolean
+        false
+
+and ~=
+
+   (a~=c)
+       true
+
+The inspect function shows the largest element in the heap:
+
+   inspect a
+       4
+
+The insert! function adds an element to the heap:
+
+   insert!(9,a)
+       [9,4,2,1,3]
+
+The map function applies a function to every element of the heap
+and returns a new heap:
+
+   map(x+->x+10,a)
+       [19,14,12,11,13]
+
+The original heap is unchanged:
+
+   a
+       [9,4,2,1,3]
+
+The map! function applies a function to every element of the heap
+and returns the original heap with modifications:
+
+   map!(x+->x+10,a)
+       [19,14,12,11,13]
+
+The original heap has been modified:
+
+   a
+       [19,14,12,11,13]
+
+The max function returns the largest element in the heap:
+
+   max a
+       19
+
+The merge function takes two heaps and creates a new heap with
+all of the elements:
+
+   merge(a,c)
+       [19,14,12,11,13,5,4,2,1,3]
+
+Notice that the original heap is unchanged:
+
+   a
+       [19,14,12,11,13]
+
+The merge! function takes two heaps and modifies the first heap
+argument to contain all of the elements:
+
+   merge!(a,c)
+       [19,14,12,11,13,5,4,2,1,3]
+
+Notice that the first argument was modified:
+
+   a
+       [19,14,12,11,13,5,4,2,1,3]
+
+but the second argument was not:
+
+   c
+       [5,4,2,1,3]
+
+A new, empty heap can be created with sample:
+
+   sample()$Heap(INT)
+       []
+
+The # function gives the size of the heap:
+
+   #a
+       10 
+
+The any? function tests each element against a predicate function
+and returns true if any pass:
+
+   any?(x+->(x=14),a)
+       true
+
+The every? function tests each element against a predicate function
+and returns true if they all pass:
+
+   every?(x+->(x=11),a)
+       false
+
+The parts function returns a list of the elements in the heap:
+
+   parts a
+       [19,14,12,11,13,5,4,2,1,3]
+
+The size? predicate compares the size of the heap to a value:
+
+   size?(a,9)
+       false
+
+The more? predicate asks if the heap size is larger than a value:
+
+   more?(a,9)
+       true
+
+The less? predicate asks if the heap size is smaller than a value:
+
+   less?(a,9)
+       false
+
+The members function returns a list of the elements of the heap:
+
+   members a
+       [19,14,12,11,13,5,4,2,1,3]
+
+The member? predicate asks if an element is in the heap:
+
+   member?(14,a)
+       true
+
+The count function has two forms, one of which counts the number
+of copies of an element in the heap:
+
+   count(14,a)
+       1
+
+The second form of the count function accepts a predicate to test
+against each member of the heap and counts the number of true results:
+
+   count(x+->(x>13),a)
+       2
+
 See Also:
-o )help FlexibleArray
+o )show Stack
+o )show ArrayStack
+o )show Queue
+o )show Dequeue
 o )show Heap
+o )show BagAggregate
 
 @
 \pagehead{Heap}{HEAP}
@@ -41596,6 +42067,141 @@ Heap(S:OrderedSet): Exports == Implementation where
       ++
       ++E i:Heap INT := heap [1,6,3,7,5,2,4]
 
+ -- Inherited Signatures repeated for examples documentation
+
+    bag : List S -> %
+      ++
+      ++X bag([1,2,3,4,5])$Heap(INT)
+    copy : % -> %
+      ++
+      ++X a:Heap INT:= heap [1,2,3,4,5]
+      ++X copy a
+    empty? : % -> Boolean
+      ++
+      ++X a:Heap INT:= heap [1,2,3,4,5]
+      ++X empty? a
+    empty : () -> %
+      ++
+      ++X b:=empty()$(Heap INT)
+    eq? : (%,%) -> Boolean
+      ++
+      ++X a:Heap INT:= heap [1,2,3,4,5]
+      ++X b:=copy a
+      ++X eq?(a,b)
+    extract_! : % -> S
+      ++
+      ++X a:Heap INT:= heap [1,2,3,4,5]
+      ++X extract! a
+      ++X a
+    insert_! : (S,%) -> %
+      ++
+      ++X a:Heap INT:= heap [1,2,3,4,5]
+      ++X insert!(8,a)
+      ++X a
+    inspect : % -> S
+      ++
+      ++X a:Heap INT:= heap [1,2,3,4,5]
+      ++X inspect a
+    map :  ((S -> S),%) -> %
+      ++
+      ++X a:Heap INT:= heap [1,2,3,4,5]
+      ++X map(x+->x+10,a)
+      ++X a
+    max : % -> S
+      ++
+      ++X a:Heap INT:= heap [1,2,3,4,5]
+      ++X max a
+    merge : (%,%) -> %
+      ++
+      ++X a:Heap INT:= heap [1,2,3,4,5]
+      ++X b:Heap INT:= heap [6,7,8,9,10]
+      ++X merge(a,b)
+    merge! : (%,%) -> %
+      ++
+      ++X a:Heap INT:= heap [1,2,3,4,5]
+      ++X b:Heap INT:= heap [6,7,8,9,10]
+      ++X merge!(a,b)
+      ++X a
+      ++X b
+    sample : () -> %
+      ++
+      ++X sample()$Heap(INT)
+    less? : (%,NonNegativeInteger) -> Boolean
+      ++
+      ++X a:Heap INT:= heap [1,2,3,4,5]
+      ++X less?(a,9)
+    more? : (%,NonNegativeInteger) -> Boolean
+      ++
+      ++X a:Heap INT:= heap [1,2,3,4,5]
+      ++X more?(a,9)
+    size? : (%,NonNegativeInteger) -> Boolean
+      ++
+      ++X a:Heap INT:= heap [1,2,3,4,5]
+      ++X size?(a,5)
+    if $ has shallowlyMutable then
+      map! :  ((S -> S),%) -> %
+        ++
+        ++X a:Heap INT:= heap [1,2,3,4,5]
+        ++X map!(x+->x+10,a)
+        ++X a
+    if S has SetCategory then
+      latex : % -> String
+        ++
+        ++X a:Heap INT:= heap [1,2,3,4,5]
+        ++X latex a
+      hash : % -> SingleInteger
+        ++
+        ++X a:Heap INT:= heap [1,2,3,4,5]
+        ++X hash a
+      coerce : % -> OutputForm
+        ++
+        ++X a:Heap INT:= heap [1,2,3,4,5]
+        ++X coerce a
+      "=": (%,%) -> Boolean
+        ++
+        ++X a:Heap INT:= heap [1,2,3,4,5]
+        ++X b:Heap INT:= heap [1,2,3,4,5]
+        ++X (a=b)@Boolean
+      "~=" : (%,%) -> Boolean
+        ++
+        ++X a:Heap INT:= heap [1,2,3,4,5]
+        ++X b:=copy a
+        ++X (a~=b)
+    if % has finiteAggregate then
+      every? : ((S -> Boolean),%) -> Boolean
+        ++
+        ++X a:Heap INT:= heap [1,2,3,4,5]
+        ++X every?(x+->(x=4),a)
+      any? : ((S -> Boolean),%) -> Boolean
+        ++
+        ++X a:Heap INT:= heap [1,2,3,4,5]
+        ++X any?(x+->(x=4),a)
+      count :  ((S -> Boolean),%) -> NonNegativeInteger
+        ++
+        ++X a:Heap INT:= heap [1,2,3,4,5]
+        ++X count(x+->(x>2),a)
+      _# : % -> NonNegativeInteger
+        ++
+        ++X a:Heap INT:= heap [1,2,3,4,5]
+        ++X #a
+      parts : % -> List S
+        ++
+        ++X a:Heap INT:= heap [1,2,3,4,5]
+        ++X parts a
+      members : % -> List S
+        ++
+        ++X a:Heap INT:= heap [1,2,3,4,5]
+        ++X members a
+    if % has finiteAggregate and S has SetCategory then
+      member? : (S,%) -> Boolean
+        ++
+        ++X a:Heap INT:= heap [1,2,3,4,5]
+        ++X member?(3,a)
+      count : (S,%) -> NonNegativeInteger
+        ++
+        ++X a:Heap INT:= heap [1,2,3,4,5]
+        ++X count(4,a)
+
   Implementation == IndexedFlexibleArray(S,0) add
     Rep := IndexedFlexibleArray( S,0)
     empty() == empty()$Rep
diff --git a/changelog b/changelog
index ec8432f..b994693 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,6 @@
+20090225 tpd src/axiom-website/patches.html 20090225.01.tpd.patch
+20090225 tpd src/interp/Makefile add regression, help for Heap
+20090225 tpd books/bookvol10.3 add regression, help, examples for Heap
 20090224 tpd src/axiom-website/patches.html 20090224.01.tpd.patch
 20090224 tpd src/interp/Makefile add regression, help for Dequeue
 20090224 tpd books/bookvol10.3 add regression, help, examples for Dequeue
diff --git a/src/algebra/Makefile.pamphlet b/src/algebra/Makefile.pamphlet
index bcf1252..ed8052e 100644
--- a/src/algebra/Makefile.pamphlet
+++ b/src/algebra/Makefile.pamphlet
@@ -16420,11 +16420,12 @@ SPADHELP=\
  ${HELP}/Complex.help                ${HELP}/ContinuedFraction.help \
  ${HELP}/CycleIndicators.help        ${HELP}/DeRhamComplex.help \
  ${HELP}/DecimalExpansion.help       ${HELP}/Dequeue.help \
+ ${HELP}/DistributedMultivariatePolynomial.help \
  ${HELP}/DoubleFloat.help \
  ${HELP}/EqTable.help                ${HELP}/Equation.help \
  ${HELP}/Expression.help \
- ${HELP}/DistributedMultivariatePolynomial.help \
  ${HELP}/EuclideanGroebnerBasisPackage.help \
+ ${HELP}/Heap.help \
  ${HELP}/Factored.help               ${HELP}/FactoredFunctions2.help \
  ${HELP}/File.help                   ${HELP}/FileName.help \
  ${HELP}/FlexibleArray.help          ${HELP}/Float.help \
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 564aaaf..c668b7b 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -965,5 +965,7 @@ bookvol10.3 add regression, help, examples for ArrayStack<br/>
 bookvol10.3 add regression, help, examples for Queue<br/>
 <a href="patches/20090224.01.tpd.patch">20090224.01.tpd.patch</a>
 bookvol10.3 add regression, help, examples for Dequeue<br/>
+<a href="patches/20090225.01.tpd.patch">20090225.01.tpd.patch</a>
+bookvol10.3 add regression, help, examples for Heap<br/>
  </body>
 </html>



From MAILER-DAEMON Wed Feb 25 14:31:34 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LcPTh-0003e3-U4
	for mharc-axiom-developer@gnu.org; Wed, 25 Feb 2009 14:31:33 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LcPTe-0003cZ-Lr
	for axiom-developer@nongnu.org; Wed, 25 Feb 2009 14:31:30 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LcPTc-0003bv-Ee
	for axiom-developer@nongnu.org; Wed, 25 Feb 2009 14:31:29 -0500
Received: from [199.232.76.173] (port=53478 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LcPTc-0003bs-9D
	for axiom-developer@nongnu.org; Wed, 25 Feb 2009 14:31:28 -0500
Received: from tvwna-ip-a-16.princeton.org ([66.180.184.26]:48669
	helo=localhost.princeton.org)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <camm@maguirefamily.org>)
	id 1LcPTb-0003i8-OV
	for axiom-developer@nongnu.org; Wed, 25 Feb 2009 14:31:27 -0500
Received: from camm by localhost.princeton.org with local (Exim 4.69)
	(envelope-from <camm@maguirefamily.org>)
	id 1LcPIw-0006ka-If; Wed, 25 Feb 2009 14:20:26 -0500
To: daly@axiom-developer.org
Subject: Re: [Axiom-developer] Re: Debian axiom build failures
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
	<87skm32x6x.fsf_-_@maguirefamily.org>
	<200902250355.n1P3tQm25134@localhost.localdomain>
From: Camm Maguire <camm@maguirefamily.org>
Date: Wed, 25 Feb 2009 14:20:26 -0500
In-Reply-To: <200902250355.n1P3tQm25134@localhost.localdomain> (root's message
	of "Tue\, 24 Feb 2009 22\:55\:26 -0500")
Message-ID: <87iqmy1fyd.fsf@maguirefamily.org>
User-Agent: Gnus/5.11 (Gnus v5.11) Emacs/22.2 (gnu/linux)
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 25 Feb 2009 19:31:31 -0000

Greetings!  I'm using the latest gcl 2.6.8pre on all platforms. Aka
gcl-system via the debian/rules mechanism of long ago.

I've verified that the missing macro file is not relevant, and that
the machine I'm working on (Debian sid ia64) is not in the list of
different gcl versions.

I can als check that the old 2005 package builds if needed, but this
does not appear helpful.

I was hoping you could shed some light on:
   No option begins with (|package| (repsq |repeatedsquaring|)) .
 
   >> System error:
   The function |boot| is undefined.

This would appear to indicate that some critical compile or load
earlier on had failed.  Does this ring any bell?

I'll try to restart when the machine becomes available again and
review the output more carefully, but nothing jumped out the first
time. 

Take care,


root <daly@axiom-developer.org> writes:

> Thoses gold sources certainly compile on other platforms so I'm not sure
> the failure lives in the Axiom source code.
>
> What version of GCL are you using? (See the top level Makefile and search
> for GCLVERSION
>
> Some platforms are sensitive to the version used.
>
> There are 4 version, the gcl 2.6.7, gcl2.6.8pre, gcl2.6.8pre2, and
> gcl2.6.8pre3
>
> The "pre" versions are various snapshots of gcl2.6.8pre over time.
> Some platforms require one version, others require a different one.
>
> Tim
>
>
> _______________________________________________
> Axiom-developer mailing list
> Axiom-developer@nongnu.org
> http://lists.nongnu.org/mailman/listinfo/axiom-developer
>
>
>
>

-- 
Camm Maguire			     		    camm@maguirefamily.org
==========================================================================
"The earth is but one country, and mankind its citizens."  --  Baha'u'llah



From MAILER-DAEMON Wed Feb 25 20:14:50 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LcUpu-0002mE-Ho
	for mharc-axiom-developer@gnu.org; Wed, 25 Feb 2009 20:14:50 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LcUpq-0002ly-Lt
	for axiom-developer@nongnu.org; Wed, 25 Feb 2009 20:14:46 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LcUpp-0002le-HX
	for axiom-developer@nongnu.org; Wed, 25 Feb 2009 20:14:46 -0500
Received: from [199.232.76.173] (port=58850 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LcUpp-0002la-BL
	for axiom-developer@nongnu.org; Wed, 25 Feb 2009 20:14:45 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:47543
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LcUpo-000644-PN
	for axiom-developer@nongnu.org; Wed, 25 Feb 2009 20:14:45 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1Q1Efug030256;
	Wed, 25 Feb 2009 19:14:41 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1Q1EdhC030245;
	Wed, 25 Feb 2009 19:14:39 -0600
Date: Wed, 25 Feb 2009 19:14:39 -0600
Message-Id: <200902260114.n1Q1EdhC030245@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090225.01.mxr.patch (bookvol10.3 Add
	NottinghamGroup)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Thu, 26 Feb 2009 01:14:46 -0000

Add Martin Rubey's NottinghamGroup along with a regression test file,
help documentation, and graph layer information.

====================================================================
diff --git a/books/bookvol10.3.pamphlet b/books/bookvol10.3.pamphlet
index 69c7c2e..edfdf79 100644
--- a/books/bookvol10.3.pamphlet
+++ b/books/bookvol10.3.pamphlet
@@ -62760,6 +62760,195 @@ NonNegativeInteger: Join(OrderedAbelianMonoidSup,Monoid) with
 
 @
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\section{domain NOTTING NottinghamGroup}
+<<NottinghamGroup.input>>=
+)sys rm -f NottinghamGroup.output
+)spool NottinghamGroup.output
+)set message test on
+)set message auto off
+)clear all
+
+--S 1
+x:=monomial(1,1)$UFPS PF 1783
+--R 
+--R
+--R   (1)  x
+--R                            Type: UnivariateFormalPowerSeries PrimeField 1783
+--E 1
+
+--S 2
+s:=retract(sin x)$NOTTING PF 1783
+--R 
+--R
+--R                3        5       7       9      11
+--R   (2)  x + 297x  + 1679x  + 427x  + 316x  + O(x  )
+--R                                        Type: NottinghamGroup PrimeField 1783
+--E 2
+
+--S 3
+s^2
+--R 
+--R
+--R                3       5        7        9      11
+--R   (3)  x + 594x  + 535x  + 1166x  + 1379x  + O(x  )
+--R                                        Type: NottinghamGroup PrimeField 1783
+--E 3
+
+--S 4
+s^-1
+--R 
+--R
+--R                 3       5       7        9      11
+--R   (4)  x + 1486x  + 847x  + 207x  + 1701x  + O(x  )
+--R                                        Type: NottinghamGroup PrimeField 1783
+--E 4
+
+--S 5
+s^-1*s
+--R 
+--R
+--R               11
+--R   (5)  x + O(x  )
+--R                                        Type: NottinghamGroup PrimeField 1783
+--E 5
+
+--S 6
+s*s^-1
+--R 
+--R
+--R               11
+--R   (6)  x + O(x  )
+--R                                        Type: NottinghamGroup PrimeField 1783
+--E 6
+
+--S 7
+sample()$NOTTING(PF(1783))
+--R
+--R   (7)  x
+--R                                        Type: NottinghamGroup PrimeField 1783
+--E 7
+
+--S 8
+)show NottinghamGroup
+--R 
+--R NottinghamGroup F: FiniteFieldCategory  is a domain constructor
+--R Abbreviation for NottinghamGroup is NOTTING 
+--R This constructor is exposed in this frame.
+--R Issue )edit bookvol10.3.spad.pamphlet to see algebra source code for NOTTING 
+--R
+--R------------------------------- Operations --------------------------------
+--R ?*? : (%,%) -> %                      ?**? : (%,Integer) -> %
+--R ?**? : (%,PositiveInteger) -> %       ?/? : (%,%) -> %
+--R ?=? : (%,%) -> Boolean                1 : () -> %
+--R ?^? : (%,Integer) -> %                ?^? : (%,PositiveInteger) -> %
+--R coerce : % -> OutputForm              commutator : (%,%) -> %
+--R conjugate : (%,%) -> %                hash : % -> SingleInteger
+--R inv : % -> %                          latex : % -> String
+--R one? : % -> Boolean                   recip : % -> Union(%,"failed")
+--R sample : () -> %                      ?~=? : (%,%) -> Boolean
+--R ?**? : (%,NonNegativeInteger) -> %
+--R ?^? : (%,NonNegativeInteger) -> %
+--R retract : UnivariateFormalPowerSeries F -> %
+--R
+--E 8
+
+)spool
+)lisp (bye)
+ 
+@
+<<NottinghamGroup.help>>=
+====================================================================
+NottinghamGroup examples
+====================================================================
+
+   x:=monomial(1,1)$UFPS PF 1783
+     x
+
+   s:=retract(sin x)$NOTTING PF 1783
+             3        5       7       9      11
+     x + 297x  + 1679x  + 427x  + 316x  + O(x  )
+
+   s^2
+             3       5        7        9      11
+     x + 594x  + 535x  + 1166x  + 1379x  + O(x  )
+
+   s^-1
+              3       5       7        9      11
+     x + 1486x  + 847x  + 207x  + 1701x  + O(x  )
+
+   s^-1*s
+            11
+     x + O(x  )
+
+   s*s^-1
+               11
+        x + O(x  )
+
+See Also:
+o )show NottinghamGroup
+o )show UnivariateFormalPowerSeries
+
+@
+\pagehead{NottinghamGroup}{NOTTING}
+\pagepic{ps/v103nottinghamgroup.ps}{NOTTING}{1.00}
+
+If F is a finite field with $p^n$ elements, then we may form the group
+of all formal power series $\{t(1+a_1t+a_2t+\ldots)\}$ where $u(0)=0$ and 
+$u^{'}(0)=1$ and $a_i \in F$. 
+The group operation is substitution (composition).
+This is called the Nottingham Group. 
+
+The Nottingham Group is the projective limit of finite p-groups.
+Every finite p-group can be embedded in the Nottingham Group.
+{\bf Exports:}\\
+\begin{tabular}{lllll}
+\cross{NOTTING}{1} &
+\cross{NOTTING}{coerce} &
+\cross{NOTTING}{commutator} &
+\cross{NOTTING}{conjugate} &
+\cross{NOTTING}{hash} \\
+\cross{NOTTING}{inv} &
+\cross{NOTTING}{latex} &
+\cross{NOTTING}{one?} &
+\cross{NOTTING}{recip} &
+\cross{NOTTING}{sample} \\
+\cross{NOTTING}{\^{}=} &
+\cross{NOTTING}{retract} &
+\cross{NOTTING}{*} &
+\cross{NOTTING}{**} &
+\cross{NOTTING}{/} \\
+\cross{NOTTING}{=} &
+\cross{NOTTING}{\^{}} &&&
+\end{tabular}
+
+<<domain NOTTING NottinghamGroup>>=
+)abbrev domain NOTTING NottinghamGroup
+NottinghamGroup(F:FiniteFieldCategory): Group with
+  retract: UnivariateFormalPowerSeries F -> %
+ == add
+  Rep:=UnivariateFormalPowerSeries F
+
+  coerce f == coerce(f::Rep)$UnivariateFormalPowerSeries(F)
+
+  retract f ==
+    if zero? coefficient(f,0) and one? coefficient(f,1)
+    then f::Rep
+    else error"The leading term must be x"
+
+  1 == monomial(1,1)
+
+  f*g == f.g
+
+  inv f == revert f
+
+@
+<<NOTTING.dotabb>>=
+"NOTTING" [color="#88FF44",href="bookvol10.3.pdf#nameddest=NOTTING"]
+"UFPS" [color="#4488FF",href="bookvol10.3.pdf#nameddest=UFPS"]
+"NOTTING" -> "UFPS"
+
+@
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{domain NIPROB NumericalIntegrationProblem}
 \pagehead{NumericalIntegrationProblem}{NIPROB}
 \pagepic{ps/v103numericalintegrationproblem.ps}{NIPROB}{1.00}
@@ -89747,7 +89936,7 @@ unfortunately.
 \end{tabular}
 
 <<domain SUPEXPR SparseUnivariatePolynomialExpressions>>=
-)abb domain SUPEXPR SparseUnivariatePolynomialExpressions
+)abbrev domain SUPEXPR SparseUnivariatePolynomialExpressions
 SparseUnivariatePolynomialExpressions(R: Ring): Exports == Implementation where
 
     Exports == UnivariatePolynomialCategory R with
@@ -115140,6 +115329,7 @@ Note that this code is not included in the generated catdef.spad file.
 <<domain NSUP NewSparseUnivariatePolynomial>>
 <<domain NONE None>>
 <<domain NNI NonNegativeInteger>>
+<<domain NOTTING NottinghamGroup>>
 <<domain NIPROB NumericalIntegrationProblem>>
 <<domain ODEPROB NumericalODEProblem>>
 <<domain OPTPROB NumericalOptimizationProblem>>
diff --git a/books/bookvol10.4.pamphlet b/books/bookvol10.4.pamphlet
index 23f6c27..a72d13e 100644
--- a/books/bookvol10.4.pamphlet
+++ b/books/bookvol10.4.pamphlet
@@ -21525,7 +21525,7 @@ works. This is probably due to missing ``/'' in UFPS.
 \end{tabular}
 
 <<package EXPRSOL ExpressionSolve>>=
-)abb package EXPRSOL ExpressionSolve
+)abbrev package EXPRSOL ExpressionSolve
 ExpressionSolve(R, F, UTSF, UTSSUPF): Exports == Implementation where
     R: Join(OrderedSet, IntegralDomain, ConvertibleTo InputForm)
     F: FunctionSpace R
@@ -92796,8 +92796,8 @@ It uses the method of undetermined coefficients.
 {\bf Exports:}\\
 \cross{UTSSOL}{seriesSolve} 
 
-<<package UTSSOL TaylorSolveTaylorSolve>>=
-)abb package UTSSOL TaylorSolve
+<<package UTSSOL TaylorSolve>>=
+)abbrev package UTSSOL TaylorSolve
 TaylorSolve(F, UTSF, UTSSUPF): Exports == Implementation where
     F: Field
     SUP  ==> SparseUnivariatePolynomialExpressions
diff --git a/books/ps/v103nottinghamgroup.ps b/books/ps/v103nottinghamgroup.ps
new file mode 100644
index 0000000..114f33d
--- /dev/null
+++ b/books/ps/v103nottinghamgroup.ps
@@ -0,0 +1,281 @@
+%!PS-Adobe-2.0
+%%Creator: Graphviz version 2.16.1 (Mon Jul  7 18:20:33 UTC 2008)
+%%For: (root) root
+%%Title: pic
+%%Pages: (atend)
+%%BoundingBox: (atend)
+%%EndComments
+save
+%%BeginProlog
+/DotDict 200 dict def
+DotDict begin
+
+/setupLatin1 {
+mark
+/EncodingVector 256 array def
+ EncodingVector 0
+
+ISOLatin1Encoding 0 255 getinterval putinterval
+EncodingVector 45 /hyphen put
+
+% Set up ISO Latin 1 character encoding
+/starnetISO {
+        dup dup findfont dup length dict begin
+        { 1 index /FID ne { def }{ pop pop } ifelse
+        } forall
+        /Encoding EncodingVector def
+        currentdict end definefont
+} def
+/Times-Roman starnetISO def
+/Times-Italic starnetISO def
+/Times-Bold starnetISO def
+/Times-BoldItalic starnetISO def
+/Helvetica starnetISO def
+/Helvetica-Oblique starnetISO def
+/Helvetica-Bold starnetISO def
+/Helvetica-BoldOblique starnetISO def
+/Courier starnetISO def
+/Courier-Oblique starnetISO def
+/Courier-Bold starnetISO def
+/Courier-BoldOblique starnetISO def
+cleartomark
+} bind def
+
+%%BeginResource: procset graphviz 0 0
+/coord-font-family /Times-Roman def
+/default-font-family /Times-Roman def
+/coordfont coord-font-family findfont 8 scalefont def
+
+/InvScaleFactor 1.0 def
+/set_scale {
+       dup 1 exch div /InvScaleFactor exch def
+       scale
+} bind def
+
+% styles
+/solid { [] 0 setdash } bind def
+/dashed { [9 InvScaleFactor mul dup ] 0 setdash } bind def
+/dotted { [1 InvScaleFactor mul 6 InvScaleFactor mul] 0 setdash } bind def
+/invis {/fill {newpath} def /stroke {newpath} def /show {pop newpath} def} bind def
+/bold { 2 setlinewidth } bind def
+/filled { } bind def
+/unfilled { } bind def
+/rounded { } bind def
+/diagonals { } bind def
+
+% hooks for setting color 
+/nodecolor { sethsbcolor } bind def
+/edgecolor { sethsbcolor } bind def
+/graphcolor { sethsbcolor } bind def
+/nopcolor {pop pop pop} bind def
+
+/beginpage {	% i j npages
+	/npages exch def
+	/j exch def
+	/i exch def
+	/str 10 string def
+	npages 1 gt {
+		gsave
+			coordfont setfont
+			0 0 moveto
+			(\() show i str cvs show (,) show j str cvs show (\)) show
+		grestore
+	} if
+} bind def
+
+/set_font {
+	findfont exch
+	scalefont setfont
+} def
+
+% draw text fitted to its expected width
+/alignedtext {			% width text
+	/text exch def
+	/width exch def
+	gsave
+		width 0 gt {
+			[] 0 setdash
+			text stringwidth pop width exch sub text length div 0 text ashow
+		} if
+	grestore
+} def
+
+/boxprim {				% xcorner ycorner xsize ysize
+		4 2 roll
+		moveto
+		2 copy
+		exch 0 rlineto
+		0 exch rlineto
+		pop neg 0 rlineto
+		closepath
+} bind def
+
+/ellipse_path {
+	/ry exch def
+	/rx exch def
+	/y exch def
+	/x exch def
+	matrix currentmatrix
+	newpath
+	x y translate
+	rx ry scale
+	0 0 1 0 360 arc
+	setmatrix
+} bind def
+
+/endpage { showpage } bind def
+/showpage { } def
+
+/layercolorseq
+	[	% layer color sequence - darkest to lightest
+		[0 0 0]
+		[.2 .8 .8]
+		[.4 .8 .8]
+		[.6 .8 .8]
+		[.8 .8 .8]
+	]
+def
+
+/layerlen layercolorseq length def
+
+/setlayer {/maxlayer exch def /curlayer exch def
+	layercolorseq curlayer 1 sub layerlen mod get
+	aload pop sethsbcolor
+	/nodecolor {nopcolor} def
+	/edgecolor {nopcolor} def
+	/graphcolor {nopcolor} def
+} bind def
+
+/onlayer { curlayer ne {invis} if } def
+
+/onlayers {
+	/myupper exch def
+	/mylower exch def
+	curlayer mylower lt
+	curlayer myupper gt
+	or
+	{invis} if
+} def
+
+/curlayer 0 def
+
+%%EndResource
+%%EndProlog
+%%BeginSetup
+14 default-font-family set_font
+1 setmiterlimit
+% /arrowlength 10 def
+% /arrowwidth 5 def
+
+% make sure pdfmark is harmless for PS-interpreters other than Distiller
+/pdfmark where {pop} {userdict /pdfmark /cleartomark load put} ifelse
+% make '<<' and '>>' safe on PS Level 1 devices
+/languagelevel where {pop languagelevel}{1} ifelse
+2 lt {
+    userdict (<<) cvn ([) cvn load put
+    userdict (>>) cvn ([) cvn load put
+} if
+
+%%EndSetup
+setupLatin1
+%%Page: 1 1
+%%PageBoundingBox: 36 36 122 152
+%%PageOrientation: Portrait
+0 0 1 beginpage
+gsave
+36 36 86 116 boxprim clip newpath
+1 1 set_scale 0 rotate 40 40 translate
+0.167 0.600 1.000 graphcolor
+newpath -4 -4 moveto
+-4 716 lineto
+536 716 lineto
+536 -4 lineto
+closepath fill
+1 setlinewidth
+0.167 0.600 1.000 graphcolor
+newpath -4 -4 moveto
+-4 716 lineto
+536 716 lineto
+536 -4 lineto
+closepath stroke
+% NOTTING
+gsave
+[ /Rect [ 0 72 78 108 ]
+  /Border [ 0 0 0 ]
+  /Action << /Subtype /URI /URI (bookvol10.3.pdf#nameddest=NOTTING) >>
+  /Subtype /Link
+/ANN pdfmark
+0.273 0.733 1.000 nodecolor
+newpath 78 108 moveto
+2.634e-14 108 lineto
+5.29438e-15 72 lineto
+78 72 lineto
+closepath fill
+1 setlinewidth
+filled
+0.273 0.733 1.000 nodecolor
+newpath 78 108 moveto
+2.634e-14 108 lineto
+5.29438e-15 72 lineto
+78 72 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+7.5 85.9 moveto 63 (NOTTING) alignedtext
+grestore
+% UFPS
+gsave
+[ /Rect [ 12 0 66 36 ]
+  /Border [ 0 0 0 ]
+  /Action << /Subtype /URI /URI (bookvol10.3.pdf#nameddest=UFPS) >>
+  /Subtype /Link
+/ANN pdfmark
+0.606 0.733 1.000 nodecolor
+newpath 66 36 moveto
+12 36 lineto
+12 1.06581e-14 lineto
+66 0 lineto
+closepath fill
+1 setlinewidth
+filled
+0.606 0.733 1.000 nodecolor
+newpath 66 36 moveto
+12 36 lineto
+12 1.06581e-14 lineto
+66 0 lineto
+closepath stroke
+0.000 0.000 0.000 nodecolor
+14.00 /Times-Roman set_font
+22.5 13.9 moveto 33 (UFPS) alignedtext
+grestore
+% NOTTING->UFPS
+gsave
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 39 72 moveto
+39 64 39 55 39 46 curveto
+stroke
+0.000 0.000 0.000 edgecolor
+newpath 42.5001 46 moveto
+39 36 lineto
+35.5001 46 lineto
+closepath fill
+1 setlinewidth
+solid
+0.000 0.000 0.000 edgecolor
+newpath 42.5001 46 moveto
+39 36 lineto
+35.5001 46 lineto
+closepath stroke
+grestore
+endpage
+showpage
+grestore
+%%PageTrailer
+%%EndPage: 1
+%%Trailer
+%%Pages: 1
+%%BoundingBox: 36 36 122 152
+end
+restore
+%%EOF
diff --git a/changelog b/changelog
index b994693..5533355 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,9 @@
+20090225 tpd src/axiom-website/patches.html 20090225.02.tpd.patch
+20090225 tpd src/algebra/Makefile add NottinghamGroup
+20090225 tpd src/algebra/exposed.lsp add NottinghamGroup
+20090225 tpd books/ps/v103nottinghamgroup.ps
+20090225 mxr books/bookvol10.4 fix TaylorSolve, UFPS
+20090225 mxr books/bookvol10.3 add NottinghamGroup
 20090225 tpd src/axiom-website/patches.html 20090225.01.tpd.patch
 20090225 tpd src/interp/Makefile add regression, help for Heap
 20090225 tpd books/bookvol10.3 add regression, help, examples for Heap
diff --git a/src/algebra/Makefile.pamphlet b/src/algebra/Makefile.pamphlet
index ed8052e..2c80c0c 100644
--- a/src/algebra/Makefile.pamphlet
+++ b/src/algebra/Makefile.pamphlet
@@ -3962,7 +3962,6 @@ LAYER8=\
 "MTSCAT" -> "TRANFUN"
 /*"MTSCAT" -> {"TRIGCAT"; "ATRIG"; "HYPCAT"; "AHYP"; "ELEMFUN"}*/
 
-"ORESUP" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ORESUP"]
 "ORESUP" -> "OREPCAT"
 /*"ORESUP" -> {"RING"; "RNG"; "ABELGRP"; "CABMON"; "ABELMON"; "ABELSG"}*/
 /*"ORESUP" -> {"SETCAT"; "BASTYPE"; "KOERCE"; "SGROUP"; "MONOID"}*/
@@ -14347,7 +14346,8 @@ LAYER18=\
   ${OUT}/FDIV.o     ${OUT}/FSCINT.o   ${OUT}/FSINT.o    ${OUT}/FS2EXPXP.o \
   ${OUT}/GSERIES.o  ${OUT}/HELLFDIV.o ${OUT}/INVLAPLA.o ${OUT}/IR2F.o     \
   ${OUT}/IRRF2F.o   ${OUT}/LAPLACE.o  ${OUT}/LIMITPS.o  ${OUT}/LODEEF.o   \
-  ${OUT}/NODE1.o    ${OUT}/NTSCAT.o   ${OUT}/ODECONST.o ${OUT}/ODEEF.o    \
+  ${OUT}/NODE1.o    ${OUT}/NOTTING.o \
+  ${OUT}/NTSCAT.o   ${OUT}/ODECONST.o ${OUT}/ODEEF.o    \
   ${OUT}/ODEINT.o   ${OUT}/QCMPACK.o  ${OUT}/REGSET.o   ${OUT}/REP.o      \
   ${OUT}/RGCHAIN.o  ${OUT}/RSDCMPK.o  ${OUT}/SFRTCAT.o  ${OUT}/SOLVERAD.o \
   ${OUT}/SULS.o     ${OUT}/SUPXS.o    ${OUT}/UFPS1.o    ${OUT}/ULS.o      \
@@ -14780,6 +14780,16 @@ LAYER18=\
 /*"NODE1" -> {"ELTAGG"; "ELTAB"; "CLAGG"; "FLAGG"; "ELAGG"; "OM"; "POLYCAT"}*/
 /*"NODE1" -> {"FAMR"; "AMR"; "PFECAT"; "NNI"; "PI"; "LSAGG-"; "STAGG-"}*/
 
+"NOTTING" [color="#88FF44",href="bookvol10.3.pdf#nameddest=NOTTING"]
+/*"NOTTING" -> {"GROUP"; "MONOID"; "SGROUP"; "SETCAT"; "BASTYPE"} */
+/*"NOTTING" -> {"KOERCE"; "FFIELDC"; "FPC"} */
+/* "NOTTING" -> {"FIELD"; "EUCDOM"; "PID"; "GCDDOM"; "INTDOM"; "COMRING"} */
+/* "NOTTING" -> {"RING"; "RNG"; "ABELGRP"; "CABMON"; "ABELMON"; "ABELSG"} */
+/* "NOTTING" -> {"LMODULE"; "BMODULE"; "RMODULE"; "ALGEBRA"; "MODULE"} */
+/* "NOTTING" -> {"ENTIRER"; "UFD"; "DIVRING"; "CHARNZ"; "FINITE"; "STEP"} */
+/* "NOTTING" -> {"DIFRING"; "NNI"; "INT"} */
+"NOTTING" -> "UFPS"
+
 "NTSCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=NTSCAT"]
 "NTSCAT" -> "RSETCAT"
 /*"NTSCAT" -> {"TSETCAT"; "PSETCAT"; "SETCAT"; "BASTYPE"; "KOERCE"}*/
@@ -15587,6 +15597,18 @@ ${MID}/UFPS1.nrlib/code.o: ${MID}/UFPS1.spad
 	      | ${INTERPSYS} >${TMP}/trace ; \
 	   fi )
 
+NOTTINGDEPS = UFPS
+
+${MID}/NOTTING.nrlib/code.o: ${MID}/NOTTING.spad
+	@echo S1 making ${MID}/NOTTING.nrlib/code.o from ${MID}/NOTTING.spad
+	@ (cd ${MID} ; \
+	 if [ -z "${NOISE}" ] ; then \
+	  echo -e ")lib ${NOTTINGDEPS} \n )co NOTTING.spad" | ${INTERPSYS}  ; \
+         else \
+	  echo -e ")lib ${NOTTINGDEPS} \n )co NOTTING.spad" \
+	    | ${INTERPSYS} >${TMP}/trace ; \
+	 fi )
+
 GUESSDEPS = NEWTON FAMR2 FFFG FFFGF SUPEXPR UTSSOL EXPRSOL GOPT GOPT0 \
             UFPS RECOP UFPS1
 
@@ -15678,8 +15700,6 @@ ${MID}/GUESSUP.nrlib/code.o: ${MID}/GUESSUP.spad
 	      | ${INTERPSYS} >${TMP}/trace ; \
 	   fi )
 
-
-
 @
 
 \section{Broken Files}
@@ -16425,7 +16445,6 @@ SPADHELP=\
  ${HELP}/EqTable.help                ${HELP}/Equation.help \
  ${HELP}/Expression.help \
  ${HELP}/EuclideanGroebnerBasisPackage.help \
- ${HELP}/Heap.help \
  ${HELP}/Factored.help               ${HELP}/FactoredFunctions2.help \
  ${HELP}/File.help                   ${HELP}/FileName.help \
  ${HELP}/FlexibleArray.help          ${HELP}/Float.help \
@@ -16449,6 +16468,7 @@ SPADHELP=\
  ${HELP}/MappingPackage2.help        ${HELP}/MappingPackage3.help \
  ${HELP}/Matrix.help                 ${HELP}/Multiset.help \
  ${HELP}/MultivariatePolynomial.help ${HELP}/None.help \
+ ${HELP}/NottinghamGroup.help \
  ${HELP}/Octonion.help               ${HELP}/OneDimensionalArray.help \
  ${HELP}/Operator.help               ${HELP}/OrderedVariableList.help \
  ${HELP}/OrderlyDifferentialPolynomial.help \
@@ -16519,6 +16539,7 @@ REGRESS=\
  MappingPackage2.regress        MappingPackage3.regress \
  Matrix.regress                 Multiset.regress \
  MultivariatePolynomial.regress None.regress \
+ NottinghamGroup.regress \
  Octonion.regress               OneDimensionalArray.regress \
  Operator.regress               OrderedVariableList.regress \
  OrderlyDifferentialPolynomial.regress \
@@ -17196,6 +17217,16 @@ ${HELP}/None.help: ${BOOKS}/bookvol10.3.pamphlet
              >${INPUT}/None.input
 	@echo "None (NONE)" >>${HELPFILE}
 
+${HELP}/NottinghamGroup.help: ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7035 create NottinghamGroup.help from \
+             ${BOOKS}/bookvol10.3.pamphlet
+	@${TANGLE} -R"NottinghamGroup.help" ${BOOKS}/bookvol10.3.pamphlet \
+             >${HELP}/NottinghamGroup.help
+	@-cp ${HELP}/NottinghamGroup.help ${HELP}/NOTTING.help
+	@${TANGLE} -R"NottinghamGroup.input" ${BOOKS}/bookvol10.3.pamphlet \
+            >${INPUT}/NottinghamGroup.input
+	@echo "NottinghamGroup (NOTTING)" >>${HELPFILE}
+
 ${HELP}/Octonion.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo 7061 create Octonion.help from ${BOOKS}/bookvol10.3.pamphlet
 	@${TANGLE} -R"Octonion.help" ${BOOKS}/bookvol10.3.pamphlet \
diff --git a/src/algebra/exposed.lsp.pamphlet b/src/algebra/exposed.lsp.pamphlet
index a577f11..e211650 100644
--- a/src/algebra/exposed.lsp.pamphlet
+++ b/src/algebra/exposed.lsp.pamphlet
@@ -119,6 +119,7 @@
   (|Exit| . EXIT)
   (|Expression| . EXPR)
   (|ExpressionFunctions2| . EXPR2)
+  (|ExpressionSolve| . EXPRSOL)
   (|ExpressionSpaceFunctions2| . ES2)
   (|ExpressionSpaceODESolver| . EXPRODE)
   (|ExpressionToOpenMath| . OMEXPR)
@@ -127,6 +128,7 @@
   (|FactoredFunctions2| . FR2)
   (|File| . FILE)
   (|FileName| . FNAME)
+  (|FiniteAbelianMonoidRingFunctions2| . FAMR2)
   (|FiniteDivisorFunctions2| . FDIV2)
   (|FiniteField| . FF)
   (|FiniteFieldCyclicGroup| . FFCG)
@@ -143,6 +145,8 @@
   (|FourierSeries| . FSERIES)
   (|Fraction| . FRAC)
   (|FractionalIdealFunctions2| . FRIDEAL2)
+  (|FractionFreeFastGaussian| . FFFG)
+  (|FractionFreeFastGaussianFractions| . FFFGF)
   (|FractionFunctions2| . FRAC2)
   (|FreeNilpotentLie| . FNLA)
   (|FullPartialFractionExpansion| . FPARFRAC)
@@ -161,11 +165,14 @@
   (|GroebnerPackage| . GB)
   (|GroebnerFactorizationPackage| . GBF)
   (|Guess| . GUESS)
-  (|GuessOption| . GOPT)
   (|GuessAlgebraicNumber| . GUESSAN)
+  (|GuessFinite| . GUESSF)
+  (|GuessFiniteFunctions| . GUESSF1)
   (|GuessInteger| . GUESSINT)
+  (|GuessOption| . GOPT)
+  (|GuessOptionFunctions0| . GOPT0)
   (|GuessPolynomial| . GUESSP)
-  (|GuessFinite| . GUESSF)
+  (|GuessUnivariatePolynomial| . GUESSUP)
   (|HallBasis| . HB)
   (|Heap| . HEAP)
   (|HexadecimalExpansion| . HEXADEC)
@@ -231,8 +238,11 @@
   (|MultivariateFactorize| . MULTFACT)
   (|MultivariatePolynomial| . MPOLY)
   (|MultFiniteFactorize| . MFINFACT)
+  (|MyUnivariatePolynomial| . MYUP)
+  (|MyExpression| . MYEXPR)
   (|NoneFunctions1| . NONE1)
   (|NonNegativeInteger| . NNI)
+  (|NottinghamGroup| . NOTTING)
   (|NormalizationPackage| . NORMPK)
   (|NormInMonogenicAlgebra| . NORMMA)
   (|NumberTheoreticPolynomialFunctions| . NTPOLFN)
@@ -322,6 +332,7 @@
   (|RealPolynomialUtilitiesPackage| . POLUTIL)
   (|RealZeroPackage| . REAL0)
   (|RealZeroPackageQ| . REAL0Q)
+  (|RecurrenceOperator| . RECOP)
   (|RectangularMatrixCategoryFunctions2| . RMCAT2)
   (|RegularSetDecompositionPackage| . RSDCMPK)
   (|RegularTriangularSet| . REGSET)
@@ -344,6 +355,7 @@
   (|SimplifyAlgebraicNumberConvertPackage| . SIMPAN)
   (|SingleInteger| . SINT)
   (|SmithNormalForm| . SMITH)
+  (|SparseUnivariatePolynomialExpressions| . SUPEXPR)
   (|SparseUnivariatePolynomialFunctions2| . SUP2)
   (|SpecialOutputPackage| . SPECOUT)
   (|SquareFreeRegularSetDecompositionPackage| . SRDCMPK)
@@ -363,6 +375,7 @@
   (|SAERationalFunctionAlgFactor| . SAERFFC)
   (|Tableau| . TABLEAU)
   (|TaylorSeries| . TS)
+  (|TaylorSolve| . UTSSOL)
   (|TexFormat| . TEX)
   (|TexFormat1| . TEX1)
   (|TextFile| . TEXTFILE)
@@ -379,6 +392,8 @@
   (|Tree| . TREE)
   (|TrigonometricManipulations| . TRIGMNIP)
   (|UnivariateLaurentSeriesFunctions2| . ULS2)
+  (|UnivariateFormalPowerSeries| . UFPS)
+  (|UnivariateFormalPowerSeriesFunctions| . UFPS1)
   (|UnivariatePolynomial| . UP)
   (|UnivariatePolynomialCategoryFunctions2| . UPOLYC2)
   (|UnivariatePolynomialCommonDenominator| . UPCDEN)
@@ -940,6 +955,7 @@
   (|NewSparseUnivariatePolynomial| . NSUP)
   (|NewSparseUnivariatePolynomialFunctions2| . NSUP2)
   (|NonCommutativeOperatorDivision| . NCODIV)
+  (|NewtonInterpolation| . NEWTON)
   (|None| . NONE)
   (|NonLinearFirstOrderODESolver| . NODE1)
   (|NonLinearSolvePackage| . NLINSOL)
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index c668b7b..55f0b57 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -967,5 +967,7 @@ bookvol10.3 add regression, help, examples for Queue<br/>
 bookvol10.3 add regression, help, examples for Dequeue<br/>
 <a href="patches/20090225.01.tpd.patch">20090225.01.tpd.patch</a>
 bookvol10.3 add regression, help, examples for Heap<br/>
+<a href="patches/20090225.02.tpd.patch">20090225.02.tpd.patch</a>
+bookvol10.3 add regression, help, examples for NottinghamGroup<br/>
  </body>
 </html>



From MAILER-DAEMON Thu Feb 26 19:01:26 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LcqAQ-0003pr-HT
	for mharc-axiom-developer@gnu.org; Thu, 26 Feb 2009 19:01:26 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LcqAO-0003pm-My
	for axiom-developer@nongnu.org; Thu, 26 Feb 2009 19:01:24 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LcqAK-0003pY-1M
	for axiom-developer@nongnu.org; Thu, 26 Feb 2009 19:01:24 -0500
Received: from [199.232.76.173] (port=51800 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LcqAJ-0003pV-SU
	for axiom-developer@nongnu.org; Thu, 26 Feb 2009 19:01:19 -0500
Received: from mx-8.zoominternet.net ([24.154.1.27]:44604
	helo=cm-2.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LcqAJ-000214-F8
	for axiom-developer@nongnu.org; Thu, 26 Feb 2009 19:01:19 -0500
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=OaenJYVfBkqHT82kK5MA:9 a=nJjtIqX9l1Dx8F0OEsDzN0V64PQA:4
	a=8b0TY1xhFYQA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.46] ([24.154.1.46:34997] helo=pop-3.zoominternet.net)
	by mx-8.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 2B/7A-09796-54D27A94; Thu, 26 Feb 2009 19:01:09 -0500
Received: (qmail 21349 invoked from network); 27 Feb 2009 00:01:10 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-3.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <camm@maguirefamily.org>; 27 Feb 2009 00:01:10 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n1R0lDf26998;
	Thu, 26 Feb 2009 19:47:13 -0500
Date: Thu, 26 Feb 2009 19:47:13 -0500
Message-Id: <200902270047.n1R0lDf26998@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: daly@axiom-developer.org
In-reply-to: <200902250355.n1P3tQm25134@localhost.localdomain> (message from
	root on Tue, 24 Feb 2009 22:55:26 -0500)
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
	<87skm32x6x.fsf_-_@maguirefamily.org>
	<200902250355.n1P3tQm25134@localhost.localdomain>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: camm@maguirefamily.org, axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Debian axiom build failures
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 27 Feb 2009 00:01:24 -0000

Camm,

I don't understand why you are getting that error.
Can you do:
  make clean
  make NOISE=
and put the complete console log someplace?

Tim




From MAILER-DAEMON Thu Feb 26 20:02:38 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Lcr7d-00012R-Tq
	for mharc-axiom-developer@gnu.org; Thu, 26 Feb 2009 20:02:38 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Lcr7a-0000zP-7U
	for axiom-developer@nongnu.org; Thu, 26 Feb 2009 20:02:34 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Lcr7W-0000y9-Rs
	for axiom-developer@nongnu.org; Thu, 26 Feb 2009 20:02:32 -0500
Received: from [199.232.76.173] (port=52752 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Lcr7W-0000xw-Na
	for axiom-developer@nongnu.org; Thu, 26 Feb 2009 20:02:30 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:47715
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Lcr7W-00009M-3s
	for axiom-developer@nongnu.org; Thu, 26 Feb 2009 20:02:30 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1R12Rug013014;
	Thu, 26 Feb 2009 19:02:27 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1R12RiV013011;
	Thu, 26 Feb 2009 19:02:27 -0600
Date: Thu, 26 Feb 2009 19:02:27 -0600
Message-Id: <200902270102.n1R12RiV013011@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090226.01.tpd.patch (input/Makefile remove
	bags.input)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 27 Feb 2009 01:02:35 -0000

The bags.input.pamphlet file was distributed to the respective domains
as regression tests, help files, and examples
=======================================================================
diff --git a/changelog b/changelog
index 5533355..eec4e31 100644
--- a/changelog
+++ b/changelog
@@ -1,4 +1,7 @@
-20090225 tpd src/axiom-website/patches.html 20090225.02.tpd.patch
+20090226 tpd src/axiom-website/patches.html 20090225.02.mxr.patch
+20090226 tpd src/input/bags.input removed. distributed into bookvol10.3
+20090226 tpd src/input/Makefile remove bags.input
+20090225 tpd src/axiom-website/patches.html 20090225.02.mxr.patch
 20090225 tpd src/algebra/Makefile add NottinghamGroup
 20090225 tpd src/algebra/exposed.lsp add NottinghamGroup
 20090225 tpd books/ps/v103nottinghamgroup.ps
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 55f0b57..9f1bebb 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -967,7 +967,9 @@ bookvol10.3 add regression, help, examples for Queue<br/>
 bookvol10.3 add regression, help, examples for Dequeue<br/>
 <a href="patches/20090225.01.tpd.patch">20090225.01.tpd.patch</a>
 bookvol10.3 add regression, help, examples for Heap<br/>
-<a href="patches/20090225.02.tpd.patch">20090225.02.tpd.patch</a>
+<a href="patches/20090225.02.mxr.patch">20090225.02.mxr.patch</a>
 bookvol10.3 add regression, help, examples for NottinghamGroup<br/>
+<a href="patches/20090226.01.mxr.patch">20090226.01.mxr.patch</a>
+input/Makefile remove bags.input<br/>
  </body>
 </html>
diff --git a/src/input/Makefile.pamphlet b/src/input/Makefile.pamphlet
index eb8cbf6..f373c0f 100644
--- a/src/input/Makefile.pamphlet
+++ b/src/input/Makefile.pamphlet
@@ -275,7 +275,7 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     arith.regress     array1.regress   array2.regress \
     arrows.regress    asinatan.regress asinhatanh.regress \
     assign.regress    atansqrt.regress \
-    asec.regress      bags.regress     bbtree.regress   besselk.regress \
+    asec.regress      bbtree.regress   besselk.regress \
     binary.regress    bini.regress     biquat.regress \
     bop.regress       bstree.regress   bouquet.regress \
     bug100.regress    bug101.regress \
@@ -527,7 +527,7 @@ FILES= ${OUT}/algaggr.input  ${OUT}/algbrbf.input    ${OUT}/algfacob.input \
        ${OUT}/asinatan.input ${OUT}/asinhatanh.input \
        ${OUT}/assign.input   ${OUT}/atansqrt.input   ${OUT}/axiom.input \
        ${OUT}/asec.input \
-       ${OUT}/bags.input     ${OUT}/bbtree.input     ${OUT}/besselk.input \
+       ${OUT}/bbtree.input     ${OUT}/besselk.input \
        ${OUT}/bern.input \
        ${OUT}/bernpoly.input ${OUT}/binary.input     ${OUT}/bini.input \
        ${OUT}/biquat.input   ${OUT}/bop.input \
@@ -739,7 +739,7 @@ DOCFILES= \
   ${DOC}/asec.input.dvi        ${DOC}/asinatan.input.dvi   \
   ${DOC}/asinhatanh.input.dvi \
   ${DOC}/assign.input.dvi      ${DOC}/atansqrt.input.dvi   \
-  ${DOC}/axiom.input.dvi       ${DOC}/bags.input.dvi       \
+  ${DOC}/axiom.input.dvi       \
   ${DOC}/bbtree.input.dvi      ${DOC}/besselk.input.dvi    \
   ${DOC}/bern.input.dvi       \
   ${DOC}/bernpoly.input.dvi    ${DOC}/binary.input.dvi     \



From MAILER-DAEMON Sat Feb 28 01:18:33 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LdIWu-0007KS-GX
	for mharc-axiom-developer@gnu.org; Sat, 28 Feb 2009 01:18:32 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LdIWq-0007IZ-Jr
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 01:18:28 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LdIWk-0007Fs-VA
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 01:18:27 -0500
Received: from [199.232.76.173] (port=39542 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LdIWk-0007Fi-EC
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 01:18:22 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:58593
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LdIWj-00042X-0d
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 01:18:21 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1S6IHug027112;
	Sat, 28 Feb 2009 00:18:17 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1S6IFKQ027103;
	Sat, 28 Feb 2009 00:18:15 -0600
Date: Sat, 28 Feb 2009 00:18:15 -0600
Message-Id: <200902280618.n1S6IFKQ027103@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: Liu Xiaojun <tigertooth4@gmail.com>
Subject: [Axiom-developer] 20090227.01.lxx.patch (Liu Xiaojun: Document
	UnivariateSkewPolynomial)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 28 Feb 2009 06:18:29 -0000

Liu Xiaojun's documentation for UnivariateSkewPolynomial was added to:

  Book Volume 0:    Jenks book
    add new domain example

  Book Volume 7.1:  Axiom Hyperdoc Pages
    add new hyperdoc page

  Book Volume 10.3: Axiom Domains
    add regression test
    add help pages

==========================================================================
diff --git a/books/bookvol0.pamphlet b/books/bookvol0.pamphlet
index b7f869d..cbe733b 100644
--- a/books/bookvol0.pamphlet
+++ b/books/bookvol0.pamphlet
@@ -48744,6 +48744,481 @@ page~\pageref{MultivariatePolynomialXmpPage}, and
 \ref{DistributedMultivariatePolynomialXmpPage} on 
 page~\pageref{DistributedMultivariatePolynomialXmpPage}.
 
+\section{UnivariateSkewPolynomial}
+\label{UnivariateSkewPolynomial}
+Skew or Ore polynomial rings provide a unified framework to
+compute with differential and difference equations.
+
+In the following, let A be an integral domain, equipped with two
+endomorphisms $\sigma$ and $\delta$ where:
+\begin{itemize}
+\item $\sigma$: A $->$ A is an injective ring endomorphism
+\item $\delta$: A $->$ A, the pseudo-derivation with respect to $\sigma$, 
+is an additive endomorphism with 
+$$
+     \delta(ab) = \sigma(a)\delta(b) + \delta(a)b
+$$    
+for all $a,b$ in A
+\end{itemize}
+
+The skew polynomial ring $[\Delta;\sigma,\delta]$ is the ring of 
+polynomials in $\Delta$ with coefficients in A, with the usual addition,
+while the product is given by
+$$
+ \Delta a = \sigma(a)\Delta + \delta(a)\quad{}{\rm\ for\ a\ in\ A}
+$$
+The two most important examples of skew polynomial rings are:
+\begin{itemize}
+\item $K(x)[D,1,\delta]$, where 1 is the identity on $K$ and $\delta$ is 
+the usual derviative, is the ring of differential polynomials
+\item $K_n [E,n,\mapsto n+1,0]$ is the ring of linear recurrence operators
+with polynomial coefficients
+\end{itemize}
+
+The UnivariateSkewPolynomialCategory (OREPCAT) provides a unified
+framework for polynomial rings in a non-central indeterminate over
+some coefficient ring R. The commutation relations between the
+indeterminate $x$ and the coefficient $t$ is given by 
+$$ 
+x r = \sigma(r) x + \delta(r)
+$$
+where $\sigma$ is a ring endomorphism of R
+and $\delta$ is a $\sigma$-derivation of R
+which is an additive map from R to R such that
+$$  
+\delta(rs) = \sigma(r) \delta(s) + \delta(r) s
+$$
+In case $\sigma$ is the identity map on R, a $\sigma$-derivation of R
+is just called a derivation. Here are some examples
+
+We start with a linear ordinary differential operator. First, we
+define the coefficient ring to be expressions in one variable $x$
+with fractional coefficients:
+
+\spadcommand{F:=EXPR(FRAC(INT))}
+
+Define Dx to be a derivative d/dx:
+
+\spadcommand{Dx:F->F:=f+->D(f,['x])}
+
+Define a skew polynomial ring over F with identity endomorphism as
+$\sigma$ and derivation d/dx as $\delta$:
+
+\spadcommand{D0:=OREUP('d,F,1,Dx)}
+
+\spadcommand{u:D0:=(operator 'u)(x)}
+$$
+u 
+\left(
+{x} 
+\right)
+$$
+
+\spadcommand{d:D0:='d}
+$$
+d 
+$$
+
+\spadcommand{a:D0:=u**3*d**3+u**2*d**2+u*d+1}
+$$
+{{{u 
+\left(
+{x} 
+\right)}^3}
+\  {d^3}}+{{{u 
+\left(
+{x} 
+\right)}^2}
+\  {d^2}}+{{u 
+\left(
+{x} 
+\right)}
+\  d}+1 
+$$
+
+\spadcommand{b:D0:=(u+1)*d**2+2*d}
+$$
+{{\left( {u 
+\left(
+{x} 
+\right)}+1
+\right)}
+\  {d^2}}+{2 \  d} 
+$$
+
+\spadcommand{r:=rightDivide(a,b)}
+$$
+\left[
+\begin{array}{c}
+\displaystyle
+{quotient={{{ \frac{{{u 
+\left(
+{x} 
+\right)}^3}}{{{u
+\left(
+{x} 
+\right)}+1}}}
+\  d}+{ \frac{{-{{{u 
+\left(
+{x} 
+\right)}^3}
+\  {{u \sb {{\ }} \sp {,}} 
+\left(
+{x} 
+\right)}}
+-{{u 
+\left(
+{x} 
+\right)}^3}+{{u
+\left(
+{x} 
+\right)}^2}}}{{{{u
+\left(
+{x} 
+\right)}^2}+{2
+\  {u 
+\left(
+{x} 
+\right)}}+1}}}}},\\
+\displaystyle
+\: {remainder={{{ \frac{{{2 \  {{u 
+\left(
+{x} 
+\right)}^3}
+\  {{u \sb {{\ }} \sp {,}} 
+\left(
+{x} 
+\right)}}+{3
+\  {{u 
+\left(
+{x} 
+\right)}^3}}+{u
+\left(
+{x} 
+\right)}}}{{{{u
+\left(
+{x} 
+\right)}^2}+{2
+\  {u 
+\left(
+{x} 
+\right)}}+1}}}
+\  d}+1}}
+\end{array}
+\right]
+$$
+
+\spadcommand{r.quotient}
+$$
+{{ \frac{{{u 
+\left(
+{x} 
+\right)}^3}}{{{u
+\left(
+{x} 
+\right)}+1}}}
+\  d}+{ \frac{{-{{{u 
+\left(
+{x} 
+\right)}^3}
+\  {{u \sb {{\ }} \sp {,}} 
+\left(
+{x} 
+\right)}}
+-{{u 
+\left(
+{x} 
+\right)}^3}+{{u
+\left(
+{x} 
+\right)}^2}}}{{{{u
+\left(
+{x} 
+\right)}^2}+{2
+\  {u 
+\left(
+{x} 
+\right)}}+1}}}
+$$
+
+\spadcommand{r.remainder}
+$$
+{{ \frac{{{2 \  {{u 
+\left(
+{x} 
+\right)}^3}
+\  {{u \sb {{\ }} \sp {,}} 
+\left(
+{x} 
+\right)}}+{3
+\  {{u 
+\left(
+{x} 
+\right)}^3}}+{u
+\left(
+{x} 
+\right)}}}{{{{u
+\left(
+{x} 
+\right)}^2}+{2
+\  {u 
+\left(
+{x} 
+\right)}}+1}}}
+\  d}+1 
+$$
+
+\subsection{A second example}
+)clear all
+ 
+As a second example, we consider the so-called Weyl algebra.
+
+Define the coefficient ring to be an ordinary polynomial over integers
+in one variable $t$
+\begin{verbatim}
+   R:=UP('t,INT)
+\end{verbatim}
+Define a skew polynomial ring over R with identity map as $\sigma$
+and derivation d/dt as $\delta$. The resulting algebra is then called
+a Weyl algebra. This is a simple ring over a division ring that is
+non-commutative, similar to the ring of matrices.
+
+\spadcommand{R:=UP('t,INT)}
+
+\spadcommand{W:=OREUP('x,R,1,D)}
+
+\spadcommand{t:W:='t}
+$$
+t 
+$$
+
+\spadcommand{x:W:='x}
+$$
+x 
+$$
+
+Let 
+
+\spadcommand{a:W:=(t-1)*x**4+(t**3+3*t+1)*x**2+2*t*x+t**3}
+$$
+{{\left( t -1 
+\right)}
+\  {x^4}}+{{\left( {t^3}+{3 \  t}+1 
+\right)}
+\  {x^2}}+{2 \  t \  x}+{t^3} 
+$$
+
+\spadcommand{b:W:=(6*t**4+2*t**2)*x**3+3*t**2*x**2}
+$$
+{{\left( {6 \  {t^4}}+{2 \  {t^2}} 
+\right)}
+\  {x^3}}+{3 \  {t^2} \  {x^2}} 
+$$
+
+Then
+
+\spadcommand{a*b}
+$$
+\begin{array}{l}
+{{\left( {6 \  {t^5}} -{6 \  {t^4}}+{2 \  {t^3}} -{2 \  {t^2}} 
+\right)}
+\  {x^7}}+{{\left( {{96} \  {t^4}} -{{93} \  {t^3}}+{{13} \  {t^2}} -{{16} \  
+t} 
+\right)}
+\  {x^6}}+\\
+{{\left( {6 \  {t^7}}+{{20} \  {t^5}}+{6 \  {t^4}}+{{438} \  {t^3}} 
+-{{406} \  {t^2}} -{24} 
+\right)}
+\  {x^5}}+\\
+{{\left( {{48} \  {t^6}}+{{15} \  {t^5}}+{{152} \  {t^4}}+{{61} \  
+{t^3}}+{{603} \  {t^2}} -{{532} \  t} -{36} 
+\right)}
+\  {x^4}}+\\
+{{\left( {6 \  {t^7}}+{{74} \  {t^5}}+{{60} \  {t^4}}+{{226} \  
+{t^3}}+{{116} \  {t^2}}+{{168} \  t} -{140} 
+\right)}
+\  {x^3}}+\\
+{{\left( {3 \  {t^5}}+{6 \  {t^3}}+{{12} \  {t^2}}+{{18} \  t}+6 
+\right)}
+\  {x^2}} 
+\end{array}
+$$
+
+\spadcommand{a**3}
+$$
+\begin{array}{l}
+{{\left( {t^3} -{3 \  {t^2}}+{3 \  t} -1 
+\right)}
+\  {x^{12}}}+{{\left( {3 \  {t^5}} -{6 \  {t^4}}+{{12} \  {t^3}} -{{15} \  
+{t^2}}+{3 \  t}+3 
+\right)}
+\  {x^{10}}}+\\
+{{\left( {6 \  {t^3}} -{{12} \  {t^2}}+{6 \  t} 
+\right)}
+\  {x^9}}+{{\left( {3 \  {t^7}} -{3 \  {t^6}}+{{21} \  {t^5}} -{{18} \  
+{t^4}}+{{24} \  {t^3}} -{9 \  {t^2}} -{{15} \  t} -3 
+\right)}
+\  {x^8}}+\\
+{{\left( {{12} \  {t^5}} -{{12} \  {t^4}}+{{36} \  {t^3}} -{{24} \  
+{t^2}} -{{12} \  t} 
+\right)}
+\  {x^7}}+\\
+{{\left( {t^9}+{{15} \  {t^7}} -{3 \  {t^6}}+{{45} \  {t^5}}+{6 \  
+{t^4}}+{{36} \  {t^3}}+{{15} \  {t^2}}+{9 \  t}+1 
+\right)}
+\  {x^6}}+\\
+{{\left( {6 \  {t^7}}+{{48} \  {t^5}}+{{54} \  {t^3}}+{{36} \  
+{t^2}}+{6 \  t} 
+\right)}
+\  {x^5}}+\\
+{{\left( {3 \  {t^9}}+{{21} \  {t^7}}+{3 \  {t^6}}+{{39} \  
+{t^5}}+{{18} \  {t^4}}+{{39} \  {t^3}}+{{12} \  {t^2}} 
+\right)}
+\  {x^4}}+\\
+{{\left( {{12} \  {t^7}}+{{36} \  {t^5}}+{{12} \  {t^4}}+{8 \  
+{t^3}} 
+\right)}
+\  {x^3}}+\\
+{{\left( {3 \  {t^9}}+{9 \  {t^7}}+{3 \  {t^6}}+{{12} \  {t^5}} 
+\right)}
+\  {x^2}}+{6 \  {t^7} \  x}+{t^9} 
+\end{array}
+$$
+
+
+\subsection{A third example}
+)clear all
+
+As a third example, we construct a difference operator algebra over
+the ring of EXPR(INT) by using an automorphism S defined by a
+``shift'' operation S:EXPR(INT) $->$ EXPR(INT)
+$$
+   s(e)(n) = e(n+1)
+$$
+and an S-derivation defined by DF:EXPR(INT) $->$ EXPR(INT) as
+$$
+   DF(e)(n) = e(n+1)-e(n)
+$$
+Define S to be a ``shift'' operator, which acts on expressions with 
+the discrete variable $n$:
+
+\spadcommand{S:EXPR(INT)->EXPR(INT):=e+->eval(e,[n],[n+1])}
+
+Define DF to be a ``difference'' operator, which acts on expressions
+with a discrete variable $n$:
+
+\spadcommand{DF:EXPR(INT)->EXPR(INT):=e+->eval(e,[n],[n+1])-e}
+
+Then define the difference operator algebra D0:
+
+\spadcommand{D0:=OREUP('D,EXPR(INT),morphism S,DF)}
+
+\spadcommand{u:=(operator 'u)[n]}
+$$
+u 
+\left(
+{n} 
+\right)
+$$
+
+\spadcommand{L:D0:='D+u}
+$$
+D+{u 
+\left(
+{n} 
+\right)}
+$$
+
+\spadcommand{L**2}
+$$
+{D^2}+{2 \  {u 
+\left(
+{n} 
+\right)}
+\  D}+{{u 
+\left(
+{n} 
+\right)}^2}
+$$
+
+\subsection{A fourth example}
+)clear all
+
+As a fourth example, we construct a skew polynomial ring by using an
+inner derivation $\delta$ induced by a fixed $y$ in R:
+$$
+   \delta(r) = yr - ry
+$$
+First we should expose the constructor SquareMatrix so it is visible
+in the interpreter:
+\begin{verbatim}
+)set expose add constructor SquareMatrix
+\end{verbatim}
+
+Define R to be the square matrix with integer entries:
+
+\spadcommand{R:=SQMATRIX(2,INT)}
+$$
+SquareMatrix(2,Integer) 
+$$
+
+\spadcommand{y:R:=matrix [ [1,1],[0,1] ]}
+$$
+\left[
+\begin{array}{cc}
+1 & 1 \\ 
+0 & 1 
+\end{array}
+\right]
+$$
+
+Define the inner derivative $\delta$:
+
+\spadcommand{delta:R->R:=r+->y*r-r*y}
+
+Define S to be a skew polynomial determined by $\sigma = 1$
+and $\delta$ as an inner derivative:
+
+\spadcommand{S:=OREUP('x,R,1,delta)}
+
+\spadcommand{x:S:='x}
+$$
+x 
+$$
+
+\spadcommand{a:S:=matrix [[2,3],[1,1]]}
+$$
+\left[
+\begin{array}{cc}
+2 & 3 \\ 
+1 & 1 
+\end{array}
+\right]
+$$
+
+\spadcommand{x**2*a}
+$$
+{{\left[ 
+\begin{array}{cc}
+2 & 3 \\ 
+1 & 1 
+\end{array}
+\right]}
+\  {x^2}}+{{\left[ 
+\begin{array}{cc}
+2 & -2 \\ 
+0 & -2 
+\end{array}
+\right]}
+\  x}+{\left[ 
+\begin{array}{cc}
+0 & -2 \\ 
+0 & 0 
+\end{array}
+\right]}
+$$
+
+
 \section{UniversalSegment}
 \label{UniversalSegmentXmpPage}
 
diff --git a/books/bookvol10.3.pamphlet b/books/bookvol10.3.pamphlet
index edfdf79..2972ab5 100644
--- a/books/bookvol10.3.pamphlet
+++ b/books/bookvol10.3.pamphlet
@@ -8219,83 +8219,32 @@ Automorphism(R:Ring): Join(Group, Eltable(R, R)) with
 )clear all
 --S 1
 lm := [3,5,7,11]
---R 
---R
---R   (1)  [3,5,7,11]
---R                                                   Type: List PositiveInteger
 --E 1
 
---S 2
-modTree(12,lm)
---R 
---R
---R   (2)  [0,2,5,1]
---R                                                           Type: List Integer
---E 2
-
 --S 3
 t := balancedBinaryTree(#lm, 0)
---R 
---R
---R   (3)  [[0,0,0],0,[0,0,0]]
---R                                  Type: BalancedBinaryTree NonNegativeInteger
 --E 3
 
 --S 4
 setleaves!(t,lm)
---R 
---R
---R   (4)  [[3,0,5],0,[7,0,11]]
---R                                  Type: BalancedBinaryTree NonNegativeInteger
 --E 4
 
 --S 5
 mapUp!(t,_*)
---R 
---R
---R   (5)  1155
---R                                                        Type: PositiveInteger
 --E 5
 
 --S 6
 t
---R 
---R
---R   (6)  [[3,15,5],1155,[7,77,11]]
---R                                  Type: BalancedBinaryTree NonNegativeInteger
 --E 6
 
 --S 7
 mapDown!(t,12,_rem)
---R 
---R
---R   (7)  [[0,12,2],12,[5,12,1]]
---R                                  Type: BalancedBinaryTree NonNegativeInteger
 --E 7
 
 --S 8
 leaves %
---R 
---R
---R   (8)  [0,2,5,1]
---R                                                Type: List NonNegativeInteger
 --E 8
 
---S 9
-squares := [x**2 rem m for x in % for m in lm]
---R 
---R
---R   (9)  [0,4,4,1]
---R                                                Type: List NonNegativeInteger
---E 9
-
---S 10
-chineseRemainder(%,lm)
---R 
---R
---R   (10)  144
---R                                                        Type: PositiveInteger
---E 10
 )spool
 )lisp (bye)
 @
@@ -105537,6 +105486,683 @@ UnivariatePuiseuxSeriesWithExponentialSingularity(R,FE,var,cen):_
 @
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{domain OREUP UnivariateSkewPolynomial}
+<<UnivariateSkewPolynomial.input>>=
+)sys rm -f UnivariateSkewPolynomial.output
+)spool UnivariateSkewPolynomial.output
+)set message test on
+)set message auto off
+)set message type off
+)clear all
+
+--S 1 of 33
+F:=EXPR(FRAC(INT))
+--R 
+--R
+--R   (1)  Expression Fraction Integer
+--E 1
+
+--S 2 of 33
+Dx:F->F:=f+->D(f,['x])
+--R 
+--R
+--R   (2)  theMap(Closure)
+--E 2
+
+--S 3 of 33
+D0:=OREUP('d,F,1,Dx)
+--R 
+--R
+--R   (3)
+--I  UnivariateSkewPolynomial(d,Expression Fraction Integer,R -> R,theMap LAMBDA-C
+--I  LOSURE(NIL,NIL,NIL,G9057 envArg,SPADCALL(G9057,coerceOrCroak(CONS(QUOTE List 
+--I  Variable x,wrap LIST QUOTE x),QUOTE List Symbol,QUOTE *1;anonymousFunction;2;
+--I  frame0;internal),ELT(*1;anonymousFunction;2;frame0;internal;MV,0))))
+--E 3
+
+--S 4 of 33
+u:D0:=(operator 'u)(x)
+--R 
+--R
+--R   (4)  u(x)
+--E 4
+
+--S 5 of 33
+d:D0:='d
+--R 
+--R
+--R   (5)  d
+--E 5
+
+--S 6 of 33
+a:D0:=u^3*d^3+u^2*d^2+u*d+1
+--R 
+--R
+--R            3 3       2 2
+--R   (6)  u(x) d  + u(x) d  + u(x)d + 1
+--E 6
+
+--S 7 of 33
+b:D0:=(u+1)*d^2+2*d
+--R 
+--R
+--R                   2
+--R   (7)  (u(x) + 1)d  + 2d
+--E 7
+
+--S 8 of 33
+r:=rightDivide(a,b)
+--R 
+--R
+--R   (8)
+--R                                 3 ,          3       2
+--R                    3      - u(x) u (x) - u(x)  + u(x)
+--R                u(x)
+--R   [quotient= -------- d + ----------------------------,
+--R              u(x) + 1               2
+--R                                 u(x)  + 2u(x) + 1
+--R                    3 ,           3
+--R               2u(x) u (x) + 3u(x)  + u(x)
+--R
+--R    remainder= --------------------------- d + 1]
+--R                        2
+--R                    u(x)  + 2u(x) + 1
+--E 8
+
+--S 9 of 33
+r.quotient
+--R 
+--R
+--R                           3 ,          3       2
+--R              3      - u(x) u (x) - u(x)  + u(x)
+--R          u(x)
+--R   (9)  -------- d + ----------------------------
+--R        u(x) + 1               2
+--R                           u(x)  + 2u(x) + 1
+--E 9
+
+--S 10 of 33
+r.remainder
+--R 
+--R
+--R              3 ,           3
+--R         2u(x) u (x) + 3u(x)  + u(x)
+--R
+--R   (10)  --------------------------- d + 1
+--R                  2
+--R              u(x)  + 2u(x) + 1
+--E 10
+
+)clear all
+ 
+--S 11 of 33
+R:=UP('t,INT)
+--R 
+--R
+--R   (1)  UnivariatePolynomial(t,Integer)
+--E 11
+
+--S 12 of 33
+W:=OREUP('x,R,1,D)
+--R 
+--R
+--R   (2)
+--R  UnivariateSkewPolynomial(x,UnivariatePolynomial(t,Integer),R -> R,theMap(DIFR
+--I  ING-;D;2S;1,411))
+--E 12
+
+--S 13 of 33
+t:W:='t
+--R 
+--R
+--R   (3)  t
+--E 13
+
+--S 14 of 33
+x:W:='x
+--R 
+--R
+--R   (4)  x
+--E 14
+
+--S 15 of 33
+a:W:=(t-1)*x^4+(t^3+3*t+1)*x^2+2*t*x+t^3
+--R 
+--R
+--R                4     3           2           3
+--R   (5)  (t - 1)x  + (t  + 3t + 1)x  + 2t x + t
+--E 15
+
+--S 16 of 33
+b:W:=(6*t^4+2*t^2)*x^3+3*t^2*x^2
+--R 
+--R
+--R           4     2  3     2 2
+--R   (6)  (6t  + 2t )x  + 3t x
+--E 16
+
+--S 17 of 33
+a*b
+--R 
+--R
+--R   (7)
+--R        5     4     3     2  7       4      3      2        6
+--R     (6t  - 6t  + 2t  - 2t )x  + (96t  - 93t  + 13t  - 16t)x
+--R   + 
+--R        7      5     4       3       2       5
+--R     (6t  + 20t  + 6t  + 438t  - 406t  - 24)x
+--R   + 
+--R         6      5       4      3       2              4
+--R     (48t  + 15t  + 152t  + 61t  + 603t  - 532t - 36)x
+--R   + 
+--R        7      5      4       3       2               3
+--R     (6t  + 74t  + 60t  + 226t  + 116t  + 168t - 140)x
+--R   + 
+--R        5     3      2            2
+--R     (3t  + 6t  + 12t  + 18t + 6)x
+--E 17
+
+--S 18 of 33
+a^3
+--R 
+--R
+--R   (8)
+--R       3     2           12      5     4      3      2           10
+--R     (t  - 3t  + 3t - 1)x   + (3t  - 6t  + 12t  - 15t  + 3t + 3)x
+--R   + 
+--R        3      2       9      7     6      5      4      3     2            8
+--R     (6t  - 12t  + 6t)x  + (3t  - 3t  + 21t  - 18t  + 24t  - 9t  - 15t - 3)x
+--R   + 
+--R         5      4      3      2        7
+--R     (12t  - 12t  + 36t  - 24t  - 12t)x
+--R   + 
+--R       9      7     6      5     4      3      2           6
+--R     (t  + 15t  - 3t  + 45t  + 6t  + 36t  + 15t  + 9t + 1)x
+--R   + 
+--R        7      5      3      2       5
+--R     (6t  + 48t  + 54t  + 36t  + 6t)x
+--R   + 
+--R        9      7     6      5      4      3      2  4
+--R     (3t  + 21t  + 3t  + 39t  + 18t  + 39t  + 12t )x
+--R   + 
+--R         7      5      4     3  3      9     7     6      5  2     7     9
+--R     (12t  + 36t  + 12t  + 8t )x  + (3t  + 9t  + 3t  + 12t )x  + 6t x + t
+--E 18
+
+)clear all
+ 
+--S 19 of 33
+S:EXPR(INT)->EXPR(INT):=e+->eval(e,[n],[n+1])
+--R 
+--R
+--R   (1)  theMap(Closure)
+--E 19
+
+--S 20 of 33
+DF:EXPR(INT)->EXPR(INT):=e+->eval(e,[n],[n+1])-e
+--R 
+--R
+--R   (2)  theMap(Closure)
+--E 20
+
+--S 21 of 33
+D0:=OREUP('D,EXPR(INT),morphism S,DF)
+--R 
+--R
+--R   (3)
+--I  UnivariateSkewPolynomial(D,Expression Integer,R -> R,theMap LAMBDA-CLOSURE(NI
+--I  L,NIL,NIL,G9384 envArg,SPADCALL(SPADCALL(G9384,coerceOrCroak(CONS(QUOTE List 
+--I  Variable n,wrap LIST QUOTE n),QUOTE List Expression Integer,QUOTE *1;anonymou
+--I  sFunction;9;frame0;internal),coerceOrCroak(CONS(QUOTE List Polynomial Integer
+--I  ,wrap LIST SPADCALL(QUOTE 1(n,1 0),QUOTE 0,ELT(*1;anonymousFunction;9;frame0;
+--I  internal;MV,0))),QUOTE List Expression Integer,QUOTE *1;anonymousFunction;9;f
+--I  rame0;internal),ELT(*1;anonymousFunction;9;frame0;internal;MV,1)),G9384,ELT(*
+--I  1;anonymousFunction;9;frame0;internal;MV,2))))
+--E 21
+
+--S 22 of 33
+u:=(operator 'u)[n]
+--R 
+--R
+--R   (4)  u(n)
+--E 22
+
+--S 23 of 33
+L:D0:='D+u
+--R 
+--R
+--R   (5)  D + u(n)
+--E 23
+
+--S 24 of 33
+L^2
+--R 
+--R
+--R         2                2
+--R   (6)  D  + 2u(n)D + u(n)
+--E 24
+
+)clear all
+ 
+--S 25 of 33
+)set expose add constructor SquareMatrix
+--R 
+--I   SquareMatrix is now explicitly exposed in frame frame0 
+--E 25
+
+--S 26 of 33
+R:=SQMATRIX(2,INT)
+--R 
+--R
+--R   (1)  SquareMatrix(2,Integer)
+--E 26
+
+--S 27 of 33
+y:R:=matrix [[1,1],[0,1]]
+--R 
+--R
+--R        +1  1+
+--R   (2)  |    |
+--R        +0  1+
+--E 27
+
+--S 28 of 33
+delta:R->R:=r+->y*r-r*y
+--R 
+--R
+--R   (3)  theMap(Closure)
+--E 28
+
+--S 29 of 33
+S:=OREUP('x,R,1,delta)
+--R 
+--R
+--R   (4)
+--I  UnivariateSkewPolynomial(x,SquareMatrix(2,Integer),R -> R,theMap LAMBDA-CLOSU
+--I  RE(NIL,NIL,NIL,G9459 envArg,SPADCALL(SPADCALL(getValueFromEnvironment(QUOTE y
+--I  ,QUOTE SquareMatrix(2,Integer)),G9459,ELT(*1;anonymousFunction;13;frame0;inte
+--I  rnal;MV,0)),SPADCALL(G9459,getValueFromEnvironment(QUOTE y,QUOTE SquareMatrix
+--I  (2,Integer)),ELT(*1;anonymousFunction;13;frame0;internal;MV,0)),ELT(*1;anonym
+--I  ousFunction;13;frame0;internal;MV,1))))
+--E 29
+
+--S 30 of 33
+x:S:='x
+--R 
+--R
+--R   (5)  x
+--E 30
+
+--S 31 of 33
+a:S:=matrix [[2,3],[1,1]]
+--R 
+--R
+--R        +2  3+
+--R   (6)  |    |
+--R        +1  1+
+--E 31
+
+--S 32 of 33
+x^2*a
+--R 
+--R
+--R        +2  3+ 2   +2  - 2+    +0  - 2+
+--R   (7)  |    |x  + |      |x + |      |
+--R        +1  1+     +0  - 2+    +0   0 +
+--E 32
+
+--S 33 of 33
+)show UnivariateSkewPolynomial
+--R 
+--R UnivariateSkewPolynomial(x: Symbol,R: Ring,sigma: Automorphism R,delta: (R -> R))  is a domain constructor
+--R Abbreviation for UnivariateSkewPolynomial is OREUP 
+--R This constructor is not exposed in this frame.
+--R Issue )edit bookvol10.3.spad.pamphlet to see algebra source code for OREUP 
+--R
+--R------------------------------- Operations --------------------------------
+--R ?*? : (R,%) -> %                      ?*? : (%,R) -> %
+--R ?*? : (%,%) -> %                      ?*? : (Integer,%) -> %
+--R ?*? : (PositiveInteger,%) -> %        ?**? : (%,PositiveInteger) -> %
+--R ?+? : (%,%) -> %                      ?-? : (%,%) -> %
+--R -? : % -> %                           ?=? : (%,%) -> Boolean
+--R 1 : () -> %                           0 : () -> %
+--R ?^? : (%,PositiveInteger) -> %        apply : (%,R,R) -> R
+--R coefficients : % -> List R            coerce : Variable x -> %
+--R coerce : R -> %                       coerce : Integer -> %
+--R coerce : % -> OutputForm              degree : % -> NonNegativeInteger
+--R hash : % -> SingleInteger             latex : % -> String
+--R leadingCoefficient : % -> R           one? : % -> Boolean
+--R recip : % -> Union(%,"failed")        reductum : % -> %
+--R retract : % -> R                      sample : () -> %
+--R zero? : % -> Boolean                  ?~=? : (%,%) -> Boolean
+--R ?*? : (NonNegativeInteger,%) -> %
+--R ?**? : (%,NonNegativeInteger) -> %
+--R ?^? : (%,NonNegativeInteger) -> %
+--R characteristic : () -> NonNegativeInteger
+--R coefficient : (%,NonNegativeInteger) -> R
+--R coerce : Fraction Integer -> % if R has RETRACT FRAC INT
+--R content : % -> R if R has GCDDOM
+--R exquo : (%,R) -> Union(%,"failed") if R has INTDOM
+--R leftDivide : (%,%) -> Record(quotient: %,remainder: %) if R has FIELD
+--R leftExactQuotient : (%,%) -> Union(%,"failed") if R has FIELD
+--R leftExtendedGcd : (%,%) -> Record(coef1: %,coef2: %,generator: %) if R has FIELD
+--R leftGcd : (%,%) -> % if R has FIELD
+--R leftLcm : (%,%) -> % if R has FIELD
+--R leftQuotient : (%,%) -> % if R has FIELD
+--R leftRemainder : (%,%) -> % if R has FIELD
+--R minimumDegree : % -> NonNegativeInteger
+--R monicLeftDivide : (%,%) -> Record(quotient: %,remainder: %) if R has INTDOM
+--R monicRightDivide : (%,%) -> Record(quotient: %,remainder: %) if R has INTDOM
+--R monomial : (R,NonNegativeInteger) -> %
+--R primitivePart : % -> % if R has GCDDOM
+--R retract : % -> Fraction Integer if R has RETRACT FRAC INT
+--R retract : % -> Integer if R has RETRACT INT
+--R retractIfCan : % -> Union(R,"failed")
+--R retractIfCan : % -> Union(Fraction Integer,"failed") if R has RETRACT FRAC INT
+--R retractIfCan : % -> Union(Integer,"failed") if R has RETRACT INT
+--R rightDivide : (%,%) -> Record(quotient: %,remainder: %) if R has FIELD
+--R rightExactQuotient : (%,%) -> Union(%,"failed") if R has FIELD
+--R rightExtendedGcd : (%,%) -> Record(coef1: %,coef2: %,generator: %) if R has FIELD
+--R rightGcd : (%,%) -> % if R has FIELD
+--R rightLcm : (%,%) -> % if R has FIELD
+--R rightQuotient : (%,%) -> % if R has FIELD
+--R rightRemainder : (%,%) -> % if R has FIELD
+--R subtractIfCan : (%,%) -> Union(%,"failed")
+--R
+--E 33
+)set expose drop constructor SquareMatrix
+
+)spool
+)lisp (bye)
+ 
+@
+<<UnivariateSkewPolynomial.help>>=
+====================================================================
+UnivariateSkewPolynomial examples
+====================================================================
+
+Skew or Ore polynomial rings provide a unified framework to
+compute with differential and difference equations.
+
+In the following, let A be an integral domain, equipped with two
+endomorphisms \sigma and \delta where:
+
+ \sigma: A -> A is an injective ring endomorphism
+ \delta: A -> A, the pseudo-derivation with respect to \sigma, 
+         is an additive endomorphism with 
+
+     \delta(ab) = \sigma(a)\delta(b) + \delta(a)b
+    
+         for all a,b in A
+
+Note that in the domains and categories below, these properties are
+not checked.
+
+The skew polynomial ring [\Delta;\sigma,\delta] is the ring of 
+polynomials in \Delta with coefficients in A, with the usual addition,
+while the product is given by
+
+ \Delta a = \sigma(a)\Delta + \delta(a) for a in A
+
+The two most important examples of skew polynomial rings are:
+
+  K(x)[D,1,\delta], where 1 is the identity on K and \delta is 
+                    the usual derviative, is the ring of differential
+                    polynomials
+
+  K [E,n,\mapsto n+1,0] is the ring of linear recurrence operators
+   n                    with polynomial coefficients
+
+
+_____________________________________________________________________
+
+For example, 
+
+The UnivariateSkewPolynomialCategory (OREPCAT) provides a unified
+framework for polynomial rings in a non-central indeterminate over
+some coefficient ring R. The commutation relations between the
+indeterminate x and the coefficient t is given by 
+
+   x r = \sigma(r) x + \delta(r)
+
+where \sigma is a ring endomorphism of R
+and   \delta is a \sigma-derivation of R
+which is an additive map from R to R such that
+  
+   \delta(rs) = \sigma(r) \delta(s) + \delta(r) s
+
+In case \sigma is the identity map on R, a \sigma-derivation of R
+is just called a derivation. Here are some examples
+
+We start with a linear ordinary differential operator. First, we
+define the coefficient ring to be expressions in one variable x
+with fractional coefficients:
+
+   F:=EXPR(FRAC(INT))
+
+Define Dx to be a derivative d/dx:
+
+   Dx:F->F:=f+->D(f,['x])
+
+Define a skew polynomial ring over F with identity endomorphism as
+\sigma and derivation d/dx as \delta:
+
+   D0:=OREUP('d,F,1,Dx)
+
+   u:D0:=(operator 'u)(x)
+
+   d:D0:='d
+
+   a:D0:=u^3*d^3+u^2*d^2+u*d+1
+
+            3 3       2 2
+        u(x) d  + u(x) d  + u(x)d + 1
+
+   b:D0:=(u+1)*d^2+2*d
+
+                   2
+        (u(x) + 1)d  + 2d
+
+   r:=rightDivide(a,b)
+
+                                 3 ,          3       2
+                    3      - u(x) u (x) - u(x)  + u(x)
+                u(x)
+   [quotient= -------- d + ----------------------------,
+              u(x) + 1               2
+                                 u(x)  + 2u(x) + 1
+                    3 ,           3
+               2u(x) u (x) + 3u(x)  + u(x)
+
+    remainder= --------------------------- d + 1]
+                        2
+                    u(x)  + 2u(x) + 1
+
+
+   r.quotient
+
+                           3 ,          3       2
+              3      - u(x) u (x) - u(x)  + u(x)
+          u(x)
+        -------- d + ----------------------------
+        u(x) + 1               2
+                           u(x)  + 2u(x) + 1
+
+
+   r.remainder
+
+              3 ,           3
+         2u(x) u (x) + 3u(x)  + u(x)
+
+         --------------------------- d + 1
+                  2
+              u(x)  + 2u(x) + 1
+
+
+_____________________________________________________________________
+
+   )clear all
+
+As a second example, we consider the so-called Weyl algebra.
+
+Define the coefficient ring to be an ordinary polynomial over integers
+in one variable t
+ 
+   R:=UP('t,INT)
+
+Define a skew polynomial ring over R with identity map as \sigma
+and derivation d/dt as \delta. The resulting algebra is then called
+a Weyl algebra. This is a simple ring over a division ring that is
+non-commutative, similar to the ring of matrices.
+
+   W:=OREUP('x,R,1,D)
+
+   t:W:='t
+
+   x:W:='x
+
+Let 
+
+   a:W:=(t-1)*x^4+(t^3+3*t+1)*x^2+2*t*x+t^3
+
+                4     3           2           3
+        (t - 1)x  + (t  + 3t + 1)x  + 2t x + t
+
+   b:W:=(6*t^4+2*t^2)*x^3+3*t^2*x^2
+
+           4     2  3     2 2
+        (6t  + 2t )x  + 3t x
+
+Then
+
+   a*b
+           5     4     3     2  7       4      3      2        6
+        (6t  - 6t  + 2t  - 2t )x  + (96t  - 93t  + 13t  - 16t)x
+      + 
+           7      5     4       3       2       5
+        (6t  + 20t  + 6t  + 438t  - 406t  - 24)x
+      + 
+            6      5       4      3       2              4
+        (48t  + 15t  + 152t  + 61t  + 603t  - 532t - 36)x
+      + 
+           7      5      4       3       2               3
+        (6t  + 74t  + 60t  + 226t  + 116t  + 168t - 140)x
+      + 
+           5     3      2            2
+        (3t  + 6t  + 12t  + 18t + 6)x
+
+   a^3
+         3     2           12      5     4      3      2           10
+       (t  - 3t  + 3t - 1)x   + (3t  - 6t  + 12t  - 15t  + 3t + 3)x
+     + 
+          3      2       9      7     6      5      4      3     2            8
+       (6t  - 12t  + 6t)x  + (3t  - 3t  + 21t  - 18t  + 24t  - 9t  - 15t - 3)x
+     + 
+           5      4      3      2        7
+       (12t  - 12t  + 36t  - 24t  - 12t)x
+     + 
+         9      7     6      5     4      3      2           6
+       (t  + 15t  - 3t  + 45t  + 6t  + 36t  + 15t  + 9t + 1)x
+     + 
+          7      5      3      2       5
+       (6t  + 48t  + 54t  + 36t  + 6t)x
+     + 
+          9      7     6      5      4      3      2  4
+       (3t  + 21t  + 3t  + 39t  + 18t  + 39t  + 12t )x
+     + 
+           7      5      4     3  3      9     7     6      5  2     7     9
+       (12t  + 36t  + 12t  + 8t )x  + (3t  + 9t  + 3t  + 12t )x  + 6t x + t
+
+
+_____________________________________________________________________
+
+   )clear all 
+
+As a third example, we construct a difference operator algebra over
+the ring of EXPR(INT) by using an automorphism S defined by a
+"shift" operation S:EXPR(INT) -> EXPR(INT)
+
+   s(e)(n) = e(n+1)
+
+and an S-derivation defined by DF:EXPR(INT) -> EXPR(INT) as
+
+   DF(e)(n) = e(n+1)-e(n)
+
+Define S to be a "shift" operator, which acts on expressions with 
+the discrete variable n:
+
+   S:EXPR(INT)->EXPR(INT):=e+->eval(e,[n],[n+1])
+
+Define DF to be a "difference" operator, which acts on expressions
+with a discrete variable n:
+
+   DF:EXPR(INT)->EXPR(INT):=e+->eval(e,[n],[n+1])-e
+
+Then define the difference operator algebra D0:
+
+   D0:=OREUP('D,EXPR(INT),morphism S,DF)
+
+   u:=(operator 'u)[n]
+
+   L:D0:='D+u
+
+        D + u(n)
+
+   L^2
+
+         2                2
+        D  + 2u(n)D + u(n)
+
+_____________________________________________________________________
+
+   )clear all
+
+As a fourth example, we construct a skew polynomial ring by using an
+inner derivation \delta induced by a fixed y in R:
+
+   \delta(r) = yr - ry
+
+First we should expose the constructor SquareMatrix so it is visible
+in the interpreter:
+
+   )set expose add constructor SquareMatrix
+
+Define R to be the square matrix with integer entries:
+
+   R:=SQMATRIX(2,INT)
+
+   y:R:=matrix [[1,1],[0,1]]
+        +1  1+
+        |    |
+        +0  1+
+
+Define the inner derivative \delta:
+
+   delta:R->R:=r+->y*r-r*y
+
+Define S to be a skew polynomial determined by \sigma = 1
+and \delta as an inner derivative:
+
+   S:=OREUP('x,R,1,delta)
+
+   x:S:='x
+
+   a:S:=matrix [[2,3],[1,1]]
+        +2  3+
+        |    |
+        +1  1+
+
+   x^2*a
+        +2  3+ 2   +2  - 2+    +0  - 2+
+        |    |x  + |      |x + |      |
+        +1  1+     +0  - 2+    +0   0 +
+
+
+See Also:
+o )show UnivariateSkewPolynomial
+o )show UnivariateSkewPolynomialCategory
+o )show SquareMatrix
+
+@
 \pagehead{UnivariateSkewPolynomial}{OREUP}
 \pagepic{ps/v103univariateskewpolynomial.ps}{OREUP}{1.00}
 {\bf See}\\
@@ -105604,7 +106230,7 @@ UnivariatePuiseuxSeriesWithExponentialSingularity(R,FE,var,cen):_
 ++   This is the domain of univariate skew polynomials over an Ore
 ++   coefficient field in a named variable.
 ++   The multiplication is given by \spad{x a = \sigma(a) x + \delta a}.
-UnivariateSkewPolynomial(x:Symbol, R:Ring, sigma:Automorphism R, delta: R -> R):
+UnivariateSkewPolynomial(x:Symbol,R:Ring,sigma:Automorphism R,delta: R -> R):
  UnivariateSkewPolynomialCategory R with
    coerce: Variable x -> %
      ++ coerce(x) returns x as a skew-polynomial.
diff --git a/books/bookvol7.1.pamphlet b/books/bookvol7.1.pamphlet
index e82869c..997c780 100644
--- a/books/bookvol7.1.pamphlet
+++ b/books/bookvol7.1.pamphlet
@@ -48292,6 +48292,10 @@ Multiple variable polynomials, recursive structure.
 {DistributedMultivariatePolyXmpPage}
 \newline
 Multiple variable polynomials, non-recursive structure.
+\menulink{UnivariateSkewPolynomial}
+{UnivariateSkewPolynomial}
+\newline
+Skew or Ore polynomials
 \endmenu
 \endscroll
 \autobuttons
@@ -60140,6 +60144,315 @@ Type: UnivariatePolynomial(b1,Fraction Polynomial Integer)
 \end{paste}\end{patch}
 
 @
+\section{oreup.ht}
+\pagehead{UnivariateSkewPolyXmpPage}{up.ht}{UnivariateSkewPolynomial}
+<<oreup.ht>>=
+\begin{page}{UnivariateSkewPolyXmpPage}{UnivariateSkewPolynomial}
+\beginscroll
+
+Skew or Ore polynomial rings provide a unified framework to
+compute with differential and difference equations.
+\newline
+In the following, let A be an integral domain, equipped with two
+endomorphisms \sigma and \delta where:
+\blankline
+\begin{items}
+\item \sigma: A -> A is an injective ring endomorphism
+\item \delta: A -> A, the pseudo-derivation with respect to 
+\sigma, is an additive endomorphism with 
+\blankline
+\delta(ab) = \sigma(a)\delta(b) + \delta(a)b
+\blankline
+for all a,b in A
+\end{items}
+\blankline
+The skew polynomial ring 
+[\Delta;\sigma,\delta] is the ring of 
+polynomials in \delta with coefficients in A, with the 
+usual addition, while the product is given by
+\blankline
+\delta a = \sigma(a)\delta + \delta(a) for a in A
+\blankline
+The two most important examples of skew polynomial rings are:
+\blankline
+K(x)[D,1,\delta]
+\blankline
+where 1 is the identity on K and \texht{$\delta$}{delta} is 
+the usual derviative, is the ring of differential polynomials
+\blankline
+  \subscriptIt{K}{n} [E,n,n->n+1,0] 
+\blankline
+is the ring of linear recurrence operators with polynomial coefficients
+
+\horizontalline
+The UnivariateSkewPolynomialCategory (OREPCAT) provides a unified
+framework for polynomial rings in a non-central indeterminate over
+some coefficient ring R. The commutation relations between the
+indeterminate x and the coefficient t is given by 
+\blankline
+   x r = \sigma(r) x + \delta(r)
+\blankline
+where \sigma is a ring endomorphism of R
+and   \delta is a \sigma-derivation of R
+which is an additive map from R to R such that
+\blankline
+   \delta(rs) = \sigma(r) \delta(s) + \delta(r) s
+\blankline
+In case \sigma is the identity map on R, a \sigma-derivation of R
+is just called a derivation. 
+\blankline
+We start with a linear ordinary differential operator. First, we
+define the coefficient ring to be expressions in one variable x
+with fractional coefficients:
+\blankline
+   F := EXPR(FRAC(INT))
+\blankline
+Define Dx to be a derivative d/dx:
+\blankline
+   Dx: F->F := f+->D(f,['x])
+\blankline
+Define a skew polynomial ring over F with identity endomorphism as
+\sigma and derivation d/dx as \delta:
+\begin{verbatim}
+   D0 := OREUP('d,F,1,Dx)
+\end{verbatim}
+\begin{verbatim}
+   u:D0 := (operator 'u)(x)
+\end{verbatim}
+\begin{verbatim}
+   d:D0 := 'd
+\end{verbatim}
+\begin{verbatim}
+   a:D0:=u^3*d^3+u^2*d^2+u*d+1
+
+            3 3       2 2
+        u(x) d  + u(x) d  + u(x)d + 1
+\end{verbatim}
+\begin{verbatim}
+   b:D0:=(u+1)*d^2+2*d
+
+                   2
+        (u(x) + 1)d  + 2d
+\end{verbatim}
+\begin{verbatim}
+   r:=rightDivide(a,b)
+
+                                 3 ,          3       2
+                    3      - u(x) u (x) - u(x)  + u(x)
+                u(x)
+   [quotient= -------- d + ----------------------------,
+              u(x) + 1               2
+                                 u(x)  + 2u(x) + 1
+                    3 ,           3
+               2u(x) u (x) + 3u(x)  + u(x)
+
+    remainder= --------------------------- d + 1]
+                        2
+                    u(x)  + 2u(x) + 1
+
+\end{verbatim}
+\begin{verbatim}
+   r.quotient
+
+                           3 ,          3       2
+              3      - u(x) u (x) - u(x)  + u(x)
+          u(x)
+        -------- d + ----------------------------
+        u(x) + 1               2
+                           u(x)  + 2u(x) + 1
+
+\end{verbatim}
+\begin{verbatim}
+   r.remainder
+
+              3 ,           3
+         2u(x) u (x) + 3u(x)  + u(x)
+
+         --------------------------- d + 1
+                  2
+              u(x)  + 2u(x) + 1
+\end{verbatim}
+
+\horizontalline
+
+   )clear all
+\blankline
+As a second example, we consider the so-called Weyl algebra.
+\blankline
+Define the coefficient ring to be an ordinary polynomial over integers
+in one variable t
+\blankline
+\begin{verbatim}
+   R := UP('t,INT)
+\end{verbatim}
+\blankline
+Define a skew polynomial ring over R with identity map as 
+\sigma
+and derivation d/dt as \delta. 
+The resulting algebra is then called a Weyl algebra:
+\blankline
+\begin{verbatim}
+   W := OREUP('x,R,1,D)
+
+   t:W := 't
+
+   x:W := 'x
+\end{verbatim}
+\blankline
+Let 
+\begin{verbatim}
+   a:W:=(t-1)*x^4+(t^3+3*t+1)*x^2+2*t*x+t^3
+
+                4     3           2           3
+        (t - 1)x  + (t  + 3t + 1)x  + 2t x + t
+\end{verbatim}
+\begin{verbatim}
+   b:W:=(6*t^4+2*t^2)*x^3+3*t^2*x^2
+
+           4     2  3     2 2
+        (6t  + 2t )x  + 3t x
+\end{verbatim}
+\blankline
+Then
+\begin{verbatim}
+   a*b
+           5     4     3     2  7       4      3      2        6
+        (6t  - 6t  + 2t  - 2t )x  + (96t  - 93t  + 13t  - 16t)x
+      + 
+           7      5     4       3       2       5
+        (6t  + 20t  + 6t  + 438t  - 406t  - 24)x
+      + 
+            6      5       4      3       2              4
+        (48t  + 15t  + 152t  + 61t  + 603t  - 532t - 36)x
+      + 
+           7      5      4       3       2               3
+        (6t  + 74t  + 60t  + 226t  + 116t  + 168t - 140)x
+      + 
+           5     3      2            2
+        (3t  + 6t  + 12t  + 18t + 6)x
+
+   a^3
+         3     2           12      5     4      3      2           10
+       (t  - 3t  + 3t - 1)x   + (3t  - 6t  + 12t  - 15t  + 3t + 3)x
+     + 
+          3      2       9      7     6      5      4      3     2            8
+       (6t  - 12t  + 6t)x  + (3t  - 3t  + 21t  - 18t  + 24t  - 9t  - 15t - 3)x
+     + 
+           5      4      3      2        7
+       (12t  - 12t  + 36t  - 24t  - 12t)x
+     + 
+         9      7     6      5     4      3      2           6
+       (t  + 15t  - 3t  + 45t  + 6t  + 36t  + 15t  + 9t + 1)x
+     + 
+          7      5      3      2       5
+       (6t  + 48t  + 54t  + 36t  + 6t)x
+     + 
+          9      7     6      5      4      3      2  4
+       (3t  + 21t  + 3t  + 39t  + 18t  + 39t  + 12t )x
+     + 
+           7      5      4     3  3      9     7     6      5  2     7     9
+       (12t  + 36t  + 12t  + 8t )x  + (3t  + 9t  + 3t  + 12t )x  + 6t x + t
+\end{verbatim}
+
+\horizontalline
+   )clear all 
+\blankline
+As a third example, we construct a difference operator algebra over
+the ring of EXPR(INT) by using an automorphism S defined by a
+"shift" operation S:EXPR(INT) -> EXPR(INT)
+\blankline
+\begin{verbatim}
+   s(e)(n) = e(n+1)
+\end{verbatim}
+\blankline
+and an S-derivation defined by DF:EXPR(INT) -> EXPR(INT) as
+\blankline
+\begin{verbatim}
+   DF(e)(n) = e(n+1)-e(n)
+\end{verbatim}
+\blankline
+Define S to be a "shift" operator, which acts on expressions with 
+the discrete variable n:
+\blankline
+\begin{verbatim}
+   S:EXPR(INT)->EXPR(INT):=e+->eval(e,[n],[n+1])
+\end{verbatim}
+\blankline
+Define DF to be a "difference" operator, which acts on expressions
+with a discrete variable n:
+\blankline
+\begin{verbatim}
+   DF:EXPR(INT)->EXPR(INT):=e+->eval(e,[n],[n+1])-e
+\end{verbatim}
+\blankline
+Then define the difference operator algebra D0:
+\blankline
+\begin{verbatim}
+   D0:=OREUP('D,EXPR(INT),morphism S,DF)
+
+   u:=(operator 'u)[n]
+
+   L:D0:='D+u
+
+        D + u(n)
+
+   L^2
+
+         2                2
+        D  + 2u(n)D + u(n)
+\end{verbatim}
+
+\horizontalline
+   )clear all
+\blankline
+As a fourth example, we construct a skew polynomial ring by using an
+inner derivation \delta induced by a fixed y in R:
+\blankline
+   \delta(r) = yr - ry
+\blankline
+First we should expose the constructor SquareMatrix so it is visible
+in the interpreter:
+\blankline
+   )set expose add constructor SquareMatrix
+\blankline
+Define R to be the square matrix with integer entries:
+\blankline
+\begin{verbatim}
+   R:=SQMATRIX(2,INT)
+
+   y:R:=matrix [[1,1],[0,1]]
+        +1  1+
+        |    |
+        +0  1+
+\end{verbatim}
+\blankline
+Define the inner derivative \delta:
+\blankline
+   delta:R->R:=r+->y*r-r*y
+\blankline
+Define S to be a skew polynomial determined by \sigma = 1
+and \delta as an inner derivative:
+\blankline
+\begin{verbatim}
+   S:=OREUP('x,R,1,delta)
+
+   x:S:='x
+
+   a:S:=matrix [[2,3],[1,1]]
+        +2  3+
+        |    |
+        +1  1+
+
+   x^2*a
+        +2  3+ 2   +2  - 2+    +0  - 2+
+        |    |x  + |      |x + |      |
+        +1  1+     +0  - 2+    +0   0 +
+\end{verbatim}
+\endscroll
+\autobuttons
+\end{page}
+
+@
 \section{vector.ht}
 \pagehead{VectorXmpPage}{vector.ht}{Vector}
 \pageto{notitle}{OneDimensionalArrayXmpPage}
@@ -61071,6 +61384,7 @@ Type: List WuWenTsunTriangularSet(Integer,IndexedExponents OrderedVariableList [
 \pageto{TextFile}{TextFileXmpPage}
 \pageto{TwoDimensionalArray}{TwoDimensionalArrayXmpPage}
 \pageto{UnivariatePolynomial}{UnivariatePolyXmpPage}
+\pageto{UnivariateSkewPolynomial}{UnivariateSkewPolyXmpPage}
 \pageto{UniversalSegment}{UniversalSegmentXmpPage}
 \pageto{Vector}{VectorXmpPage}
 \pageto{Void}{VoidXmpPage}
@@ -61177,6 +61491,7 @@ Click on any item below to see that section.
 { \downlink{TextFile}{TextFileXmpPage} }
 { \downlink{TwoDimensionalArray}{TwoDimensionalArrayXmpPage} }
 { \downlink{UnivariatePolynomial}{UnivariatePolyXmpPage} }
+{ \downlink{UnivariateSkewPolynomial}{UnivariateSkewPolyXmpPage} }
 { \downlink{UniversalSegment}{UniversalSegmentXmpPage} }
 { \downlink{Vector}{VectorXmpPage} }
 { \downlink{Void}{VoidXmpPage} }
@@ -187623,6 +187938,7 @@ RootPage
         PolynomialXmpPage
         MultivariatePolyXmpPage
         DistributedMultivariatePolyXmpPage
+      UnivariateSkewPolynomialPage
       UniversalSegmentXmpPage
         SegmentXmpPage
         SegmentBindingXmpPage
diff --git a/changelog b/changelog
index eec4e31..cdca04a 100644
--- a/changelog
+++ b/changelog
@@ -1,4 +1,9 @@
-20090226 tpd src/axiom-website/patches.html 20090225.02.mxr.patch
+20090227 tpd src/axiom-website/patches.html 20090227.01.lxx.patch
+20090227 lxx src/algebra/Makefile document UnivariateSkewPolynomial
+20090227 tpd books/bookvol0 add UnivariateSkewPolynomial
+20090227 lxx books/bookvol10.3 document UnivariateSkewPolynomial
+20090227 lxx books/bookvol7.1 document UnivariateSkewPolynomial
+20090226 tpd src/axiom-website/patches.html 20090226.01.mxr.patch
 20090226 tpd src/input/bags.input removed. distributed into bookvol10.3
 20090226 tpd src/input/Makefile remove bags.input
 20090225 tpd src/axiom-website/patches.html 20090225.02.mxr.patch
diff --git a/src/algebra/Makefile.pamphlet b/src/algebra/Makefile.pamphlet
index 2c80c0c..bd760c9 100644
--- a/src/algebra/Makefile.pamphlet
+++ b/src/algebra/Makefile.pamphlet
@@ -16488,6 +16488,7 @@ SPADHELP=\
  ${HELP}/StringTable.help            ${HELP}/Symbol.help \
  ${HELP}/Table.help                  ${HELP}/TextFile.help \
  ${HELP}/TwoDimensionalArray.help    ${HELP}/TwoDimensionalViewport.help \
+ ${HELP}/UnivariateSkewPolynomial.help \
  ${HELP}/UnivariatePolynomial.help   ${HELP}/UniversalSegment.help \
  ${HELP}/Vector.help                 ${HELP}/Void.help \
  ${HELP}/WuWenTsunTriangularSet.help ${HELP}/XPBWPolynomial.help \
@@ -16557,7 +16558,7 @@ REGRESS=\
  Stream.regress                 String.regress \
  StringTable.regress            Symbol.regress \
  Table.regress                  TextFile.regress \
- TwoDimensionalArray.regress \
+ TwoDimensionalArray.regress    UnivariateSkewPolynomial.regress \
  UnivariatePolynomial.regress   UniversalSegment.regress \
  Vector.regress                 Void.regress \
  WuWenTsunTriangularSet.regress XPBWPolynomial.regress \
@@ -17569,6 +17570,18 @@ ${HELP}/UnivariatePolynomial.help: ${BOOKS}/bookvol10.3.pamphlet
             >${INPUT}/UnivariatePolynomial.input
 	@echo "UnivariatePolynomial (UP)" >>${HELPFILE}
 
+${HELP}/UnivariateSkewPolynomial.help: ${BOOKS}/bookvol10.3.pamphlet
+	@echo 7095 create UnivariateSkewPolynomial.help from \
+           ${BOOKS}/bookvol10.3.pamphlet
+	@${TANGLE} -R"UnivariateSkewPolynomial.help" \
+          ${BOOKS}/bookvol10.3.pamphlet \
+           >${HELP}/UnivariateSkewPolynomial.help
+	@cp ${HELP}/UnivariateSkewPolynomial.help ${HELP}/OREUP.help
+	@${TANGLE} -R"UnivariateSkewPolynomial.input" \
+           ${BOOKS}/bookvol10.3.pamphlet \
+            >${INPUT}/UnivariateSkewPolynomial.input
+	@echo "UnivariateSkewPolynomial (OREUP)" >>${HELPFILE}
+
 ${HELP}/UniversalSegment.help: ${BOOKS}/bookvol10.3.pamphlet
 	@echo 7096 create UniversalSegment.help from \
            ${BOOKS}/bookvol10.3.pamphlet
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 9f1bebb..ef940f5 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -971,5 +971,7 @@ bookvol10.3 add regression, help, examples for Heap<br/>
 bookvol10.3 add regression, help, examples for NottinghamGroup<br/>
 <a href="patches/20090226.01.mxr.patch">20090226.01.mxr.patch</a>
 input/Makefile remove bags.input<br/>
+<a href="patches/20090227.01.lxx.patch">20090227.01.lxx.patch</a>
+bookvol10.3 document UnivariateSkewPolynomial<br/>
  </body>
 </html>
diff --git a/src/input/bags.input.pamphlet b/src/input/bags.input.pamphlet
deleted file mode 100644
index f253093..0000000
--- a/src/input/bags.input.pamphlet
+++ /dev/null
@@ -1,383 +0,0 @@
-\documentclass{article}
-\usepackage{axiom}
-\begin{document}
-\title{\$SPAD/src/input bags.input}
-\author{Timothy Daly}
-\maketitle
-\begin{abstract}
-\end{abstract}
-\eject
-\tableofcontents
-\eject
-\section{License}
-<<license>>=
---Copyright The Numerical Algorithms Group Limited 1991.
-@
-<<*>>=
-)spool bags.output
-)set message test on
-)set message auto off
-)clear all
-
---S 1 of 44
-a:Stack INT:= stack [1,2,3,4,5]
---R 
---R
---R   (1)  [1,2,3,4,5]
---R                                                          Type: Stack Integer
---E 1
-
---S 2 of 44
-pop! a
---R 
---R
---R   (2)  1
---R                                                        Type: PositiveInteger
---E 2
-
---S 3 of 44
-a
---R 
---R
---R   (3)  [2,3,4,5]
---R                                                          Type: Stack Integer
---E 3
-
---S 4 of 44
-push!(9,a)
---R 
---R
---R   (4)  9
---R                                                        Type: PositiveInteger
---E 4
-
---S 5 of 44
-a
---R 
---R
---R   (5)  [9,2,3,4,5]
---R                                                          Type: Stack Integer
---E 5
-
---S 6 of 44
-empty? a
---R 
---R
---R   (6)  false
---R                                                                Type: Boolean
---E 6
-
---S 7 of 44
-b:=empty()$(Stack INT)
---R 
---R
---R   (7)  []
---R                                                          Type: Stack Integer
---E 7
-
---S 8 of 44
-empty? b
---R 
---R
---R   (8)  true
---R                                                                Type: Boolean
---E 8
-
---S 9 of 44
-c:ArrayStack INT:= arrayStack [1,2,3,4,5]
---R 
---R
---R   (9)  [1,2,3,4,5]
---R                                                     Type: ArrayStack Integer
---E 9
-
---S 10 of 44
-pop! c
---R 
---R
---R   (10)  5
---R                                                        Type: PositiveInteger
---E 10
-
---S 11 of 44
-c
---R 
---R
---R   (11)  [1,2,3,4]
---R                                                     Type: ArrayStack Integer
---E 11
-
---S 12 of 44
-push!(9,c)
---R 
---R
---R   (12)  9
---R                                                        Type: PositiveInteger
---E 12
-
---S 13 of 44
-c
---R 
---R
---R   (13)  [9,1,2,3,4]
---R                                                     Type: ArrayStack Integer
---E 13
-
---S 14 of 44
-empty? c
---R 
---R
---R   (14)  false
---R                                                                Type: Boolean
---E 14
-
---S 15 of 44
-d:=empty()$(ArrayStack INT)
---R 
---R
---R   (15)  []
---R                                                     Type: ArrayStack Integer
---E 15
-
---S 16 of 44
-empty? d
---R 
---R
---R   (16)  true
---R                                                                Type: Boolean
---E 16
-
---S 17 of 44
-e:Queue INT:= queue [1,2,3,4,5]
---R 
---R
---R   (17)  [1,2,3,4,5]
---R                                                          Type: Queue Integer
---E 17
-
---S 18 of 44
-dequeue! e
---R 
---R
---R   (18)  1
---R                                                        Type: PositiveInteger
---E 18
-
---S 19 of 44
-e
---R 
---R
---R   (19)  [2,3,4,5]
---R                                                          Type: Queue Integer
---E 19
-
---S 20 of 44
-enqueue!(9,e)
---R 
---R
---R   (20)  9
---R                                                        Type: PositiveInteger
---E 20
-
---S 21 of 44
-e
---R 
---R
---R   (21)  [2,3,4,5,9]
---R                                                          Type: Queue Integer
---E 21
-
---S 22 of 44
-empty? e
---R 
---R
---R   (22)  false
---R                                                                Type: Boolean
---E 22
-
---S 23 of 44
-f:=empty()$(Queue INT)
---R 
---R
---R   (23)  []
---R                                                          Type: Queue Integer
---E 23
-
---S 24 of 44
-empty? f
---R 
---R
---R   (24)  true
---R                                                                Type: Boolean
---E 24
-
---S 25 of 44
-g:Dequeue INT:= dequeue [1,2,3,4,5]
---R 
---R
---R   (25)  [1,2,3,4,5]
---R                                                        Type: Dequeue Integer
---E 25
-
---S 26 of 44
-extractBottom! g
---R 
---R
---R   (26)  5
---R                                                        Type: PositiveInteger
---E 26
-
---S 27 of 44
-g
---R 
---R
---R   (27)  [1,2,3,4]
---R                                                        Type: Dequeue Integer
---E 27
-
---S 28 of 44
-insertBottom!(9,g)
---R 
---R
---R   (28)  9
---R                                                        Type: PositiveInteger
---E 28
-
---S 29 of 44
-g
---R 
---R
---R   (29)  [1,2,3,4,9]
---R                                                        Type: Dequeue Integer
---E 29
-
---S 30 of 44
-extractTop! g
---R 
---R
---R   (30)  1
---R                                                        Type: PositiveInteger
---E 30
-
---S 31 of 44
-g
---R 
---R
---R   (31)  [2,3,4,9]
---R                                                        Type: Dequeue Integer
---E 31
-
---S 32 of 44
-insertTop!(9,g)
---R 
---R
---R   (32)  9
---R                                                        Type: PositiveInteger
---E 32
-
---S 33 of 44
-g
---R 
---R
---R   (33)  [9,2,3,4,9]
---R                                                        Type: Dequeue Integer
---E 33
-
---S 34 of 44
-empty? g
---R 
---R
---R   (34)  false
---R                                                                Type: Boolean
---E 34
-
---S 35 of 44
-h:=empty()$(Dequeue INT)
---R 
---R
---R   (35)  []
---R                                                        Type: Dequeue Integer
---E 35
-
---S 36 of 44
-empty? h
---R 
---R
---R   (36)  true
---R                                                                Type: Boolean
---E 36
-
---S 37 of 44
-i:Heap INT := bag [1,6,3,7,5,2,4]
---R 
---R
---R   (37)  [7,6,4,1,5,2,3]
---R                                                           Type: Heap Integer
---E 37
-
---S 38 of 44
-insert!(10,i)
---R 
---R
---R   (38)  [10,7,4,6,5,2,3,1]
---R                                                           Type: Heap Integer
---E 38
-
---S 39 of 44
-i
---R 
---R
---R   (39)  [10,7,4,6,5,2,3,1]
---R                                                           Type: Heap Integer
---E 39
-
---S 40 of 44
-max i
---R 
---R
---R   (40)  10
---R                                                        Type: PositiveInteger
---E 40
-
---S 41 of 44
-extract! i
---R 
---R
---R   (41)  10
---R                                                        Type: PositiveInteger
---E 41
-
---S 42 of 44
-i
---R 
---R
---R   (42)  [7,6,4,1,5,2,3]
---R                                                           Type: Heap Integer
---E 42
-
---S 43 of 44
-heapsort x ==
-       empty? x => []
-       cons(extract! x,heapsort x)
---R 
---R                                                                   Type: Void
---E 43
-
---S 44 of 44
-heapsort i
---R 
---R   Compiling function heapsort with type Heap Integer -> List Integer 
---R
---R   (44)  [7,6,5,4,3,2,1]
---R                                                           Type: List Integer
---E 44
-)spool
-)lisp (bye)
- 
-@
-\eject
-\begin{thebibliography}{99}
-\bibitem{1} nothing
-\end{thebibliography}
-\end{document}
- 





From MAILER-DAEMON Sat Feb 28 01:30:11 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LdIiB-0006n4-2e
	for mharc-axiom-developer@gnu.org; Sat, 28 Feb 2009 01:30:11 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LdIi8-0006mv-Uc
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 01:30:09 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LdIi6-0006mV-5s
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 01:30:08 -0500
Received: from [199.232.76.173] (port=35221 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LdIi5-0006mR-RE
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 01:30:05 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:48549
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LdIi5-00055l-B2
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 01:30:05 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1S6U3ug029301;
	Sat, 28 Feb 2009 00:30:03 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1S6U3PG029298;
	Sat, 28 Feb 2009 00:30:03 -0600
Date: Sat, 28 Feb 2009 00:30:03 -0600
Message-Id: <200902280630.n1S6U3PG029298@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090227.02.tpd.patch (bookvol5 remove duplicate
	function)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 28 Feb 2009 06:30:09 -0000

In bookvol5, the function initializeInterpreterFrameRing duplicate was removed.

========================================================================
diff --git a/books/bookvol5.pamphlet b/books/bookvol5.pamphlet
index 2becf4e..850e46d 100644
--- a/books/bookvol5.pamphlet
+++ b/books/bookvol5.pamphlet
@@ -4397,23 +4397,6 @@ updateCurrentInterpreterFrame() ==
   nil)
 
 @
-\subsection{defun initializeInterpreterFrameRing}
-\begin{verbatim}
-initializeInterpreterFrameRing() ==
-  $interpreterFrameName := 'initial
-  $interpreterFrameRing := [emptyInterpreterFrame($interpreterFrameName)]
-  updateFromCurrentInterpreterFrame()
-  NIL
-\end{verbatim}
-<<defun initializeInterpreterFrameRing>>=
-(defun |initializeInterpreterFrameRing| ()
-  (spadlet |$interpreterFrameName| '|initial|)
-  (spadlet |$interpreterFrameRing|
-   (cons (|emptyInterpreterFrame| |$interpreterFrameName|) nil))
-  (|updateFromCurrentInterpreterFrame|)
-  nil)
-
-@
 \subsection{defun nextInterpreterFrame}
 
 This function updates the current frame to make sure all of the
diff --git a/changelog b/changelog
index cdca04a..6fdafc0 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,5 @@
+20090227 tpd src/axiom-website/patches.html 20090227.02.tpd.patch
+20090227 tpd books/bookvol5 remove initializeInterpreterFrameRing duplicate
 20090227 tpd src/axiom-website/patches.html 20090227.01.lxx.patch
 20090227 lxx src/algebra/Makefile document UnivariateSkewPolynomial
 20090227 tpd books/bookvol0 add UnivariateSkewPolynomial
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index ef940f5..11a8e9f 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -973,5 +973,7 @@ bookvol10.3 add regression, help, examples for NottinghamGroup<br/>
 input/Makefile remove bags.input<br/>
 <a href="patches/20090227.01.lxx.patch">20090227.01.lxx.patch</a>
 bookvol10.3 document UnivariateSkewPolynomial<br/>
+<a href="patches/20090227.02.tpd.patch">20090227.02.tpd.patch</a>
+bookvol5 remove duplicate function<br/>
  </body>
 </html>



From MAILER-DAEMON Sat Feb 28 01:59:09 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LdJAD-0005Km-A1
	for mharc-axiom-developer@gnu.org; Sat, 28 Feb 2009 01:59:09 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LdJAB-0005I5-GZ
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 01:59:07 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LdJA9-0005FJ-Qn
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 01:59:06 -0500
Received: from [199.232.76.173] (port=55583 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LdJA9-0005Ew-Li
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 01:59:05 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:54371
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LdJA9-0007XH-3y
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 01:59:05 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1S6wwug001226;
	Sat, 28 Feb 2009 00:59:01 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1S6wv7m001222;
	Sat, 28 Feb 2009 00:58:57 -0600
Date: Sat, 28 Feb 2009 00:58:57 -0600
Message-Id: <200902280658.n1S6wv7m001222@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] Hyperdoc tutorial on making new pages
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 28 Feb 2009 06:59:07 -0000

In Axiom it is easy to develop new pages in hyperdoc.
All of the hyperdoc pages live in bookvol7.1.pamphlet.

The structure of each page, say for the Fantastic domain, consists 
of a few lines of latex followed by a literate chunk. All of the
hyperdoc page information goes into the literate chunk and will
be extracted as a hyperdoc page.

\section{fantastic.ht}  <-- ordinary latex
\pagehead{FantasticPage}{fantastic.ht}{Fantastic} <-- special latex
\pagto{.....            <-- for latex (not hyperdoc) links to other pages
<<fantastic.ht>>=       <-- this is what htadd looks for

   all the documentation for domain Fantastic

@                       <-- this is the end of the page for htadd

When you add new pages to bookvol7.1.pamphlet you need to tell the
system about the changes.  The "htadd" function will search the
bookvol7.1.pamphlet file for chunks with the name "*.ht" and build the
file ht.db.

The ht.db file is used by hyperdoc to find pages. 
Each line in ht.db contains a line that 

FantasticPage (byteIndex) (lineIndex)

So the two critical files, bookvol7.1.pamphlet and ht.db live in $AXIOM/doc


There is a very fast cycle for editing.
cd $AXIOM/doc

while (1) do
   axiom                          <-- at the shell prompt
   (navigate to page in hyperdoc) <-- to check your work
   )lisp (bye)                    <-- at the axiom prompt
   (modify bookvol7.1.pamphlet)   <-- change the page
   rm ht.db                       <-- remove the old database
   htadd bookvol7.1.pamphlet      <-- remake the database

Tim








From MAILER-DAEMON Sat Feb 28 02:27:45 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LdJbt-0004DA-O3
	for mharc-axiom-developer@gnu.org; Sat, 28 Feb 2009 02:27:45 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LdJbs-0004Bw-Rm
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 02:27:44 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LdJbq-00046j-Ko
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 02:27:43 -0500
Received: from [199.232.76.173] (port=40341 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LdJbq-00046Q-E4
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 02:27:42 -0500
Received: from vs338.rosehosting.com ([209.135.140.38]:43321
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LdJbq-0001Pg-53
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 02:27:42 -0500
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id n1S7Rdug006826;
	Sat, 28 Feb 2009 01:27:39 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id n1S7RdAa006820;
	Sat, 28 Feb 2009 01:27:39 -0600
Date: Sat, 28 Feb 2009 01:27:39 -0600
Message-Id: <200902280727.n1S7RdAa006820@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20090227.03.tpd.patch (bookvol4: Hyperdoc
	tutorial)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 28 Feb 2009 07:27:45 -0000

Add the tutorial for making new hyperdoc pages to 
Book Volume 4: Axiom Developers Guide
=======================================================================
diff --git a/books/bookvol4.pamphlet b/books/bookvol4.pamphlet
index 70d411d..d06e4c3 100644
--- a/books/bookvol4.pamphlet
+++ b/books/bookvol4.pamphlet
@@ -4420,6 +4420,53 @@ digraph pic {
 }
 \end{verbatim}
 
+\section{Adding or Editing pages in Hyperdoc}
+In Axiom it is easy to develop new pages in hyperdoc.
+All of the hyperdoc pages live in bookvol7.1.pamphlet.
+
+The structure of each page, say for the Fantastic domain, consists 
+of a few lines of latex followed by a literate chunk. All of the
+hyperdoc page information goes into the literate chunk and will
+be extracted as a hyperdoc page.
+
+\begin{verbatim}
+ \section{fantastic.ht}  <-- ordinary latex
+ \pagehead{FantasticPage}{fantastic.ht}{Fantastic} <-- special latex
+ \pageto{.....           <-- for latex (not hyperdoc) links to other pages
+ <<fantastic.ht>>=       <-- this is what htadd looks for
+
+   all the documentation for domain Fantastic
+
+ @                       <-- this is the end of the page for htadd
+\end{verbatim}
+
+When you add new pages to bookvol7.1.pamphlet you need to tell the
+system about the changes.  The ``htadd'' function will search the
+bookvol7.1.pamphlet file for chunks with the name ``*.ht'' and build the
+file ht.db.
+
+The ht.db file is used by hyperdoc to find pages. 
+Each line in ht.db contains a line that 
+
+\begin{verbatim}
+FantasticPage (byteIndex) (lineIndex)
+\end{verbatim}
+
+So the two critical files, bookvol7.1.pamphlet and ht.db live in \$AXIOM/doc
+
+
+There is a very fast cycle for editing.
+\begin{verbatim}
+cd $AXIOM/doc
+
+while (1) do
+   axiom                          <-- at the shell prompt
+   (navigate to page in hyperdoc) <-- to check your work
+   )lisp (bye)                    <-- at the axiom prompt
+   (modify bookvol7.1.pamphlet)   <-- change the page
+   rm ht.db                       <-- remove the old database
+   htadd bookvol7.1.pamphlet      <-- remake the database
+\end{verbatim}
 \section{Graphviz file creation}
 The graphviz output used on the website is a scaled vector graphics
 file (SVG). The dot command to output this file is:
diff --git a/src/axiom-website/patches.html b/src/axiom-website/patches.html
index 11a8e9f..c029a9f 100644
--- a/src/axiom-website/patches.html
+++ b/src/axiom-website/patches.html
@@ -975,5 +975,7 @@ input/Makefile remove bags.input<br/>
 bookvol10.3 document UnivariateSkewPolynomial<br/>
 <a href="patches/20090227.02.tpd.patch">20090227.02.tpd.patch</a>
 bookvol5 remove duplicate function<br/>
+<a href="patches/20090227.03.tpd.patch">20090227.03.tpd.patch</a>
+bookvol4 Hyperdoc tutorial on making new pages<br/>
  </body>
 </html>



From MAILER-DAEMON Sat Feb 28 10:06:22 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LdQli-0004C0-65
	for mharc-axiom-developer@gnu.org; Sat, 28 Feb 2009 10:06:22 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LdQlf-0004Be-OU
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 10:06:19 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LdQld-0004Ar-Fw
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 10:06:18 -0500
Received: from [199.232.76.173] (port=38789 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LdQld-0004Ao-DU
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 10:06:17 -0500
Received: from mx-8.zoominternet.net ([24.154.1.27]:57284
	helo=cm-2.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1LdQld-0003fH-2F
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 10:06:17 -0500
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=9rZUY6H0CbYA:10 a=XfeEPuNNjv4A:10
	a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=KyrqQq3maK4UE4-WOxkA:9 a=k62DQYR79djRZJCZAlPoVPqdpwgA:4
	a=8b0TY1xhFYQA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.46] ([24.154.1.46:49051] helo=pop-3.zoominternet.net)
	by mx-8.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 49/5B-09796-BD259A94; Sat, 28 Feb 2009 10:06:03 -0500
Received: (qmail 26396 invoked from network); 28 Feb 2009 15:06:06 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-3.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 28 Feb 2009 15:06:06 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id n1SFqJA28535;
	Sat, 28 Feb 2009 10:52:19 -0500
Date: Sat, 28 Feb 2009 10:52:19 -0500
Message-Id: <200902281552.n1SFqJA28535@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: camm@maguirefamily.org
In-reply-to: <87iqmy1fyd.fsf@maguirefamily.org> (message from Camm Maguire on
	Wed, 25 Feb 2009 14:20:26 -0500)
Subject: Re: [Axiom-developer] Re: Debian axiom build failures
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
	<87skm32x6x.fsf_-_@maguirefamily.org>
	<200902250355.n1P3tQm25134@localhost.localdomain>
	<87iqmy1fyd.fsf@maguirefamily.org>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 28 Feb 2009 15:06:19 -0000

Camm,

In the latest version of GCL-2.6.8pre there is a change to the function
READ-CHAR-NO-HANG that seems to break Axiom's new browse function.

Can you tell me what changed?

Tim



From MAILER-DAEMON Sat Feb 28 18:21:00 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LdYUO-0002Wc-DC
	for mharc-axiom-developer@gnu.org; Sat, 28 Feb 2009 18:21:00 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LdYUL-0002Su-69
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 18:20:57 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LdYUH-0002QU-SQ
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 18:20:56 -0500
Received: from [199.232.76.173] (port=56665 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LdYUH-0002QI-KC
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 18:20:53 -0500
Received: from mail10.dslextreme.com ([66.51.199.98]:46399)
	by monty-python.gnu.org with smtp (Exim 4.60)
	(envelope-from <camm@maguirefamily.org>) id 1LdYUG-0003wP-VD
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 18:20:53 -0500
Received: (qmail 6411 invoked from network); 28 Feb 2009 23:20:11 -0000
Received: from unknown (HELO wisdom.m.enhanced.com) (141.150.251.63)
	by mail10.dslextreme.com with (AES256-SHA encrypted) SMTP;
	Sat, 28 Feb 2009 15:20:11 -0800
Received: from love.m.enhanced.com ([192.168.3.9] helo=localhost)
	by wisdom.m.enhanced.com with esmtp (Exim 4.63)
	(envelope-from <camm@maguirefamily.org>)
	id 1LdYTG-0006QI-Ph; Sat, 28 Feb 2009 18:19:50 -0500
Received: from camm by localhost.m.enhanced.com with local (Exim 4.69)
	(envelope-from <camm@maguirefamily.org>)
	id 1LdXVv-0000aN-Tg; Sat, 28 Feb 2009 17:18:31 -0500
To: daly@axiom-developer.org
Subject: Re: [Axiom-developer] Re: Debian axiom build failures
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
	<87skm32x6x.fsf_-_@maguirefamily.org>
	<200902250355.n1P3tQm25134@localhost.localdomain>
	<87iqmy1fyd.fsf@maguirefamily.org>
	<200902281552.n1SFqJA28535@localhost.localdomain>
From: Camm Maguire <camm@maguirefamily.org>
Date: Sat, 28 Feb 2009 17:18:31 -0500
In-Reply-To: <200902281552.n1SFqJA28535@localhost.localdomain> (root's message
	of "Sat\, 28 Feb 2009 10\:52\:19 -0500")
Message-ID: <87eixiryrs.fsf@maguirefamily.org>
User-Agent: Gnus/5.11 (Gnus v5.11) Emacs/22.2 (gnu/linux)
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6 (newer, 3)
Cc: axiom-developer@nongnu.org
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 28 Feb 2009 23:20:57 -0000

Greetings!  We made it ansi compliant -- specifically it ignores
trailing newlines, so that (read-char-no-hang) at the prompt does not
return #\Newline, but rather

(read-char-no-hang)

NIL

>(read-char-no-hang)a

#\a

>

Please let me know if this causes you problems.

Take care,

root <daly@axiom-developer.org> writes:

> Camm,
>
> In the latest version of GCL-2.6.8pre there is a change to the function
> READ-CHAR-NO-HANG that seems to break Axiom's new browse function.
>
> Can you tell me what changed?
>
> Tim
>
>
>
>

-- 
Camm Maguire			     		    camm@maguirefamily.org
==========================================================================
"The earth is but one country, and mankind its citizens."  --  Baha'u'llah



From MAILER-DAEMON Sat Feb 28 18:21:01 2009
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1LdYUO-0002Wu-Lq
	for mharc-axiom-developer@gnu.org; Sat, 28 Feb 2009 18:21:00 -0500
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1LdYUL-0002Sh-40
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 18:20:57 -0500
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1LdYUH-0002QT-Ry
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 18:20:56 -0500
Received: from [199.232.76.173] (port=56664 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1LdYUH-0002QH-KK
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 18:20:53 -0500
Received: from mail10.dslextreme.com ([66.51.199.98]:50359)
	by monty-python.gnu.org with smtp (Exim 4.60)
	(envelope-from <camm@maguirefamily.org>) id 1LdYUG-0003wR-Uw
	for axiom-developer@nongnu.org; Sat, 28 Feb 2009 18:20:53 -0500
Received: (qmail 6405 invoked from network); 28 Feb 2009 23:20:10 -0000
Received: from unknown (HELO wisdom.m.enhanced.com) (141.150.251.63)
	by mail10.dslextreme.com with (AES256-SHA encrypted) SMTP;
	Sat, 28 Feb 2009 15:20:10 -0800
Received: from love.m.enhanced.com ([192.168.3.9] helo=localhost)
	by wisdom.m.enhanced.com with esmtp (Exim 4.63)
	(envelope-from <camm@maguirefamily.org>)
	id 1LdYTG-0006QE-MF; Sat, 28 Feb 2009 18:19:50 -0500
Received: from camm by localhost.m.enhanced.com with local (Exim 4.69)
	(envelope-from <camm@maguirefamily.org>)
	id 1LdXbs-0000b5-LN; Sat, 28 Feb 2009 17:24:40 -0500
To: daly@axiom-developer.org
References: <200812170459.mBH4xOd17234@localhost.localdomain>
	<87eiyd8na4.fsf@maguirefamily.org>
	<200902051354.n15Dsb221922@localhost.localdomain>
	<87iqn41rbp.fsf@maguirefamily.org>
	<200902220708.n1M78vt15122@localhost.localdomain>
	<87vdr1ate8.fsf_-_@maguirefamily.org>
	<200902232250.n1NMoBR23993@localhost.localdomain>
	<87skm32x6x.fsf_-_@maguirefamily.org>
	<200902250355.n1P3tQm25134@localhost.localdomain>
	<200902270047.n1R0lDf26998@localhost.localdomain>
From: Camm Maguire <camm@maguirefamily.org>
Date: Sat, 28 Feb 2009 17:24:40 -0500
In-Reply-To: <200902270047.n1R0lDf26998@localhost.localdomain> (root's message
	of "Thu\, 26 Feb 2009 19\:47\:13 -0500")
Message-ID: <87ab86ryhj.fsf@maguirefamily.org>
User-Agent: Gnus/5.11 (Gnus v5.11) Emacs/22.2 (gnu/linux)
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6 (newer, 3)
Cc: axiom-developer@nongnu.org, gcl-devel@gnu.org
Subject: [Axiom-developer] Re: Debian axiom build failures
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 28 Feb 2009 23:20:57 -0000

Greetings!  This is a broken alternate linking build procedure we
introduced for axiom 2005 on systems where native object relocation is
not yet implemented in GCL.  For 2.6.8pre, this is ia64, hppa, mips,
mipsel, and alpha.  For 2.7.0 just ia64 and hppa remain.
:native-reloc is the relevant feature.  Here is the patch to the
makeint.lisp and makedep.lis stage that we had used, which for some
reason now is missing some file:

--- ./src/interp/Makefile.pamphlet.orig	2009-02-16 20:05:58.000000000 +0000
+++ ./src/interp/Makefile.pamphlet	2009-02-16 20:08:02.000000000 +0000
@@ -571,8 +571,28 @@
 \begin{verbatim}
 <<save depsys image>>=
 	@ (cd ${MNT}/${SYS}/bin ; \
-	   echo '(progn (load "${OUT}/makedep.lisp")' \
-                '(spad-save "${DEPSYS}"))' | ${LISPSYS})
+	   echo '#+native-reloc(progn (load "${OUT}/makedep.lisp") (spad-save "${DEPSYS}"))#-native-reloc(progn\
+			(setq si::*collect-binary-modules* t)\
+			(load "${OUT}/makedep.lisp")\
+			(compiler::link\
+				(remove-duplicates si::*binary-modules* :test (quote equal))\
+				"$(DEPSYS)"\
+				(format nil "\
+					(setq si::*collect-binary-modules* t)\
+					(let ((si::*load-path* (cons ~S si::*load-path*))\
+	                                     (si::*load-types* ~S))\
+						(compiler::emit-fn t))\
+					(load \"$(OUT)/makedep.lisp\")\
+					(gbc t)\
+					(when si::*binary-modules*\
+						(error si::*binary-modules*))\
+					(setq si::collect-binary-modules* nil si::*binary-modules* nil)\
+					(gbc t)\
+					(when (fboundp (quote si::sgc-on)) (si::sgc-on t))\
+					(setq compiler::*default-system-p* t)\
+				" si::*system-directory* (quote (list ".lsp")))\
+				""\
+				nil))' | sed 's,\\$$,,g' | ${LISPSYS})
 @
 \end{verbatim}
 
@@ -901,8 +923,33 @@
 	@ echo '#+:akcl (setq si::*system-directory* "${SPAD}/bin/")' \
                >> ${OUT}/makeint.lisp
 	@ (cd ${OBJ}/${SYS}/bin ; \
-	  echo '(progn (gbc t) (load "${OUT}/makeint.lisp")' \
-                 '(gbc t) (user::spad-save "${SAVESYS}"))' | ${LISPSYS} )
+	  echo '#+native-reloc(progn (gbc t) (setq x si::*system-directory*)(load "${OUT}/makeint.lisp") (setq si::*system-directory* x) (unintern (quote x))(gbc t)(user::spad-save "${SAVESYS}"))#-native-reloc(progn\
+			(setq si::*collect-binary-modules* t)\
+			(setq x si::*system-directory*)\
+			(load "${OUT}/makeint.lisp")\
+			(setq si::*system-directory* x)\
+			(unintern (quote x))\
+			(compiler::link\
+				(remove-duplicates si::*binary-modules* :test (quote equal))\
+				"$(SAVESYS)"\
+				(format nil "\
+					(let ((si::*load-path* (cons ~S si::*load-path*))\
+                                             (si::*load-types* ~S))\
+						(compiler::emit-fn t))\
+					 (setq si::*collect-binary-modules* t)\
+					 (setq x si::*system-directory*)\
+					 (load \"$(OUT)/makeint.lisp\")\
+					 (setq si::*system-directory* x)\
+					 (unintern (quote x))\
+					 (when si::*binary-modules*\
+						(error si::*binary-modules*))\
+					(setq si::collect-binary-modules* nil si::*binary-modules* nil)\
+					(gbc t)\
+					(when (fboundp (quote si::sgc-on)) (si::sgc-on t))\
+					(setq compiler::*default-system-p* t)\
+				" si::*system-directory* (quote (list ".lsp")))\
+			"$(OBJ)/$(SYS)/lib/sockio-c.o $(OBJ)/$(SYS)/lib/cfuns-c.o $(OBJ)/$(SYS)/lib/libspad.a" \
+			nil))' | sed 's,\\$$,,g' | $(LISPSYS))
 	@ echo 6 ${SAVESYS} created
 	@ cp ${SAVESYS} ${AXIOMSYS}
 	@ echo 6a ${AXIOMSYS} created

THere is one other small area where compiler:link is used but I do not
suspect that.  Can you perhaps spot the missing functionality from the
error message, and give me a hint as to what load is missing?
Specifically, the last autoload in the message I originally sent
(preprocess?), seems to be linked into depsys, but not AXIOMsys.
Could be a red herring.

Thanks for any insight.  I'll figure it out if you are busy.

Take care,


root <daly@axiom-developer.org> writes:

> Camm,
>
> I don't understand why you are getting that error.
> Can you do:
>   make clean
>   make NOISE=
> and put the complete console log someplace?
>
> Tim
>
>
>
>
>

-- 
Camm Maguire			     		    camm@maguirefamily.org
==========================================================================
"The earth is but one country, and mankind its citizens."  --  Baha'u'llah



