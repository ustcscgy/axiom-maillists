From MAILER-DAEMON Fri Aug 01 03:38:12 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KOpDI-0001nG-9r
	for mharc-axiom-developer@gnu.org; Fri, 01 Aug 2008 03:38:12 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KOpDG-0001mA-DT
	for axiom-developer@nongnu.org; Fri, 01 Aug 2008 03:38:10 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KOpDE-0001l5-DB
	for axiom-developer@nongnu.org; Fri, 01 Aug 2008 03:38:09 -0400
Received: from [199.232.76.173] (port=44175 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KOpDE-0001l0-9e
	for axiom-developer@nongnu.org; Fri, 01 Aug 2008 03:38:08 -0400
Received: from mx20.gnu.org ([199.232.41.8]:6179)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <martin.rubey@univie.ac.at>)
	id 1KOpDE-0003Hu-C1
	for axiom-developer@nongnu.org; Fri, 01 Aug 2008 03:38:08 -0400
Received: from grace.univie.ac.at ([131.130.3.115])
	by mx20.gnu.org with esmtp (Exim 4.60)
	(envelope-from <martin.rubey@univie.ac.at>) id 1KOodA-0004hb-R7
	for axiom-developer@nongnu.org; Fri, 01 Aug 2008 03:00:53 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=univie.ac.at; s=rev1; h=Sender:To:Cc:Subject:References:From:
	Date:In-Reply-To:Message-ID:MIME-Version:Content-Type; bh=EPQARG
	HpKZ8D/RxH7ZCd/YfUH41YzTgU9oDQOYQDu3Y=; b=YqDJhwSxrT5Bg+on6s2+Bc
	4OKbauglizwXb9dhA2ljGfjwiNugsi14479p3CJwJkpMano25oCPxuMtGEmrC0Nn
	Bc7RhVDmDQQp2axAHj9qco5NTswgzNZRdc7w/b+Fbas6DcQrhtZYEiJxvE7o8JiB
	cywO6nYinA3d+kA4B0BZI=
Received: from joan.univie.ac.at ([131.130.3.110] helo=joan.univie.ac.at)
	by grace.univie.ac.at with esmtp (Exim 4.69)
	(envelope-from <martin.rubey@univie.ac.at>)
	id 1KOod6-0005U8-MA; Fri, 01 Aug 2008 09:00:48 +0200
Received: from aquin.mat.univie.ac.at ([131.130.16.163]
	helo=aquin.mat.univie.ac.at)
	by joan.univie.ac.at with esmtp (Exim 4.69)
	(envelope-from <martin.rubey@univie.ac.at>)
	id 1KOod6-00059L-L6; Fri, 01 Aug 2008 09:00:48 +0200
Sender: rubey@aquin.mat.univie.ac.at
To: Ralf Hemmecke <ralf@hemmecke.de>
References: <489244B8.8010208@hemmecke.de>
From: Martin Rubey <martin.rubey@univie.ac.at>
Date: 01 Aug 2008 09:00:48 +0200
In-Reply-To: <489244B8.8010208@hemmecke.de>
Message-ID: <9q1w19nrrz.fsf@aquin.mat.univie.ac.at>
Lines: 56
User-Agent: Gnus/5.09 (Gnus v5.9.0) Emacs/21.4
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-detected-kernel: by mx20.gnu.org: Linux 2.6, seldom 2.4 (older, 4)
X-detected-kernel: by monty-python.gnu.org: Linux 2.6, seldom 2.4 (older, 4)
Cc: Peter Broadbery <p.broadbery@googlemail.com>,
	fricas-devel <fricas-devel@googlegroups.com>,
	open-axiom-devel <open-axiom-devel@lists.sourceforge.net>,
	axiom-dev <axiom-developer@nongnu.org>
Subject: [Axiom-developer] Re: [open-axiom-devel] AXIOMsys vs depsys
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 01 Aug 2008 07:38:10 -0000

Ralf Hemmecke <ralf@hemmecke.de> writes:

> Dear Peter, dear "whoever knows about the following"
> 
> In src_aldor3 you call $(MNT)/bin/AXIOMsys to generate the dependencies 
> and the .ap files for the Axiom domains.
> 
> Furthermore, I find ${OBJ}/bin/depsys in the Makefile stanza
> 
> $(aldor_lsp_o_files): $(ALDOR_MNT)/lib/%.o: $(ALDOR_INT)/lsp/%.lsp
> 	echo LSP->O: $(notdir $@)
> 	@echo '(progn (load "$(OBJ)/interp/foam_l.o") (compile-file "$(filter 
> %.lsp,$^)" :output-file "$@") (bye))' \
> 		| ${OBJ}/bin/depsys > $(ALDOR_OBJ)/$(notdir $@).log ;
> 	@if test -f $@; then echo "Built $(notdir $@)" ; else cat 
> $(OBJ)/$(SYS)/aldor/build/$(notdir $@).log; false; fi
> 
> 1) What is the difference between AXIOMsys and depsys?

I think that AXIOMsys contains more than depsys, but I don't really know.  In
any case, depsys doesn't start the axiom interpreter, rather it gives you a
lisp prompt right away.  I guess that it's faster to start it.

> 2) Is it safe to call AXIOMsys instead of depsys?

I think so.  I also thought about trying this, because it might imply that we
could generate the interface from a distribution, too.

Martin

martin@rubey-laptop:~/ax-build-speed/build/i686-pc-linux/bin$ time echo ")qu" | ./interpsys
Checking for foreign routines
AXIOM="/home/martin/lib/axiom/target/i686-pc-linux"
spad-lib="/home/martin/lib/axiom/target/i686-pc-linux/lib/libspad.so"
                 FriCAS (AXIOM fork) Computer Algebra System
                         Version: FriCAS 2008-03-29
               Timestamp: Thursday April 3, 2008 at 09:10:03
-----------------------------------------------------------------------------
   Issue )copyright to view copyright notices.
   Issue )summary for a summary of useful system commands.
   Issue )quit to leave FriCAS and return to shell.
-----------------------------------------------------------------------------

   Re-reading compress.daase   Re-reading interp.daase
   Re-reading operation.daase
   Re-reading category.daase
   Re-reading browse.daase
(1) ->
real    0m0.728s
user    0m0.496s
sys     0m0.036s
martin@rubey-laptop:~/ax-build-speed/build/i686-pc-linux/bin$ time echo "(quit)" | ./depsys
*
real    0m0.068s
user    0m0.032s
sys     0m0.004s




From MAILER-DAEMON Fri Aug 01 15:46:50 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KP0aQ-0004ZQ-P4
	for mharc-axiom-developer@gnu.org; Fri, 01 Aug 2008 15:46:50 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KP0aO-0004VH-VY
	for axiom-developer@nongnu.org; Fri, 01 Aug 2008 15:46:49 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KP0aN-0004T2-Vn
	for axiom-developer@nongnu.org; Fri, 01 Aug 2008 15:46:48 -0400
Received: from [199.232.76.173] (port=57485 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KP0aN-0004Sh-RC
	for axiom-developer@nongnu.org; Fri, 01 Aug 2008 15:46:47 -0400
Received: from idcmail-mo2no.shaw.ca ([64.59.134.9]:57359
	helo=pd5mo1no-dmz.prod.shaw.ca)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <awilliamson@mandriva.com>) id 1KP0aN-0006Gq-K1
	for axiom-developer@nongnu.org; Fri, 01 Aug 2008 15:46:47 -0400
Received: from unknown (HELO pd6ml1no-ssvc.prod.shaw.ca) ([10.0.153.160])
	by pd5mo1no-svcs.prod.shaw.ca with ESMTP; 01 Aug 2008 13:46:45 -0600
X-Cloudmark-SP-Filtered: true
X-Cloudmark-SP-Result: v=1.0 c=0 a=FLhA3KDuAAAA:8 a=-XYrsifHZFWnYEcxhdQA:9
	a=qFlTLguX9dTb7fOWV2cA:7 a=nAso0GubTSaDxkZuXUprkvx29V8A:4
	a=sKv9N_OC1u4A:10 a=96gWqFv9ClYA:10
Received: from unknown (HELO lenovo.local.net) ([24.84.172.249])
	by pd6ml1no-dmz.prod.shaw.ca with ESMTP; 01 Aug 2008 13:46:44 -0600
Date: Fri, 1 Aug 2008 12:46:44 -0700
From: Adam Williamson <awilliamson@mandriva.com>
To: axiom-developer@nongnu.org
Message-ID: <20080801124644.02cdcc06@lenovo.local.net>
Organization: Mandriva
X-Mailer: Claws Mail 3.5.0 (GTK+ 2.13.5; i586-mandriva-linux-gnu)
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
X-detected-kernel: by monty-python.gnu.org: Genre and OS details not
	recognized.
Subject: [Axiom-developer] Compile failure on Linux x86-64 (Error 255)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 01 Aug 2008 19:46:49 -0000

Hi, all. I am updating old packages in Mandriva, and I've come to
Axiom. Our current package is for a version from 2005, and doesn't
rebuild cleanly.

I've updated the package to the current Gold release, and it builds
okay (and seems to work, at least as far as I can judge...) on i586.
However, I've had problems on x86-64.

First I ran into the gcl "I am not an object" problem which was
documented on a few lists back in 2007. I worked around this by
replacing the gcl snapshot in Axiom with a bang up to date one from
today (and disabling one Axiom patch that doesn't apply any more). That
gets through that error.

However, now the build fails later on:

44 invoking make in /home/mandrake/rpm/BUILD/axiom/src/boot with parms:
SYS= linux
LSP= /home/mandrake/rpm/BUILD/axiom/lsp
PART= cprogs
SPAD= /home/mandrake/rpm/BUILD/axiom/mnt/linux
SRC= /home/mandrake/rpm/BUILD/axiom/src
INT= /home/mandrake/rpm/BUILD/axiom/int
OBJ= /home/mandrake/rpm/BUILD/axiom/obj
MNT= /home/mandrake/rpm/BUILD/axiom/mnt
make[3]: *** [/home/mandrake/rpm/BUILD/axiom/obj/linux/bin/bootsys]
Error 255 make[3]: Leaving directory
`/home/mandrake/rpm/BUILD/axiom/src/boot' make[2]: *** [bootdir] Error 2
make[2]: Leaving directory `/home/mandrake/rpm/BUILD/axiom/src'
make[1]: *** [srcdir] Error 2
make[1]: Leaving directory `/home/mandrake/rpm/BUILD/axiom'
make: *** [all] Error 2

Does anyone know how this can be fixed? The full build log is here:

http://kenobi.mandriva.com/queue/failure/cooker/contrib/release/20080801190334.adamw.kenobi.7061/log/axiom-3.4-0.20080701.1mdv2009.0/build.0.20080801190655.log

but it'll disappear in a few days. Just to note again, the build works
on i586. So this appears to be x86-64 specific in some way.
-- 
adamw



From MAILER-DAEMON Sun Aug 10 00:21:38 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KS2Qz-0000SX-Oo
	for mharc-axiom-developer@gnu.org; Sun, 10 Aug 2008 00:21:37 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KS2Qx-0000PX-OE
	for axiom-developer@nongnu.org; Sun, 10 Aug 2008 00:21:35 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KS2Qv-0000Lg-UK
	for axiom-developer@nongnu.org; Sun, 10 Aug 2008 00:21:35 -0400
Received: from [199.232.76.173] (port=34305 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KS2Qv-0000LR-N8
	for axiom-developer@nongnu.org; Sun, 10 Aug 2008 00:21:33 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:57631
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KS2Qv-0006S8-Fm
	for axiom-developer@nongnu.org; Sun, 10 Aug 2008 00:21:33 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7A4LTr3000366;
	Sat, 9 Aug 2008 23:21:29 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7A4LTxg000363;
	Sat, 9 Aug 2008 23:21:29 -0500
Date: Sat, 9 Aug 2008 23:21:29 -0500
Message-Id: <200808100421.m7A4LTxg000363@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080802.01.tpd.patch (build ht.db from
	bookvol7.1)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 10 Aug 2008 04:21:35 -0000

There is no reason to extract the pages from the pamphlet file.
Instead we modify the htadd function to use the pamphlet file directly.

With this patch bookvol7.1 replaces all of the .ht files with a
single file. The hyperdoc browser now fetches pages directly from
the pamphlet.

Tim



From MAILER-DAEMON Sun Aug 10 01:55:07 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KS3tS-0007fD-HC
	for mharc-axiom-developer@gnu.org; Sun, 10 Aug 2008 01:55:06 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KS3tP-0007da-3j
	for axiom-developer@nongnu.org; Sun, 10 Aug 2008 01:55:03 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KS3tM-0007dL-Ij
	for axiom-developer@nongnu.org; Sun, 10 Aug 2008 01:55:01 -0400
Received: from [199.232.76.173] (port=35600 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KS3tM-0007dI-FU
	for axiom-developer@nongnu.org; Sun, 10 Aug 2008 01:55:00 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:42976
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KS3tM-00062r-2C
	for axiom-developer@nongnu.org; Sun, 10 Aug 2008 01:55:00 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7A5sur3014405;
	Sun, 10 Aug 2008 00:54:56 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7A5suU0014402;
	Sun, 10 Aug 2008 00:54:56 -0500
Date: Sun, 10 Aug 2008 00:54:56 -0500
Message-Id: <200808100554.m7A5suU0014402@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080809.01.tpd.patch (remove pages subdirectory)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 10 Aug 2008 05:55:03 -0000

Hyperdoc now gets all of its page and patch file information
directly from bookvol7.1.pamphlet. The pages subdirectory is gone.
Since htadd knows how to process pamphlet files directly we no
longer need separate files.

This reduces the number of files by a couple hundred as well as
the time to process the files. The htadd function is much quicker.
In fact, it is so fast that it appears we no longer need to build
the ht.db file at all. However, removing this file will be the
subject of a later update.

The ht.db file is now created in the doc subdirectory.

+20080809 tpd books/bookvol7 remove all references to doc/hypertex
+20080809 tpd src/Makefile stop creating the doc/hypertex/pages subdir
+20080809 tpd src/input/Makefile remove reference to hyperdoc/pages
+20080809 tpd src/share/Makefile remove HYPER variable
+20080808 tpd src/Makefile stop creating hypertex/pages
+20080806 tpd books/bookvol7.1 add paste/patch files
+20080806 tpd books/pages/*.pht embed in bookvol7.1, removed



From MAILER-DAEMON Mon Aug 11 20:11:23 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KShTv-0007Xf-BN
	for mharc-axiom-developer@gnu.org; Mon, 11 Aug 2008 20:11:23 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KShTt-0007V7-HZ
	for axiom-developer@nongnu.org; Mon, 11 Aug 2008 20:11:21 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KShTq-0007Og-7Y
	for axiom-developer@nongnu.org; Mon, 11 Aug 2008 20:11:20 -0400
Received: from [199.232.76.173] (port=33334 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KShTq-0007OL-1r
	for axiom-developer@nongnu.org; Mon, 11 Aug 2008 20:11:18 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:37401
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KShTp-0004Kb-PN
	for axiom-developer@nongnu.org; Mon, 11 Aug 2008 20:11:17 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7C0BEr3018441;
	Mon, 11 Aug 2008 19:11:14 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7C0BEWV018438;
	Mon, 11 Aug 2008 19:11:14 -0500
Date: Mon, 11 Aug 2008 19:11:14 -0500
Message-Id: <200808120011.m7C0BEWV018438@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] Doyen live CD image
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 12 Aug 2008 00:11:21 -0000

Alfredo has created an Ubuntu-based Live CD image of Axiom
for the July 2008 release. It is available from the downloads page:
<http://axiom-developer.org/axiom-website/download.html>

Thanks for this effort.

Tim



From MAILER-DAEMON Thu Aug 14 03:30:31 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KTXHz-00044w-Ai
	for mharc-axiom-developer@gnu.org; Thu, 14 Aug 2008 03:30:31 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KTXHw-00044g-OJ
	for axiom-developer@nongnu.org; Thu, 14 Aug 2008 03:30:28 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KTXHu-00043r-9q
	for axiom-developer@nongnu.org; Thu, 14 Aug 2008 03:30:27 -0400
Received: from [199.232.76.173] (port=49188 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KTXHu-00043o-2P
	for axiom-developer@nongnu.org; Thu, 14 Aug 2008 03:30:26 -0400
Received: from mx20.gnu.org ([199.232.41.8]:24384)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <martin.rubey@univie.ac.at>)
	id 1KTXHt-0007GA-IK
	for axiom-developer@nongnu.org; Thu, 14 Aug 2008 03:30:25 -0400
Received: from grace.univie.ac.at ([131.130.3.115])
	by mx20.gnu.org with esmtp (Exim 4.60)
	(envelope-from <martin.rubey@univie.ac.at>) id 1KTXHn-00082a-Sd
	for axiom-developer@nongnu.org; Thu, 14 Aug 2008 03:30:20 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=univie.ac.at; s=rev1; h=Sender:To:Cc:Subject:References:From:
	Date:In-Reply-To:Message-ID:MIME-Version:Content-Type; bh=wki4B9
	nqcywY67L1LS85WqYDOhvhx+U2twnTu+mmmzQ=; b=kzqlg5eCc/C1Zs97Bt5sxl
	hf5UxEPuPm+XPRYFyvxkbav6LUi6MSLqoCHsxkOExL2zpCwXpyAAzxpGYyTJEZCg
	ynVlSybBOOMNX91pJdMAXdPEu+0AWcnkyxTF1J0wdRG+XfpJi6Na9z1Pgu8LamqK
	pkLOVTGLoPJn+CgjJozn8=
Received: from justin.univie.ac.at ([131.130.3.111] helo=justin.univie.ac.at)
	by grace.univie.ac.at with esmtp (Exim 4.69)
	(envelope-from <martin.rubey@univie.ac.at>)
	id 1KTXHj-0006ZL-TZ; Thu, 14 Aug 2008 09:30:15 +0200
Received: from aquin.mat.univie.ac.at ([131.130.16.163]
	helo=aquin.mat.univie.ac.at)
	by justin.univie.ac.at with esmtp (Exim 4.69)
	(envelope-from <martin.rubey@univie.ac.at>)
	id 1KTXHj-0007pG-RA; Thu, 14 Aug 2008 09:30:15 +0200
Sender: rubey@aquin.mat.univie.ac.at
To: Adam Williamson <awilliamson@mandriva.com>
Subject: Re: [Axiom-developer] Compile failure on Linux x86-64 (Error 255)
References: <20080801124644.02cdcc06@lenovo.local.net>
From: Martin Rubey <martin.rubey@univie.ac.at>
Date: 14 Aug 2008 09:30:15 +0200
In-Reply-To: <20080801124644.02cdcc06@lenovo.local.net>
Message-ID: <9qabfgoxyw.fsf@aquin.mat.univie.ac.at>
Lines: 13
User-Agent: Gnus/5.09 (Gnus v5.9.0) Emacs/21.4
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-detected-kernel: by mx20.gnu.org: Linux 2.6, seldom 2.4 (older, 4)
X-detected-kernel: by monty-python.gnu.org: Linux 2.6, seldom 2.4 (older, 4)
Cc: axiom-developer@nongnu.org, fricas-devel <fricas-devel@googlegroups.com>
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Thu, 14 Aug 2008 07:30:29 -0000

Adam Williamson <awilliamson@mandriva.com> writes:

> Hi, all. I am updating old packages in Mandriva, and I've come to
> Axiom. Our current package is for a version from 2005, and doesn't
> rebuild cleanly.

Since you didn't get any answer, may I suggest that you try to use FriCAS.  On
user level it is compatible with Axiom, but it builds at least on linux, macosx
and ms windows, using configure and make.  Moreover, you can choose to use a
variety of common lisp implementations to build it (eg., sbcl, clisp, ecl,
Closure CL, gcl) and are not tied to gcl.

Marting




From MAILER-DAEMON Fri Aug 15 02:25:21 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KTskT-000738-C1
	for mharc-axiom-developer@gnu.org; Fri, 15 Aug 2008 02:25:21 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KTskR-00072z-RY
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 02:25:19 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KTskQ-00072S-3r
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 02:25:19 -0400
Received: from [199.232.76.173] (port=34872 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KTskP-00072J-SI
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 02:25:17 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:37330
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KTskP-0001a9-J0
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 02:25:17 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7F6PDr3006358;
	Fri, 15 Aug 2008 01:25:13 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7F6PDVV006355;
	Fri, 15 Aug 2008 01:25:13 -0500
Date: Fri, 15 Aug 2008 01:25:13 -0500
Message-Id: <200808150625.m7F6PDVV006355@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] New web page for patches
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 15 Aug 2008 06:25:20 -0000

All of the patches applied to Axiom are available on a new web page:
<http://axiom.axiom-developer.org/axiom-website/patches.html>
as well as the release notes for each release.

Summary headers for each patch will be included as time permits.

Tim



From MAILER-DAEMON Fri Aug 15 15:41:11 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KU5Ad-0003KJ-H6
	for mharc-axiom-developer@gnu.org; Fri, 15 Aug 2008 15:41:11 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KU5Ac-0003Jo-BX
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 15:41:10 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KU5AZ-0003IX-He
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 15:41:09 -0400
Received: from [199.232.76.173] (port=51969 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KU5AZ-0003IS-AC
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 15:41:07 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:52446
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KU5AZ-0005vO-1D
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 15:41:07 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7FJf4r3008029;
	Fri, 15 Aug 2008 14:41:04 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7FJf4wB008026;
	Fri, 15 Aug 2008 14:41:04 -0500
Date: Fri, 15 Aug 2008 14:41:04 -0500
Message-Id: <200808151941.m7FJf4wB008026@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080814.01.tpd.patch (Use uncompress at build
	time)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 15 Aug 2008 19:41:10 -0000

This fix bugs 7115, 7117.
Hyperdoc graphics patch files which use viewports crashes.
This patch fixes two cases of failures.

The compress function is no longer shipped with linux.
The gunzip function replaces it.
There appears to be a race condition with compress which causes
random crashes with patch files and viewports so we eliminate it
by doing the uncompress at build time rather than inline.

======================================================================
diff --git a/Makefile.pamphlet b/Makefile.pamphlet
index cca2cde..624b7df 100644
--- a/Makefile.pamphlet
+++ b/Makefile.pamphlet
@@ -316,6 +316,7 @@ TANGLE=${SPADBIN}/lib/notangle
 WEAVE=${SPADBIN}/lib/noweave
 NOISE="-o ${TMP}/trace"
 PATCH=patch
+UNCOMPRESS=gunzip
 
 <<part>>
 
@@ -324,7 +325,7 @@ ENV= SPAD=${SPAD} SYS=${SYS} SPD=${SPD} LSP=${LSP} GCLDIR=${GCLDIR} \
      SPADBIN=${SPADBIN} INC=${INC} CCLBASE=${CCLBASE} PART=${PART} \
      SUBPART=${SUBPART} NOISE=${NOISE} GCLVERSION=${GCLVERSION} \
      TANGLE=${TANGLE} VERSION=${VERSION} PATCH=${PATCH} DOCUMENT=${DOCUMENT} \
-     WEAVE=${WEAVE}
+     WEAVE=${WEAVE} UNCOMPRESS=${UNCOMPRESS}
 
 @
 \subsection{rootdirs}
diff --git a/books/bookvol7.1.pamphlet b/books/bookvol7.1.pamphlet
index 2ad4111..9054a51 100644
--- a/books/bookvol7.1.pamphlet
+++ b/books/bookvol7.1.pamphlet
@@ -188309,7 +188309,8 @@ ${HYPER}/ht.db: ${BOOK}
 	   htadd ${PAGEFILE} )
 	@ cp -pr ${IN}/bitmaps ${HYPER}
 	@ cp -pr ${IN}/viewports ${HYPER}
-
+	@ (cd ${HYPER}/viewports ; \
+            for i in `find . -name "*.Z"` ; do ${UNCOMPRESS} $$i ; done )
 
 @
 \eject
diff --git a/books/bookvol7.pamphlet b/books/bookvol7.pamphlet
index 1ce229c..4bc1789 100644
--- a/books/bookvol7.pamphlet
+++ b/books/bookvol7.pamphlet
@@ -16916,10 +16916,7 @@ void parseInputPix(void) {
         else {
             pixnode->type = Inputpixmap;
             strcpy(f, pixnode->data.text);
-#ifdef OLD
-            strcat(f, ".pm");
-#endif
-            strcat(f, ".xpm.Z");
+            strcat(f, ".xpm");
             p=pixnode->data.text;
             pixnode->data.text = allocString(f);
             free(p);
diff --git a/changelog b/changelog
index 11a9c9f..1667f96 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,6 @@
+20080814 tpd books/bookvol7 handle uncompressed images
+20080814 tpd books/bookvol7.1 uncompress viewport directory images
+20080814 tpd Makefile add UNCOMPRESS
 20080809 tpd books/bookvol7 remove all references to doc/hypertex
 20080809 tpd src/Makefile stop creating the doc/hypertex/pages subdir
 20080809 tpd src/input/Makefile remove reference to hyperdoc/pages



From MAILER-DAEMON Fri Aug 15 18:24:42 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KU7is-0002tC-8T
	for mharc-axiom-developer@gnu.org; Fri, 15 Aug 2008 18:24:42 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KU7iq-0002rY-2a
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 18:24:40 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KU7im-0002ne-Ip
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 18:24:38 -0400
Received: from [199.232.76.173] (port=50538 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KU7im-0002nZ-GZ
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 18:24:36 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:51418
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KU7il-0000oT-Sy
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 18:24:36 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7FMOVr3000813;
	Fri, 15 Aug 2008 17:24:31 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7FMOVPr000809;
	Fri, 15 Aug 2008 17:24:31 -0500
Date: Fri, 15 Aug 2008 17:24:31 -0500
Message-Id: <200808152224.m7FMOVPr000809@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] Changes and Plans
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 15 Aug 2008 22:24:40 -0000

The patch files are now available from the Axiom website.
All of the patches have been annotated with a one-line description.
<http://axiom.axiom-developer.org/axiom-website/patches.html>

There are 226 patches listed. Over a 1 year period 7/21/07-7/21/08
there were 218 patches, averaging about 4 patches per week over the year.

The system is being fundamentally restructured to work directly from 
the book format. One side-effect is a massive simplification of the
whole build procedure. The long term target is to remove the need for
make and noweb.

As you can see from the page:
<http://axiom.axiom-developer.org/axiom-website/documentation.html>
there are 15 volumes (the algebra will end up being multi-volumed).
These volumes will contain the complete system text in literate
format. Some of these have been developed over the past year.

INTERPRETER (vol. 5)

Portions of the interpreter now live in bookvol5.  Several boot files
have been rewritten from the lisp form and more are done (but not yet
released, awaiting testing). The new lisp code will be ANSI common
lisp compatible. Once the code is all lisp the bootsys image, boot
parser, and boot subdirectory will disappear.

HYPERDOC (vols. 7 and 7.1)

The hyperdoc code is in two books (vol7 is code, vol7.1 is pages).
The src/hyper directory is gone. The code in volume 7 is completely
restructured into single C files. This eliminates local include files
and requires only a single invocation of GCC, giving significant speed
improvements.

The hypertex command reads pages directly from vol7.1 instead of files.
This reduces the build time. The ht.db step will disappear shortly.

Volume 7.1 is a fully hyperlinked PDF so it is possible to walk static
portions of the hyperdoc pages directly in the PDF file without
running hypertex. See the hyperlinks below the page images.

Both volumes will have more documentation added.

GRAPHICS (vol. 8)

Currently graphics code is all built from bookvol8.  The src/graph
subdirectory is gone. The next step is detailed code documenation.
The code in volume 8 is completely restructured into single C files.
Tests are being developed against the CRC Handbook of Curves and
Surfaces.

FIREFOX (vol. 11)

The firefox browser lives in bookvol11. All of the xhtml pages are
currently extracted at build time but the plan is to read the xhtml
directly from the book sources, similar to hyperdoc pages. Further
work is planned to port pages from hyperdoc. Firefox is a superset of
hyperdoc and contains new pages which are not in hyperdoc. Grahics 
can now be run from firefox pages.

Tim



From MAILER-DAEMON Fri Aug 15 22:28:24 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KUBWi-0000SA-NR
	for mharc-axiom-developer@gnu.org; Fri, 15 Aug 2008 22:28:24 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KUBWg-0000Rk-TL
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 22:28:22 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KUBWe-0000RY-Bn
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 22:28:21 -0400
Received: from [199.232.76.173] (port=57475 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KUBWe-0000RV-6b
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 22:28:20 -0400
Received: from mx-7.zoominternet.net ([24.154.1.26]:49255
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KUBWe-0002dc-12
	for axiom-developer@nongnu.org; Fri, 15 Aug 2008 22:28:20 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=Lczhz_mWAAAA:8 a=1XWaLZrsAAAA:8 a=OHCxe1xClIAfEnJOZmoA:9
	a=w1xShicvEuciXvYjpuoA:7 a=Ji6lwARYViuRshBP1wLzj69D7nEA:4
	a=yqFbmg6DZFsA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.45] ([24.154.1.45:55139] helo=pop-2.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 76/37-14770-C3B36A84; Fri, 15 Aug 2008 22:28:12 -0400
Received: (qmail 4746 invoked from network); 16 Aug 2008 02:28:14 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-2.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <aldor-l@aldor.org>; 16 Aug 2008 02:28:14 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id m7G3rPd17462;
	Fri, 15 Aug 2008 23:53:25 -0400
Date: Fri, 15 Aug 2008 23:53:25 -0400
Message-Id: <200808160353.m7G3rPd17462@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: ralf@hemmecke.de
In-reply-to: <48A606DF.70301@hemmecke.de> (message from Ralf Hemmecke on Sat, 
	16 Aug 2008 00:44:47 +0200)
References: <48A606DF.70301@hemmecke.de>
X-detected-kernel: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: fricas-devel@googlegroups.com, axiom-developer@nongnu.org,
	aldor-l@aldor.org
Subject: [Axiom-developer] Re: [Aldor-l] Fortress
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 16 Aug 2008 02:28:23 -0000

>I think now I understand what allowing Unicode in a programming language 
>might bring.
>
>Watch the talk of Guy Steel
>   http://www.infoq.com/presentations/fortress-steele
>in particular around the following times:
>
>16:00 min -- 19:35 min
>34:00 min -- 42:00 min
>52:00 min
>
>and maybe the whole talk might be interesting for some of you.
>
>Happy streaming...
>
>Ralf

His description of generators/reducers is very close to the
Google map/reduce algorithm. See
<http://labs.google.com/papers/mapreduce.html>

I do like his regions/distributions idea but he only seems to 
take this to the core level of a processor. A pentium or gpu
has parallelism in the instruction set (e.g. psubb) which does
a SIMD parallel subtract within a single object. And the Sage
group spent a lot of time working on the slicing of matrices
to optimize the algorithm for cache lines. I suppose one could
rewrite the library implementation.

I do like the unicode extension idea for operators. I would like
to pick up the standard lisp ideas of 

(drop 2 (1 2 3 4 5)) -> (3 4 5)
(take 9 (cycle (1 2 3 4))) -> (1 2 3 4 1 2 3 4 1)
(interleave (:a :b :c :d) (1 2 3 4)) -> (:a 1 :b 2 :c 3 :d 4)
(partition (1 2 3 4 5 6 7 8 9)) -> ((1 2 3) (4 5 6) (7 8 9))
(map vector (:a :b :c :d) (1 2 3 4)) -> (<:a 1> <:b 2> <:c 3> <:d 4>)
(apply str (interpose \, "abcd")) -> "a,b,c,d"
(reduce + (range 100)) -> 4950

with a larger set of symbols I can easily make these look like
standard mathematical notations.

And, of course, the latex-like output as an input form would
interact very well with a literate description of the algorithms.

Tim
 



From MAILER-DAEMON Sat Aug 16 11:53:09 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KUO5V-0006ip-Gm
	for mharc-axiom-developer@gnu.org; Sat, 16 Aug 2008 11:53:09 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KUO5U-0006if-Dm
	for axiom-developer@nongnu.org; Sat, 16 Aug 2008 11:53:08 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KUO5T-0006i9-33
	for axiom-developer@nongnu.org; Sat, 16 Aug 2008 11:53:08 -0400
Received: from [199.232.76.173] (port=49789 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KUO5T-0006i6-0r
	for axiom-developer@nongnu.org; Sat, 16 Aug 2008 11:53:07 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:47495
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KUO5S-00019y-21
	for axiom-developer@nongnu.org; Sat, 16 Aug 2008 11:53:06 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7GFqxr3010943;
	Sat, 16 Aug 2008 10:52:59 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7GFqwok010940;
	Sat, 16 Aug 2008 10:52:58 -0500
Date: Sat, 16 Aug 2008 10:52:58 -0500
Message-Id: <200808161552.m7GFqwok010940@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080815.01.tpd.patch (make firefox pages before
	input tests)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 16 Aug 2008 15:53:08 -0000

Reorder the sequence of system builds so that testing is last.
Also fix a typo in the Makefile, as the last patch dropped a $.

======================================================================
diff --git a/Makefile.pamphlet b/Makefile.pamphlet
index 624b7df..9e28029 100644
--- a/Makefile.pamphlet
+++ b/Makefile.pamphlet
@@ -712,7 +712,7 @@ needed at the moment because certain functions do not yet work on
 all platforms. 
 <<SRCDIRS>>=
 SRCDIRS="bootdir interpdir sharedir algebradir etcdir clefdir docdir \
-        graphdir smandir hyperdir inputdir browserdir"
+        graphdir smandir hyperdir browserdir inputdir"
 @
 \subsubsection{The [[GCLVERSION]] variable }
 [[GCLVERSION]] is the name of the GCL version. The one we used to
diff --git a/books/bookvol7.1.pamphlet b/books/bookvol7.1.pamphlet
index 9054a51..a629a3c 100644
--- a/books/bookvol7.1.pamphlet
+++ b/books/bookvol7.1.pamphlet
@@ -188310,7 +188310,7 @@ ${HYPER}/ht.db: ${BOOK}
 	@ cp -pr ${IN}/bitmaps ${HYPER}
 	@ cp -pr ${IN}/viewports ${HYPER}
 	@ (cd ${HYPER}/viewports ; \
-            for i in `find . -name "*.Z"` ; do ${UNCOMPRESS} $$i ; done )
+            for i in `find . -name "*.Z"` ; do $${UNCOMPRESS} $$i ; done )
 
 @
 \eject
diff --git a/changelog b/changelog
index 1667f96..ff04512 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,5 @@
+20080815 tpd books/bookvol7.1 fix typo, lost $ recovered
+20080815 tpd Makefile make hyperdoc before testing
 20080814 tpd books/bookvol7 handle uncompressed images
 20080814 tpd books/bookvol7.1 uncompress viewport directory images
 20080814 tpd Makefile add UNCOMPRESS



From MAILER-DAEMON Sun Aug 17 01:27:46 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KUanp-0007zK-UP
	for mharc-axiom-developer@gnu.org; Sun, 17 Aug 2008 01:27:46 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KUann-0007z4-DE
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 01:27:43 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KUanl-0007xW-GW
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 01:27:42 -0400
Received: from [199.232.76.173] (port=46400 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KUanl-0007xN-8S
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 01:27:41 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:57314
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KUanl-0007qC-5c
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 01:27:41 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7H5Rbr3015368;
	Sun, 17 Aug 2008 00:27:37 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7H5Rb2b015365;
	Sun, 17 Aug 2008 00:27:37 -0500
Date: Sun, 17 Aug 2008 00:27:37 -0500
Message-Id: <200808170527.m7H5Rb2b015365@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080816.01.tpd.patch (comment out long running
	test)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 17 Aug 2008 05:27:43 -0000

tutchap2 has a test that runs about half the time it takes for the whole
build. this test is commented out.

========================================================================
diff --git a/changelog b/changelog
index ff04512..30cf744 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,4 @@
+20080816 tpd src/input/tutchap2.input remove f 0, it takes too long
 20080815 tpd books/bookvol7.1 fix typo, lost $ recovered
 20080815 tpd Makefile make hyperdoc before testing
 20080814 tpd books/bookvol7 handle uncompressed images
diff --git a/src/input/tutchap2.input.pamphlet b/src/input/tutchap2.input.pamphlet
index ae81f5f..2fcb523 100644
--- a/src/input/tutchap2.input.pamphlet
+++ b/src/input/tutchap2.input.pamphlet
@@ -92,7 +92,7 @@ f 1000
 f(n : PositiveInteger) : Any ==                   _
           (local length; length := #((2^n)::String);      _
            if length > 120 then "Too long!" else length)
-f 0
+-- this takes too long to compute -- f 0
 g1(x) == 2*x
 g2(x) == %
 G := 2*x



From MAILER-DAEMON Sun Aug 17 01:38:00 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KUaxk-0005Rw-Ez
	for mharc-axiom-developer@gnu.org; Sun, 17 Aug 2008 01:38:00 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KUaxh-0005Pw-2p
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 01:37:57 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KUaxd-0005O1-MK
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 01:37:55 -0400
Received: from [199.232.76.173] (port=55408 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KUaxd-0005Nj-Eq
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 01:37:53 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:43508
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KUaxc-0001f8-CR
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 01:37:53 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7H5bmr3016686;
	Sun, 17 Aug 2008 00:37:48 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7H5bmRm016682;
	Sun, 17 Aug 2008 00:37:48 -0500
Date: Sun, 17 Aug 2008 00:37:48 -0500
Message-Id: <200808170537.m7H5bmRm016682@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080816.02.tpd.patch add additional regression
	tests
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 17 Aug 2008 05:37:57 -0000

Add additional regression tests.
======================================================================
diff --git a/changelog b/changelog
index 30cf744..5a3a67b 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,7 @@
+20080816 tpd src/input/Makefile add regression tests
+20080816 tpd src/input/test.input create regression
+20080816 tpd src/input/regset.input create regression
+20080816 tpd src/input/bern.input break into pieces
 20080816 tpd src/input/tutchap2.input remove f 0, it takes too long
 20080815 tpd books/bookvol7.1 fix typo, lost $ recovered
 20080815 tpd Makefile make hyperdoc before testing
diff --git a/src/input/Makefile.pamphlet b/src/input/Makefile.pamphlet
index 93718ee..5581e71 100644
--- a/src/input/Makefile.pamphlet
+++ b/src/input/Makefile.pamphlet
@@ -240,7 +240,7 @@ ASEC=errortrap.output
 
 # Error: FLUSH is invalid as a function
 # Error signalled by newGoGet
-FLUSH=regset.output 
+FLUSH=
 
 # Error: The function WRAPPED is undefined.
 WRAPPED=loop.output      
@@ -353,7 +353,8 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     poly1.regress     polycoer.regress poly.regress     psgenfcn.regress \
     quat1.regress     quat.regress     r20abugs.regress r20bugs.regress \
     r21bugsbig.regress r21bugs.regress radff.regress    radix.regress \
-    realclos.regress  reclos.regress   repa6.regress    robidoux.regress \
+    realclos.regress  reclos.regress   regset.regress \
+    repa6.regress     robidoux.regress \
     roman.regress     roots.regress    ruleset.regress  rules.regress \
     schaum1.regress   schaum2.regress  schaum3.regress  schaum4.regress \
     schaum5.regress   schaum6.regress  schaum7.regress  schaum8.regress \
@@ -373,7 +374,7 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     stbl.regress      stream2.regress  stream.regress   streams.regress \
     string.regress    strtbl.regress   summation.regress \
     symbol.regress    t111293.regress  table.regress    tancot.regress \
-    tanhcoth.regress  tanatan.regress  tbagg.regress \
+    tanhcoth.regress  tanatan.regress  tbagg.regress    test.regress \
     textfile.regress  torus.regress \
     triglim.regress   tsetcatvermeer.regress            tutchap1.regress \
     void.regress      uniseg.regress
@@ -942,7 +943,8 @@ DOCFILES= \
   ${DOC}/r20bugs.input.dvi     ${DOC}/r21bugsbig.input.dvi \
   ${DOC}/r21bugs.input.dvi     ${DOC}/radff.input.dvi      \
   ${DOC}/radix.input.dvi       ${DOC}/realclos.input.dvi   \
-  ${DOC}/reclos.input.dvi      ${DOC}/reductio.input.dvi   \
+  ${DOC}/reclos.input.dvi      ${DOC}/regset.input.dvi   \
+  ${DOC}/reductio.input.dvi   \
   ${DOC}/regset.input.dvi      ${DOC}/repa6.input.dvi      \
   ${DOC}/ribbon.input.dvi      ${DOC}/ribbons.input.dvi    \
   ${DOC}/ribbonsnew.input.dvi  ${DOC}/rk4draw.input.dvi    \
diff --git a/src/input/bern.input.pamphlet b/src/input/bern.input.pamphlet
index b383351..78cca45 100644
--- a/src/input/bern.input.pamphlet
+++ b/src/input/bern.input.pamphlet
@@ -10,8 +10,11 @@
 \tableofcontents
 \eject
 <<*>>=
--- @(#)bern.input	1.1    89/09/07  20:54:27
-draw(curve(cos(t)/(1+sin(t)**2),sin(t)*cos(t)/(1+sin(t)**2)),t = -%pi..%pi, [title "Lemniscate of Bernoulli"])
+f(t)==cos(t)/(1+sin(t)**2)
+g(t)==sin(t)*cos(t)/(1+sin(t)**2)
+c(t)==curve(f(t),g(t))
+d:=draw(c(t)),t = -%pi..%pi, [title "Lemniscate of Bernoulli"])
+close(d)
 @
 \eject
 \begin{thebibliography}{99}
diff --git a/src/input/regset.input.pamphlet b/src/input/regset.input.pamphlet
index 1e52bfb..cc33b54 100644
--- a/src/input/regset.input.pamphlet
+++ b/src/input/regset.input.pamphlet
@@ -1,53 +1,550 @@
 \documentclass{article}
 \usepackage{axiom}
 \begin{document}
-\title{\$SPAD/src/input REGSET.input}
-\author{The Axiom Team}
+\title{\$SPAD/src/input regset.input}
+\author{Timothy Daly}
 \maketitle
 \begin{abstract}
+Input generated from RegularTriangularSetXmpPage
 \end{abstract}
 \eject
 \tableofcontents
 \eject
 <<*>>=
-
--- Input generated from RegularTriangularSetXmpPage
+)spool regset.output
+)set message test on
+)set message auto off
 )clear all
-
+ 
+--S 1 of 34
 R := Integer
+--R 
+--R
+--R   (1)  Integer
+--R                                                                 Type: Domain
+--E 1
+
+--S 2 of 34
 ls : List Symbol := [x,y,z,t]
+--R 
+--R
+--R   (2)  [x,y,z,t]
+--R                                                            Type: List Symbol
+--E 2
+
+--S 3 of 34
 V := OVAR(ls)
+--R 
+--R
+--R   (3)  OrderedVariableList [x,y,z,t]
+--R                                                                 Type: Domain
+--E 3
+
+--S 4 of 34
 E := IndexedExponents V
+--R 
+--R
+--R   (4)  IndexedExponents OrderedVariableList [x,y,z,t]
+--R                                                                 Type: Domain
+--E 4
+
+--S 5 of 34
 P := NSMP(R, V)
+--R 
+--R
+--R   (5)  NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--R                                                                 Type: Domain
+--E 5
+
+--S 6 of 34
 x: P := 'x
+--R 
+--R
+--R   (6)  x
+--R Type: NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 6
+
+--S 7 of 34
 y: P := 'y
+--R 
+--R
+--R   (7)  y
+--R Type: NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 7
+
+--S 8 of 34
 z: P := 'z
+--R 
+--R
+--R   (8)  z
+--R Type: NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 8
+
+--S 9 of 34
 t: P := 't
+--R 
+--R
+--R   (9)  t
+--R Type: NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 9
+
+--S 10 of 34
 T := REGSET(R,E,V,P)
+--R 
+--R
+--R   (10)
+--R  RegularTriangularSet(Integer,IndexedExponents OrderedVariableList [x,y,z,t],O
+--R  rderedVariableList [x,y,z,t],NewSparseMultivariatePolynomial(Integer,OrderedV
+--R  ariableList [x,y,z,t]))
+--R                                                                 Type: Domain
+--E 10
+
+--S 11 of 34
 p1 := x ** 31 - x ** 6 - x - y
+--R 
+--R
+--R          31    6
+--R   (11)  x   - x  - x - y
+--R Type: NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 11
+
+--S 12 of 34
 p2 := x ** 8  - z
+--R 
+--R
+--R          8
+--R   (12)  x  - z
+--R Type: NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 12
+
+--S 13 of 34
 p3 := x ** 10 - t
+--R 
+--R
+--R          10
+--R   (13)  x   - t
+--R Type: NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 13
+
+--S 14 of 34
 lp := [p1, p2, p3]
+--R 
+--R
+--R           31    6          8      10
+--R   (14)  [x   - x  - x - y,x  - z,x   - t]
+--RType: List NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 14
+
+--S 15 of 34
 zeroSetSplit(lp)$T
+--R 
+--R
+--R            5    4      2     3     8     5    3    2   4                2
+--R   (15)  [{z  - t ,t z y  + 2z y - t  + 2t  + t  - t ,(t  - t)x - t y - z }]
+--RType: List RegularTriangularSet(Integer,IndexedExponents OrderedVariableList [x,y,z,t],OrderedVariableList [x,y,z,t],NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t]))
+--E 15
+
+--S 16 of 34
 lts := zeroSetSplit(lp,false)$T
+--R 
+--R
+--R   (16)
+--R      5    4      2     3     8     5    3    2   4                2
+--R   [{z  - t ,t z y  + 2z y - t  + 2t  + t  - t ,(t  - t)x - t y - z },
+--R      3      5          2     3         2
+--R    {t  - 1,z  - t,t z y  + 2z y + 1,z x  - t}, {t,z,y,x}]
+--RType: List RegularTriangularSet(Integer,IndexedExponents OrderedVariableList [x,y,z,t],OrderedVariableList [x,y,z,t],NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t]))
+--E 16
+
+--S 17 of 34
 [coHeight(ts) for ts in lts]
+--R 
+--R
+--R   (17)  [1,0,0]
+--R                                                Type: List NonNegativeInteger
+--E 17
+
+--S 18 of 34
 f1 := y**2*z+2*x*y*t-2*x-z
+--R 
+--R
+--R                          2
+--R   (18)  (2t y - 2)x + z y  - z
+--R Type: NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 18
+
+--S 19 of 34
 f2 :=   -x**3*z+ 4*x*y**2*z+ 4*x**2*y*t+ 2*y**3*t+ 4*x**2- 10*y**2+ 4*x*z- 10*y*t+ 2
+--R 
+--R
+--R              3              2        2              3      2
+--R   (19)  - z x  + (4t y + 4)x  + (4z y  + 4z)x + 2t y  - 10y  - 10t y + 2
+--R Type: NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 19
+
+--S 20 of 34
 f3 :=  2*y*z*t+x*t**2-x-2*z
+--R 
+--R
+--R           2
+--R   (20)  (t  - 1)x + 2t z y - 2z
+--R Type: NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 20
+
+--S 21 of 34
 f4 :=   -x*z**3+ 4*y*z**2*t+ 4*x*z*t**2+ 2*y*t**3+ 4*x*z+ 4*z**2-10*y*t- 10*t**2+2
+--R 
+--R
+--R             3      2                2     3             2      2
+--R   (21)  (- z  + (4t  + 4)z)x + (4t z  + 2t  - 10t)y + 4z  - 10t  + 2
+--R Type: NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 21
+
+--S 22 of 34
 lf := [f1, f2, f3, f4]
+--R 
+--R
+--R   (22)
+--R                     2
+--R   [(2t y - 2)x + z y  - z,
+--R         3              2        2              3      2
+--R    - z x  + (4t y + 4)x  + (4z y  + 4z)x + 2t y  - 10y  - 10t y + 2,
+--R      2
+--R    (t  - 1)x + 2t z y - 2z,
+--R        3      2                2     3             2      2
+--R    (- z  + (4t  + 4)z)x + (4t z  + 2t  - 10t)y + 4z  - 10t  + 2]
+--RType: List NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 22
+
+--S 23 of 34
 zeroSetSplit(lf)$T
+--R 
+--R
+--R   (23)
+--R      2      8      6       2                 3            2
+--R   [{t  - 1,z  - 16z  + 256z  - 256,t y - 1,(z  - 8z)x - 8z  + 16},
+--R       2      2     2
+--R    {3t  + 1,z  - 7t  - 1,y + t,x + z},
+--R      8      6      2         3            2
+--R    {t  - 10t  + 10t  - 1,z,(t  - 5t)y - 5t  + 1,x},
+--R      2      2
+--R    {t  + 3,z  - 4,y + t,x - z}]
+--RType: List RegularTriangularSet(Integer,IndexedExponents OrderedVariableList [x,y,z,t],OrderedVariableList [x,y,z,t],NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t]))
+--E 23
+
+--S 24 of 34
 lts2 := zeroSetSplit(lf,false)$T
+--R 
+--R
+--R   (24)
+--R      8      6      2         3            2
+--R   [{t  - 10t  + 10t  - 1,z,(t  - 5t)y - 5t  + 1,x},
+--R      2      8      6       2                 3            2
+--R    {t  - 1,z  - 16z  + 256z  - 256,t y - 1,(z  - 8z)x - 8z  + 16},
+--R       2      2     2                     2      2
+--R    {3t  + 1,z  - 7t  - 1,y + t,x + z}, {t  + 3,z  - 4,y + t,x - z}]
+--RType: List RegularTriangularSet(Integer,IndexedExponents OrderedVariableList [x,y,z,t],OrderedVariableList [x,y,z,t],NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t]))
+--E 24
+
+--S 25 of 34
 [coHeight(ts) for ts in lts2]
+--R 
+--R
+--R   (25)  [0,0,0,0]
+--R                                                Type: List NonNegativeInteger
+--E 25
+
+--S 26 of 34
 degrees := [degree(ts) for ts in lts2]
+--R 
+--R
+--R   (26)  [8,16,4,4]
+--R                                                Type: List NonNegativeInteger
+--E 26
+
+--S 27 of 34
 reduce(+,degrees)
+--R 
+--R
+--R   (27)  32
+--R                                                        Type: PositiveInteger
+--E 27
+
+--S 28 of 34
 u : R := 2
+--R 
+--R
+--R   (28)  2
+--R                                                                Type: Integer
+--E 28
+
+--S 29 of 34
 q1 := 2*(u-1)**2+ 2*(x-z*x+z**2)+ y**2*(x-1)**2- 2*u*x+ 2*y*t*(1-x)*(x-z)+ 2*u*z*t*(t-y)+ u**2*t**2*(1-2*z)+ 2*u*t**2*(z-x)+ 2*u*t*y*(z-1)+ 2*u*z*x*(y+1)+ (u**2-2*u)*z**2*t**2+ 2*u**2*z**2+ 4*u*(1-u)*z+ t**2*(z-x)**2
+--R 
+--R
+--R   (29)
+--R       2           2  2        2                            2           2
+--R     (y  - 2t y + t )x  + (- 2y  + ((2t + 4)z + 2t)y + (- 2t  + 2)z - 4t  - 2)x
+--R   + 
+--R      2                      2       2          2
+--R     y  + (- 2t z - 4t)y + (t  + 10)z  - 8z + 4t  + 2
+--R Type: NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 29
+
+--S 30 of 34
 q2 := t*(2*z+1)*(x-z)+ y*(z+2)*(1-x)+ u*(u-2)*t+ u*(1-2*u)*z*t+ u*y*(x+u-z*x-1)+ u*(u+1)*z**2*t
+--R 
+--R
+--R                                               2
+--R   (30)  (- 3z y + 2t z + t)x + (z + 4)y + 4t z  - 7t z
+--R Type: NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 30
+
+--S 31 of 34
 q3 := -u**2*(z-1)**2+ 2*z*(z-x)-2*(x-1)
+--R 
+--R
+--R                         2
+--R   (31)  (- 2z - 2)x - 2z  + 8z - 2
+--R Type: NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 31
+
+--S 32 of 34
 q4 :=   u**2+4*(z-x**2)+3*y**2*(x-1)**2- 3*t**2*(z-x)**2 +3*u**2*t**2*(z-1)**2+u**2*z*(z-2)+6*u*t*y*(z+x+z*x-1)
+--R 
+--R
+--R   (32)
+--R        2     2      2        2                      2        2
+--R     (3y  - 3t  - 4)x  + (- 6y  + (12t z + 12t)y + 6t z)x + 3y  + (12t z - 12t)y
+--R   + 
+--R        2      2         2            2
+--R     (9t  + 4)z  + (- 24t  - 4)z + 12t  + 4
+--R Type: NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 32
+
+--S 33 of 34
 lq := [q1, q2, q3, q4]
+--R 
+--R
+--R   (33)
+--R   [
+--R         2           2  2
+--R       (y  - 2t y + t )x
+--R     + 
+--R            2                            2           2          2
+--R       (- 2y  + ((2t + 4)z + 2t)y + (- 2t  + 2)z - 4t  - 2)x + y
+--R     + 
+--R                          2       2          2
+--R       (- 2t z - 4t)y + (t  + 10)z  - 8z + 4t  + 2
+--R     ,
+--R                                          2                         2
+--R    (- 3z y + 2t z + t)x + (z + 4)y + 4t z  - 7t z, (- 2z - 2)x - 2z  + 8z - 2,
+--R
+--R          2     2      2        2                      2        2
+--R       (3y  - 3t  - 4)x  + (- 6y  + (12t z + 12t)y + 6t z)x + 3y
+--R     + 
+--R                           2      2         2            2
+--R       (12t z - 12t)y + (9t  + 4)z  + (- 24t  - 4)z + 12t  + 4
+--R     ]
+--RType: List NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t])
+--E 33
+
+--S 34 of 34
 zeroSetSplit(lq,true,true)$T
+--R 
+--R[1 <4,0> -> |4|; {0}]W[2 <5,0>,<3,1> -> |8|; {0}][2 <4,1>,<3,1> -> |7|; {0}][1 <3,1> -> |3|; {0}]G[2 <4,1>,<4,1> -> |8|; {0}]W[3 <5,1>,<4,1>,<3,2> -> |12|; {0}]GI[3 <4,2>,<4,1>,<3,2> -> |11|; {0}]GWw[3 <4,1>,<3,2>,<5,2> -> |12|; {0}][3 <3,2>,<3,2>,<5,2> -> |11|; {0}]GIwWWWw[4 <3,2>,<4,2>,<5,2>,<2,3> -> |14|; {0}][4 <2,2>,<4,2>,<5,2>,<2,3> -> |13|; {0}]Gwww[5 <3,2>,<3,2>,<4,2>,<5,2>,<2,3> -> |17|; {0}]Gwwwwww[8 <3,2>,<4,2>,<4,2>,<4,2>,<4,2>,<4,2>,<5,2>,<2,3> -> |30|; {0}]Gwwwwww[8 <4,2>,<4,2>,<4,2>,<4,2>,<4,2>,<4,2>,<5,2>,<2,3> -> |31|; {0}][8 <3,3>,<4,2>,<4,2>,<4,2>,<4,2>,<4,2>,<5,2>,<2,3> -> |30|; {0}][8 <2,3>,<4,2>,<4,2>,<4,2>,<4,2>,<4,2>,<5,2>,<2,3> -> |29|; {0}][8 <1,3>,<4,2>,<4,2>,<4,2>,<4,2>,<4,2>,<5,2>,<2,3> -> |28|; {0}][7 <4,2>,<4,2>,<4,2>,<4,2>,<4,2>,<5,2>,<2,3> -> |27|; {0}][6 <4,2>,<4,2>,<4,2>,<4,2>,<5,2>,<2,3> -> |23|; {0}][5 <4,2>,<4,2>,<4,2>,<5,2>,<2,3> -> |19|; {0}]GIGIWwww[6 <5,2>,<4,2>,<4,2>,<5,2>,<3,3>,<2,3> -> |23|; {0}][6 <4,3>,<4,2>,<4,2>,<5,2>,<3,3!
>,<2,3> -> |22|; {0}]GIGI[6 <3,4>,<4,2>,<4,2>,<5,2>,<3,3>,<2,3> -> |21|; {0}][6 <2,4>,<4,2>,<4,2>,<5,2>,<3,3>,<2,3> -> |20|; {0}]GGG[5 <4,2>,<4,2>,<5,2>,<3,3>,<2,3> -> |18|; {0}]GIGIWwwwW[6 <5,2>,<4,2>,<5,2>,<3,3>,<3,3>,<2,3> -> |22|; {0}][6 <4,3>,<4,2>,<5,2>,<3,3>,<3,3>,<2,3> -> |21|; {0}]GIwwWwWWWWWWWwWWWWwwwww[8 <4,2>,<5,2>,<3,3>,<3,3>,<4,3>,<2,3>,<3,4>,<3,4> -> |27|; {0}][8 <3,3>,<5,2>,<3,3>,<3,3>,<4,3>,<2,3>,<3,4>,<3,4> -> |26|; {0}][8 <2,3>,<5,2>,<3,3>,<3,3>,<4,3>,<2,3>,<3,4>,<3,4> -> |25|; {0}]Gwwwwwwwwwwwwwwwwwwww[9 <5,2>,<3,3>,<3,3>,<4,3>,<3,3>,<3,3>,<2,3>,<3,4>,<3,4> -> |29|; {0}]GI[9 <4,3>,<3,3>,<3,3>,<4,3>,<3,3>,<3,3>,<2,3>,<3,4>,<3,4> -> |28|; {0}][9 <3,3>,<3,3>,<3,3>,<4,3>,<3,3>,<3,3>,<2,3>,<3,4>,<3,4> -> |27|; {0}][9 <2,3>,<3,3>,<3,3>,<4,3>,<3,3>,<3,3>,<2,3>,<3,4>,<3,4> -> |26|; {0}]GGwwwwwwwwwwwwWWwwwwwwww[11 <3,3>,<3,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |33|; {0}][11 <2,3>,<3,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> !
|32|; {0}][11 <1,3>,<3,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>!
,<3,3>,<3,4>,<3,4> -> |31|; {0}]GGGwwwwwwwwwwwww[12 <2,3>,<2,3>,<3,3>,<3,3>,<4,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |34|; {0}]GGwwwwwwwwwwwww[13 <3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |38|; {0}]Gwwwwwwwwwwwww[13 <2,3>,<3,3>,<4,3>,<3,3>,<4,3>,<3,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |39|; {0}]GGGwwwwwwwwwwwww[15 <3,3>,<4,3>,<3,3>,<3,3>,<3,3>,<3,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |46|; {0}][14 <4,3>,<3,3>,<3,3>,<3,3>,<3,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |43|; {0}]GIGGGGIGGI[14 <3,4>,<3,3>,<3,3>,<3,3>,<3,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |42|; {0}]GGG[14 <2,4>,<3,3>,<3,3>,<3,3>,<3,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |41|; {0}][14 <1,4>,<3,3>,<3,3>,<3,3>,<3,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |40|; {0}]GGG[13 <3,3>,<3,3>,<3,3>,<3,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |39|;!
 {0}]Gwwwwwwwwwwwww[15 <3,3>,<3,3>,<4,3>,<4,3>,<4,3>,<3,3>,<3,3>,<4,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |48|; {0}]Gwwwwwwwwwwwww[15 <4,3>,<4,3>,<3,3>,<4,3>,<4,3>,<3,3>,<4,3>,<3,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |49|; {0}]GIGI[15 <3,4>,<4,3>,<3,3>,<4,3>,<4,3>,<3,3>,<4,3>,<3,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |48|; {0}]G[14 <4,3>,<3,3>,<4,3>,<4,3>,<3,3>,<4,3>,<3,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |45|; {0}][13 <3,3>,<4,3>,<4,3>,<3,3>,<4,3>,<3,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |41|; {0}]Gwwwwwwwwwwwww[13 <4,3>,<4,3>,<4,3>,<3,3>,<3,3>,<4,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |42|; {0}]GIGGGGIGGI[13 <3,4>,<4,3>,<4,3>,<3,3>,<3,3>,<4,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |41|; {0}]GGGGGGGG[13 <2,4>,<4,3>,<4,3>,<3,3>,<3,3>,<4,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |40|; {0}][13 <1,4>,<4,3>,<4,3>,<3,3>,<3,3>,<4,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |39|; {0}][13 <0,4>,<4,3>,<4,3>,!
<3,3>,<3,3>,<4,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -!
> |38|; {0}][12 <4,3>,<4,3>,<3,3>,<3,3>,<4,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |38|; {1}][11 <4,3>,<3,3>,<3,3>,<4,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |34|; {1}][10 <3,3>,<3,3>,<4,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |30|; {1}][10 <2,3>,<3,3>,<4,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |29|; {1}]GGGwwwwwwwwwwwww[11 <3,3>,<3,3>,<4,3>,<3,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |33|; {1}]GGGwwwwwwwwwwwww[12 <4,3>,<3,3>,<4,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |38|; {1}]Gwwwwwwwwwwwww[12 <3,3>,<4,3>,<5,3>,<3,3>,<4,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |39|; {1}]GGwwwwwwwwwwwww[13 <5,3>,<4,3>,<4,3>,<4,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |44|; {1}]GIGGGGIGGIW[13 <4,4>,<4,3>,<4,3>,<4,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |43|; {1}]GGW[13 <3,4>,<4,3>,<4,3>,<4,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |42|; {1}]GGG[12 <4,3>,<4,3>,<4,3>,<3,3>!
,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |39|; {1}]Gwwwwwwwwwwwww[12 <4,3>,<4,3>,<5,3>,<3,3>,<4,3>,<3,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |40|; {1}]Gwwwwwwwwwwwww[13 <5,3>,<5,3>,<4,3>,<5,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |46|; {1}]GIGIW[13 <4,4>,<5,3>,<4,3>,<5,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |45|; {1}][13 <3,4>,<5,3>,<4,3>,<5,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |44|; {1}][13 <2,4>,<5,3>,<4,3>,<5,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |43|; {1}]GG[12 <5,3>,<4,3>,<5,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |41|; {1}]GIGGGGIGGIW[12 <4,4>,<4,3>,<5,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |40|; {1}]GGGGGGW[12 <3,4>,<4,3>,<5,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |39|; {1}][12 <2,4>,<4,3>,<5,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |38|; {1}][12 <1,4>,<4,3>,<5,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,!
3>,<3,3>,<3,3>,<3,4>,<3,4> -> |37|; {1}]GGG[11 <4,3>,<5,3>,<3!
,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |36|; {1}][10 <5,3>,<3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |32|; {1}][9 <3,3>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |27|; {1}]W[9 <2,4>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |26|; {1}][9 <1,4>,<3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |25|; {1}][8 <3,3>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |24|; {1}]W[8 <2,4>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |23|; {1}][8 <1,4>,<4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |22|; {1}][7 <4,3>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |21|; {1}]w[7 <3,4>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |20|; {1}][7 <2,4>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |19|; {1}][7 <1,4>,<2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |18|; {1}][6 <2,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |17|; {1}]GGwwwwww[7 <3,3>,<3,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |21|; {1}]GIW[7 <2,4>,<3,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |20|; {1}]GG[6 <3,3>,<3,3>,<3,3>,<3,3>,<3!
,4>,<3,4> -> |18|; {1}]Gwwwwww[7 <4,3>,<4,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |23|; {1}]GIW[7 <3,4>,<4,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |22|; {1}][6 <4,3>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |19|; {1}]GIW[6 <3,4>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |18|; {1}]GGW[6 <2,4>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |17|; {1}][6 <1,4>,<3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |16|; {1}]GGG[5 <3,3>,<3,3>,<3,3>,<3,4>,<3,4> -> |15|; {1}]GIW[5 <2,4>,<3,3>,<3,3>,<3,4>,<3,4> -> |14|; {1}]GG[4 <3,3>,<3,3>,<3,4>,<3,4> -> |12|; {1}][3 <3,3>,<3,4>,<3,4> -> |9|; {1}]W[3 <2,4>,<3,4>,<3,4> -> |8|; {1}][3 <1,4>,<3,4>,<3,4> -> |7|; {1}]G[2 <3,4>,<3,4> -> |6|; {1}]G[1 <3,4> -> |3|; {1}][1 <2,4> -> |2|; {1}][1 <1,4> -> |1|; {1}]
+--R   *** QCMPACK Statistics ***
+--R      Table     size:  36
+--R      Entries reused:  255
+--R
+--R   *** REGSETGCD: Gcd Statistics ***
+--R      Table     size:  125
+--R      Entries reused:  0
+--R
+--R   *** REGSETGCD: Inv Set Statistics ***
+--R      Table     size:  30
+--R      Entries reused:  0
+--R
+--R   (34)
+--R   [
+--R     {
+--R                         24                   23                    22
+--R         960725655771966t   + 386820897948702t   + 8906817198608181t
+--R       + 
+--R                          21                     20                    19
+--R         2704966893949428t   + 37304033340228264t   + 7924782817170207t
+--R       + 
+--R                           18                     17                      16
+--R         93126799040354990t   + 13101273653130910t   + 156146250424711858t
+--R       + 
+--R                           15                      14                     13
+--R         16626490957259119t   + 190699288479805763t   + 24339173367625275t
+--R       + 
+--R                            12                     11                      10
+--R         180532313014960135t   + 35288089030975378t   + 135054975747656285t
+--R       + 
+--R                           9                     8                     7
+--R         34733736952488540t  + 75947600354493972t  + 19772555692457088t
+--R       + 
+--R                           6                    5                    4
+--R         28871558573755428t  + 5576152439081664t  + 6321711820352976t
+--R       + 
+--R                       3                   2
+--R       438314209312320t  + 581105748367008t  - 60254467992576t + 1449115951104
+--R       ,
+--R
+--R                                                                         23
+--R             26604210869491302385515265737052082361668474181372891857784t
+--R           + 
+--R                                                                          22
+--R             443104378424686086067294899528296664238693556855017735265295t
+--R           + 
+--R                                                                          21
+--R             279078393286701234679141342358988327155321305829547090310242t
+--R           + 
+--R                                                                           20
+--R             3390276361413232465107617176615543054620626391823613392185226t
+--R           + 
+--R                                                                          19
+--R             941478179503540575554198645220352803719793196473813837434129t
+--R           + 
+--R                                                                            18
+--R             11547855194679475242211696749673949352585747674184320988144390t
+--R           + 
+--R                                                                           17
+--R             1343609566765597789881701656699413216467215660333356417241432t
+--R           + 
+--R                                                                            16
+--R             23233813868147873503933551617175640859899102987800663566699334t
+--R           + 
+--R                                                                          15
+--R             869574020537672336950845440508790740850931336484983573386433t
+--R           + 
+--R                                                                            14
+--R             31561554305876934875419461486969926554241750065103460820476969t
+--R           + 
+--R                                                                           13
+--R             1271400990287717487442065952547731879554823889855386072264931t
+--R           + 
+--R                                                                            12
+--R             31945089913863736044802526964079540198337049550503295825160523t
+--R           + 
+--R                                                                           11
+--R             3738735704288144509871371560232845884439102270778010470931960t
+--R           + 
+--R                                                                            10
+--R             25293997512391412026144601435771131587561905532992045692885927t
+--R           + 
+--R                                                                           9
+--R             5210239009846067123469262799870052773410471135950175008046524t
+--R           + 
+--R                                                                            8
+--R             15083887986930297166259870568608270427403187606238713491129188t
+--R           + 
+--R                                                                           7
+--R             3522087234692930126383686270775779553481769125670839075109000t
+--R           + 
+--R                                                                           6
+--R             6079945200395681013086533792568886491101244247440034969288588t
+--R           + 
+--R                                                                           5
+--R             1090634852433900888199913756247986023196987723469934933603680t
+--R           + 
+--R                                                                           4
+--R             1405819430871907102294432537538335402102838994019667487458352t
+--R           + 
+--R                                                                         3
+--R             88071527950320450072536671265507748878347828884933605202432t
+--R           + 
+--R                                                                          2
+--R             135882489433640933229781177155977768016065765482378657129440t
+--R           + 
+--R             - 13957283442882262230559894607400314082516690749975646520320t
+--R           + 
+--R             334637692973189299277258325709308472592117112855749713920
+--R        *
+--R           z
+--R       + 
+--R                                                                    23
+--R         8567175484043952879756725964506833932149637101090521164936t
+--R       + 
+--R                                                                      22
+--R         149792392864201791845708374032728942498797519251667250945721t
+--R       + 
+--R                                                                     21
+--R         77258371783645822157410861582159764138123003074190374021550t
+--R       + 
+--R                                                                       20
+--R         1108862254126854214498918940708612211184560556764334742191654t
+--R       + 
+--R                                                                      19
+--R         213250494460678865219774480106826053783815789621501732672327t
+--R       + 
+--R                                                                       18
+--R         3668929075160666195729177894178343514501987898410131431699882t
+--R       + 
+--R                                                                      17
+--R         171388906471001872879490124368748236314765459039567820048872t
+--R       + 
+--R                                                                       16
+--R         7192430746914602166660233477331022483144921771645523139658986t
+--R       + 
+--R                                                                        15
+--R         - 128798674689690072812879965633090291959663143108437362453385t
+--R       + 
+--R                                                                       14
+--R         9553010858341425909306423132921134040856028790803526430270671t
+--R       + 
+--R                                                                       13
+--R         - 13296096245675492874538687646300437824658458709144441096603t
+--R       + 
+--R                                                                       12
+--R         9475806805814145326383085518325333106881690568644274964864413t
+--R       + 
+--R                                                                      11
+--R         803234687925133458861659855664084927606298794799856265539336t
+--R       + 
+--R                                                                       10
+--R         7338202759292865165994622349207516400662174302614595173333825t
+--R       + 
+--R                                                                       9
+--R         1308004628480367351164369613111971668880538855640917200187108t
+--R       + 
+--R                                                                       8
+--R         4268059455741255498880229598973705747098216067697754352634748t
+--R       + 
+--R                                                                      7
+--R         892893526858514095791318775904093300103045601514470613580600t
+--R       + 
+--R                                                                       6
+--R         1679152575460683956631925852181341501981598137465328797013652t
+--R       + 
+--R                                                                      5
+--R         269757415767922980378967154143357835544113158280591408043936t
+--R       + 
+--R                                                                      4
+--R         380951527864657529033580829801282724081345372680202920198224t
+--R       + 
+--R                                                                     3
+--R         19785545294228495032998826937601341132725035339452913286656t
+--R       + 
+--R                                                                     2
+--R         36477412057384782942366635303396637763303928174935079178528t
+--R       + 
+--R         - 3722212879279038648713080422224976273210890229485838670848t
+--R       + 
+--R         89079724853114348361230634484013862024728599906874105856
+--R       ,
+--R         3      2                  3       2
+--R      (3z  - 11z  + 8z + 4)y + 2t z  + 4t z  - 5t z - t,
+--R                  2
+--R      (z + 1)x + z  - 4z + 1}
+--R     ]
+--RType: List RegularTriangularSet(Integer,IndexedExponents OrderedVariableList [x,y,z,t],OrderedVariableList [x,y,z,t],NewSparseMultivariatePolynomial(Integer,OrderedVariableList [x,y,z,t]))
+--E 34
+)spool 
+)lisp (bye)
+ 
 @
 \eject
 \begin{thebibliography}{99}
diff --git a/src/input/test.input.pamphlet b/src/input/test.input.pamphlet
index 49460a9..ea9b453 100644
--- a/src/input/test.input.pamphlet
+++ b/src/input/test.input.pamphlet
@@ -2,9 +2,10 @@
 \usepackage{axiom}
 \begin{document}
 \title{\$SPAD/src/input test.input}
-\author{The Axiom Team}
+\author{Scott Morrison, Bill Burge, Robert Sutor, Timothy Daly}
 \maketitle
 \begin{abstract}
+File of recently fixed interpreter bugs
 \end{abstract}
 \eject
 \tableofcontents
@@ -14,638 +15,2350 @@
 --Copyright The Numerical Algorithms Group Limited 1991.
 @
 <<*>>=
-<<license>>
-
-
-
--- File of recently fixed interpreter bugs
-
---- eval a polynomial with EXPR substitution values
---- Fixed by SCM, verified on 10/30/90
-
+)spool test.output
+)set message test on
+)set message auto off
+)set break resume
+
+@ 
+Eval a polynomial with EXPR substitution values.
+Fixed by SCM, verified on 10/30/90
+<<*>>=
 )clear all
 
-
+--S 1
 eq1:= A*x**2 + B*x*y + C*y**2 +D*x + E*y + F
-
+--R 
+--R
+--R           2                   2
+--R   (1)  C y  + (B x + E)y + A x  + D x + F
+--R                                                     Type: Polynomial Integer
+--E 1
+
+--S 2
 eq2:= eval(eq1,[x= xdot*cos(t) - ydot*sin(t), y=xdot*sin(t) + ydot*cos(t)])
+--R 
+--R
+--R   (2)
+--R            2                       2       2
+--R     (A ydot  - B xdot ydot + C xdot )sin(t)
+--R   + 
+--R               2                              2
+--R     ((- B ydot  + (2C - 2A)xdot ydot + B xdot )cos(t) - D ydot + E xdot)sin(t)
+--R   + 
+--R            2                       2       2
+--R     (C ydot  + B xdot ydot + A xdot )cos(t)  + (E ydot + D xdot)cos(t) + F
+--R                                                     Type: Expression Integer
+--E 2
 
--- UTS coercions.  Fixed by SCM, verified on 10/30/90
-
+@
+UTS coercions.  Fixed by SCM, verified on 10/30/90
+<<*>>=
 )clear all
 
+--S 3
 taylor exp x
-
+--R 
+--R
+--R   (1)
+--R             1  2   1  3    1  4    1   5    1   6     1   7     1    8
+--R     1 + x + - x  + - x  + -- x  + --- x  + --- x  + ---- x  + ----- x
+--R             2      6      24      120      720      5040      40320
+--R   + 
+--R        1    9      1     10      11
+--R     ------ x  + ------- x   + O(x  )
+--R     362880      3628800
+--R                         Type: UnivariateTaylorSeries(Expression Integer,x,0)
+--E 3
+
+--S 4
 s := %
-
+--R 
+--R
+--R   (2)
+--R             1  2   1  3    1  4    1   5    1   6     1   7     1    8
+--R     1 + x + - x  + - x  + -- x  + --- x  + --- x  + ---- x  + ----- x
+--R             2      6      24      120      720      5040      40320
+--R   + 
+--R        1    9      1     10      11
+--R     ------ x  + ------- x   + O(x  )
+--R     362880      3628800
+--R                         Type: UnivariateTaylorSeries(Expression Integer,x,0)
+--E 4
+
+--S 5
 s::(UTS(EXPR FLOAT, x, 0))
+--R 
+--R
+--R   (3)
+--R                    2                            3
+--R     1.0 + x + 0.5 x  + 0.1666666666 6666666667 x
+--R   + 
+--R                                4                               5
+--R     0.0416666666 6666666666 7 x  + 0.0083333333 3333333333 34 x
+--R   + 
+--R                                 6                               7
+--R     0.0013888888 8888888888 89 x  + 0.0001984126 9841269841 27 x
+--R   + 
+--R                                   8                                  9
+--R     0.0000248015 8730158730 1587 x  + 0.0000027557 3192239858 90653 x
+--R   + 
+--R                                   10      11
+--R     0.2755731922 3985890653 E -6 x   + O(x  )
+--R                         Type: UnivariateTaylorSeries(Expression Float,x,0.0)
+--E 5
+
+--S 6
 s::(UTS(FLOAT, x, 0))
-
+--R 
+--R
+--R   (4)
+--R                    2                            3
+--R     1.0 + x + 0.5 x  + 0.1666666666 6666666667 x
+--R   + 
+--R                                4                               5
+--R     0.0416666666 6666666666 7 x  + 0.0083333333 3333333333 34 x
+--R   + 
+--R                                 6                               7
+--R     0.0013888888 8888888888 89 x  + 0.0001984126 9841269841 27 x
+--R   + 
+--R                                   8                                  9
+--R     0.0000248015 8730158730 1587 x  + 0.0000027557 3192239858 90653 x
+--R   + 
+--R                                   10      11
+--R     0.2755731922 3985890653 E -6 x   + O(x  )
+--R                                    Type: UnivariateTaylorSeries(Float,x,0.0)
+--E 6
+
+--S 7
 eval(s,1)
+--R 
+--R
+--R             5 8 65 163 1957 685 109601 98641
+--R   (5)  [1,2,-,-,--,---,----,---,------,-----,...]
+--R             2 3 24  60  720 252  40320 36288
+--R                                              Type: Stream Expression Integer
+--E 7
+
+--S 8
 %::(Stream Float)
+--R 
+--R
+--R   (6)
+--R   [1.0, 2.0, 2.5, 2.6666666666 666666667, 2.7083333333 333333333,
+--R    2.7166666666 666666667, 2.7180555555 555555556, 2.7182539682 53968254,
+--R    2.7182787698 412698413, 2.7182815255 731922399, ...]
+--R                                                           Type: Stream Float
+--E 8
 
--- Another bug, fixed by adding UPXS2 package,
+@
+Another bug, fixed by adding UPXS2 package,
+<<*>>=
+)clear all
 
+--S 9
 s := series(sin(a*x),x=0)
+--R 
+--R
+--R               3        5        7          9            11
+--R              a   3    a   5    a    7     a     9      a      11      12
+--R   (1)  a x - -- x  + --- x  - ---- x  + ------ x  - -------- x   + O(x  )
+--R               6      120      5040      362880      39916800
+--R                        Type: UnivariatePuiseuxSeries(Expression Integer,x,0)
+--E 9
+
+--S 10
 eval(s, 1.0)
-
+--R 
+--R
+--R   (2)
+--R                                          3
+--R   [0.0, a, a, - 0.1666666666 6666666667 a  + a,
+--R                               3
+--R    - 0.1666666666 6666666667 a  + a,
+--R                                5                            3
+--R    0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a,
+--R                                5                            3
+--R    0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a,
+--R
+--R                                     7                               5
+--R       - 0.0001984126 9841269841 27 a  + 0.0083333333 3333333333 34 a
+--R     + 
+--R                                  3
+--R       - 0.1666666666 6666666667 a  + a
+--R     ,
+--R
+--R                                     7                               5
+--R       - 0.0001984126 9841269841 27 a  + 0.0083333333 3333333333 34 a
+--R     + 
+--R                                  3
+--R       - 0.1666666666 6666666667 a  + a
+--R     ,
+--R
+--R                                      9                               7
+--R       0.0000027557 3192239858 90653 a  - 0.0001984126 9841269841 27 a
+--R     + 
+--R                                   5                            3
+--R       0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a
+--R     ,
+--R    ...]
+--R                                                Type: Stream Expression Float
+--E 10
+
+--S 11
 s - a*x
+--R 
+--R
+--R   (3)
+--R        3        5        7          9            11              13
+--R       a   3    a   5    a    7     a     9      a      11       a       13
+--R     - -- x  + --- x  - ---- x  + ------ x  - -------- x   + ---------- x
+--R        6      120      5040      362880      39916800       6227020800
+--R   + 
+--R        14
+--R     O(x  )
+--R                        Type: UnivariatePuiseuxSeries(Expression Integer,x,0)
+--E 11
 
+@
+Grand finale, just fixed on 3/23/91
+<<*>>=
 
--- grand finale, just fixed on 3/23/91
+--S 12
 eval(s, 1.0)
+--R 
+--R
+--R   (4)
+--R                                          3
+--R   [0.0, a, a, - 0.1666666666 6666666667 a  + a,
+--R                               3
+--R    - 0.1666666666 6666666667 a  + a,
+--R                                5                            3
+--R    0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a,
+--R                                5                            3
+--R    0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a,
+--R
+--R                                     7                               5
+--R       - 0.0001984126 9841269841 27 a  + 0.0083333333 3333333333 34 a
+--R     + 
+--R                                  3
+--R       - 0.1666666666 6666666667 a  + a
+--R     ,
+--R
+--R                                     7                               5
+--R       - 0.0001984126 9841269841 27 a  + 0.0083333333 3333333333 34 a
+--R     + 
+--R                                  3
+--R       - 0.1666666666 6666666667 a  + a
+--R     ,
+--R
+--R                                      9                               7
+--R       0.0000027557 3192239858 90653 a  - 0.0001984126 9841269841 27 a
+--R     + 
+--R                                   5                            3
+--R       0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a
+--R     ,
+--R    ...]
+--R                                                Type: Stream Expression Float
+--E 12
 
--- generalized resolve
--- Fixed (enhanced) by SCM in 3/23/91
-
-)cl all
+@
+Generalized resolve. Fixed (enhanced) by SCM in 3/23/91
+<<*>>=
+)clear all
 
+--S 13
 v := vector [1,2,3]
-(1/2)*v
+--R 
+--R
+--R   (1)  [1,2,3]
+--R                                                 Type: Vector PositiveInteger
+--E 13
 
+--S 14
+(1/2)*v
+--R 
+--R
+--R         1   3
+--R   (2)  [-,1,-]
+--R         2   2
+--R                                                Type: Vector Fraction Integer
+--E 14
+
+--S 15
 eval(x**2, x=1/2)
+--R 
+--R
+--R        1
+--R   (3)  -
+--R        4
+--R                                            Type: Polynomial Fraction Integer
+--E 15
+
+--S 16
 eval(x**2, x=0.5)
-eval(3**x, x=0.5)
+--R 
+--R
+--R   (4)  0.25
+--R                                                       Type: Polynomial Float
+--E 16
 
--- overloading interpreter maps on arity
---- Fixed by SCM, verified on 10/30/90
+--S 17
+eval(3**x, x=0.5)
+--R 
+--R
+--R   (5)  1.7320508075 688772935
+--R                                                       Type: Expression Float
+--E 17
 
+@
+Overloading interpreter maps on arity. Fixed by SCM, verified on 10/30/90
+<<*>>=
 )clear all
 
+--S 18
 f(x) == x+1
+--R 
+--R                                                                   Type: Void
+--E 18
+
+--S 19
 f(x,y) == x+y
+--R 
+--R                                                                   Type: Void
+--E 19
 
+--S 20
 f 3
+--R 
+--R   Compiling function f with type PositiveInteger -> PositiveInteger 
+--R
+--R   (3)  4
+--R                                                        Type: PositiveInteger
+--E 20
+
+--S 21
 f(3,4)
+--R 
+--R   Compiling function f with type (PositiveInteger,PositiveInteger) -> 
+--R      PositiveInteger 
+--R
+--R   (4)  7
+--R                                                        Type: PositiveInteger
+--E 21
+
+--S 22
 f(5)
-f(1,x)
+--R 
+--R
+--R   (5)  6
+--R                                                        Type: PositiveInteger
+--E 22
 
--- targetted function requiring a coercion
---- Fixed by SCM, verified on 10/30/90
+--S 23
+f(1,x)
+--R 
+--R   Compiling function f with type (PositiveInteger,Variable x) -> 
+--R      Polynomial Integer 
+--R
+--R   (6)  x + 1
+--R                                                     Type: Polynomial Integer
+--E 23
 
+@
+Targetted function requiring a coercion. Fixed by SCM, verified on 10/30/90
+<<*>>=
 )clear all
-series(n +-> bernoulli(n)/factorial(n), t=0)
 
--- in-homogeneous list mapping
---- Fixed by SCM, verified on 10/30/90
+--S 24
+series(n +-> bernoulli(n)/factorial(n), t=0)
+--R 
+--R
+--R   (1)
+--R       1      1  2    1   4     1    6      1     8       1     10      11
+--R   1 - - t + -- t  - --- t  + ----- t  - ------- t  + -------- t   + O(t  )
+--R       2     12      720      30240      1209600      47900160
+--R                        Type: UnivariatePuiseuxSeries(Expression Integer,t,0)
+--E 24
 
+@
+In-homogeneous list mapping. Fixed by SCM, verified on 10/30/90
+<<*>>=
 )clear all
+
+--S 25
 l := [1,2,-1]
+--R 
+--R
+--R   (1)  [1,2,- 1]
+--R                                                           Type: List Integer
+--E 25
+
+--S 26
 f : INT -> FRAC INT
+--R 
+--R                                                                   Type: Void
+--E 26
+
+--S 27
 f x == x
+--R 
+--R                                                                   Type: Void
+--E 27
+
+--S 28
 map(f, l)
+--R 
+--R   Compiling function f with type Integer -> Fraction Integer 
+--R
+--R   (4)  [1,2,- 1]
+--R                                                  Type: List Fraction Integer
+--E 28
 
--- Function args to interpreter functions
---- Fixed by SCM, verified on 10/30/90
+@
+Function args to interpreter functions. Fixed by SCM, verified on 10/30/90
+<<*>>=
+)clear all
 
-)cl all
+--S 29
 f: INT -> INT
+--R 
+--R                                                                   Type: Void
+--E 29
+
+--S 30
 f x == x+1
+--R 
+--R                                                                   Type: Void
+--E 30
+
+--S 31
 u g == g 3
-u f
+--R 
+--R                                                                   Type: Void
+--E 31
 
--- category modemap requiring a field to be constructed
---- Fixed by SCM, verified on 10/30/90
+--S 32
+u f
+--R 
+--R   Compiling function u with type (Integer -> Integer) -> Integer 
+--R   Compiling function f with type Integer -> Integer 
+--R
+--R   (4)  4
+--R                                                        Type: PositiveInteger
+--E 32
 
+@
+Category modemap requiring a field to be constructed.
+Fixed by SCM, verified on 10/30/90
+<<*>>=
 )clear all
 
+--S 33
 groebner [x**2 - y, y**3+1]
+--R 
+--R
+--R              2  6
+--R   (1)  [y - x ,x  + 1]
+--R                                                Type: List Polynomial Integer
+--E 33
 
--- operations requiring polynomials, passed variables
---- Fixed by SCM, verified on 10/30/90
-
+@
+Operations requiring polynomials, passed variables.
+Fixed by SCM, verified on 10/30/90
+<<*>>=
 )clear all
+
+--S 34
 factor x
-draw(x, x=-1..1)
+--R 
+--R
+--R   (1)  x
+--R                                            Type: Factored Polynomial Integer
+--E 34
 
--- bracket parsing and empty-set types
---- Fixed by SCM, verified on 10/30/90
+--draw(x, x=-1..1)
 
+@
+Bracket parsing and empty-set types. Fixed by SCM, verified on 10/30/90
+<<*>>=
 )clear all
+
+@
+--S 35
+{}$(List INT)
+--R 
+--RDaly Bug
+--R   The function SEQ is not implemented in List Integer .
+--E 35
+
+--S 36
 brace []  -- {}
---{}$(List INT)
+--R
+--R   (1)  {}
+--R                                                               Type: Set None
+--E 36
+
+--S 37
 brace [1] -- {1}
--- The following still doesn't work
-union(brace [], brace [1,2])   -- union({}, {1,2})
+--R
+--R   (2)  {1}
+--R                                                    Type: Set PositiveInteger
+--E 37
 
--- Shouldn't work, but no longer bombs the interpreter
---- Fixed by SCM, verified on 10/30/90
+--S 38
+union(brace [], brace [1,2])   -- union({}, {1,2})
+--R
+--R   (3)  {1,2}
+--R                                                    Type: Set PositiveInteger
+--E 38
 
+@
+Shouldn't work, but no longer bombs the interpreter.
+Fixed by SCM, verified on 10/30/90
+<<*>>=
 )clear all
+
 )set mes test off
+
+--S 39
 map(variable, [x,y])
+--R 
+--R
+--R   (1)  [x,y]
+--R                         Type: List Union(OrderedVariableList [x,y],"failed")
+--E 39
+
 )set mes test on
 
--- Recursive map type analysis bug
---- Fixed by SCM, verified on 10/30/90
-)set fun recur off
+@
+Recursive map type analysis bug. Fixed by SCM, verified on 10/30/90
+<<*>>=
 )clear all
 
+)set fun recur off
+
+--S 40
 p(n,x) == if n=0 then 1 else (x+n-1)*p(n-1,x)
+--R 
+--R                                                                   Type: Void
+--E 40
+
+--S 41
 pp(n,x) == if n=0 then 1 else if n<0 then (-1)**n/p(-n,1-x) else p(n,x)
+--R 
+--R                                                                   Type: Void
+--E 41
+
+--S 42
 pp(-1,x) -- should be 1/(x-1)
+--R 
+--R   Compiling function p with type (Integer,Polynomial Integer) -> 
+--R      Polynomial Integer 
+--R   Compiling function p with type (Integer,Variable x) -> Polynomial 
+--R      Integer 
+--R   Compiling function pp with type (Integer,Variable x) -> Fraction 
+--R      Polynomial Fraction Integer 
+--R
+--R          1
+--R   (3)  -----
+--R        x - 1
+--R                                   Type: Fraction Polynomial Fraction Integer
+--E 42
 
--- interpret-code mode for iterators is broken
+@
+Interpret-code mode for iterators is broken
+<<*>>=
+)clear all
 
-)cl all
+--S 43
 f n ==
   for i in 1..n repeat
     j:=2*i
     m:SQMATRIX(j,?):=1
     print m
+--R 
+--R                                                                   Type: Void
+--E 43
+
+--S 44
 g n ==
     j:=2*n
     m:SQMATRIX(j,?):=1
     print m
+--R 
+--R                                                                   Type: Void
+--E 44
 
+--S 45
 g 3
+--R 
+--R   Cannot compile the declaration for m because its (possible partial) 
+--R      type contains a local variable.
+--R   AXIOM will attempt to step through and interpret the code.
+--R   +1  0  0  0  0  0+
+--R   |                |
+--R   |0  1  0  0  0  0|
+--R   |                |
+--R   |0  0  1  0  0  0|
+--R   |                |
+--R   |0  0  0  1  0  0|
+--R   |                |
+--R   |0  0  0  0  1  0|
+--R   |                |
+--R   +0  0  0  0  0  1+
+--R                                                                   Type: Void
+--E 45
+
+--S 46
 f 3
+--R 
+--R   Cannot compile the declaration for m because its (possible partial) 
+--R      type contains a local variable.
+--R   AXIOM will attempt to step through and interpret the code.
+--R   +1  0+
+--R   |    |
+--R   +0  1+
+--R   +1  0  0  0+
+--R   |          |
+--R   |0  1  0  0|
+--R   |          |
+--R   |0  0  1  0|
+--R   |          |
+--R   +0  0  0  1+
+--R   +1  0  0  0  0  0+
+--R   |                |
+--R   |0  1  0  0  0  0|
+--R   |                |
+--R   |0  0  1  0  0  0|
+--R   |                |
+--R   |0  0  0  1  0  0|
+--R   |                |
+--R   |0  0  0  0  1  0|
+--R   |                |
+--R   +0  0  0  0  0  1+
+--R                                                                   Type: Void
+--E 46
 
--- Test interpreter list destructuring
-
+@
+Test interpreter list destructuring
+<<*>>=
 )clear all
+
+--S 47
 mp(x,l) ==
   l is [a,:b] =>
     a*x**(#b)+ mp(x,b)
   0
+--R 
+--R                                                                   Type: Void
+--E 47
 
+--S 48
 mp(x, [1,3,4, 2])
+--R 
+--R   Compiling function mp with type (Variable x,List PositiveInteger)
+--R       -> Polynomial Integer 
+--R
+--R         3     2
+--R   (2)  x  + 3x  + 4x + 2
+--R                                                     Type: Polynomial Integer
+--E 48
+
+--S 49
 mp(x, [1,2,-3, 4])
+--R 
+--R   Compiling function mp with type (Variable x,List Integer) -> 
+--R      Polynomial Integer 
+--R
+--R         3     2
+--R   (3)  x  + 2x  - 3x + 4
+--R                                                     Type: Polynomial Integer
+--E 49
 
--- Tests compilation of recursive functions
-
+@
+Tests compilation of recursive functions
+<<*>>=
 )clear all
 
+--S 50
 f1 n ==
   if n=0 then 1 else if n=1 then 1 else f1(n-1)+f1(n-2)
+--R 
+--R                                                                   Type: Void
+--E 50
 
+--S 51
 f2 n ==
   m:=n
   if n=0 then 1 else if n=1 then 1 else f2(n-1)+f2(n-2)
+--R 
+--R                                                                   Type: Void
+--E 51
 
+--S 52
 f3 n ==
   n=0 => 1
   n=1 => 1
   f3(n-1)+f3(n-2)
+--R 
+--R                                                                   Type: Void
+--E 52
 
+--S 53
 f4 n ==
   m:=n
   n=0 => 1
   n=1 => 1
   m:=n
   f4(n-1)+f4(n-2)
+--R 
+--R                                                                   Type: Void
+--E 53
 
+--S 54
 f5 n == if n=0 or n=1 then 1 else f5(n-1)+f5(n-2)
+--R 
+--R                                                                   Type: Void
+--E 54
 
+--S 55
 [f1 3,f2 3, f3 3,f4 3,f5 3]
+--R 
+--R   Compiling function f1 with type Integer -> PositiveInteger 
+--R   Compiling function f2 with type Integer -> PositiveInteger 
+--R   Compiling function f3 with type Integer -> PositiveInteger 
+--R   Compiling function f4 with type Integer -> PositiveInteger 
+--R   Compiling function f5 with type Integer -> PositiveInteger 
+--R
+--R   (6)  [3,3,3,3,3]
+--R                                                   Type: List PositiveInteger
+--E 55
 
--- Input of GDMP types
--- Fixed by SCM on 1/22/91
-
-)cl all
+@
+Input of GDMP types. Fixed by SCM on 1/22/91
+<<*>>=
+)clear all
 
+--S 56
 g: GDMP([x,y], INT, DIRPROD(2, NNI)) := x**2 + y
+--R 
+--R
+--R         2
+--R   (1)  x  + y
+--RType: GeneralDistributedMultivariatePolynomial([x,y],Integer,DirectProduct(2,NonNegativeInteger))
+--E 56
 
--- has test with variables
--- Fixed by SCM on 1/22/91
-
-)cl all
+@
+Has test with variables. Fixed by SCM on 1/22/91
+<<*>>=
+)clear all
 
+--S 57
 i := INT
-i has Algebra(i)
+--R 
+--R
+--R   (1)  Integer
+--R                                                                 Type: Domain
+--E 57
 
---  returns in functions
--- Fixed by SCM on 1/22/91
+--S 58
+i has Algebra(i)
+--R 
+--R
+--R   (2)  true
+--R                                                                Type: Boolean
+--E 58
 
-)cl all
+@
+Returns in functions. Fixed by SCM on 1/22/91
+<<*>>=
+)clear all
 
+--S 59
 f x == if x<0 then return x else x+1
+--R 
+--R                                                                   Type: Void
+--E 59
 
+--S 60
 f 2 -- should be 3
+--R 
+--R   Compiling function f with type PositiveInteger -> PositiveInteger 
+--R
+--R   (2)  3
+--R                                                        Type: PositiveInteger
+--E 60
+
+--S 61
 f(-2) -- should be -2
+--R 
+--R   Compiling function f with type Integer -> Integer 
+--R
+--R   (3)  - 2
+--R                                                                Type: Integer
+--E 61
 
--- resolveTT not returning Any
--- Fixed by SCM 1/30/91
-
-)cl all
+@
+resolveTT not returning Any. Fixed by SCM 1/30/91
+<<*>>=
+)clear all
 
+--S 62
 m = [[1,2],[2,3]]  -- Should return type EQ POLY SQMATRIX(2, INT)
-
+--R 
+--R
+--R           +1  2+
+--R   (1)  m= |    |
+--R           +2  3+
+--R                            Type: Equation Polynomial SquareMatrix(2,Integer)
+--E 62
+
+--S 63
 [1, "asd"]   -- Should be of type List Any
+--R 
+--R
+--R   (2)  [1,"asd"]
+--R                                                               Type: List Any
+--E 63
 
 )set mes test off
+
+--S 64
 1+"asd"  -- These should both fail in the same way
+--R 
+--R   There are 11 exposed and 5 unexposed library operations named + 
+--R      having 2 argument(s) but none was determined to be applicable. 
+--R      Use HyperDoc Browse, or issue
+--R                                )display op +
+--R      to learn more about the available operations. Perhaps 
+--R      package-calling the operation or using coercions on the arguments
+--R      will allow you to apply the operation.
+--R 
+--R   Cannot find a definition or applicable library operation named + 
+--R      with argument type(s) 
+--R                               PositiveInteger
+--R                                   String
+--R      
+--R      Perhaps you should use "@" to indicate the required return type, 
+--R      or "$" to specify which version of the function you need.
+--E 64
+
+--S 65
 1/"asd"
-)set mes test on
+--R 
+--R   There are 12 exposed and 12 unexposed library operations named / 
+--R      having 2 argument(s) but none was determined to be applicable. 
+--R      Use HyperDoc Browse, or issue
+--R                                )display op /
+--R      to learn more about the available operations. Perhaps 
+--R      package-calling the operation or using coercions on the arguments
+--R      will allow you to apply the operation.
+--R 
+--R   Cannot find a definition or applicable library operation named / 
+--R      with argument type(s) 
+--R                               PositiveInteger
+--R                                   String
+--R      
+--R      Perhaps you should use "@" to indicate the required return type, 
+--R      or "$" to specify which version of the function you need.
+--E 65
 
--- Passing type variables to )show
+)set mes test on
 
-)cl all
+@
+Passing type variables to )show
+<<*>>=
+)clear all
 
+--S 66
 t := MPOLY([x,y], INT)
+--R 
+--R
+--R   (1)  MultivariatePolynomial([x,y],Integer)
+--R                                                                 Type: Domain
+--E 66
+
+--S 67
 )show t
+--R 
+--R MultivariatePolynomial([x,y],Integer) is a domain constructor.
+--R Abbreviation for MultivariatePolynomial is MPOLY 
+--R This constructor is exposed in this frame.
+--R Issue )edit multpoly.spad.pamphlet to see algebra source code for MPOLY 
+--R
+--R------------------------------- Operations --------------------------------
+--R
+--R ?*? : (Fraction Integer,%) -> %       ?*? : (Integer,%) -> %
+--R ?*? : (PositiveInteger,%) -> %        ?*? : (%,Fraction Integer) -> %
+--R ?*? : (%,Integer) -> %                ?*? : (%,%) -> %
+--R ?**? : (%,PositiveInteger) -> %       ?+? : (%,%) -> %
+--R ?-? : (%,%) -> %                      -? : % -> %
+--R ?/? : (%,Integer) -> %                ?<? : (%,%) -> Boolean
+--R ?<=? : (%,%) -> Boolean               ?=? : (%,%) -> Boolean
+--R ?>? : (%,%) -> Boolean                ?>=? : (%,%) -> Boolean
+--R 1 : () -> %                           0 : () -> %
+--R ?^? : (%,PositiveInteger) -> %        associates? : (%,%) -> Boolean
+--R coefficients : % -> List Integer      coerce : % -> OutputForm
+--R coerce : Fraction Integer -> %        coerce : Integer -> %
+--R coerce : % -> %                       content : % -> Integer
+--R convert : % -> InputForm              convert : % -> Pattern Float
+--R convert : % -> Pattern Integer        eval : (%,Equation %) -> %
+--R eval : (%,List Equation %) -> %       eval : (%,List %,List %) -> %
+--R eval : (%,%,%) -> %                   factor : % -> Factored %
+--R gcd : List % -> %                     gcd : (%,%) -> %
+--R ground : % -> Integer                 ground? : % -> Boolean
+--R hash : % -> SingleInteger             latex : % -> String
+--R lcm : List % -> %                     lcm : (%,%) -> %
+--R leadingCoefficient : % -> Integer     leadingMonomial : % -> %
+--R max : (%,%) -> %                      min : (%,%) -> %
+--R monomial? : % -> Boolean              monomials : % -> List %
+--R one? : % -> Boolean                   prime? : % -> Boolean
+--R primitiveMonomials : % -> List %      primitivePart : % -> %
+--R recip : % -> Union(%,"failed")        reductum : % -> %
+--R retract : % -> Fraction Integer       retract : % -> Integer
+--R sample : () -> %                      squareFree : % -> Factored %
+--R squareFreePart : % -> %               unit? : % -> Boolean
+--R unitCanonical : % -> %                zero? : % -> Boolean
+--R ?~=? : (%,%) -> Boolean              
+--R ?*? : (NonNegativeInteger,%) -> %
+--R ?**? : (%,NonNegativeInteger) -> %
+--R D : (%,List OrderedVariableList [x,y],List NonNegativeInteger) -> %
+--R D : (%,List OrderedVariableList [x,y]) -> %
+--R D : (%,OrderedVariableList [x,y],NonNegativeInteger) -> %
+--R D : (%,OrderedVariableList [x,y]) -> %
+--R ?^? : (%,NonNegativeInteger) -> %
+--R binomThmExpt : (%,%,NonNegativeInteger) -> %
+--R characteristic : () -> NonNegativeInteger
+--R charthRoot : % -> Union(%,"failed")
+--R coefficient : (%,IndexedExponents OrderedVariableList [x,y]) -> Integer
+--R coefficient : (%,List OrderedVariableList [x,y],List NonNegativeInteger) -> %
+--R coefficient : (%,OrderedVariableList [x,y],NonNegativeInteger) -> %
+--R coerce : OrderedVariableList [x,y] -> %
+--R conditionP : Matrix % -> Union(Vector %,"failed")
+--R content : (%,OrderedVariableList [x,y]) -> %
+--R degree : % -> IndexedExponents OrderedVariableList [x,y]
+--R degree : (%,List OrderedVariableList [x,y]) -> List NonNegativeInteger
+--R degree : (%,OrderedVariableList [x,y]) -> NonNegativeInteger
+--R differentiate : (%,List OrderedVariableList [x,y],List NonNegativeInteger) -> %
+--R differentiate : (%,List OrderedVariableList [x,y]) -> %
+--R differentiate : (%,OrderedVariableList [x,y],NonNegativeInteger) -> %
+--R differentiate : (%,OrderedVariableList [x,y]) -> %
+--R discriminant : (%,OrderedVariableList [x,y]) -> %
+--R eval : (%,List OrderedVariableList [x,y],List Integer) -> %
+--R eval : (%,List OrderedVariableList [x,y],List %) -> %
+--R eval : (%,OrderedVariableList [x,y],Integer) -> %
+--R eval : (%,OrderedVariableList [x,y],%) -> %
+--R exquo : (%,Integer) -> Union(%,"failed")
+--R exquo : (%,%) -> Union(%,"failed")
+--R factorPolynomial : SparseUnivariatePolynomial % -> Factored SparseUnivariatePolynomial %
+--R factorSquareFreePolynomial : SparseUnivariatePolynomial % -> Factored SparseUnivariatePolynomial %
+--R gcdPolynomial : (SparseUnivariatePolynomial %,SparseUnivariatePolynomial %) -> SparseUnivariatePolynomial %
+--R isExpt : % -> Union(Record(var: OrderedVariableList [x,y],exponent: NonNegativeInteger),"failed")
+--R isPlus : % -> Union(List %,"failed")
+--R isTimes : % -> Union(List %,"failed")
+--R mainVariable : % -> Union(OrderedVariableList [x,y],"failed")
+--R map : ((Integer -> Integer),%) -> %
+--R mapExponents : ((IndexedExponents OrderedVariableList [x,y] -> IndexedExponents OrderedVariableList [x,y]),%) -> %
+--R minimumDegree : % -> IndexedExponents OrderedVariableList [x,y]
+--R minimumDegree : (%,List OrderedVariableList [x,y]) -> List NonNegativeInteger
+--R minimumDegree : (%,OrderedVariableList [x,y]) -> NonNegativeInteger
+--R monicDivide : (%,%,OrderedVariableList [x,y]) -> Record(quotient: %,remainder: %)
+--R monomial : (Integer,IndexedExponents OrderedVariableList [x,y]) -> %
+--R monomial : (%,List OrderedVariableList [x,y],List NonNegativeInteger) -> %
+--R monomial : (%,OrderedVariableList [x,y],NonNegativeInteger) -> %
+--R multivariate : (SparseUnivariatePolynomial Integer,OrderedVariableList [x,y]) -> %
+--R multivariate : (SparseUnivariatePolynomial %,OrderedVariableList [x,y]) -> %
+--R numberOfMonomials : % -> NonNegativeInteger
+--R patternMatch : (%,Pattern Float,PatternMatchResult(Float,%)) -> PatternMatchResult(Float,%)
+--R patternMatch : (%,Pattern Integer,PatternMatchResult(Integer,%)) -> PatternMatchResult(Integer,%)
+--R pomopo! : (%,Integer,IndexedExponents OrderedVariableList [x,y],%) -> %
+--R primitivePart : (%,OrderedVariableList [x,y]) -> %
+--R reducedSystem : Matrix % -> Matrix Integer
+--R reducedSystem : (Matrix %,Vector %) -> Record(mat: Matrix Integer,vec: Vector Integer)
+--R resultant : (%,%,OrderedVariableList [x,y]) -> %
+--R retract : % -> OrderedVariableList [x,y]
+--R retractIfCan : % -> Union(Fraction Integer,"failed")
+--R retractIfCan : % -> Union(Integer,"failed")
+--R retractIfCan : % -> Union(OrderedVariableList [x,y],"failed")
+--R solveLinearPolynomialEquation : (List SparseUnivariatePolynomial %,SparseUnivariatePolynomial %) -> Union(List SparseUnivariatePolynomial %,"failed")
+--R squareFreePolynomial : SparseUnivariatePolynomial % -> Factored SparseUnivariatePolynomial %
+--R subtractIfCan : (%,%) -> Union(%,"failed")
+--R totalDegree : (%,List OrderedVariableList [x,y]) -> NonNegativeInteger
+--R totalDegree : % -> NonNegativeInteger
+--R unitNormal : % -> Record(unit: %,canonical: %,associate: %)
+--R univariate : % -> SparseUnivariatePolynomial Integer
+--R univariate : (%,OrderedVariableList [x,y]) -> SparseUnivariatePolynomial %
+--R variables : % -> List OrderedVariableList [x,y]
+--R
+--R
+--E 67
 
--- caching nullary functions
+@
+Caching nullary functions
+<<*>>=
+)clear all
 
+--S 68
 )set fun cache all
+--R 
+--R   In general, interpreter functions will cache all values.
+--E 68
 
+--S 69
 u == 1
+--R 
+--R                                                                   Type: Void
+--E 69
 
+--S 70
 u
+--R 
+--R   Compiling body of rule u to compute value of type PositiveInteger 
+--R   u will cache all previously computed values.
+--R
+--R   (2)  1
+--R                                                        Type: PositiveInteger
+--E 70
+
+--S 71
 )set fun cache 0
+--R 
+--R In general, functions will cache no returned values.
+--E 71
 
--- Interpreter Only mode on collects
--- Fixed by SCM on 3/1/91
+@
+Interpreter Only mode on collects. Fixed by SCM on 3/1/91
+<<*>>=
+)clear all
 
+--S 72
 factorp: (UP(x,INT),PositiveInteger,PositiveInteger) -> List(UP(x,INT))
+--R 
+--R                                                                   Type: Void
+--E 72
+
+--S 73
 factorp(poly,p,e) ==
    ppoly:UP(x,PF p):=poly
    pl := [rec.factor for rec in factors factor ppoly]
    facl:=pl::List(UP(x,INT))
+--R 
+--R                                                                   Type: Void
+--E 73
 
+--S 74
 factorp(x**2+x+5,7,1)
+--R 
+--R   Cannot compile the declaration for ppoly because its (possible 
+--R      partial) type contains a local variable.
+--R   AXIOM will attempt to step through and interpret the code.
+--R   Compiling function factorp with type (UnivariatePolynomial(x,Integer
+--R      ),PositiveInteger,PositiveInteger) -> List UnivariatePolynomial(x
+--R      ,Integer) 
+--R
+--R   (3)  [x + 2,x + 6]
+--R                                   Type: List UnivariatePolynomial(x,Integer)
+--E 74
 
+@
+Using "by" with segments. Fixed by SCM on 2/14/91
+<<*>>=
+)clear all
 
--- using "by" with segments
--- Fixed by SCM on 2/14/91
-
-)cl all
-
+--S 75
 b:= 1..10
-for i in b by 2 repeat output i
+--R 
+--R
+--R   (1)  1..10
+--R                                                Type: Segment PositiveInteger
+--E 75
 
--- DMP resolve bug
--- Fixed by SCM 3/7/91
+--S 76
+for i in b by 2 repeat output i
+--R 
+--R   1
+--R   3
+--R   5
+--R   7
+--R   9
+--R                                                                   Type: Void
+--E 76
 
-)cl all
+@
+DMP resolve bug. Fixed by SCM 3/7/91
+<<*>>=
+)clear all
 
+--S 77
 macro RN == FRAC INT
+--R 
+--R                                                                   Type: Void
+--E 77
+
+--S 78
 a51:=x+y+z+t+u;
+--R 
+--R
+--R                                                     Type: Polynomial Integer
+--E 78
+
+--S 79
 a52:=x*y+y*z+z*t+x*u+t*u;
+--R 
+--R
+--R                                                     Type: Polynomial Integer
+--E 79
+
+--S 80
 a53:=x*y*z+y*z*t+x*y*u+x*t*u+z*t*u;
+--R 
+--R
+--R                                                     Type: Polynomial Integer
+--E 80
+
+--S 81
 a54:=x*y*z*t+x*y*z*u+x*y*t*u+x*z*t*u+y*z*t*u;
+--R 
+--R
+--R                                                     Type: Polynomial Integer
+--E 81
+
+--S 82
 a55:=x*y*z*t*u-1;
+--R 
+--R
+--R                                                     Type: Polynomial Integer
+--E 82
 
+--S 83
 arnborg5: List HDMP([x,y,z,t,u],RN):=[a51,a52,a53,a54,a55];
-arnborg5l: List DMP([x,y,z,t,u],RN):=[a51,a52,a53,a54,a55];
+--R 
+--R
+--RType: List HomogeneousDistributedMultivariatePolynomial([x,y,z,t,u],Fraction Integer)
+--E 83
 
--- construct in interpret-only mode
--- Fixed by SCM on 3/7/91
+--S 84
+arnborg5l: List DMP([x,y,z,t,u],RN):=[a51,a52,a53,a54,a55];
+--R 
+--R
+--R   Type: List DistributedMultivariatePolynomial([x,y,z,t,u],Fraction Integer)
+--E 84
 
-)cl all
+@
+Construct in interpret-only mode. Fixed by SCM on 3/7/91
+<<*>>=
+)clear all
 
+--S 85
 factorp(poly,p,e) ==
    [rec.factor for rec in factors factor (poly::UP(x, PF p))]::List UP(x, INT)
+--R 
+--R                                                                   Type: Void
+--E 85
 
+--S 86
 factorp(x**2+x+5,7,1)
+--R 
+--R   Cannot compile conversion for types involving local variables. In 
+--R      particular, could not compile the expression involving :: UP(x,PF
+--R      #2) 
+--R   AXIOM will attempt to step through and interpret the code.
+--R
+--R   (2)  [x + 2,x + 6]
+--R                                   Type: List UnivariatePolynomial(x,Integer)
+--E 86
 
--- return in interpret-only mode
--- fixed by SCM 3/11/91
-
-)cl all
+@
+Return in interpret-only mode. fixed by SCM 3/11/91
+<<*>>=
+)clear all
 
+--S 87
 f (x) ==
   y: PF x := 1
   x = 3 => return x
   x = 4 => return(-x)
   (x+1)
+--R 
+--R                                                                   Type: Void
+--E 87
 
+--S 88
 f 3
+--R 
+--R   Cannot compile the declaration for y because its (possible partial) 
+--R      type contains a local variable.
+--R   AXIOM will attempt to step through and interpret the code.
+--R
+--R   (2)  3
+--R                                                        Type: PositiveInteger
+--E 88
 
--- incorrect handling of type of returns
--- fixed by SCM 3/11/91
-
-)cl all
+@
+Incorrect handling of type of returns. fixed by SCM 3/11/91
+<<*>>=
+)clear all
 
+--S 89
 f (x) ==
   x = 3 => return x
   x = 4 => return(-x)
   return (x+1)
+--R 
+--R                                                                   Type: Void
+--E 89
 
+--S 90
 f 3
+--R 
+--R   Compiling function f with type PositiveInteger -> Integer 
+--R
+--R   (2)  3
+--R                                                        Type: PositiveInteger
+--E 90
 
--- SquareMatrix coercion bug
--- Fixed by SCM on 4/3/91
-
-)cl all
+@
+SquareMatrix coercion bug. Fixed by SCM on 4/3/91
+<<*>>=
+)clear all
 
+--S 91
 s:SQMATRIX(2, INT) := matrix [[1,2],[2,3]]
+--R 
+--R
+--R        +1  2+
+--R   (1)  |    |
+--R        +2  3+
+--R                                                Type: SquareMatrix(2,Integer)
+--E 91
+
+--S 92
 s::SQMATRIX(2, FRAC INT)
+--R 
+--R
+--R        +1  2+
+--R   (2)  |    |
+--R        +2  3+
+--R                                       Type: SquareMatrix(2,Fraction Integer)
+--E 92
 
+@
+SquareMatric resolve bug
+<<*>>=
+)clear all
 
--- SquareMatric resolve bug
-
-)cl all
+--S 93
 Mat := SquareMatrix(2, Polynomial Integer)
+--R 
+--R
+--R   (1)  SquareMatrix(2,Polynomial Integer)
+--R                                                                 Type: Domain
+--E 93
+
+--S 94
 s:Mat := matrix [[ 2*x + 1, x], [x, 1]]
+--R 
+--R
+--R        +2x + 1  x+
+--R   (2)  |         |
+--R        +  x     1+
+--R                                     Type: SquareMatrix(2,Polynomial Integer)
+--E 94
+
+--S 95
 s**3
+--R 
+--R
+--R        +   3      2             3     2     +
+--R        |12x  + 15x  + 6x + 1  5x  + 6x  + 3x|
+--R   (3)  |                                    |
+--R        |     3     2            3     2     |
+--R        +   5x  + 6x  + 3x     2x  + 3x  + 1 +
+--R                                     Type: SquareMatrix(2,Polynomial Integer)
+--E 95
+
+--S 96
 %::Polynomial(?)
+--R 
+--R
+--R        +12  5+ 3   +15  6+ 2   +6  3+    +1  0+
+--R   (4)  |     |x  + |     |x  + |    |x + |    |
+--R        +5   2+     +6   3+     +3  0+    +0  1+
+--R                                     Type: Polynomial SquareMatrix(2,Integer)
+--E 96
 
--- parsing bug
--- Fixed by BURGE on 4/18/91
+@
+Parsing bug. Fixed by BURGE on 4/18/91
+<<*>>=
+)clear all
 
-)cl all
+--S 97
 -2**2  -- Should return -4
+--R 
+--R
+--R   (1)  - 4
+--R                                                                Type: Integer
+--E 97
 
--- # in constructor arguemnt list bug
--- Fixed by SCM on 4/9/91
+@
+\# in constructor arguemnt list bug. Fixed by SCM on 4/9/91
+<<*>>=
+)clear all
 
-)cl all
+--S 98
 f: DMP([x,y], INT) := x**2-y**2
+--R 
+--R
+--R         2    2
+--R   (1)  x  - y
+--R                       Type: DistributedMultivariatePolynomial([x,y],Integer)
+--E 98
+
+--S 99
 coefficient(f, degree f)
+--R 
+--R
+--R   (2)  1
+--R                                                        Type: PositiveInteger
+--E 99
 
--- retract from EXPR to POLY
--- fixed by SCM and SUTOR on 5/1/91
+@
+Retract from EXPR to POLY. fixed by SCM and SUTOR on 5/1/91
+<<*>>=
+)clear all
 
-)cl all
+--S 100
 x+1::EXPR INT
+--R 
+--R
+--R   (1)  x + 1
+--R                                                     Type: Expression Integer
+--E 100
+
+--S 101
 %::POLY INT
+--R 
+--R
+--R   (2)  x + 1
+--R                                                     Type: Polynomial Integer
+--E 101
 
--- fixed by SCM in May
+@
+Fixed by SCM in May
+<<*>>=
+)clear all
 
-)cl all
+--S 102
 solve([[1,2],[2,3]],[-2,3])
+--R 
+--R
+--R   (1)  [particular= [12,- 7],basis= [[0,0]]]
+--RType: Record(particular: Union(Vector Fraction Integer,"failed"),basis: List Vector Fraction Integer)
+--E 102
 
+@
+Fixed by several people over a period of time
+<<*>>=
+)clear all
 
--- fixed by several people over a period of time
-)cl all
-
+--S 103
 eval(m**2, m=[[1,2],[2,3]])
+--R 
+--R
+--R        +5  8 +
+--R   (1)  |     |
+--R        +8  13+
+--R                                     Type: Polynomial SquareMatrix(2,Integer)
+--E 103
 
--- filtering various illegal declarations
-
-)cl all
+@
+Filtering various illegal declarations
+<<*>>=
+)clear all
 
 )set mes test off
+
+--S 104
 r: Ring
+--R 
+--R 
+--R   Ring is a category, not a domain, and declarations require domains.
+--E 104
+
+--S 105
 w: RF INT
-)set mes test on
+--R 
+--R 
+--R   RationalFunction Integer is a package, not a domain, and 
+--R      declarations require domains.
+--E 105
 
--- Correct representation of length 1 records
+)set mes test on
 
-)cl all
+@
+Correct representation of length 1 records
+<<*>>=
+)clear all
 
+--S 106
 r:Record(a: INT) := [1]
+--R 
+--R
+--R   (1)  [a= 1]
+--R                                                     Type: Record(a: Integer)
+--E 106
 
--- Fast generation of POLY FLOAT graphics code
+@
+Fast generation of POLY FLOAT graphics code
+<<*>>=
+)clear all
 
-)time on
+--S 107
 p: POLY FLOAT := (x-1)**30
-draw(p, x=-1..1)
-
-)time )off
+--R 
+--R
+--R   (1)
+--R      30         29          28           27            26             25
+--R     x   - 30.0 x   + 435.0 x   - 4060.0 x   + 27405.0 x   - 142506.0 x
+--R   + 
+--R               24              23              22               21
+--R     593775.0 x   - 2035800.0 x   + 5852925.0 x   - 14307150.0 x
+--R   + 
+--R                 20               19               18                 17
+--R     30045015.0 x   - 54627300.0 x   + 86493225.0 x   - 1 19759850.0 x
+--R   + 
+--R                   16                 15                 14                 13
+--R     1 45422675.0 x   - 1 55117520.0 x   + 1 45422675.0 x   - 1 19759850.0 x
+--R   + 
+--R                 12               11               10               9
+--R     86493225.0 x   - 54627300.0 x   + 30045015.0 x   - 14307150.0 x
+--R   + 
+--R                8              7             6             5            4
+--R     5852925.0 x  - 2035800.0 x  + 593775.0 x  - 142506.0 x  + 27405.0 x
+--R   + 
+--R               3          2
+--R     - 4060.0 x  + 435.0 x  - 30.0 x + 1.0
+--R                                                       Type: Polynomial Float
+--E 107
+
+--draw(p, x=-1..1)
 
--- Case broken in interpreter
--- fixed by SCM in early 1991
-
-)cl all
+@
+Case broken in interpreter. fixed by SCM in early 1991
+<<*>>=
+)clear all
 
+--S 108
 sayBranch x == _
  if x case INT then output "Integer Branch" _
  else if x case STRING then output "String Branch" _
  else if x case FLOAT then output "Float Branch" _
  else output "don't know"
+--R 
+--R                                                                   Type: Void
+--E 108
 
+--S 109
 x:Union(INT,STRING,FLOAT)
+--R 
+--R                                                                   Type: Void
+--E 109
+
+--S 110
 x:=3
-sayBranch(x)
+--R 
+--R
+--R   (3)  3
+--R                                                     Type: Union(Integer,...)
+--E 110
 
--- bug in evaluateType
--- fixed by SCM in May 1991
+--S 111
+sayBranch(x)
+--R 
+--R 
+--RDaly Bug
+--R   case is only used for Unions and the object on the left-hand side 
+--R      does not belong to a union.
+--E 111
 
-)cl all
+@
+Bug in evaluateType. fixed by SCM in May 1991
+<<*>>=
+)clear all
 
+--S 112
 RFI := FRAC POLY INT
+--R 
+--R
+--R   (1)  Fraction Polynomial Integer
+--R                                                                 Type: Domain
+--E 112
+
+--S 113
 g:DMP([x,y], RFI) := a**2*x**2/b**2 - c**2*y**2/d**2
+--R 
+--R
+--R         2       2
+--R        a   2   c   2
+--R   (2)  -- x  - -- y
+--R         2       2
+--R        b       d
+--R   Type: DistributedMultivariatePolynomial([x,y],Fraction Polynomial Integer)
+--E 113
+
+--S 114
 factor g
+--R 
+--R
+--R         2
+--R        a       b c        b c
+--R   (3)  -- (x - --- y)(x + --- y)
+--R         2      a d        a d
+--R        b
+--RType: Factored DistributedMultivariatePolynomial([x,y],Fraction Polynomial Integer)
+--E 114
 
--- bug in resolveTTSpecial
--- Fixed by SCM 6/2/91
-
-)cl all
+@
+Bug in resolveTTSpecial. Fixed by SCM 6/2/91
+<<*>>=
+)clear all
 
+--S 115
 f(u:DoubleFloat, v:DoubleFloat):DoubleFloat == u+v
+--R 
+--R   Function declaration f : (DoubleFloat,DoubleFloat) -> DoubleFloat 
+--R      has been added to workspace.
+--R                                                                   Type: Void
+--E 115
+
+--S 116
 g(u:DoubleFloat, v:DoubleFloat):DoubleFloat == sin(u+v)
+--R 
+--R   Function declaration g : (DoubleFloat,DoubleFloat) -> DoubleFloat 
+--R      has been added to workspace.
+--R                                                                   Type: Void
+--E 116
+
+--S 117
 h(u:DoubleFloat, v:DoubleFloat):DoubleFloat == u+cos(v)
-draw(surface(f,g,h), 0..4, 0..2*%pi)
+--R 
+--R   Function declaration h : (DoubleFloat,DoubleFloat) -> DoubleFloat 
+--R      has been added to workspace.
+--R                                                                   Type: Void
+--E 117
 
--- check for package calling from categories
--- fixed by SCM 6/4/91
+--draw(surface(f,g,h), 0..4, 0..2*%pi)
 
-)cl all
+@
+Check for package calling from categories. fixed by SCM 6/4/91
+<<*>>=
+)clear all
 
 )set mes test off
+
+--S 118
 (1+1)$Ring
-)set mes test on
+--R 
+--R 
+--R   The right-hand side of the $ operator must be a package or domain 
+--R      name, but Ring is a category.
+--E 118
 
--- UnivariateSeries coercions
--- Fixed by SCM 6/20/91
+)set mes test on
 
-)cl all
+@
+UnivariateSeries coercions. Fixed by SCM 6/20/91
+<<*>>=
+)clear all
 
+--S 119
 s := series(sin(a*x), x=0)
+--R 
+--R
+--R               3        5        7          9            11
+--R              a   3    a   5    a    7     a     9      a      11      12
+--R   (1)  a x - -- x  + --- x  - ---- x  + ------ x  - -------- x   + O(x  )
+--R               6      120      5040      362880      39916800
+--R                        Type: UnivariatePuiseuxSeries(Expression Integer,x,0)
+--E 119
+
+--S 120
 s - a*x
+--R 
+--R
+--R   (2)
+--R        3        5        7          9            11              13
+--R       a   3    a   5    a    7     a     9      a      11       a       13
+--R     - -- x  + --- x  - ---- x  + ------ x  - -------- x   + ---------- x
+--R        6      120      5040      362880      39916800       6227020800
+--R   + 
+--R        14
+--R     O(x  )
+--R                        Type: UnivariatePuiseuxSeries(Expression Integer,x,0)
+--E 120
+
+--S 121
 s - sin(a*x)
+--R 
+--R
+--R           21
+--R   (3)  O(x  )
+--R                        Type: UnivariatePuiseuxSeries(Expression Integer,x,0)
+--E 121
 
--- Complex & AlgebraicNumber coercions
--- fixed by SCM 6/91
-
-)cl all
+@
+Complex & AlgebraicNumber coercions. fixed by SCM 6/91
+<<*>>=
+)clear all
 
+--S 122
 sin %i
+--R 
+--R
+--R   (1)  sin(%i)
+--R                                             Type: Expression Complex Integer
+--E 122
+
+--S 123
 sin sqrt 2
+--R 
+--R
+--R             +-+
+--R   (2)  sin(\|2 )
+--R                                                     Type: Expression Integer
+--E 123
+
+--S 124
 %i*sqrt(2)
+--R 
+--R
+--R           +-+
+--R   (3)  %i\|2
+--R                                             Type: Expression Complex Integer
+--E 124
+
+--S 125
 sin(%i*sqrt 2)
+--R 
+--R
+--R               +-+
+--R   (4)  sin(%i\|2 )
+--R                                             Type: Expression Complex Integer
+--E 125
+
+--S 126
 %i * sin(x)
+--R 
+--R
+--R   (5)  %i sin(x)
+--R                                             Type: Expression Complex Integer
+--E 126
+
+--S 127
 sin(x/sqrt(2))
+--R 
+--R
+--R              +-+
+--R            x\|2
+--R   (6)  sin(-----)
+--R              2
+--R                                                     Type: Expression Integer
+--E 127
 
--- bug in resolve
--- fixed by SCM 8/12/91
+@
+Bug in resolve. fixed by SCM 8/12/91
+<<*>>=
+)clear all
 
-)cl all
+)set msg test off
 
-)set test msg off
+--S 128
 primaryDecomp xx
-)set test msg on
+--R 
+--R   There are 1 exposed and 0 unexposed library operations named 
+--R      primaryDecomp having 1 argument(s) but none was determined to be 
+--R      applicable. Use HyperDoc Browse, or issue
+--R                          )display op primaryDecomp
+--R      to learn more about the available operations. Perhaps 
+--R      package-calling the operation or using coercions on the arguments
+--R      will allow you to apply the operation.
+--R 
+--RDaly Bug
+--R   Cannot find a definition or applicable library operation named 
+--R      primaryDecomp with argument type(s) 
+--R                                 Variable xx
+--R      
+--R      Perhaps you should use "@" to indicate the required return type, 
+--R      or "$" to specify which version of the function you need.
+--E 128
+
+)set msg test on
 
+@
+Functions with ADEFs were broken. fixed by SCM 8/9/91
+<<*>>=
+)clear all
 
--- functions with ADEFs were broken
--- fixwd by SCM 8/9/91
-
-)cl all
-
+--S 129
 f l ==
   reduce((x,y) +-> l.1 + x + y, l)
+--R 
+--R                                                                   Type: Void
+--E 129
 
+--S 130
 f [10,2,53]
-
+--R 
+--R   Compiling function f with type List PositiveInteger -> 
+--R      PositiveInteger 
+--R
+--R   (2)  85
+--R                                                        Type: PositiveInteger
+--E 130
+
+--S 131
 g l ==
   (x:INT):INT +-> l.x
+--R 
+--R                                                                   Type: Void
+--E 131
 
+--S 132
 w := g [23,1,341,12] ;
-
+--R 
+--R   Compiling function g with type List PositiveInteger -> (Integer -> 
+--R      Integer) 
+--R
+--R                                                   Type: (Integer -> Integer)
+--E 132
+
+--S 133
 w(1) + w(3)
--- w(-1) removed tpd; causes testing to crash
+--R 
+--R
+--R   (5)  364
+--R                                                        Type: PositiveInteger
+--E 133
+
+--S 134
+w(-1) 
+--R 
+--R 
+--RDaly Bug
+--R   >> Error detected within library code:
+--R   index out of range
+--R
+--R   Continuing to read the file...
+--R
+--E 134
 
--- coerces RN to PF and POLY to EXPR
--- fixed by SCM 8/9/91
-
-)cl all
+@
+Coerces RN to PF and POLY to EXPR. fixed by SCM 8/9/91
+<<*>>=
+)clear all
 
+--S 135
 a := 2/3
+--R 
+--R
+--R        2
+--R   (1)  -
+--R        3
+--R                                                       Type: Fraction Integer
+--E 135
+
 )set mes test off
+
+--S 136
 a::PF 3
+--R 
+--R 
+--R   Division by zero on conversion to GaloisField.
+--E 136
+
 )set mes test on
 
+--S 137
 b := x+1
-b:: EXPR FLOAT
-
--- minivector use in coercion functions
+--R 
+--R
+--R   (2)  x + 1
+--R                                                     Type: Polynomial Integer
+--E 137
 
-)cl all
+--S 138
+b:: EXPR FLOAT
+--R 
+--R
+--R   (3)  x + 1.0
+--R                                                       Type: Expression Float
+--E 138
 
+@
+Minivector use in coercion functions.
+<<*>>=
+)clear all
+ 
+--S 139
 symbol(s:Symbol,i:Integer):Symbol ==
   st0:String:= convert(i)
   st0:= concat(string(s),st0)
   st0::Symbol
+--R 
+--R   Function declaration symbol : (Symbol,Integer) -> Symbol has been 
+--R      added to workspace.
+--R                                                                   Type: Void
+--E 139
 
+--S 140
 f(a,b) == symbol(a,b)
+--R 
+--R                                                                   Type: Void
+--E 140
 
+--S 141
 f('abc,3)
+--R 
+--R   Compiling function symbol with type (Symbol,Integer) -> Symbol 
+--R   Compiling function f with type (Variable abc,PositiveInteger) -> 
+--R      Symbol 
+--R
+--R   (3)  abc3
+--R                                                                 Type: Symbol
+--E 141
 
--- coercing undeclared maps to Mapping types
--- fixed by SCM 9/3/91
-)cl all
+@
+Coercing undeclared maps to Mapping types. fixed by SCM 9/3/91
+<<*>>=
+)clear all
 
+--S 142
 f := operator 'f
+--R 
+--R
+--R   (1)  f
+--R                                                          Type: BasicOperator
+--E 412
+
+--S 143
 y := f(x)
+--R 
+--R
+--R   (2)  f(x)
+--R                                                     Type: Expression Integer
+--E 143
+
+--S 144
 foo(u) == sin(u)
-eval(y, 'f, foo)
+--R 
+--R                                                                   Type: Void
+--E 144
 
--- package calling constants
--- fixed by SCM 9/3/91
+--S 145
+eval(y, 'f, foo)
+--R 
+--R   There are 2 exposed and 6 unexposed library operations named sin 
+--R      having 1 argument(s) but none was determined to be applicable. 
+--R      Use HyperDoc Browse, or issue
+--R                               )display op sin
+--R      to learn more about the available operations. Perhaps 
+--R      package-calling the operation or using coercions on the arguments
+--R      will allow you to apply the operation.
+--R   Compiling function foo with type Expression Integer -> Expression 
+--R      Integer 
+--R
+--R   (4)  sin(x)
+--R                                                     Type: Expression Integer
+--E 145
 
-)cl all
+@
+Package calling constants. fixed by SCM 9/3/91
+<<*>>=
+)clear all
 
+--S 146
 init()$(PF 3)
+--R 
+--R
+--R   (1)  0
+--R                                                           Type: PrimeField 3
+--E 146
 
--- passing ADEFs to functions which require specific mapping types
-
-draw((x,y) +-> x**2 - y**2, -1..1, -1..1)
+@
+Passing ADEFs to functions which require specific mapping types.
+<<*>>=
+)clear all
 
--- DP bug.  Don't know where this came from, but its fixed
--- DP makes problems:
+--draw((x,y) +-> x**2 - y**2, -1..1, -1..1)
 
+@
+DP bug.  Don't know where this came from, but its fixed. DP makes problems:
+<<*>>=
+)clear all
 
+--S 147
 dmp := DMP([u1,u2,u3],Fraction INT)
+--R 
+--R
+--R   (1)  DistributedMultivariatePolynomial([u1,u2,u3],Fraction Integer)
+--R                                                                 Type: Domain
+--E 147
+
+--S 148
 p : dmp := 2*u1**4*u2*u3
+--R 
+--R
+--R           4
+--R   (2)  2u1 u2 u3
+--R         Type: DistributedMultivariatePolynomial([u1,u2,u3],Fraction Integer)
+--E 148
+
+--S 149
 e1 := degree p
--- the following doesn't work
+--R 
+--R
+--R   (3)  [4,1,1]
+--R                                    Type: DirectProduct(3,NonNegativeInteger)
+--E 149
+
+--S 150
 e2 : DirectProduct(3,NonNegativeInteger) := e1
+--R 
+--R
+--R   (4)  [4,1,1]
+--R                                    Type: DirectProduct(3,NonNegativeInteger)
+--E 150
+
+--S 151
 sup(e1,e1)
--- if you give to many infos to the Interpreter it has problems
+--R 
+--R
+--R   (5)  [4,1,1]
+--R                                    Type: DirectProduct(3,NonNegativeInteger)
+--E 151
+
+@
+If you give to many infos to the Interpreter it has problems.
+<<*>>=
+
+--S 152
 sup(e1,e1)$DirectProduct(3,NonNegativeInteger)
+--R 
+--R
+--R   (6)  [4,1,1]
+--R                                    Type: DirectProduct(3,NonNegativeInteger)
+--E 152
 
--- Some other bug.
 )clear all
 
+--S 153
 sum:=0
+--R 
+--R
+--R   (1)  0
+--R                                                     Type: NonNegativeInteger
+--E 153
+
+--S 154
 m:=matrix [[1,2],[3,4]]
+--R 
+--R
+--R        +1  2+
+--R   (2)  |    |
+--R        +3  4+
+--R                                                         Type: Matrix Integer
+--E 154
+
+--S 155
 lastcol:=ncols(m)
+--R 
+--R
+--R   (3)  2
+--R                                                        Type: PositiveInteger
+--E 155
+
+--S 156
 for r in 1..nrows(m) repeat
  -- interpreter having a value for "row" would cause it to hide
  -- the system function
  Row:=row(m,r)
  for c in 1..lastcol repeat
   sum:=sum+Row.c
-sum
-
+--R 
+--R                                                                   Type: Void
+--E 156
 
--- interpOnly mode left things in an incosistent state if it failed twice
--- fixed by SCM
+--S 157
+sum
+--R 
+--R
+--R   (5)  10
+--R                                                        Type: PositiveInteger
+--E 157
 
-)cl all
+@
+interpOnly mode left things in an incosistent state if it failed twice.
+fixed by SCM
+<<*>>=
+)clear all
 
+--S 158
 splitPoly(f,var) ==
    map(g +-> multivariate(g,var),monomials univariate(f,var))
+--R 
+--R                                                                   Type: Void
+--E 158
 
+--S 159
 g:=sin(x)+cos(x)
+--R 
+--R
+--R   (2)  sin(x) + cos(x)
+--R                                                     Type: Expression Integer
+--E 159
+
+--S 160
 k:=kernels(g).1
+--R 
+--R
+--R   (3)  sin(x)
+--R                                              Type: Kernel Expression Integer
+--E 160
 
 )set mes test off
+
+--S 161
 splitPoly([g],k) -- this is an incorrect call
+--R 
+--R   There are 4 exposed and 1 unexposed library operations named 
+--R      univariate having 2 argument(s) but none was determined to be 
+--R      applicable. Use HyperDoc Browse, or issue
+--R                           )display op univariate
+--R      to learn more about the available operations. Perhaps 
+--R      package-calling the operation or using coercions on the arguments
+--R      will allow you to apply the operation.
+--R   Cannot find a definition or applicable library operation named 
+--R      univariate with argument type(s) 
+--R                           List Expression Integer
+--R                          Kernel Expression Integer
+--R      
+--R      Perhaps you should use "@" to indicate the required return type, 
+--R      or "$" to specify which version of the function you need.
+--R   AXIOM will attempt to step through and interpret the code.
+--R   There are 4 exposed and 1 unexposed library operations named 
+--R      univariate having 2 argument(s) but none was determined to be 
+--R      applicable. Use HyperDoc Browse, or issue
+--R                           )display op univariate
+--R      to learn more about the available operations. Perhaps 
+--R      package-calling the operation or using coercions on the arguments
+--R      will allow you to apply the operation.
+--R 
+--R   Cannot find a definition or applicable library operation named 
+--R      univariate with argument type(s) 
+--R                           List Expression Integer
+--R                          Kernel Expression Integer
+--R      
+--R      Perhaps you should use "@" to indicate the required return type, 
+--R      or "$" to specify which version of the function you need.
+--E 161
+
 )set mes test on
+
+--S 162
 splitPoly(numer g,k) -- this is a correct call
+--R 
+--R   Compiling function splitPoly with type (SparseMultivariatePolynomial
+--R      (Integer,Kernel Expression Integer),Kernel Expression Integer)
+--R       -> List SparseMultivariatePolynomial(Integer,Kernel Expression 
+--R      Integer) 
+--R
+--R   (4)  [sin(x),cos(x)]
+--R   Type: List SparseMultivariatePolynomial(Integer,Kernel Expression Integer)
+--E 162
 
--- scoping of lambda variables
--- fixed by SCM in March, 1992
+@
+Scoping of lambda variables. fixed by SCM in March, 1992
+<<*>>=
+)clear all
 
-)cl all
+--S 163
 f x ==
   g := (y:DoubleFloat):DoubleFloat +-> y+x
   output(y+1)
   g(x)
+--R 
+--R                                                                   Type: Void
+--E 163
 
+--S 164
 f 3
+--R 
+--R   Compiling function f with type PositiveInteger -> DoubleFloat 
+--R   y + 1
+--R
+--R   (2)  6.
+--R                                                            Type: DoubleFloat
+--E 164
 
--- coercing undeclared interpreter function to mapping type with
--- target which need to be coerced.
--- fixed by SCM in March, 1992
-
-)cl all
+@
+Coercing undeclared interpreter function to mapping type with
+target which need to be coerced.
+fixed by SCM in March, 1992
+<<*>>=
+)clear all
 
+--S 165
 f x == 1/factorial(x)
+--R 
+--R                                                                   Type: Void
+--E 165
 
+--S 166
 series(f, x=0)
+--R 
+--R   Compiling function f with type Integer -> Expression Integer 
+--R
+--R   (2)
+--R             1  2   1  3    1  4    1   5    1   6     1   7     1    8
+--R     1 + x + - x  + - x  + -- x  + --- x  + --- x  + ---- x  + ----- x
+--R             2      6      24      120      720      5040      40320
+--R   + 
+--R        1    9      1     10      11
+--R     ------ x  + ------- x   + O(x  )
+--R     362880      3628800
+--R                        Type: UnivariatePuiseuxSeries(Expression Integer,x,0)
+--E 166
 
--- rule dependencies with dependencies on the operator postion
+@
+Rule dependencies with dependencies on the operator position.
+<<*>>=
+)clear all
 
-)cl all
+--S 167
 node_a == i1+i2+i3-i5+i6=0
+--R 
+--R                                                                   Type: Void
+--E 167
+
+--S 168
 node_b == -i2-i3+i4-i6=0
+--R 
+--R                                                                   Type: Void
+--E 168
+
+--S 169
 i1 == va/r1
+--R 
+--R                                                                   Type: Void
+--E 169
+
+--S 170
 i2 == (va-vb)/r2
+--R 
+--R                                                                   Type: Void
+--E 170
+
+--S 171
 i3 == (va-vb)/r3
+--R 
+--R                                                                   Type: Void
+--E 171
+
+--S 172
 i4 == vb/r4
+--R 
+--R                                                                   Type: Void
+--E 172
+
+--S 173
 node_a
+--R 
+--R   Compiling body of rule i1 to compute value of type Fraction 
+--R      Polynomial Integer 
+--R   Compiling body of rule i2 to compute value of type Fraction 
+--R      Polynomial Integer 
+--R   Compiling body of rule i3 to compute value of type Fraction 
+--R      Polynomial Integer 
+--R   Compiling body of rule nodea to compute value of type Equation 
+--R      Fraction Polynomial Integer 
+--R
+--R        (- r1 r3 - r1 r2)vb + ((r2 + r1)r3 + r1 r2)va + (i6 - i5)r1 r2 r3
+--R   (7)  -----------------------------------------------------------------= 0
+--R                                     r1 r2 r3
+--R                                   Type: Equation Fraction Polynomial Integer
+--E 173
+
+--S 174
 node_b
+--R 
+--R   Compiling body of rule i4 to compute value of type Fraction 
+--R      Polynomial Integer 
+--R   Compiling body of rule nodeb to compute value of type Equation 
+--R      Fraction Polynomial Integer 
+--R
+--R        ((r3 + r2)r4 + r2 r3)vb + (- r3 - r2)r4 va - i6 r2 r3 r4
+--R   (8)  --------------------------------------------------------= 0
+--R                                r2 r3 r4
+--R                                   Type: Equation Fraction Polynomial Integer
+--E 174
+
+--S 175
 ans == solve([node_a,node_b],[va,vb]) -- (*)
+--R 
+--R                                                                   Type: Void
+--E 175
+
+--S 176
 x1 == rhs(ans.1.1)
+--R 
+--R                                                                   Type: Void
+--E 176
+
+--S 177
 x2 == rhs(ans.1.2)
+--R 
+--R                                                                   Type: Void
+--E 177
+
+--S 178
 x1       -- (**)
+--R 
+--R   Compiling body of rule ans to compute value of type List List 
+--R      Equation Fraction Polynomial Integer 
+--R   Compiling body of rule x1 to compute value of type Fraction 
+--R      Polynomial Integer 
+--R
+--R         (i5 r1 r3 + i5 r1 r2)r4 + (- i6 + i5)r1 r2 r3
+--R   (12)  ---------------------------------------------
+--R               (r3 + r2)r4 + (r2 + r1)r3 + r1 r2
+--R                                            Type: Fraction Polynomial Integer
+--E 178
+
+--S 179
 r1 == 2  -- (***)
+--R 
+--R   Compiled code for i1 has been cleared.
+--R   Compiled code for nodea has been cleared.
+--R   Compiled code for ans has been cleared.
+--R   Compiled code for x1 has been cleared.
+--R                                                                   Type: Void
+--E 179
+
+--S 180
 x1       -- (****)
+--R 
+--R   Compiling body of rule r1 to compute value of type PositiveInteger 
+--R   Compiling body of rule i1 to compute value of type Polynomial 
+--R      Fraction Integer 
+--R   Compiling body of rule nodea to compute value of type Equation 
+--R      Fraction Polynomial Integer 
+--R   Compiling body of rule ans to compute value of type List List 
+--R      Equation Fraction Polynomial Integer 
+--R   Compiling body of rule x1 to compute value of type Fraction 
+--R      Polynomial Integer 
+--R
+--R         (2i5 r3 + 2i5 r2)r4 + (- 2i6 + 2i5)r2 r3
+--R   (14)  ----------------------------------------
+--R              (r3 + r2)r4 + (r2 + 2)r3 + 2r2
+--R                                            Type: Fraction Polynomial Integer
+--E 180
 
--- look for immediate data in operator position
--- fixed in March 1992 by SCM and RSS
+@
+Look for immediate data in operator position. 
+fixed in March 1992 by SCM and RSS
+<<*>>=
+)clear all
 
+--S 181
 "asd" "sdfsdf" "dfgdfg"
+--R 
+--R
+--R   (1)  "asdsdfsdfdfgdfg"
+--R                                                                 Type: String
+--E 181
 
--- global variables that change type in a loop.
--- fixed by SCM
+@
+Global variables that change type in a loop.
+fixed by SCM
+<<*>>=
 )clear all
+
+--S 182
 s := 3.4
+--R 
+--R
+--R   (1)  3.4
+--R                                                                  Type: Float
+--E 182
+
+--S 183
 while s > 1.0 repeat (s := 1/2; print s)
+--R 
+--R   1
+--R   -
+--R   2
+--R                                                                   Type: Void
+--E 183
+
+--S 184
 s
+--R 
+--R
+--R        1
+--R   (3)  -
+--R        2
+--R                                                       Type: Fraction Integer
+--E 184
 
-)cl all
+)clear all
 
+--S 185
 f x ==
   free s
   s := x
   while s > 1.0 repeat (s := 1/2; print s)
   s
+--R 
+--R                                                                   Type: Void
+--E 185
 
+--S 186
 f(3.4)
+--R 
+--R   Compiling function f with type Float -> Float 
+--R   Compiled code for f has been cleared.
+--R   0.5
+--R
+--R   (2)  0.5
+--R                                                                  Type: Float
+--E 186
 
--- returns in sequences
--- fixed by SCM
+@
+Returns in sequences. fixed by SCM
+<<*>>=
+)clear all
 
+--S 187
 t x ==
   if x = 1 then (1; return [x])
   return [2]
+--R 
+--R                                                                   Type: Void
+--E 187
 
+--S 188
 t 1
+--R 
+--R   Compiling function t with type PositiveInteger -> List 
+--R      PositiveInteger 
+--R
+--R   (2)  [1]
+--R                                                   Type: List PositiveInteger
+--E 188
+)spool 
+)lisp (bye)
+ 
 @
 \eject
 \begin{thebibliography}{99}



From MAILER-DAEMON Sun Aug 17 16:06:24 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KUoW8-0005cX-LO
	for mharc-axiom-developer@gnu.org; Sun, 17 Aug 2008 16:06:24 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KUoW6-0005aj-Kg
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 16:06:22 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KUoW3-0005Xq-Ep
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 16:06:22 -0400
Received: from [199.232.76.173] (port=38820 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KUoW3-0005Xe-9B
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 16:06:19 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:48189
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KUoW2-0006Qr-O6
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 16:06:18 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7HK6Gr3007240;
	Sun, 17 Aug 2008 15:06:16 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7HK6FcB007236;
	Sun, 17 Aug 2008 15:06:15 -0500
Date: Sun, 17 Aug 2008 15:06:15 -0500
Message-Id: <200808172006.m7HK6FcB007236@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080817.01.tpd.patch (fix uncompress)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 17 Aug 2008 20:06:22 -0000

There is an interaction between the makefile syntax and the shell
variable syntax which leads to problems. Hardcode the desired result.
======================================================================
diff --git a/books/bookvol7.1.pamphlet b/books/bookvol7.1.pamphlet
index a629a3c..09a7929 100644
--- a/books/bookvol7.1.pamphlet
+++ b/books/bookvol7.1.pamphlet
@@ -188310,7 +188310,7 @@ ${HYPER}/ht.db: ${BOOK}
 	@ cp -pr ${IN}/bitmaps ${HYPER}
 	@ cp -pr ${IN}/viewports ${HYPER}
 	@ (cd ${HYPER}/viewports ; \
-            for i in `find . -name "*.Z"` ; do $${UNCOMPRESS} $$i ; done )
+            for i in `find . -name "*.Z"` ; do gunzip $$i ; done )
 
 @
 \eject
diff --git a/changelog b/changelog
index 5a3a67b..7603cef 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,4 @@
+20080817 tpd books/bookvol7.1 fix uncompress
 20080816 tpd src/input/Makefile add regression tests
 20080816 tpd src/input/test.input create regression
 20080816 tpd src/input/regset.input create regression



From MAILER-DAEMON Sun Aug 17 22:57:51 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KUuwJ-0003L6-FY
	for mharc-axiom-developer@gnu.org; Sun, 17 Aug 2008 22:57:51 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KUuwH-0003Kx-LC
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 22:57:49 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KUuwG-0003KZ-0D
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 22:57:48 -0400
Received: from [199.232.76.173] (port=32979 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KUuwF-0003KJ-RW
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 22:57:47 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:48558
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KUuwF-0007nK-8f
	for axiom-developer@nongnu.org; Sun, 17 Aug 2008 22:57:47 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7I2vhr3030477;
	Sun, 17 Aug 2008 21:57:43 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7I2vh66030474;
	Sun, 17 Aug 2008 21:57:43 -0500
Date: Sun, 17 Aug 2008 21:57:43 -0500
Message-Id: <200808180257.m7I2vh66030474@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080817.02.tpd.patch (recover function.input)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 18 Aug 2008 02:57:50 -0000

The input file function.input had several outstanding bugs.
These have been fixed. The file has been rewritten into
regression format and added to the test suite.

====================================================================
diff --git a/changelog b/changelog
index 7603cef..ea20f30 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,5 @@
+20080817 tpd src/input/Makefile add function.regress
+20080817 tpd src/input/function.input fix problems with input file
 20080817 tpd books/bookvol7.1 fix uncompress
 20080816 tpd src/input/Makefile add regression tests
 20080816 tpd src/input/test.input create regression
diff --git a/src/input/Makefile.pamphlet b/src/input/Makefile.pamphlet
index 5581e71..a4d2218 100644
--- a/src/input/Makefile.pamphlet
+++ b/src/input/Makefile.pamphlet
@@ -238,18 +238,11 @@ SKIP= as-eg1.output as-eg2.output    \
 # Error ASEC is invalid as a function.
 ASEC=errortrap.output 
 
-# Error: FLUSH is invalid as a function
-# Error signalled by newGoGet
-FLUSH=
-
 # Error: The function WRAPPED is undefined.
 WRAPPED=loop.output      
 
 # Error: Value stack overflow.
-VALUESTACK=tutchap67.output  test.output
-
-# Broken at |MODOP;ELT;$2M;6|.  Type :H for Help.
-MODOP=function.output  
+VALUESTACK=tutchap67.output
 
 # Broken at |MATCAT-;*;3S;29|.  Type :H for Help.
 MATCAT=linalg.output    
@@ -317,7 +310,7 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     float.regress     fname1.regress   fname.regress    fnla.regress \
     fns.regress       fparfrac.regress fparfrc.regress  fr1.regress \
     fr2.regress       frac.regress     fr.regress       free.regress \
-    galois.regress    gamma.regress \
+    function.regress  galois.regress    gamma.regress \
     gbf.regress       genups.regress   gonshor.regress  grpthry.regress \
     gstbl.regress     heap.regress     heat.regress     help.regress \
     herm.regress      heugcd.regress \
diff --git a/src/input/function.input.pamphlet b/src/input/function.input.pamphlet
index dc331f4..8e2c181 100644
--- a/src/input/function.input.pamphlet
+++ b/src/input/function.input.pamphlet
@@ -9,78 +9,356 @@
 \eject
 \tableofcontents
 \eject
+Input for page RationatFunctionPage
 <<*>>=
-
--- Input for page RationatFunctionPage
+)spool function.output
+)set message test on
+)set message auto off
 )clear all
 
+--S 1 of 33
 f := (x - y) / (x + y)
+--R
+--R        - y + x
+--R   (1)  -------
+--R         y + x
+--R                                            Type: Fraction Polynomial Integer
+--E 1
+
+--S 2 of 33
 numer f
+--R
+--R   (2)  - y + x
+--R                                                     Type: Polynomial Integer
+--E 2
+
+--S 3 of 33
 denom f
+--R
+--R   (3)  y + x
+--R                                                     Type: Polynomial Integer
+--E 3
+
+--S 4 of 33
 eval(f, x = 1/x)
+--R
+--R        - x y + 1
+--R   (4)  ---------
+--R         x y + 1
+--R                                            Type: Fraction Polynomial Integer
+--E 4
+
+--S 5 of 33
 eval(f, [x = y, y = x])
+--R
+--R        y - x
+--R   (5)  -----
+--R        y + x
+--R                                            Type: Fraction Polynomial Integer
+--E 5
 
--- Input for page AlgebraicFunctionPage
+@
+Input for page AlgebraicFunctionPage
+<<*>>=
 )clear all
 
+--S 6 of 33
 f := sqrt(1 + x ** (1/3))
+--R
+--R         +--------+
+--R         |3+-+
+--R   (1)  \|\|x  + 1
+--R                                                     Type: Expression Integer
+--E 6
+
+--S 7 of 33
 y := rootOf(y**3 + y**2 - x*y + x**3 - 1, y)
+--R
+--R   (2)  y
+--R                                                     Type: Expression Integer
+--E 7
+
+--S 8 of 33
 differentiate(y, x)
+--R
+--R                 2
+--R           y - 3x
+--R   (3)  ------------
+--R          2
+--R        3y  + 2y - x
+--R                                                     Type: Expression Integer
+--E 8
+
+--S 9 of 33
 (y + 1) ** 3
+--R
+--R          2               3
+--R   (4)  2y  + (x + 3)y - x  + 2
+--R                                                     Type: Expression Integer
+--E 9
+
+--S 10 of 33
 g := inv f
-ratForm g
+--R
+--R             1
+--R   (5)  -----------
+--R         +--------+
+--R         |3+-+
+--R        \|\|x  + 1
+--R                                                     Type: Expression Integer
+--E 10
 
--- Input for page OperatorPage
-)clear all
+--S 11 of 33
+ratPoly g
+--R
+--R                6     4     2
+--R   (6)  (x + 1)?  - 3?  + 3?  - 1
+--R                          Type: SparseUnivariatePolynomial Expression Integer
+--E 11
 
-R := SQMATRIX(2, INT)
-t := operator("tilde")::OP(R)
-evaluate(t, m +-> transpose m)
-s:R := matrix [[0, 1], [1, 0]]
-rho := t * s
-z := rho**4 - 1
-m:R := matrix [[1, 2], [3, 4]]
-z m
-rho m
-rho rho m
-(rho**3) m
-b := t * s - s * t
-b m
-)read opalg
-
--- Input for page ElementaryFunctionPage
+@
+Input for page ElementaryFunctionPage
+<<*>>=
 )clear all
 
+--S 12 of 33
 f := x * log y * sin(1/(x+y))
+--R
+--R                      1
+--R   (1)  x log(y)sin(-----)
+--R                    y + x
+--R                                                     Type: Expression Integer
+--E 12
+
+--S 13 of 33
 eval(f, [x = y, y = x])
+--R
+--R                      1
+--R   (2)  y log(x)sin(-----)
+--R                    y + x
+--R                                                     Type: Expression Integer
+--E 13
+
+--S 14 of 33
 eval(f, log y = acosh(x + sqrt y))
+--R
+--R                1          +-+
+--R   (3)  x sin(-----)acosh(\|y  + x)
+--R              y + x
+--R                                                     Type: Expression Integer
+--E 14
 
--- Input for page FunctionSimplificationPage
+@
+Input for page FunctionSimplificationPage
+<<*>>=
 )clear all
 
+--S 15 of 33
 f := cos(x)/sec(x) * log(sin(x)**2/(cos(x)**2+sin(x)**2))
+--R
+--R                             2
+--R                       sin(x)
+--R        cos(x)log(-----------------)
+--R                        2         2
+--R                  sin(x)  + cos(x)
+--R   (1)  ----------------------------
+--R                   sec(x)
+--R                                                     Type: Expression Integer
+--E 15
+
+--S 16 of 33
 g := simplify f
+--R
+--R              2            2
+--R   (2)  cos(x) log(- cos(x)  + 1)
+--R                                                     Type: Expression Integer
+--E 16
+
+--S 17 of 33
 h := sin2csc cos2sec g
+--R
+--R                  2
+--R            sec(x)  - 1
+--R        log(-----------)
+--R                    2
+--R              sec(x)
+--R   (3)  ----------------
+--R                   2
+--R             sec(x)
+--R                                                     Type: Expression Integer
+--E 17
+
+--S 18 of 33
 expandLog h
+--R
+--R                  2
+--R        log(sec(x)  - 1) - 2log(sec(x))
+--R   (4)  -------------------------------
+--R                          2
+--R                    sec(x)
+--R                                                     Type: Expression Integer
+--E 18
+
+--S 19 of 33
 f1 := sqrt((x+1)**3)
+--R
+--R         +-----------------+
+--R         | 3     2
+--R   (5)  \|x  + 3x  + 3x + 1
+--R                                                     Type: Expression Integer
+--E 19
+
+--S 20 of 33
 rootSimp f1
+--R
+--R                +-----+
+--R   (6)  (x + 1)\|x + 1
+--R                                                     Type: Expression Integer
+--E 20
+
+--S 21 of 33
 g1 := sin(x + cos x)
+--R
+--R   (7)  sin(cos(x) + x)
+--R                                                     Type: Expression Integer
+--E 21
+
+--S 22 of 33
 g2 := complexElementary g1
+--R
+--R                              +---+ 2               +---+          2
+--R                    +---+   x\|- 1         +---+  x\|- 1     +---+
+--R                   \|- 1 (%e       )  + 2x\|- 1 %e        + \|- 1
+--R                   -----------------------------------------------
+--R                                           +---+
+--R                                         x\|- 1
+--R           +---+                      2%e                               +---+
+--R        - \|- 1 (%e                                               )  + \|- 1
+--R   (8)  ---------------------------------------------------------------------
+--R                                +---+ 2               +---+
+--R                      +---+   x\|- 1         +---+  x\|- 1     +---+
+--R                     \|- 1 (%e       )  + 2x\|- 1 %e        + \|- 1
+--R                     -----------------------------------------------
+--R                                             +---+
+--R                                           x\|- 1
+--R                                        2%e
+--R                  2%e
+--R                                                     Type: Expression Integer
+--E 22
+
+--S 23 of 33
 trigs g2
+--R
+--R   (9)  sin(cos(x) + x)
+--R                                                     Type: Expression Integer
+--E 23
+
+--S 24 of 33
 h1 := sinh(x + cosh x)
+--R
+--R   (10)  sinh(cosh(x) + x)
+--R                                                     Type: Expression Integer
+--E 24
+
+--S 25 of 33
 h2 := realElementary h1
+--R
+--R               x 2        x     2
+--R            (%e )  + 2x %e  + 1
+--R            -------------------
+--R                       x
+--R                    2%e
+--R         (%e                   )  - 1
+--R   (11)  ----------------------------
+--R                  x 2        x
+--R               (%e )  + 2x %e  + 1
+--R               -------------------
+--R                          x
+--R                       2%e
+--R            2%e
+--R                                                     Type: Expression Integer
+--E 25
+
+--S 26 of 33
 htrigs h2
+--R
+--R   (12)  sinh(cosh(x) + x)
+--R                                                     Type: Expression Integer
+--E 26
 
--- Input for page PatternMatchingPage
+@
+Input for page PatternMatchingPage
+<<*>>=
 )clear all
 
+--S 27 of 33
 groupSqrt := _rule(sqrt(a) * sqrt(b), sqrt(a*b))
+--R
+--R           +-+ +-+       +---+
+--I   (1)  %B\|a \|b  == %B\|a b
+--R                        Type: RewriteRule(Integer,Integer,Expression Integer)
+--E 27
+
+--S 28 of 33
 a := sqrt(2) * sqrt(3)
+--R
+--R         +-+ +-+
+--R   (2)  \|2 \|3
+--R                                                        Type: AlgebraicNumber
+--E 28
+
+--S 29 of 33
 groupSqrt a
+--R
+--R         +-+
+--R   (3)  \|6
+--R                                                     Type: Expression Integer
+--E 29
+
+--S 30 of 33
 a := (sqrt(x) + sqrt(y))**4
+--R
+--R                  +-+ +-+    2           2
+--R   (4)  (4y + 4x)\|x \|y  + y  + 6x y + x
+--R                                                     Type: Expression Integer
+--E 30
+
+--S 31 of 33
 groupSqrt a
-)read sincosex
+--R
+--R                  +---+    2           2
+--R   (5)  (4y + 4x)\|x y  + y  + 6x y + x
+--R                                                     Type: Expression Integer
+--E 31
+
+--S 32 of 33
+sinCosExpand := rule
+  sin(-x)    == - sin(x)
+  cos(-x)    == cos(x)
+  sin(x + y) == sin(x) * cos(y) + sin(y) * cos(x)
+  cos(x + y) == cos(x) * cos(y) - sin(x) * sin(y)
+  sin((n | integer? n and n > 1) * x) ==_
+       sin(x) * cos((n-1)*x) + sin((n-1)*x) * cos(x)
+  cos((n | integer? n and n > 1) * x) ==_
+       cos(x) * cos((n-1)*x) - sin(x) * sin((n-1)*x)
+--R 
+--R
+--R   (6)
+--I   {- %BC sin(x) == - %BC sin(x), cos(x) == cos(x),
+--R    sin(y + x) == cos(x)sin(y) + cos(y)sin(x),
+--R    cos(y + x) == - sin(x)sin(y) + cos(x)cos(y),
+--R    sin(n x) == cos(x)sin((n - 1)x) + cos((n - 1)x)sin(x),
+--R    cos(n x) == - sin(x)sin((n - 1)x) + cos(x)cos((n - 1)x)}
+--R                            Type: Ruleset(Integer,Integer,Expression Integer)
+--E 32
+
+--S 33 of 33
 sinCosExpand(sin(x+y-2*z) * cos y)
+--R
+--R   (7)  - cos(y)sin(2z - y - x)
+--R                                                     Type: Expression Integer
+--E 33
+
 @
 \eject
 \begin{thebibliography}{99}



From MAILER-DAEMON Mon Aug 18 00:57:33 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KUwo9-0000PH-CY
	for mharc-axiom-developer@gnu.org; Mon, 18 Aug 2008 00:57:33 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KUwo7-0000PB-7i
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 00:57:31 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KUwo3-0000Oy-AC
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 00:57:30 -0400
Received: from [199.232.76.173] (port=43321 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KUwo3-0000Ov-1h
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 00:57:27 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:33969
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KUwo1-0003lg-1h
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 00:57:27 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7I4vLr3014583;
	Sun, 17 Aug 2008 23:57:21 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7I4vLWl014580;
	Sun, 17 Aug 2008 23:57:21 -0500
Date: Sun, 17 Aug 2008 23:57:21 -0500
Message-Id: <200808180457.m7I4vLWl014580@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] Example documentation for exposed functions
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 18 Aug 2008 04:57:31 -0000

Making Axiom easier to use is a primary goal and user documentation is
a primary subgoal. 

Given a particular function from a particular domain it is often
difficult to figure out how to construct a correct instance of a call
to that function. Ideally the user should just be able to display the
function and see an example.

The algebra files now contain a documentation syntax for exported
functions. If a domain has an exported line like:

   coerce: PrimitiveArray S -> %
    ++ coerce(a) makes a tuple from primitive array a

there is a new extension to the syntax to add examples. Essentially
any line that begins with ++E will be output as Example documentation
to the display command. So the coerce from Tuple now reads:

   coerce: PrimitiveArray S -> %
    ++ coerce(a) makes a tuple from primitive array a
    ++
    ++E t1:PrimitiveArray(Integer):= [i for i in 1..10]
    ++E t2:=coerce(t1)$Tuple(Integer)

Axiom now prints examples of function invocation. So when a user 
asks to display a particular operation (e.g. coerce):

   )display operation coerce

among the final output are the lines:

   Examples of coerce from Tuple

    t1:PrimitiveArray(Integer):= [i for i in 1..10]
    t2:=coerce(t1)$Tuple(Integer)

as well as examples from any other domain with Example documentation
for the same requested function:

   Examples of coerce from PendantTree

    t1:=ptree([1,2,3])
    t2:=ptree(t1,ptree([1,2,3]))
    t2::Tree List PositiveInteger


Attached is a file to track the progress in documenting all 5090
exposed, unique function names in Axiom. This information will be
tracked and updated on a regular basis. So far I have documented
103 functions.

Tim

==========================================================================

There are approximately 5090 functions exposed in Axiom.
The first set of functions have documentation printed 
to show an example of invoking the function when the
user types:
   )d op map

The functions after the break (that is, after the ============= line)
still need examples.

This file exists solely to document the progress.

=== DOCUMENTED=============================================================

absolutelyIrreducible? from FunctionFieldCategory
alphabetic? from Character
alphanumeric? from Character
arrayStack from ArrayStack

balancedBinaryTree from BalancedBinaryTree
binary from BinaryExpansion
binary from InputForm
branchPointAtInfinity? from FunctionFieldCategory
binarySearchTree from BinarySearchTree
binaryTournament from BinaryTournament
binaryTree from BinaryTree

char from Character
coerce from PendantTree
coerce from Tuple
column from TwoDimensionalArrayCategory
cyclicCopy from Tree
cyclicEntries from Tree
cyclicEqual? from Tree
cyclicParents from Tree
cyclic? from Tree

delete! from ExtensibleLinearAggregate
dequeue from Dequeue
digit? from Character

elt from TwoDimensionalArrayCategory
escape from Character
expand from Factored
exponent from Factored

factorList from Factored
factors from Factored
fill! from TwoDimensionalArrayCategory
flagFactor from Factored
flexibleArray from IndexedFlexibleArray

gcd from HeuGcd
genus from FunctionFieldCategory

heap from Heap
hexDigit? from Character

insert! from BinarySearchTree
insert! from BinaryTournament
insertRoot! from BinarySearchTree
integralBasis from FunctionFieldCategory
integralBasisAtInfinity from FunctionFieldCategory
integralMatrix from FunctionFieldCategory
integralMatrixAtInfinity from FunctionFieldCategory
inverseIntegralMatrix from FunctionFieldCategory
inverseIntegralMatrixAtInfinity from FunctionFieldCategory
irreducibleFactor from Factored

length from Tuple
lowerCase from Character
lowerCase? from Character

makeFR from Factored
map from Factored
map from OneDimensionalArrayFunctions2
map from PrimitiveArrayFunctions2
map from TwoDimensionalArrayCategory
map! from TwoDimensionalArrayCategory
mapDown! from BalancedBinaryTree
mapUp! from BalancedBinaryTree
maxColIndex from TwoDimensionalArrayCategory
maxRowIndex from TwoDimensionalArrayCategory
minColIndex from TwoDimensionalArrayCategory
minRowIndex from TwoDimensionalArrayCategory

ncols from TwoDimensionalArrayCategory
new from TwoDimensionalArrayCategory
nilFactor from Factored
nrows from TwoDimensionalArrayCategory
nthExponent from Factored
nthFactor from Factored
nthFlag from Factored
numberOfComponents from FunctionFieldCategory
numberOfFactors from Factored

oneDimensionalArray from OneDimensionalArray
ord from Character

parts from TwoDimensionalArrayCategory
physicalLength from IndexedFlexibleArray
physicalLength! from IndexedFlexibleArray
plot from Plot
primeFactor from Factored
ptree from PendantTree

qelt from TwoDimensionalArrayCategory
quote from Character
qsetelt! from TwoDimensionalArrayCategory
queue from Queue

rationalPoint? from FunctionFieldCategory
reduce from OneDimensionalArrayFunctions2
reduce from PrimitiveArrayFunctions2
row from TwoDimensionalArrayCategory

scan from OneDimensionalArrayFunctions2
scan from PrimitiveArrayFunctions2
select from Tuple
setColumn! from TwoDimensionalArrayCategory
setelt from TwoDimensionalArrayCategory
setleaves! from BalancedBinaryTree
setRow! from TwoDimensionalArrayCategory
shrinkable from IndexedFlexibleArray
space from Character
split from BinarySearchTree
sqfrFactor from Factored
stack from Stack

table from TableAggregate
tree from Tree

unit from Factored
upperCase from Character
upperCase? from Character

=== UNDOCUMENTED ========================================================

# from Aggregate
# from SExpressionCategory
# from XPolynomialRing

* from AbelianGroup
* from AbelianMonoid
* from AbelianSemiGroup
* from CartesianTensor
* from Color
* from DenavitHartenbergMatrix
* from Equation
* from FreeAbelianMonoidCategory
* from FreeGroup
* from FreeModule1
* from FreeModuleCat
* from FreeMonoid
* from GeneralModulePolynomial
* from GradedModule
* from InnerNormalBasisFieldFunctions
* from InnerTaylorSeries
* from InputForm
* from LeftModule
* from Magma
* from MappingPackage3
* from MatrixCategory
* from Monad
* from OrderedFreeMonoid
* from OutputForm
* from Pattern
* from PolynomialIdeals
* from PseudoRemainderSequence
* from RightModule
* from SemiGroup
* from SparseMultivariateTaylorSeries
* from SquareMatrixCategory
* from StreamTaylorSeriesOperations
* from TubePlotTools
* from VectorCategory
* from XFreeAlgebra
* from XPolynomialRing

** from AlgebraicFunction
** from CardinalNumber
** from CombinatorialFunction
** from DivisionRing
** from DoubleFloat
** from ElementaryFunctionCategory
** from ElementaryFunctionsUnivariateLaurentSeries
** from ElementaryFunctionsUnivariatePuiseuxSeries
** from Float
** from FreeGroup
** from FreeMonoid
** from FunctionSpace
** from Group
** from InnerNormalBasisFieldFunctions
** from InputForm
** from MappingPackage1
** from MatrixCategory
** from ModuleOperator
** from Monad
** from MonadWithUnit
** from Monoid
** from Operator
** from OrderedFreeMonoid
** from OutputForm
** from Pattern
** from PolynomialIdeals
** from RadicalCategory
** from SemiGroup
** from SquareMatrixCategory
** from StorageEfficientMatrixOperations
** from StreamTranscendentalFunctions
** from StreamTranscendentalFunctionsNonCommutative
** from UnivariateTaylorSeriesCategory

+ from AbelianSemiGroup
+ from Color
+ from Database
+ from Equation
+ from FreeAbelianMonoidCategory
+ from FullPartialFractionExpansion
+ from GradedModule
+ from InputForm
+ from MatrixCategory
+ from OutputForm
+ from Pattern
+ from PolynomialIdeals
+ from StreamTaylorSeriesOperations
+ from TubePlotTools
+ from VectorCategory

- from AbelianGroup
- from CardinalNumber
- from Database
- from Equation
- from GradedModule
- from MatrixCategory
- from OutputForm
- from StreamTaylorSeriesOperations
- from TubePlotTools
- from VectorCategory

/ from AbelianMonoidRing
/ from DoubleFloat
/ from Equation
/ from Field
/ from Float
/ from FunctionSpace
/ from Group
/ from InnerNormalBasisFieldFunctions
/ from InputForm
/ from LieAlgebra
/ from LocalAlgebra
/ from Localize
/ from MatrixCategory
/ from OrdinaryWeightedPolynomials
/ from OutputForm
/ from Pattern
/ from QuotientFieldCategory
/ from RectangularMatrixCategory
/ from StreamTaylorSeriesOperations
/ from VectorSpace
/ from WeightedPolynomials
/ from XPolynomialRing

/\ from Logic
/\ from SingleInteger

< from OrderedSet
< from OutputForm
< from PermutationCategory
< from PermutationGroup
< from SetAggregate

<= from OrderedSet
<= from OutputForm
<= from PermutationGroup

= from BasicType
= from Equation
= from FortranScalarType
= from OutputForm
= from Reference

> from OrderedSet
> from OutputForm

>= from OrderedSet
>= from OutputForm

AND from Switch
Aleph from CardinalNumber
An from ModMonic
And from IndexedBits
And from SingleInteger

B1solve from ParametricLinearEquations
BY from SegmentCategory
BasicMethod from IntegerFactorizationPackage
Beta from DoubleFloat
Beta from DoubleFloatSpecialFunctions
Beta from FunctionalSpecialFunction
Beta from RandomFloatDistributions
Beta from SpecialFunctionCategory
BumInSepFFE from UnivariatePolynomialSquareFree

Ci from LiouvillianFunction
Ci from LiouvillianFunctionCategory

D from DifferentialExtension
D from DifferentialRing
D from FullPartialFractionExpansion
D from LinearOrdinaryDifferentialOperatorCategory
D from PartialDifferentialRing

E1 from DoubleFloatSpecialFunctions
EQ from Switch
Ei from DoubleFloatSpecialFunctions
Ei from LiouvillianFunction
Ei from LiouvillianFunctionCategory
Ei1 from DoubleFloatSpecialFunctions
Ei2 from DoubleFloatSpecialFunctions
Ei3 from DoubleFloatSpecialFunctions
Ei4 from DoubleFloatSpecialFunctions
Ei5 from DoubleFloatSpecialFunctions
Ei6 from DoubleFloatSpecialFunctions
En from DoubleFloatSpecialFunctions

F from RandomFloatDistributions
F2FG from InnerTrigonometricManipulations
FG2F from InnerTrigonometricManipulations
FormatArabic from NumberFormats
FormatRoman from NumberFormats
Frobenius from ExtensionField
Frobenius from NormRetractPackage

GE from Switch
GF2FG from InnerTrigonometricManipulations
GT from Switch
Gamma from DoubleFloat
Gamma from DoubleFloatSpecialFunctions
Gamma from FunctionalSpecialFunction
Gamma from SpecialFunctionCategory
GospersMethod from GosperSummationMethod

Hausdorff from XExponentialPackage
HenselLift from GeneralHenselPackage
HermiteIntegrate from AlgebraicHermiteIntegration
HermiteIntegrate from TranscendentalHermiteIntegration

Is from PatternMatch

KrullNumber from RegularSetDecompositionPackage
KrullNumber from SquareFreeRegularSetDecompositionPackage
LE from Switch
LODO2FUN from UTSodetools
LT from Switch
LagrangeInterpolation from PolynomialInterpolationAlgorithms
Lazard from PseudoRemainderSequence
Lazard2 from PseudoRemainderSequence
LazardQuotient from RecursivePolynomialCategory
LazardQuotient2 from RecursivePolynomialCategory
LiePoly from FreeLieAlgebra
LiePolyIfCan from LiePolynomial
LiePolyIfCan from XPBWPolynomial
ListOfTerms from FreeModuleCat
ListOfTerms from LieExponentials
ListOfTerms from PoincareBirkhoffWittLyndonBasis
LowTriBddDenomInv from TriangularMatrixOperations
LyndonBasis from LieExponentials
LyndonCoordinates from LieExponentials
LyndonWordsList from LyndonWord
LyndonWordsList1 from LyndonWord

NOT from Switch
Not from IndexedBits
Not from SingleInteger
Nul from ExtAlgBasis

ODESolve from OrdinaryDifferentialEquationsSolverCategory
OMParseError? from OpenMathErrorKind
OMReadError? from OpenMathErrorKind
OMUnknownCD? from OpenMathErrorKind
OMUnknownSymbol? from OpenMathErrorKind
OMbindTCP from OpenMathConnection
OMclose from OpenMathDevice
OMcloseConn from OpenMathConnection
OMconnInDevice from OpenMathConnection
OMconnOutDevice from OpenMathConnection
OMconnectTCP from OpenMathConnection
OMencodingBinary from OpenMathEncoding
OMencodingSGML from OpenMathEncoding
OMencodingUnknown from OpenMathEncoding
OMencodingXML from OpenMathEncoding
OMgetApp from OpenMathDevice
OMgetAtp from OpenMathDevice
OMgetAttr from OpenMathDevice
OMgetBVar from OpenMathDevice
OMgetBind from OpenMathDevice
OMgetEndApp from OpenMathDevice
OMgetEndAtp from OpenMathDevice
OMgetEndAttr from OpenMathDevice
OMgetEndBVar from OpenMathDevice
OMgetEndBind from OpenMathDevice
OMgetEndError from OpenMathDevice
OMgetEndObject from OpenMathDevice
OMgetError from OpenMathDevice
OMgetFloat from OpenMathDevice
OMgetInteger from OpenMathDevice
OMgetObject from OpenMathDevice
OMgetString from OpenMathDevice
OMgetSymbol from OpenMathDevice
OMgetType from OpenMathDevice
OMgetVariable from OpenMathDevice
OMlistCDs from OpenMathPackage
OMlistSymbols from OpenMathPackage
OMmakeConn from OpenMathConnection
OMopenFile from OpenMathDevice
OMopenString from OpenMathDevice
OMputApp from OpenMathDevice
OMputAtp from OpenMathDevice
OMputAttr from OpenMathDevice
OMputBVar from OpenMathDevice
OMputBind from OpenMathDevice
OMputEndApp from OpenMathDevice
OMputEndAtp from OpenMathDevice
OMputEndAttr from OpenMathDevice
OMputEndBVar from OpenMathDevice
OMputEndBind from OpenMathDevice
OMputEndError from OpenMathDevice
OMputEndObject from OpenMathDevice
OMputError from OpenMathDevice
OMputFloat from OpenMathDevice
OMputInteger from OpenMathDevice
OMputObject from OpenMathDevice
OMputString from OpenMathDevice
OMputSymbol from OpenMathDevice
OMputVariable from OpenMathDevice
OMread from OpenMathPackage
OMreadFile from OpenMathPackage
OMreadStr from OpenMathPackage
OMreceive from OpenMathServerPackage
OMsend from OpenMathServerPackage
OMserve from OpenMathServerPackage
OMsetEncoding from OpenMathDevice
OMsupportsCD? from OpenMathPackage
OMsupportsSymbol? from OpenMathPackage
OMunhandledSymbol from OpenMathPackage
OMwrite from ExpressionToOpenMath
OMwrite from OpenMath
OR from Switch
One from GradedAlgebra
One from InputForm
One from MonadWithUnit
One from Monoid
One from Pattern
One from PoincareBirkhoffWittLyndonBasis
Or from IndexedBits
Or from SingleInteger

PDESolve from PartialDifferentialEquationsSolverCategory
ParCond from ParametricLinearEquations
ParCondList from ParametricLinearEquations
PollardSmallFactor from IntegerFactorizationPackage

RF2UTS from UTSodetools
ReduceOrder from ReductionOfOrder
RemainderList from XPolynomial
RemainderList from XRecursivePolynomial
RittWuCompare from RecursivePolynomialCategory

SEGMENT from OutputForm
SEGMENT from SegmentCategory
SEGMENT from UniversalSegment
SFunction from CycleIndicators
ScanArabic from NumberFormats
ScanFloatIgnoreSpaces from NumberFormats
ScanFloatIgnoreSpacesIfCan from NumberFormats
ScanRoman from NumberFormats
Si from LiouvillianFunction
Si from LiouvillianFunctionCategory
SturmHabicht from SturmHabichtPackage
SturmHabichtCoefficients from SturmHabichtPackage
SturmHabichtMultiple from SturmHabichtPackage
SturmHabichtSequence from SturmHabichtPackage

UP2UTS from UTSodetools
UP2ifCan from FunctionSpaceUnivariatePolynomialFactor
UTS2UP from UTSodetools
UnVectorise from ModMonic
UpTriBddDenomInv from TriangularMatrixOperations

Vectorise from ModMonic

Y from ParadoxicalCombinatorsForStreams

Zero from AbelianMonoid
Zero from GradedModule
Zero from InputForm
Zero from Pattern

\/ from Logic
\/ from SingleInteger

^ from BitAggregate
^ from Boolean
^ from DivisionRing
^ from Group
^ from Monoid
^ from SemiGroup
^= from OutputForm

aCubic from PolynomialSolveByFormulas
aLinear from PolynomialSolveByFormulas
aQuadratic from PolynomialSolveByFormulas
aQuartic from PolynomialSolveByFormulas
abelianGroup from PermutationGroupExamples
abs from ComplexCategory
abs from FortranExpression
abs from FunctionalSpecialFunction
abs from OctonionCategory
abs from OrderedRing
abs from QuaternionCategory
abs from RealNumberSystem
abs from SpecialFunctionCategory
absolutelyIrreducible? from FunctionFieldCategory&
accuracyIF from d02AgentsPackage
acos from ArcTrigonometricFunctionCategory
acos from ElementaryFunction
acos from ElementaryFunctionsUnivariateLaurentSeries
acos from ElementaryFunctionsUnivariatePuiseuxSeries
acos from FortranExpression
acos from StreamTranscendentalFunctions
acos from StreamTranscendentalFunctionsNonCommutative
acosIfCan from PartialTranscendentalFunctions
acosh from ArcHyperbolicFunctionCategory
acosh from ElementaryFunction
acosh from ElementaryFunctionsUnivariateLaurentSeries
acosh from ElementaryFunctionsUnivariatePuiseuxSeries
acosh from StreamTranscendentalFunctions
acosh from StreamTranscendentalFunctionsNonCommutative
acoshIfCan from PartialTranscendentalFunctions
acot from ArcTrigonometricFunctionCategory
acot from ElementaryFunction
acot from ElementaryFunctionsUnivariateLaurentSeries
acot from ElementaryFunctionsUnivariatePuiseuxSeries
acot from StreamTranscendentalFunctions
acot from StreamTranscendentalFunctionsNonCommutative
acotIfCan from PartialTranscendentalFunctions
acoth from ArcHyperbolicFunctionCategory
acoth from ElementaryFunction
acoth from ElementaryFunctionsUnivariateLaurentSeries
acoth from ElementaryFunctionsUnivariatePuiseuxSeries
acoth from StreamTranscendentalFunctions
acoth from StreamTranscendentalFunctionsNonCommutative
acothIfCan from PartialTranscendentalFunctions
acsc from ArcTrigonometricFunctionCategory
acsc from ElementaryFunction
acsc from ElementaryFunctionsUnivariateLaurentSeries
acsc from ElementaryFunctionsUnivariatePuiseuxSeries
acsc from StreamTranscendentalFunctions
acsc from StreamTranscendentalFunctionsNonCommutative
acscIfCan from PartialTranscendentalFunctions
acsch from ArcHyperbolicFunctionCategory
acsch from ElementaryFunction
acsch from ElementaryFunctionsUnivariateLaurentSeries
acsch from ElementaryFunctionsUnivariatePuiseuxSeries
acsch from StreamTranscendentalFunctions
acsch from StreamTranscendentalFunctionsNonCommutative
acschIfCan from PartialTranscendentalFunctions
adaptive from DrawOption
adaptive from DrawOptionFunctions0
adaptive from GraphicsDefaults
adaptive3D? from Plot3D
adaptive? from Plot
addBadValue from Pattern
addBadValue from PatternFunctions1
addMatch from PatternMatchResult
addMatchRestricted from PatternMatchResult
addPoint from SubSpace
addPoint2 from SubSpace
addPointLast from SubSpace
addiag from StreamTaylorSeriesOperations
addmod from IntegerNumberSystem
adjoint from LinearOrdinaryDifferentialOperatorCategory
adjoint from MatrixLinearAlgebraFunctions
adjoint from ModuleOperator
adjoint from Operator
airyAi from DoubleFloatSpecialFunctions
airyAi from FunctionalSpecialFunction
airyAi from SpecialFunctionCategory
airyBi from DoubleFloatSpecialFunctions
airyBi from FunctionalSpecialFunction
airyBi from SpecialFunctionCategory
algDsolve from PureAlgebraicLODE
algSplitSimple from FunctionFieldCategory
algebraic? from ExtensionField
algebraic? from TriangularSetCategory
algebraicCoefficients? from RegularTriangularSetCategory
algebraicDecompose from RegularSetDecompositionPackage
algebraicDecompose from SquareFreeRegularSetDecompositionPackage
algebraicOf from RealClosure
algebraicSort from QuasiComponentPackage
algebraicSort from SquareFreeQuasiComponentPackage
algebraicVariables from TriangularSetCategory
algint from AlgebraicIntegration
algintegrate from AlgebraicIntegrate
allRootsOf from RealClosedField
allRootsOf from RealRootCharacterizationCategory
alphabetic from CharacterClass
alphanumeric from CharacterClass
alternating from CycleIndicators
alternatingGroup from PermutationGroupExamples
alternative? from FiniteRankNonAssociativeAlgebra
alternative? from FiniteRankNonAssociativeAlgebra&
and from BitAggregate
and from Boolean
and from OutputForm
anfactor from FunctionSpaceUnivariatePolynomialFactor
antiAssociative? from FiniteRankNonAssociativeAlgebra
antiAssociative? from FiniteRankNonAssociativeAlgebra&
antiCommutative? from FiniteRankNonAssociativeAlgebra
antiCommutative? from FiniteRankNonAssociativeAlgebra&
antiCommutator from NonAssociativeRng
anticoord from LinGroebnerPackage
antisymmetric? from MatrixCategory
antisymmetric? from RectangularMatrixCategory
antisymmetricTensors from RepresentationPackage1
any from Any
any? from HomogeneousAggregate
append from List
appendPoint from GraphImage
apply from ApplyUnivariateSkewPolynomial
apply from FramedNonAssociativeAlgebra
apply from UnivariateSkewPolynomialCategory
apply from UnivariateSkewPolynomialCategoryOps
applyQuote from FunctionSpace
applyRules from ApplyRules
approxNthRoot from IntegerRoots
approxSqrt from IntegerRoots
approximants from ContinuedFraction
approximate from BalancedPAdicRational
approximate from PAdicIntegerCategory
approximate from PAdicRational
approximate from PAdicRationalConstructor
approximate from RealClosedField
approximate from RealRootCharacterizationCategory
approximate from UnivariatePowerSeriesCategory
areEquivalent? from RepresentationPackage2
arg1 from MappingPackageInternalHacks2
arg2 from MappingPackageInternalHacks2
argscript from Symbol
argument from ComplexCategory
argument from FourierComponent
argument from Kernel
argumentList! from TheSymbolTable
argumentListOf from TheSymbolTable
arity from BasicOperator
aromberg from NumericalQuadrature
asec from ArcTrigonometricFunctionCategory
asec from ElementaryFunction
asec from ElementaryFunctionsUnivariateLaurentSeries
asec from ElementaryFunctionsUnivariatePuiseuxSeries
asec from StreamTranscendentalFunctions
asec from StreamTranscendentalFunctionsNonCommutative
asecIfCan from PartialTranscendentalFunctions
asech from ArcHyperbolicFunctionCategory
asech from ElementaryFunction
asech from ElementaryFunctionsUnivariateLaurentSeries
asech from ElementaryFunctionsUnivariatePuiseuxSeries
asech from StreamTranscendentalFunctions
asech from StreamTranscendentalFunctionsNonCommutative
asechIfCan from PartialTranscendentalFunctions
asimpson from NumericalQuadrature
asin from ArcTrigonometricFunctionCategory
asin from ElementaryFunction
asin from ElementaryFunctionsUnivariateLaurentSeries
asin from ElementaryFunctionsUnivariatePuiseuxSeries
asin from FortranExpression
asin from StreamTranscendentalFunctions
asin from StreamTranscendentalFunctionsNonCommutative
asinIfCan from PartialTranscendentalFunctions
asinh from ArcHyperbolicFunctionCategory
asinh from ElementaryFunction
asinh from ElementaryFunctionsUnivariateLaurentSeries
asinh from ElementaryFunctionsUnivariatePuiseuxSeries
asinh from StreamTranscendentalFunctions
asinh from StreamTranscendentalFunctionsNonCommutative
asinhIfCan from PartialTranscendentalFunctions
aspFilename from NAGLinkSupportPackage
assert from BasicOperator
assert from FunctionSpaceAssertions
assert from PatternMatchAssertions
assign from FortranCode
assign from OutputForm
assoc from AssociationListAggregate
associatedEquations from AssociatedEquations
associatedSystem from AssociatedEquations
associates? from IntegralDomain
associative? from FiniteRankNonAssociativeAlgebra
associative? from FiniteRankNonAssociativeAlgebra&
associator from NonAssociativeRng
associatorDependence from FiniteRankNonAssociativeAlgebra
associatorDependence from FiniteRankNonAssociativeAlgebra&
atan from ArcTrigonometricFunctionCategory
atan from DoubleFloat
atan from ElementaryFunction
atan from ElementaryFunctionsUnivariateLaurentSeries
atan from ElementaryFunctionsUnivariatePuiseuxSeries
atan from Float
atan from FortranExpression
atan from StreamTranscendentalFunctions
atan from StreamTranscendentalFunctionsNonCommutative
atanIfCan from PartialTranscendentalFunctions
atanh from ArcHyperbolicFunctionCategory
atanh from ElementaryFunction
atanh from ElementaryFunctionsUnivariateLaurentSeries
atanh from ElementaryFunctionsUnivariatePuiseuxSeries
atanh from StreamTranscendentalFunctions
atanh from StreamTranscendentalFunctionsNonCommutative
atanhIfCan from PartialTranscendentalFunctions
atom? from SExpressionCategory
atoms from PatternMatchListResult
atrapezoidal from NumericalQuadrature
att2Result from ExpertSystemToolsPackage
augment from RegularTriangularSetCategory
autoReduced? from TriangularSetCategory
axServer from AxiomServer
axes from ThreeDimensionalViewport
axes from TwoDimensionalViewport
axesColorDefault from ViewDefaultsPackage

back from QueueAggregate
backOldPos from PolynomialIdeals
badNum from PointsOfFiniteOrderTools
badValues from PatternFunctions1
bag from BagAggregate
balancedFactorisation from BalancedFactorisation
bandedHessian from MultiVariableCalculusFunctions
bandedJacobian from MultiVariableCalculusFunctions
base from FloatingPointSystem
base from IntegerNumberSystem
base from MachineFloat
base from PermutationGroup
baseRDE from TranscendentalRischDE
baseRDEsys from TranscendentalRischDESystem
basicSet from TriangularSetCategory
basis from AlgebraPackage
basis from FiniteAlgebraicExtensionField
basis from FractionalIdeal
basis from FramedAlgebra
basis from FramedModule
basis from FramedNonAssociativeAlgebra
basis from InnerNormalBasisFieldFunctions
basisOfCenter from AlgebraPackage
basisOfCentroid from AlgebraPackage
basisOfCommutingElements from AlgebraPackage
basisOfLeftAnnihilator from AlgebraPackage
basisOfLeftNucleus from AlgebraPackage
basisOfLeftNucloid from AlgebraPackage
basisOfMiddleNucleus from AlgebraPackage
basisOfNucleus from AlgebraPackage
basisOfRightAnnihilator from AlgebraPackage
basisOfRightNucleus from AlgebraPackage
basisOfRightNucloid from AlgebraPackage
bat from TableauxBumpers
bat1 from TableauxBumpers
beauzamyBound from GaloisGroupFactorizationUtilities
belong? from AlgebraicFunction
belong? from CombinatorialFunction
belong? from ElementaryFunction
belong? from ExpressionSpace
belong? from ExpressionSpace&
belong? from FunctionSpace&
belong? from FunctionalSpecialFunction
belong? from LiouvillianFunction
bernoulli from IntegerNumberTheoryFunctions
bernoulli from PolynomialNumberTheoryFunctions
bernoulliB from NumberTheoreticPolynomialFunctions
besselI from DoubleFloatSpecialFunctions
besselI from FunctionalSpecialFunction
besselI from SpecialFunctionCategory
besselJ from DoubleFloatSpecialFunctions
besselJ from FunctionalSpecialFunction
besselJ from SpecialFunctionCategory
besselK from DoubleFloatSpecialFunctions
besselK from FunctionalSpecialFunction
besselK from SpecialFunctionCategory
besselY from DoubleFloatSpecialFunctions
besselY from FunctionalSpecialFunction
besselY from SpecialFunctionCategory
bezoutDiscriminant from BezoutMatrix
bezoutMatrix from BezoutMatrix
bezoutResultant from BezoutMatrix
bfEntry from BasicFunctions
bfKeys from BasicFunctions
biRank from AlgebraPackage
binaryFunction from MakeBinaryCompiledFunction
binomThmExpt from FiniteAbelianMonoidRing
binomial from CombinatorialFunction
binomial from CombinatorialFunctionCategory
binomial from IntegerCombinatoricFunctions
binomial from OutputForm
binomial from RandomIntegerDistributions
bipolar from CoordinateSystems
bipolarCylindrical from CoordinateSystems
birth from SubSpace
bit? from IntegerNumberSystem
bitCoef from IntegerBits
bitLength from IntegerBits
bitTruth from IntegerBits
bits from Bits
bits from FloatingPointSystem
bivariate? from PolynomialSetUtilitiesPackage
bivariatePolynomials from PolynomialSetUtilitiesPackage
bivariateSLPEBR from PolynomialFactorizationByRecursion
blankSeparate from OutputForm
block from FortranCode
blue from Color
bombieriNorm from GaloisGroupFactorizationUtilities
bottom! from DequeueAggregate
boundOfCauchy from RealPolynomialUtilitiesPackage
box from ExpressionSpace
box from OutputForm
brace from OutputForm
brace from SetAggregate
bracket from OutputForm
branchIfCan from QuasiComponentPackage
branchIfCan from SquareFreeQuasiComponentPackage
branchPoint? from FunctionFieldCategory
bright from DisplayPackage
bright from Palette
brillhartIrreducible? from BrillhartTests
brillhartTrials from BrillhartTests
bringDown from FunctionSpaceReduce
bsolve from ParametricLinearEquations
btwFact from GaloisGroupFactorizer
bubbleSort! from SortPackage
build from GeneralModulePolynomial
bumprow from TableauxBumpers
bumptab from TableauxBumpers
bumptab1 from TableauxBumpers

c02aff from NagPolynomialRootsPackage
c02agf from NagPolynomialRootsPackage
c05adf from NagRootFindingPackage
c05nbf from NagRootFindingPackage
c05pbf from NagRootFindingPackage
c06eaf from NagSeriesSummationPackage
c06ebf from NagSeriesSummationPackage
c06ecf from NagSeriesSummationPackage
c06ekf from NagSeriesSummationPackage
c06fpf from NagSeriesSummationPackage
c06fqf from NagSeriesSummationPackage
c06frf from NagSeriesSummationPackage
c06fuf from NagSeriesSummationPackage
c06gbf from NagSeriesSummationPackage
c06gcf from NagSeriesSummationPackage
c06gqf from NagSeriesSummationPackage
c06gsf from NagSeriesSummationPackage
cAcos from InnerSparseUnivariatePowerSeries
cAcosh from InnerSparseUnivariatePowerSeries
cAcot from InnerSparseUnivariatePowerSeries
cAcoth from InnerSparseUnivariatePowerSeries
cAcsc from InnerSparseUnivariatePowerSeries
cAcsch from InnerSparseUnivariatePowerSeries
cAsec from InnerSparseUnivariatePowerSeries
cAsech from InnerSparseUnivariatePowerSeries
cAsin from InnerSparseUnivariatePowerSeries
cAsinh from InnerSparseUnivariatePowerSeries
cAtan from InnerSparseUnivariatePowerSeries
cAtanh from InnerSparseUnivariatePowerSeries
cCos from InnerSparseUnivariatePowerSeries
cCosh from InnerSparseUnivariatePowerSeries
cCot from InnerSparseUnivariatePowerSeries
cCoth from InnerSparseUnivariatePowerSeries
cCsc from InnerSparseUnivariatePowerSeries
cCsch from InnerSparseUnivariatePowerSeries
cExp from InnerSparseUnivariatePowerSeries
cLog from InnerSparseUnivariatePowerSeries
cPower from InnerSparseUnivariatePowerSeries
cRationalPower from InnerSparseUnivariatePowerSeries
cSec from InnerSparseUnivariatePowerSeries
cSech from InnerSparseUnivariatePowerSeries
cSin from InnerSparseUnivariatePowerSeries
cSinh from InnerSparseUnivariatePowerSeries
cTan from InnerSparseUnivariatePowerSeries
cTanh from InnerSparseUnivariatePowerSeries
cache from SortedCache
calcRanges from PlotTools
call from FortranCode
cap from CycleIndicators
car from SExpressionCategory
cardinality from FiniteSetAggregate
cartesian from CoordinateSystems
cdr from SExpressionCategory
ceiling from QuotientFieldCategory
ceiling from RealNumberSystem
center from DisplayPackage
center from OutputForm
center from UnivariatePowerSeriesCategory
central? from d03AgentsPackage
certainlySubVariety? from PolynomialSetUtilitiesPackage
cfirst from WeierstrassPreparation
chainSubResultants from PseudoRemainderSequence
changeBase from MachineFloat
changeBase from PseudoLinearNormalForm
changeMeasure from RoutinesTable
changeName from d01AgentsPackage
changeNameToObjf from e04AgentsPackage
changeThreshhold from RoutinesTable
changeVar from PrimitiveRatRicDE
changeWeightLevel from OrdinaryWeightedPolynomials
changeWeightLevel from WeightedPolynomials
charClass from CharacterClass
character? from FortranScalarType
characteristic from ComplexCategory&
characteristic from DirectProductCategory&
characteristic from FunctionSpace&
characteristic from IntegerNumberSystem&
characteristic from NonAssociativeRing
characteristic from OctonionCategory&
characteristic from QuaternionCategory&
characteristic from QuotientFieldCategory&
characteristic from RealClosedField&
characteristic from RealNumberSystem&
characteristic from Ring
characteristicPolynomial from CharacteristicPolynomialInMonogenicalAlgebra
characteristicPolynomial from CharacteristicPolynomialPackage
characteristicPolynomial from EigenPackage
characteristicPolynomial from FiniteRankAlgebra
characteristicPolynomial from NumericComplexEigenPackage
characteristicPolynomial from NumericRealEigenPackage
characteristicSerie from WuWenTsunTriangularSet
characteristicSet from WuWenTsunTriangularSet
charpol from InnerNumericEigenPackage
charthRoot from CharacteristicNonZero
charthRoot from FiniteFieldCategory
chebyshevT from OrthogonalPolynomialFunctions
chebyshevT from PolynomialNumberTheoryFunctions
chebyshevU from OrthogonalPolynomialFunctions
chebyshevU from PolynomialNumberTheoryFunctions
check from MultivariateSquareFree
check from ThreeSpaceCategory
checkForZero from DefiniteIntegrationTools
checkPrecision from NAGLinkSupportPackage
checkRur from InternalRationalUnivariateRepresentationPackage
chiSquare from RandomFloatDistributions
chiSquare1 from RandomFloatDistributions
child from SubSpace
child? from RecursiveAggregate
children from RecursiveAggregate
children from SubSpace
chineseRemainder from CRApackage
chineseRemainder from ChineseRemainderToolsForIntegralBases
chineseRemainder from IntegerNumberTheoryFunctions
choosemon from LinGroebnerPackage
chvar from ChangeOfVariable
clearCache from SortedCache
clearDenominator from CommonDenominator
clearDenominator from InnerCommonDenominator
clearDenominator from MatrixCommonDenominator
clearDenominator from UnivariatePolynomialCommonDenominator
clearFortranOutputStack from FortranOutputStackPackage
clearTable! from TabulatedComputationPackage
clearTheFTable from IntegrationFunctionsTable
clearTheIFTable from ODEIntensityFunctionsTable
clearTheSymbolTable from TheSymbolTable
clikeUniv from WeierstrassPreparation
clip from DrawOption
clip from TwoDimensionalPlotClipping
clipBoolean from DrawOptionFunctions0
clipParametric from TwoDimensionalPlotClipping
clipPointsDefault from GraphicsDefaults
clipSurface from ThreeDimensionalViewport
clipWithRanges from TwoDimensionalPlotClipping
close from SubSpaceComponentProperty
close from ThreeDimensionalViewport
close from TwoDimensionalViewport
close! from FileCategory
close! from Library
closeComponent from SubSpace
closed? from SubSpaceComponentProperty
closed? from TubePlot
closedCurve from ThreeSpaceCategory
closedCurve? from ThreeSpaceCategory
cn from EllipticFunctionsUnivariateTaylorSeries
coHeight from TriangularSetCategory
code from FortranCode
coef from FreeLieAlgebra
coef from XFreeAlgebra
coef from XPolynomialRing
coefChoose from MultivariateSquareFree
coefficient from AbelianMonoidRing
coefficient from AntiSymm
coefficient from CliffordAlgebra
coefficient from DeRhamComplex
coefficient from FreeAbelianMonoidCategory
coefficient from FreeModuleCat
coefficient from LaurentPolynomial
coefficient from MonogenicLinearOperator
coefficient from MonoidRing
coefficient from MultivariateTaylorSeriesCategory
coefficient from PolynomialCategory
coefficient from SparseMultivariateTaylorSeries
coefficient from TaylorSeries
coefficient from UnivariateSkewPolynomialCategory
coefficients from FiniteAbelianMonoidRing
coefficients from FreeModuleCat
coefficients from InnerTaylorSeries
coefficients from MonoidRing
coefficients from UnivariateSkewPolynomialCategory
coefficients from UnivariateTaylorSeriesCategory
coerce from Algebra
coerce from AlgebraGivenByStructuralConstants
coerce from AlgebraicNumber
coerce from AnyFunctions1
coerce from Asp1
coerce from Asp10
coerce from Asp19
coerce from Asp20
coerce from Asp24
coerce from Asp31
coerce from Asp35
coerce from Asp4
coerce from Asp41
coerce from Asp42
coerce from Asp49
coerce from Asp50
coerce from Asp55
coerce from Asp6
coerce from Asp7
coerce from Asp73
coerce from Asp74
coerce from Asp77
coerce from Asp78
coerce from Asp80
coerce from Asp9
coerce from AssociatedJordanAlgebra
coerce from AssociatedLieAlgebra
coerce from BinaryExpansion
coerce from CartesianTensor
coerce from CoerceVectorMatrixPackage
coerce from CoercibleTo
coerce from DataList
coerce from Database
coerce from DecimalExpansion
coerce from DifferentialVariableCategory
coerce from DrawNumericHack
coerce from EuclideanModularRing
coerce from ExponentialExpansion
coerce from ExtAlgBasis
coerce from FileNameCategory
coerce from FiniteFieldHomomorphisms
coerce from FortranCode
coerce from FortranExpression
coerce from FortranFunctionCategory
coerce from FortranMatrixCategory
coerce from FortranMatrixFunctionCategory
coerce from FortranProgram
coerce from FortranScalarType
coerce from FortranType
coerce from FortranVectorCategory
coerce from FortranVectorFunctionCategory
coerce from FourierSeries
coerce from FreeLieAlgebra
coerce from FunctionSpace
coerce from GeneralUnivariatePowerSeries
coerce from GenericNonAssociativeAlgebra
coerce from GraphImage
coerce from HexadecimalExpansion
coerce from IndexCard
coerce from InnerAlgebraicNumber
coerce from LeftAlgebra
coerce from LieExponentials
coerce from LyndonWord
coerce from MachineComplex
coerce from MachineFloat
coerce from MachineInteger
coerce from Magma
coerce from MakeCachableSet
coerce from MappingPackage1
coerce from MathMLFormat
coerce from MatrixCategory
coerce from ModMonic
coerce from ModularField
coerce from ModularRing
coerce from ModuleMonomial
coerce from MonoidRing
coerce from NonAssociativeRing
coerce from NoneFunctions1
coerce from NumericalIntegrationProblem
coerce from NumericalODEProblem
coerce from NumericalOptimizationProblem
coerce from NumericalPDEProblem
coerce from OpenMathErrorKind
coerce from OrdSetInts
coerce from OrdinaryDifferentialRing
coerce from OrdinaryWeightedPolynomials
coerce from Palette
coerce from PartialFraction
coerce from Partition
coerce from Permutation
coerce from PermutationGroup
coerce from PiCoercions
coerce from PoincareBirkhoffWittLyndonBasis
coerce from PolynomialAN2Expression
coerce from PolynomialIdeals
coerce from RadixExpansion
coerce from RationalFunction
coerce from RectangularMatrix
coerce from ResidueRing
coerce from ResolveLatticeCompletion
coerce from RetractableTo
coerce from Ring
coerce from ScriptFormulaFormat
coerce from ScriptFormulaFormat1
coerce from SparseMultivariateTaylorSeries
coerce from SparseUnivariateLaurentSeries
coerce from SparseUnivariatePuiseuxSeries
coerce from SparseUnivariateTaylorSeries
coerce from SquareMatrix
coerce from Stream
coerce from StreamTaylorSeriesOperations
coerce from StringAggregate
coerce from Switch
coerce from Symbol
coerce from SymbolTable
coerce from Tableau
coerce from TaylorSeries
coerce from TexFormat
coerce from TexFormat1
coerce from ThreeDimensionalMatrix
coerce from ThreeSpaceCategory
coerce from TwoDimensionalViewport
coerce from UnivariateLaurentSeries
coerce from UnivariateLaurentSeriesConstructorCategory
coerce from UnivariatePolynomial
coerce from UnivariatePuiseuxSeries
coerce from UnivariatePuiseuxSeriesConstructorCategory
coerce from UnivariateSkewPolynomial
coerce from UnivariateTaylorSeries
coerce from UniversalSegment
coerce from Variable
coerce from ViewportPackage
coerce from Void
coerce from WeightedPolynomials
coerce from XAlgebra
coerce from XFreeAlgebra
coerce from XPBWPolynomial
coerce from XPolynomialRing
coerceImages from Permutation
coerceL from MathMLFormat
coerceListOfPairs from Permutation
coerceP from CoerceVectorMatrixPackage
coercePreimagesImages from Permutation
coerceS from MathMLFormat
coleman from SymmetricGroupCombinatoricFunctions
collect from PolynomialSetCategory
collectQuasiMonic from TriangularSetCategory
collectUnder from PolynomialSetCategory
collectUpper from PolynomialSetCategory
color from Color
color from PointPackage
colorDef from ThreeDimensionalViewport
colorFunction from DrawOption
column from RectangularMatrixCategory
combineFeatureCompatibility from d02AgentsPackage
commaSeparate from OutputForm
commaSeparate from d01AgentsPackage
comment from FortranCode
common from FortranCode
commonDenominator from CommonDenominator
commonDenominator from InnerCommonDenominator
commonDenominator from MatrixCommonDenominator
commonDenominator from UnivariatePolynomialCommonDenominator
commutative? from FiniteRankNonAssociativeAlgebra
commutative? from FiniteRankNonAssociativeAlgebra&
commutativeEquality from ListMonoidOps
commutator from Group
commutator from NonAssociativeRng
comp from MappingPackageInternalHacks3
compBound from GenExEuclid
compactFraction from PartialFraction
companionBlocks from PseudoLinearNormalForm
comparison from BasicOperator
compdegd from MultivariateSquareFree
compile from InputForm
compiledFunction from MakeBinaryCompiledFunction
compiledFunction from MakeUnaryCompiledFunction
complement from FiniteSetAggregate
complementaryBasis from FunctionFieldCategory
complete from ContinuedFraction
complete from CycleIndicators
complete from LazyStreamAggregate
complete from PAdicIntegerCategory
complete from PowerSeriesCategory
completeEchelonBasis from RepresentationPackage2
completeEval from FactoringUtilities
completeHensel from GeneralHenselPackage
completeHermite from SmithNormalForm
completeSmith from SmithNormalForm
complex from ComplexCategory
complex? from FortranScalarType
complexEigenvalues from NumericComplexEigenPackage
complexEigenvectors from NumericComplexEigenPackage
complexElementary from ComplexTrigonometricManipulations
complexElementary from TrigonometricManipulations
complexExpand from IntegrationResultRFToFunction
complexExpand from IntegrationResultToFunction
complexForm from ComplexTrigonometricManipulations
complexForm from TrigonometricManipulations
complexIntegrate from FunctionSpaceComplexIntegration
complexIntegrate from IntegrationResultRFToFunction
complexLimit from PowerSeriesLimitPackage
complexLimit from RationalFunctionLimitPackage
complexNormalize from ComplexTrigonometricManipulations
complexNormalize from TrigonometricManipulations
complexNumeric from Numeric
complexNumericIfCan from Numeric
complexRoots from FloatingComplexPackage
complexSolve from FloatingComplexPackage
complexZeros from ComplexRootFindingPackage
complexZeros from ComplexRootPackage
component from GraphImage
components from ThreeSpaceCategory
compose from PolynomialComposition
compose from StreamTaylorSeriesOperations
composite from ThreeSpaceCategory
composite from UnivariatePolynomialCategory
composites from ThreeSpaceCategory
computeBasis from LinGroebnerPackage
computeCycleEntry from CyclicStreamTools
computeCycleLength from CyclicStreamTools
computeInt from DefiniteIntegrationTools
computePowers from ModMonic
concat from ExpertSystemToolsPackage
concat from LinearAggregate
concat from RoutinesTable
concat from StreamFunctions1
concat from UnaryRecursiveAggregate
concat! from DoublyLinkedAggregate
concat! from ExtensibleLinearAggregate
concat! from UnaryRecursiveAggregate
cond from FortranCode
condition from SplittingNode
conditionP from CharacteristicNonZero
conditionP from FiniteFieldCategory
conditions from SplittingTree
conditionsForIdempotents from FiniteRankNonAssociativeAlgebra
conditionsForIdempotents from FramedNonAssociativeAlgebra
conditionsForIdempotents from FramedNonAssociativeAlgebra&
conditionsForIdempotents from GenericNonAssociativeAlgebra
conical from CoordinateSystems
conjug from ModuleOperator
conjug from Operator
conjugate from ComplexCategory
conjugate from Group
conjugate from OctonionCategory
conjugate from Partition
conjugate from PartitionsAndPermutations
conjugate from QuaternionCategory
conjugates from PartitionsAndPermutations
connect from TwoDimensionalViewport
cons from List
cons from Stream
consnewpol from MultivariateSquareFree
const from MappingPackage2
constDsolve from ConstantLODE
constant from FunctionSpaceAssertions
constant from MappingPackage2
constant from PatternMatchAssertions
constant from XFreeAlgebra
constant from XPolynomialRing
constant? from Pattern
constant? from XFreeAlgebra
constant? from XPolynomialRing
constantCoefficientRicDE from PrimitiveRatRicDE
constantIfCan from KernelFunctions2
constantKernel from KernelFunctions2
constantLeft from MappingPackage3
constantOpIfCan from BasicOperatorFunctions1
constantOperator from BasicOperatorFunctions1
constantRight from MappingPackage3
constantToUnaryFunction from ExpressionTubePlot
construct from Collection
construct from FortranType
construct from FullPartialFractionExpansion
construct from InfiniteTuple
construct from LieAlgebra
construct from LiePolynomial
construct from ModuleMonomial
construct from PatternMatchResult
construct from SplittingNode
construct from SplittingTree
construct from SuchThat
construct from ThreeDimensionalMatrix
contains? from IntervalCategory
content from FiniteAbelianMonoidRing
content from HeuGcd
content from PolynomialCategory
content from UnivariateSkewPolynomialCategory
continue from FortranCode
continuedFraction from BalancedPAdicRational
continuedFraction from ContinuedFraction
continuedFraction from NumericContinuedFraction
continuedFraction from PAdicRational
continuedFraction from PAdicRationalConstructor
contract from CartesianTensor
contract from IdealDecompositionPackage
contractSolve from RadicalSolvePackage
controlPanel from ThreeDimensionalViewport
controlPanel from TwoDimensionalViewport
convergents from ContinuedFraction
convert from ComplexPattern
convert from ConvertibleTo
convert from ExpertSystemToolsPackage
convert from Float
convert from FramedAlgebra
convert from FramedNonAssociativeAlgebra
convert from FunctionSpace
convert from GeneralPolynomialSet
convert from InputForm
convert from MonogenicAlgebra
convert from Pattern
convert from PointCategory
convert from RecursivePolynomialCategory
convert from RegularSetDecompositionPackage
convert from RomanNumeral
convert from SExpressionCategory
convert from ScriptFormulaFormat
convert from SegmentCategory
convert from SingletonAsOrderedSet
convert from SquareFreeRegularSetDecompositionPackage
convert from TexFormat
convert from ZeroDimensionalSolvePackage
coord from DrawOption
coord from DrawOptionFunctions0
coord from LinGroebnerPackage
coordinate from ParametricPlaneCurve
coordinate from ParametricSpaceCurve
coordinate from ParametricSurface
coordinates from DrawOption
coordinates from FiniteAlgebraicExtensionField
coordinates from FiniteRankAlgebra
coordinates from FiniteRankNonAssociativeAlgebra
coordinates from FramedAlgebra
coordinates from FramedNonAssociativeAlgebra
coordinates from StructuralConstantsPackage
copies from DisplayPackage
copy from Aggregate
copy from BasicOperator
copy from IntegerNumberSystem
copy from Pattern
copy from SplittingNode
copy from SubSpaceComponentProperty
copy from ThreeSpaceCategory
copy! from StorageEfficientMatrixOperations
copyInto! from FiniteLinearAggregate
corrPoly from MultivariateLifting
cos from ElementaryFunction
cos from ElementaryFunctionsUnivariateLaurentSeries
cos from ElementaryFunctionsUnivariatePuiseuxSeries
cos from FortranExpression
cos from FourierComponent
cos from StreamTranscendentalFunctions
cos from StreamTranscendentalFunctionsNonCommutative
cos from TrigonometricFunctionCategory
cos2sec from TranscendentalManipulations
cosIfCan from PartialTranscendentalFunctions
cosSinInfo from TubePlotTools
cosh from ElementaryFunction
cosh from ElementaryFunctionsUnivariateLaurentSeries
cosh from ElementaryFunctionsUnivariatePuiseuxSeries
cosh from FortranExpression
cosh from HyperbolicFunctionCategory
cosh from StreamTranscendentalFunctions
cosh from StreamTranscendentalFunctionsNonCommutative
cosh2sech from TranscendentalManipulations
coshIfCan from PartialTranscendentalFunctions
cot from ElementaryFunction
cot from ElementaryFunctionsUnivariateLaurentSeries
cot from ElementaryFunctionsUnivariatePuiseuxSeries
cot from StreamTranscendentalFunctions
cot from StreamTranscendentalFunctionsNonCommutative
cot from TrigonometricFunctionCategory
cot2tan from TranscendentalManipulations
cot2trig from TranscendentalManipulations
cotIfCan from PartialTranscendentalFunctions
coth from ElementaryFunction
coth from ElementaryFunctionsUnivariateLaurentSeries
coth from ElementaryFunctionsUnivariatePuiseuxSeries
coth from HyperbolicFunctionCategory
coth from StreamTranscendentalFunctions
coth from StreamTranscendentalFunctionsNonCommutative
coth2tanh from TranscendentalManipulations
coth2trigh from TranscendentalManipulations
cothIfCan from PartialTranscendentalFunctions
count from HomogeneousAggregate
countRealRoots from SturmHabichtPackage
countRealRootsMultiple from SturmHabichtPackage
countable? from CardinalNumber
create from SingletonAsOrderedSet
create3Space from ThreeSpaceCategory
createGenericMatrix from RepresentationPackage1
createIrreduciblePoly from FiniteFieldPolynomialPackage
createLowComplexityNormalBasis from FiniteFieldFunctions
createLowComplexityTable from FiniteFieldFunctions
createMultiplicationMatrix from FiniteFieldFunctions
createMultiplicationTable from FiniteFieldFunctions
createNormalElement from FiniteAlgebraicExtensionField
createNormalPoly from FiniteFieldPolynomialPackage
createNormalPrimitivePoly from FiniteFieldPolynomialPackage
createPrimitiveElement from FiniteFieldCategory
createPrimitiveNormalPoly from FiniteFieldPolynomialPackage
createPrimitivePoly from FiniteFieldPolynomialPackage
createRandomElement from RepresentationPackage2
createThreeSpace from TopLevelThreeSpace
createZechTable from FiniteFieldFunctions
credPol from GroebnerInternalPackage
crest from WeierstrassPreparation
critB from GroebnerInternalPackage
critBonD from GroebnerInternalPackage
critM from GroebnerInternalPackage
critMTonD1 from GroebnerInternalPackage
critMonD1 from GroebnerInternalPackage
critT from GroebnerInternalPackage
critpOrder from GroebnerInternalPackage
cross from PointCategory
cross from TubePlotTools
cross from VectorCategory
crushedSet from PolynomialSetUtilitiesPackage
csc from ElementaryFunction
csc from ElementaryFunctionsUnivariateLaurentSeries
csc from ElementaryFunctionsUnivariatePuiseuxSeries
csc from StreamTranscendentalFunctions
csc from StreamTranscendentalFunctionsNonCommutative
csc from TrigonometricFunctionCategory
csc2sin from TranscendentalManipulations
cscIfCan from PartialTranscendentalFunctions
csch from ElementaryFunction
csch from ElementaryFunctionsUnivariateLaurentSeries
csch from ElementaryFunctionsUnivariatePuiseuxSeries
csch from HyperbolicFunctionCategory
csch from StreamTranscendentalFunctions
csch from StreamTranscendentalFunctionsNonCommutative
csch2sinh from TranscendentalManipulations
cschIfCan from PartialTranscendentalFunctions
csubst from SparseMultivariateTaylorSeries
cubic from PolynomialSolveByFormulas
cup from CycleIndicators
currentSubProgram from TheSymbolTable
curry from MappingPackage2
curryLeft from MappingPackage3
curryRight from MappingPackage3
curve from ParametricPlaneCurve
curve from ParametricSpaceCurve
curve from ThreeSpaceCategory
curve? from ThreeSpaceCategory
curveColor from DrawOption
curveColorPalette from DrawOptionFunctions0
cycle from PermutationCategory
cycleElt from CyclicStreamTools
cycleEntry from UnaryRecursiveAggregate
cycleLength from UnaryRecursiveAggregate
cyclePartition from Permutation
cycleRagits from RadixExpansion
cycleSplit! from UnaryRecursiveAggregate
cycleTail from UnaryRecursiveAggregate
cycles from PermutationCategory
cyclic from CycleIndicators
cyclic? from RecursiveAggregate
cyclicGroup from PermutationGroupExamples
cyclicSubmodule from RepresentationPackage2
cyclotomic from CyclotomicPolynomialPackage
cyclotomic from NumberTheoreticPolynomialFunctions
cyclotomic from PolynomialNumberTheoryFunctions
cyclotomicDecomposition from CyclotomicPolynomialPackage
cyclotomicFactorization from CyclotomicPolynomialPackage
cylindrical from CoordinateSystems

d01ajf from NagIntegrationPackage
d01akf from NagIntegrationPackage
d01alf from NagIntegrationPackage
d01amf from NagIntegrationPackage
d01anf from NagIntegrationPackage
d01apf from NagIntegrationPackage
d01aqf from NagIntegrationPackage
d01asf from NagIntegrationPackage
d01bbf from NagIntegrationPackage
d01fcf from NagIntegrationPackage
d01gaf from NagIntegrationPackage
d01gbf from NagIntegrationPackage
d02bbf from NagOrdinaryDifferentialEquationsPackage
d02bhf from NagOrdinaryDifferentialEquationsPackage
d02cjf from NagOrdinaryDifferentialEquationsPackage
d02ejf from NagOrdinaryDifferentialEquationsPackage
d02gaf from NagOrdinaryDifferentialEquationsPackage
d02gbf from NagOrdinaryDifferentialEquationsPackage
d02kef from NagOrdinaryDifferentialEquationsPackage
d02raf from NagOrdinaryDifferentialEquationsPackage
d03edf from NagPartialDifferentialEquationsPackage
d03eef from NagPartialDifferentialEquationsPackage
d03faf from NagPartialDifferentialEquationsPackage
dAndcExp from InnerNormalBasisFieldFunctions
dark from Palette
datalist from DataList
ddFact from ModularDistinctDegreeFactorizer
debug from Plot
debug3D from Plot3D
dec from IntegerNumberSystem
decimal from DecimalExpansion
declare from InputForm
declare! from SymbolTable
declare! from TheSymbolTable
decompose from FiniteDivisorCategory
decompose from MonomialExtensionTools
decompose from PolynomialDecomposition
decompose from RegularSetDecompositionPackage
decompose from SquareFreeRegularSetDecompositionPackage
decomposeFunc from TransSolvePackageService
decrease from AttributeButtons
decreasePrecision from FloatingPointSystem
deepCopy from SubSpace
deepExpand from FreeNilpotentLie
deepestInitial from RecursivePolynomialCategory
deepestTail from RecursivePolynomialCategory
defineProperty from SubSpace
definingEquations from QuasiAlgebraicSet
definingInequation from QuasiAlgebraicSet
definingPolynomial from AlgebraicFunction
definingPolynomial from ComplexCategory&
definingPolynomial from FiniteAlgebraicExtensionField
definingPolynomial from MonogenicAlgebra
definingPolynomial from RealRootCharacterizationCategory
definingPolynomial from Ring
degree from AbelianMonoidRing
degree from AntiSymm
degree from DeRhamComplex
degree from DifferentialPolynomialCategory
degree from ExtAlgBasis
degree from ExtensionField
degree from FactoringUtilities
degree from FiniteAlgebraicExtensionField
degree from FreeLieAlgebra
degree from GradedModule
degree from LaurentPolynomial
degree from MonogenicLinearOperator
degree from Permutation
degree from PermutationGroup
degree from PolynomialCategory
degree from PowerSeriesCategory
degree from TriangularSetCategory
degree from UnivariateLaurentSeriesConstructorCategory
degree from UnivariatePuiseuxSeriesConstructorCategory
degree from UnivariateSkewPolynomialCategory
degree from XPolynomialsCat
degreePartition from GaloisGroupFactorizer
degreePartition from GaloisGroupPolynomialUtilities
degreeSubResultant from PseudoRemainderSequence
degreeSubResultantEuclidean from PseudoRemainderSequence
delay from Stream
delete from LinearAggregate
deleteProperty! from BasicOperator
deleteRoutine! from RoutinesTable
delta from SetOfMIntegersInOneToN
denom from AlgebraicNumber
denom from FractionalIdeal
denom from FunctionSpace
denom from InnerAlgebraicNumber
denom from LocalAlgebra
denom from Localize
denom from QuotientFieldCategory
denomLODE from PrimitiveRatDE
denomRicDE from PrimitiveRatRicDE
denominator from FunctionSpace
denominator from QuotientFieldCategory
denominators from ContinuedFraction
depth from Pattern
depth from StackAggregate
dequeue from DequeueAggregate
dequeue! from QueueAggregate
deref from Reference
deriv from StreamTaylorSeriesOperations
derivationCoordinates from MonogenicAlgebra
derivative from BasicOperatorFunctions1
destruct from PatternMatchResult
destruct from SExpressionCategory
determinant from InnerMatrixLinearAlgebraFunctions
determinant from MatrixCategory
determinant from MatrixLinearAlgebraFunctions
determinant from SquareMatrixCategory
df2ef from ExpertSystemToolsPackage
df2fi from ExpertSystemToolsPackage
df2mf from ExpertSystemToolsPackage
df2st from ExpertSystemContinuityPackage
df2st from ExpertSystemToolsPackage
df2st from d01AgentsPackage
dfRange from ExpertSystemToolsPackage
dflist from ExpertSystemToolsPackage
diag from MappingPackage2
diagonal from SquareMatrixCategory
diagonal? from MatrixCategory
diagonal? from RectangularMatrixCategory
diagonalMatrix from Matrix
diagonalMatrix from MatrixCategory
diagonalMatrix from SquareMatrixCategory
diagonalProduct from IntegralBasisTools
diagonalProduct from SquareMatrixCategory
diagonals from ThreeDimensionalViewport
dictionary from DictionaryOperations
diff from ODEIntegration
difference from SetAggregate
differentialVariables from DifferentialPolynomialCategory
differentiate from DifferentialExtension
differentiate from DifferentialRing
differentiate from DifferentialVariableCategory
differentiate from FullPartialFractionExpansion
differentiate from FunctionFieldCategory
differentiate from GeneralUnivariatePowerSeries
differentiate from IntegrationResult
differentiate from OutputForm
differentiate from PartialDifferentialRing
differentiate from SparseUnivariateLaurentSeries
differentiate from SparseUnivariatePuiseuxSeries
differentiate from SparseUnivariateTaylorSeries
differentiate from UnivariateLaurentSeries
differentiate from UnivariatePolynomialCategory
differentiate from UnivariatePuiseuxSeries
differentiate from UnivariateTaylorSeries
digamma from DoubleFloatSpecialFunctions
digamma from FunctionalSpecialFunction
digamma from SpecialFunctionCategory
digit from CharacterClass
digits from FloatingPointSystem
digits from FloatingPointSystem&
digits from PAdicIntegerCategory
dihedral from CycleIndicators
dihedralGroup from PermutationGroupExamples
dilog from LiouvillianFunction
dilog from LiouvillianFunctionCategory
dim from Palette
dimension from DirectProductCategory&
dimension from FiniteAlgebraicExtensionField&
dimension from FreeNilpotentLie
dimension from PointCategory
dimension from PolynomialIdeals
dimension from VectorSpace
dimensionOfIrreducibleRepresentation from IrrRepSymNatPackage
dimensions from ThreeDimensionalViewport
dimensions from TwoDimensionalViewport
dimensionsOf from FortranType
dimensionsOf from NAGLinkSupportPackage
dioSolve from DiophantineSolutionPackage
diophantineSystem from SmithNormalForm
directProduct from DirectProductCategory
directSum from LinearOrdinaryDifferentialOperatorCategory
directSum from LinearOrdinaryDifferentialOperatorsOps
direction from ToolsForSign
directory from FileNameCategory
discreteLog from FieldOfPrimeCharacteristic
discreteLog from FiniteFieldCategory
discriminant from ComplexCategory&
discriminant from FiniteRankAlgebra
discriminant from FramedAlgebra
discriminant from FramedAlgebra&
discriminant from NumberFieldIntegralBasis
discriminant from PolynomialCategory
discriminant from PseudoRemainderSequence
discriminant from UnivariatePolynomialCategory
discriminantEuclidean from PseudoRemainderSequence
display from BasicOperator
display from Database
display from IndexCard
display from MathMLFormat
display from ScriptFormulaFormat
display from TexFormat
distFact from LeadingCoefDetermination
distance from RecursiveAggregate
distdfact from DistinctDegreeFactorize
distribute from ExpressionSpace
div from OrderedFreeMonoid
div from OutputForm
divergence from MultiVariableCalculusFunctions
divide from EuclideanDomain
divide from FreeMonoid
divide from NonNegativeInteger
divide from PseudoRemainderSequence
divideExponents from UnivariatePolynomialCategory
divideIfCan from UnivariatePolynomialDivisionPackage
divideIfCan! from IntegralBasisTools
divisor from FiniteDivisorCategory
divisorCascade from ComplexRootFindingPackage
divisors from IntegerNumberTheoryFunctions
dmp2rfi from ParametricLinearEquations
dmpToHdmp from PolToPol
dmpToP from PolToPol
dn from EllipticFunctionsUnivariateTaylorSeries
dom from Any
domainOf from Any
dominantTerm from UnivariatePuiseuxSeriesWithExponentialSingularity
dot from DirectProductCategory
dot from OutputForm
dot from TubePlotTools
dot from VectorCategory
double from RepeatedDoubling
double? from FortranScalarType
doubleComplex? from FortranScalarType
doubleDisc from PointsOfFiniteOrderTools
doubleFloatFormat from DoubleFloat
doubleRank from AlgebraPackage
doubleResultant from DoubleResultantPackage
doublyTransitive? from AlgFactor
draw from TopLevelDrawFunctions
draw from TopLevelDrawFunctionsForAlgebraicCurves
draw from TopLevelDrawFunctionsForCompiledFunctions
draw from TopLevelDrawFunctionsForPoints
drawComplex from DrawComplex
drawComplexVectorField from DrawComplex
drawCurves from ViewportPackage
drawStyle from ThreeDimensionalViewport
drawToScale from GraphicsDefaults
droot from AlgebraicFunction
duplicates from MultiDictionary
duplicates? from ListMultiDictionary

e from CliffordAlgebra
e01baf from NagInterpolationPackage
e01bef from NagInterpolationPackage
e01bff from NagInterpolationPackage
e01bgf from NagInterpolationPackage
e01bhf from NagInterpolationPackage
e01daf from NagInterpolationPackage
e01saf from NagInterpolationPackage
e01sbf from NagInterpolationPackage
e01sef from NagInterpolationPackage
e01sff from NagInterpolationPackage
e02adf from NagFittingPackage
e02aef from NagFittingPackage
e02agf from NagFittingPackage
e02ahf from NagFittingPackage
e02ajf from NagFittingPackage
e02akf from NagFittingPackage
e02baf from NagFittingPackage
e02bbf from NagFittingPackage
e02bcf from NagFittingPackage
e02bdf from NagFittingPackage
e02bef from NagFittingPackage
e02daf from NagFittingPackage
e02dcf from NagFittingPackage
e02ddf from NagFittingPackage
e02def from NagFittingPackage
e02dff from NagFittingPackage
e02gaf from NagFittingPackage
e02zaf from NagFittingPackage
e04dgf from NagOptimisationPackage
e04fdf from NagOptimisationPackage
e04gcf from NagOptimisationPackage
e04jaf from NagOptimisationPackage
e04mbf from NagOptimisationPackage
e04naf from NagOptimisationPackage
e04ucf from NagOptimisationPackage
e04ycf from NagOptimisationPackage
edf2df from ExpertSystemToolsPackage
edf2ef from ExpertSystemToolsPackage
edf2efi from ExpertSystemToolsPackage
edf2fi from ExpertSystemToolsPackage
ef2edf from ExpertSystemToolsPackage
eigenMatrix from RadicalEigenPackage
eigenvalues from EigenPackage
eigenvector from EigenPackage
eigenvectors from EigenPackage
eisensteinIrreducible? from GaloisGroupFactorizer
elColumn2! from MatrixLinearAlgebraFunctions
elRow1! from MatrixLinearAlgebraFunctions
elRow2! from MatrixLinearAlgebraFunctions
elem? from IntegrationResult
element? from PolynomialIdeals
elementary from CycleIndicators
elements from SetOfMIntegersInOneToN
elliptic from CoordinateSystems
elliptic from FunctionFieldCategory
elliptic from FunctionFieldCategory&
elliptic? from d03AgentsPackage
ellipticCylindrical from CoordinateSystems
elt from BinaryRecursiveAggregate
elt from CartesianTensor
elt from DataList
elt from Database
elt from Eltable
elt from EltableAggregate
elt from EuclideanModularRing
elt from ExpressionSpace
elt from FramedNonAssociativeAlgebra
elt from FunctionFieldCategory
elt from IndexCard
elt from Library
elt from LinearAggregate
elt from MatrixCategory
elt from OutputForm
elt from Pattern
elt from PermutationCategory
elt from PermutationGroup
elt from QuadraticForm
elt from RectangularMatrixCategory
elt from RecursiveAggregate
elt from Reference
elt from RewriteRule
elt from Ruleset
elt from SExpressionCategory
elt from StringAggregate
elt from Symbol
elt from ThreeDimensionalMatrix
elt from UnaryRecursiveAggregate
elt from UnivariatePolynomialCategory
elt from UnivariatePowerSeriesCategory
empty from Aggregate
empty from OutputForm
empty from QuasiAlgebraicSet
empty from SplittingNode
empty from SymbolTable
empty from TheSymbolTable
empty? from Aggregate
empty? from QuasiAlgebraicSet
empty? from SplittingNode
endOfFile? from TextFile
endSubProgram from TheSymbolTable
enqueue! from QueueAggregate
enterInCache from SortedCache
enterPointData from ThreeSpaceCategory
entries from IndexedAggregate
entries from IntegrationFunctionsTable
entry from IntegrationFunctionsTable
entry? from IndexedAggregate
enumerate from SetOfMIntegersInOneToN
epilogue from ScriptFormulaFormat
epilogue from TexFormat
eq from SExpressionCategory
eq? from Aggregate
equality from BasicOperator
equation from Equation
equation from QueryEquation
equation from SegmentBinding
erf from LiouvillianFunction
erf from LiouvillianFunctionCategory
error from ErrorFunctions
errorInfo from OpenMathError
errorKind from OpenMathError
euclideanGroebner from EuclideanGroebnerBasisPackage
euclideanNormalForm from EuclideanGroebnerBasisPackage
euclideanSize from EuclideanDomain
euler from IntegerNumberTheoryFunctions
euler from PolynomialNumberTheoryFunctions
eulerE from NumberTheoreticPolynomialFunctions
eulerPhi from IntegerNumberTheoryFunctions
eval from ChangeOfVariable
eval from CycleIndicators
eval from Equation
eval from Evalable
eval from EvaluateCycleIndicators
eval from ExpressionSpace
eval from FreeLieAlgebra
eval from FunctionSpace
eval from InnerEvalable
eval from MoebiusTransform
eval from PermutationCategory
eval from RationalFunction
eval from StreamTaylorSeriesOperations
eval from UnivariatePowerSeriesCategory
eval from d02AgentsPackage
evaluate from BasicOperatorFunctions1
evaluate from ModuleOperator
evaluate from Operator
evaluateInverse from ModuleOperator
evaluateInverse from Operator
even? from IntegerNumberSystem
even? from Permutation
even? from RetractableTo
evenInfiniteProduct from InfiniteProductCharacteristicZero
evenInfiniteProduct from InfiniteProductFiniteField
evenInfiniteProduct from InfiniteProductPrimeField
evenInfiniteProduct from StreamInfiniteProduct
evenlambert from StreamTaylorSeriesOperations
evenlambert from UnivariateTaylorSeries
every? from HomogeneousAggregate
exQuo from EuclideanModularRing
exQuo from ModularField
exQuo from ModularRing
exactQuotient from RecursivePolynomialCategory
exactQuotient! from RecursivePolynomialCategory
exists? from FileNameCategory
exp from AntiSymm
exp from ElementaryFunction
exp from ElementaryFunctionCategory
exp from ElementaryFunctionsUnivariateLaurentSeries
exp from ElementaryFunctionsUnivariatePuiseuxSeries
exp from FortranExpression
exp from LieExponentials
exp from StreamTranscendentalFunctions
exp from StreamTranscendentalFunctionsNonCommutative
exp from XExponentialPackage
exp from XPBWPolynomial
exp1 from DoubleFloat
exp1 from Float
expIfCan from PartialTranscendentalFunctions
expPot from InnerNormalBasisFieldFunctions
expand from DegreeReductionPackage
expand from IntegrationResultRFToFunction
expand from IntegrationResultToFunction
expand from SegmentExpansionCategory
expand from TranscendentalManipulations
expand from XPolynomial
expand from XRecursivePolynomial
expandLog from TranscendentalManipulations
expandPower from TranscendentalManipulations
expandTrigProducts from TranscendentalManipulations
expenseOfEvaluation from ExpertSystemToolsPackage
expenseOfEvaluation from e04AgentsPackage
expenseOfEvaluationIF from d02AgentsPackage
expextendedint from TranscendentalIntegration
expint from ODEIntegration
expintegrate from TranscendentalIntegration
expintfldpoly from TranscendentalIntegration
explicitEntries? from LazyStreamAggregate
explicitlyEmpty? from LazyStreamAggregate
explicitlyFinite? from StreamAggregate
explimitedint from TranscendentalIntegration
explogs2trigs from InnerTrigonometricManipulations
exponent from ExponentialOfUnivariatePuiseuxSeries
exponent from FloatingPointSystem
exponent from MachineFloat
exponent from ModuleMonomial
exponential from ExponentialOfUnivariatePuiseuxSeries
exponential from RandomFloatDistributions
exponential1 from RandomFloatDistributions
exponentialOrder from ExponentialOfUnivariatePuiseuxSeries
exponents from ExtAlgBasis
expr from SExpressionCategory
exprHasAlgebraicWeight from d01WeightsPackage
exprHasLogarithmicWeights from d01WeightsPackage
exprHasWeightCosWXorSinWX from d01WeightsPackage
exprToGenUPS from FunctionSpaceToUnivariatePowerSeries
exprToUPS from FunctionSpaceToUnivariatePowerSeries
exprToXXP from FunctionSpaceToExponentialExpansion
expressIdealMember from PrincipalIdealDomain
exprex from MathMLFormat
expt from RepeatedSquaring
exptMod from DistinctDegreeFactorize
exptMod from ModularDistinctDegreeFactorizer
exquo from ComplexCategory
exquo from FiniteAbelianMonoidRing
exquo from IntegralDomain
exquo from MatrixCategory
exquo from NonNegativeInteger
exquo from OutputForm
exquo from PseudoRemainderSequence
exquo from RectangularMatrixCategory
exquo from StreamTaylorSeriesOperations
exquo from UnivariateSkewPolynomialCategory
extend from ContinuedFraction
extend from LazyStreamAggregate
extend from MultivariateTaylorSeriesCategory
extend from PAdicIntegerCategory
extend from PointCategory
extend from RegularTriangularSetCategory
extend from TriangularSetCategory
extend from UnivariatePowerSeriesCategory
extendIfCan from TriangularSetCategory
extendedEuclidean from EuclideanDomain
extendedIntegrate from RationalFunctionIntegration
extendedResultant from NewSparseUnivariatePolynomial
extendedSubResultantGcd from NewSparseUnivariatePolynomial
extendedSubResultantGcd from RecursivePolynomialCategory
extendedint from RationalIntegration
extension from FileNameCategory
extensionDegree from ExtensionField
extensionDegree from FiniteAlgebraicExtensionField
extensionDegree from FiniteAlgebraicExtensionField&
exteriorDifferential from DeRhamComplex
external? from FortranType
externalList from SymbolTable
extract! from BagAggregate
extractBottom! from DequeueAggregate
extractClosed from SubSpace
extractIfCan from TabulatedComputationPackage
extractIndex from SubSpace
extractPoint from SubSpace
extractProperty from SubSpace
extractSplittingLeaf from SplittingTree
extractTop! from DequeueAggregate
eyeDistance from ThreeDimensionalViewport

f01brf from NagMatrixOperationsPackage
f01bsf from NagMatrixOperationsPackage
f01maf from NagMatrixOperationsPackage
f01mcf from NagMatrixOperationsPackage
f01qcf from NagMatrixOperationsPackage
f01qdf from NagMatrixOperationsPackage
f01qef from NagMatrixOperationsPackage
f01rcf from NagMatrixOperationsPackage
f01rdf from NagMatrixOperationsPackage
f01ref from NagMatrixOperationsPackage
f02aaf from NagEigenPackage
f02abf from NagEigenPackage
f02adf from NagEigenPackage
f02aef from NagEigenPackage
f02aff from NagEigenPackage
f02agf from NagEigenPackage
f02ajf from NagEigenPackage
f02akf from NagEigenPackage
f02awf from NagEigenPackage
f02axf from NagEigenPackage
f02bbf from NagEigenPackage
f02bjf from NagEigenPackage
f02fjf from NagEigenPackage
f02wef from NagEigenPackage
f02xef from NagEigenPackage
f04adf from NagLinearEquationSolvingPackage
f04arf from NagLinearEquationSolvingPackage
f04asf from NagLinearEquationSolvingPackage
f04atf from NagLinearEquationSolvingPackage
f04axf from NagLinearEquationSolvingPackage
f04faf from NagLinearEquationSolvingPackage
f04jgf from NagLinearEquationSolvingPackage
f04maf from NagLinearEquationSolvingPackage
f04mbf from NagLinearEquationSolvingPackage
f04mcf from NagLinearEquationSolvingPackage
f04qaf from NagLinearEquationSolvingPackage
f07adf from NagLapack
f07aef from NagLapack
f07fdf from NagLapack
f07fef from NagLapack
f2df from ExpertSystemToolsPackage
f2st from ExpertSystemToolsPackage
fTable from IntegrationFunctionsTable
factor from AlgFactor
factor from AlgebraicMultFact
factor from ComplexFactorization
factor from ComplexRootFindingPackage
factor from DistinctDegreeFactorize
factor from GaloisGroupFactorizer
factor from GaussianFactorizationPackage
factor from GenUFactorize
factor from GeneralizedMultivariateFactorize
factor from InnerAlgFactor
factor from InnerMultFact
factor from IntegerFactorizationPackage
factor from LinearOrdinaryDifferentialOperatorFactorizer
factor from LyndonWord
factor from MPolyCatPolyFactorizer
factor from MPolyCatRationalFunctionFactorizer
factor from MRationalFactorize
factor from ModularDistinctDegreeFactorizer
factor from MultFiniteFactorize
factor from MultivariateFactorize
factor from RationalFactorize
factor from RationalFunctionFactor
factor from SAERationalFunctionAlgFactor
factor from SimpleAlgebraicExtensionAlgFactor
factor from SupFractionFactorizer
factor from UniqueFactorizationDomain
factor from UnivariateFactorize
factor1 from LinearOrdinaryDifferentialOperatorFactorizer
factorAndSplit from Equation
factorByRecursion from PolynomialFactorizationByRecursion
factorByRecursion from PolynomialFactorizationByRecursionUnivariate
factorFraction from RationalFunctionFactorizer
factorGroebnerBasis from GroebnerFactorizationPackage
factorList from ChineseRemainderToolsForIntegralBases
factorOfDegree from GaloisGroupFactorizer
factorOfDegree from GaloisGroupPolynomialUtilities
factorPolynomial from Expression
factorPolynomial from PolynomialFactorizationExplicit
factorSFBRlcUnit from PolynomialFactorizationByRecursion
factorSFBRlcUnit from PolynomialFactorizationByRecursionUnivariate
factorSquareFree from DistinctDegreeFactorize
factorSquareFree from GaloisGroupFactorizer
factorSquareFree from RationalFactorize
factorSquareFree from UnivariateFactorize
factorSquareFreeByRecursion from PolynomialFactorizationByRecursion
factorSquareFreeByRecursion from PolynomialFactorizationByRecursionUnivariate
factorSquareFreePolynomial from PolynomialFactorizationExplicit
factorial from CombinatorialFunction
factorial from CombinatorialFunctionCategory
factorial from IntegerCombinatoricFunctions
factorials from CombinatorialFunction
factorials from CombinatorialOpsCategory
factors from FreeGroup
factors from FreeMonoid
factors from OrderedFreeMonoid
factorsOfCyclicGroupSize from FiniteFieldCategory
factorsOfDegree from GaloisGroupPolynomialUtilities
factorset from ParametricLinearEquations
failed from PatternMatchListResult
failed from PatternMatchResult
failed? from PatternMatchListResult
failed? from PatternMatchResult
false from Boolean
ffactor from FunctionSpaceUnivariatePolynomialFactor
fglmIfCan from FGLMIfCanPackage
fglmIfCan from LexTriangularPackage
fi2df from ExpertSystemToolsPackage
fibonacci from IntegerNumberTheoryFunctions
figureUnits from GraphImage
filename from FileNameCategory
fill! from IndexedAggregate
fillPascalTriangle from GaloisGroupUtilities
filterUntil from InfiniteTuple
filterUntil from Stream
filterWhile from InfiniteTuple
filterWhile from Stream
find from Collection
findCycle from Stream
finite? from CardinalNumber
finite? from OnePointCompletion
finite? from OrderedCompletion
finiteBasis from FiniteDivisor
finiteBound from e04AgentsPackage
fintegrate from SparseMultivariateTaylorSeries
fintegrate from TaylorSeries
first from IndexedAggregate
first from Magma
first from OrderedFreeMonoid
first from PoincareBirkhoffWittLyndonBasis
first from TriangularSetCategory
first from UnaryRecursiveAggregate
firstDenom from PartialFraction
firstNumer from PartialFraction
firstSubsetGray from GrayCode
firstUncouplingMatrix from PrecomputedAssociatedEquations
fixPredicate from PatternMatchPushDown
fixedDivisor from PolynomialNumberTheoryFunctions
fixedPoint from MappingPackage1
fixedPointExquo from UnivariateTaylorSeriesODESolver
fixedPoints from Permutation
flatten from InputForm
flexible? from FiniteRankNonAssociativeAlgebra
flexible? from FiniteRankNonAssociativeAlgebra&
flexibleArray from FlexibleArray
float from FloatingPointSystem
float from SExpressionCategory
float? from SExpressionCategory
floor from QuotientFieldCategory
floor from RealNumberSystem
fmecg from NewSparseUnivariatePolynomial
fmecg from PolynomialRing
fmecg from SparseUnivariatePolynomial
fmecg from SymmetricPolynomial
fmecg from UnivariatePolynomial
forLoop from FortranCode
formula from ScriptFormulaFormat
fortran from SimpleFortranProgram
fortranCarriageReturn from FortranTemplate
fortranCharacter from FortranType
fortranCompilerName from NAGLinkSupportPackage
fortranComplex from FortranType
fortranDouble from FortranType
fortranDoubleComplex from FortranType
fortranInteger from FortranType
fortranLinkerArgs from NAGLinkSupportPackage
fortranLiteral from FortranTemplate
fortranLiteralLine from FortranTemplate
fortranLogical from FortranType
fortranReal from FortranType
fortranTypeOf from SymbolTable
fprindINFO from GroebnerInternalPackage
fracPart from FullPartialFractionExpansion
fractRadix from RadixExpansion
fractRagits from RadixExpansion
fractionFreeGauss! from MatrixLinearAlgebraFunctions
fractionPart from BinaryExpansion
fractionPart from DecimalExpansion
fractionPart from HexadecimalExpansion
fractionPart from QuotientFieldCategory
fractionPart from RadixExpansion
fractionPart from RealNumberSystem
freeOf? from ExpressionSpace
frobenius from ModMonic
front from QueueAggregate
froot from PolynomialRoots
frst from LazyStreamAggregate
fullDisplay from Database
fullDisplay from IndexCard
fullPartialFraction from FullPartialFractionExpansion
function from InputForm
function from MakeFunction
functionIsContinuousAtEndPoints from d01AgentsPackage
functionIsFracPolynomial? from ExpertSystemContinuityPackage
functionIsOscillatory from d01AgentsPackage

gbasis from GroebnerInternalPackage
gcd from GcdDomain
gcd from ModularDistinctDegreeFactorizer
gcd from NonNegativeInteger
gcd from PolynomialGcdPackage
gcd from PositiveInteger
gcd from PseudoRemainderSequence
gcd from RecursivePolynomialCategory
gcdPolynomial from GcdDomain
gcdPolynomial from GeneralPolynomialGcdPackage
gcdPolynomial from PolynomialFactorizationExplicit
gcdPrimitive from PolynomialGcdPackage
gcdcofact from HeuGcd
gcdcofactprim from HeuGcd
gcdprim from HeuGcd
gderiv from StreamTaylorSeriesOperations
generalInfiniteProduct from InfiniteProductCharacteristicZero
generalInfiniteProduct from InfiniteProductFiniteField
generalInfiniteProduct from InfiniteProductPrimeField
generalInfiniteProduct from StreamInfiniteProduct
generalLambert from StreamTaylorSeriesOperations
generalLambert from UnivariateTaylorSeries
generalPosition from PolynomialIdeals
generalSqFr from TwoFactorize
generalTwoFactor from TwoFactorize
generalizedContinuumHypothesisAssumed from CardinalNumber
generalizedContinuumHypothesisAssumed? from CardinalNumber
generalizedEigenvector from EigenPackage
generalizedEigenvectors from EigenPackage
generalizedInverse from InnerMatrixLinearAlgebraFunctions
generate from HallBasis
generate from InfiniteTuple
generate from Stream
generateIrredPoly from IrredPolyOverFiniteField
generator from AntiSymm
generator from DeRhamComplex
generator from FiniteAlgebraicExtensionField
generator from FiniteDivisorCategory
generator from FreeNilpotentLie
generator from MonogenicAlgebra
generators from PermutationGroup
generators from PolynomialIdeals
generic from GenericNonAssociativeAlgebra
generic? from Pattern
genericLeftDiscriminant from GenericNonAssociativeAlgebra
genericLeftMinimalPolynomial from GenericNonAssociativeAlgebra
genericLeftNorm from GenericNonAssociativeAlgebra
genericLeftTrace from GenericNonAssociativeAlgebra
genericLeftTraceForm from GenericNonAssociativeAlgebra
genericPosition from GroebnerSolve
genericRightDiscriminant from GenericNonAssociativeAlgebra
genericRightMinimalPolynomial from GenericNonAssociativeAlgebra
genericRightNorm from GenericNonAssociativeAlgebra
genericRightTrace from GenericNonAssociativeAlgebra
genericRightTraceForm from GenericNonAssociativeAlgebra
genus from FunctionFieldCategory&
geometric from RandomIntegerDistributions
getBadValues from Pattern
getButtonValue from AttributeButtons
getCode from FortranCode
getCurve from TubePlot
getDatabase from AxiomServer
getDatabase from OperationsQuery
getExplanations from RoutinesTable
getGoodPrime from PointsOfFiniteOrderTools
getGraph from TwoDimensionalViewport
getMatch from PatternMatchResult
getMeasure from RoutinesTable
getMultiplicationMatrix from FiniteFieldNormalBasis
getMultiplicationMatrix from FiniteFieldNormalBasisExtension
getMultiplicationMatrix from FiniteFieldNormalBasisExtensionByPolynomial
getMultiplicationTable from FiniteFieldNormalBasis
getMultiplicationTable from FiniteFieldNormalBasisExtension
getMultiplicationTable from FiniteFieldNormalBasisExtensionByPolynomial
getOrder from UserDefinedPartialOrdering
getPickedPoints from TwoDimensionalViewport
getRef from InnerSparseUnivariatePowerSeries
getStream from InnerSparseUnivariatePowerSeries
getVariableOrder from UserDefinedVariableOrdering
getZechTable from FiniteFieldCyclicGroup
getZechTable from FiniteFieldCyclicGroupExtension
getZechTable from FiniteFieldCyclicGroupExtensionByPolynomial
gethi from ExpertSystemContinuityPackage
gethi from ExpertSystemToolsPackage
gethi from d01AgentsPackage
getlo from ExpertSystemContinuityPackage
getlo from ExpertSystemToolsPackage
getlo from d01AgentsPackage
goodPoint from ChangeOfVariable
goodnessOfFit from AnnaNumericalOptimizationPackage
goto from FortranCode
gradient from MultiVariableCalculusFunctions
graeffe from ComplexRootFindingPackage
gramschmidt from RadicalEigenPackage
graphCurves from ViewportPackage
graphImage from GraphImage
graphState from TwoDimensionalViewport
graphStates from TwoDimensionalViewport
graphs from CycleIndicators
graphs from TwoDimensionalViewport
green from Color
groebSolve from GroebnerSolve
groebgen from LinGroebnerPackage
groebner from FGLMIfCanPackage
groebner from GroebnerPackage
groebner from LexTriangularPackage
groebner from PolynomialIdeals
groebner? from PolynomialIdeals
groebnerFactorize from GroebnerFactorizationPackage
groebnerIdeal from PolynomialIdeals
ground from FiniteAbelianMonoidRing
ground from FunctionSpace
ground? from FiniteAbelianMonoidRing
ground? from FunctionSpace

hMonic from GroebnerInternalPackage
halfExtendedResultant1 from NewSparseUnivariatePolynomial
halfExtendedResultant2 from NewSparseUnivariatePolynomial
halfExtendedSubResultantGcd1 from NewSparseUnivariatePolynomial
halfExtendedSubResultantGcd1 from RecursivePolynomialCategory
halfExtendedSubResultantGcd2 from NewSparseUnivariatePolynomial
halfExtendedSubResultantGcd2 from RecursivePolynomialCategory
harmonic from IntegerNumberTheoryFunctions
has? from BasicOperator
hasHi from UniversalSegment
hasPredicate? from Pattern
hasSolution? from LinearSystemMatrixPackage
hasSolution? from LinearSystemMatrixPackage1
hasTopPredicate? from Pattern
hash from DoubleFloat
hash from IndexedString
hash from IntegerNumberSystem
hash from SetCategory
hasoln from ParametricLinearEquations
hclf from FreeMonoid
hclf from OrderedFreeMonoid
hconcat from OutputForm
hcrf from FreeMonoid
hcrf from OrderedFreeMonoid
hdmpToDmp from PolToPol
hdmpToP from PolToPol
head from DoublyLinkedAggregate
head from RecursivePolynomialCategory
headReduce from RecursivePolynomialCategory
headReduce from TriangularSetCategory
headReduced? from RecursivePolynomialCategory
headReduced? from TriangularSetCategory
headRemainder from PolynomialSetCategory
heapSort from FiniteLinearAggregateSort
height from DequeueAggregate
height from ExpressionSpace
height from GaloisGroupFactorizationUtilities
height from Kernel
height from OutputForm
henselFact from GaloisGroupFactorizer
henselFact from UnivariateFactorize
hermite from PolynomialNumberTheoryFunctions
hermite from SmithNormalForm
hermiteH from OrthogonalPolynomialFunctions
hessian from MultiVariableCalculusFunctions
hex from HexadecimalExpansion
hexDigit from CharacterClass
hi from SegmentCategory
high from SegmentCategory
highCommonTerms from FreeAbelianMonoidCategory
hitherPlane from ThreeDimensionalViewport
homogeneous? from AntiSymm
homogeneous? from DeRhamComplex
horizConcat from MatrixCategory
hspace from OutputForm
htrigs from TranscendentalManipulations
hue from Color
hue from Palette
hue from PointPackage
hyperelliptic from FunctionFieldCategory
hyperelliptic from FunctionFieldCategory&
hypergeometric0F1 from DoubleFloatSpecialFunctions

iCompose from InnerSparseUnivariatePowerSeries
iExquo from InnerSparseUnivariatePowerSeries
iFTable from ODEIntensityFunctionsTable
id from MappingPackage1
ideal from FiniteDivisorCategory
ideal from FractionalIdeal
ideal from PolynomialIdeals
idealSimplify from QuasiAlgebraicSet
idealiser from IntegralBasisTools
idealiserMatrix from IntegralBasisTools
identification from LieExponentials
identity from DenavitHartenbergMatrix
identityMatrix from ThreeDimensionalMatrix
identitySquareMatrix from FortranCodePackage1
iflist2Result from ExpertSystemToolsPackage
ignore? from DefiniteIntegrationTools
iiAiryAi from FunctionalSpecialFunction
iiAiryBi from FunctionalSpecialFunction
iiBesselI from FunctionalSpecialFunction
iiBesselJ from FunctionalSpecialFunction
iiBesselK from FunctionalSpecialFunction
iiBesselY from FunctionalSpecialFunction
iiBeta from FunctionalSpecialFunction
iiGamma from FunctionalSpecialFunction
iiabs from FunctionalSpecialFunction
iiacos from ElementaryFunction
iiacosh from ElementaryFunction
iiacot from ElementaryFunction
iiacoth from ElementaryFunction
iiacsc from ElementaryFunction
iiacsch from ElementaryFunction
iiasec from ElementaryFunction
iiasech from ElementaryFunction
iiasin from ElementaryFunction
iiasinh from ElementaryFunction
iiatan from ElementaryFunction
iiatanh from ElementaryFunction
iibinom from CombinatorialFunction
iicos from ElementaryFunction
iicosh from ElementaryFunction
iicot from ElementaryFunction
iicoth from ElementaryFunction
iicsc from ElementaryFunction
iicsch from ElementaryFunction
iidigamma from FunctionalSpecialFunction
iidprod from CombinatorialFunction
iidsum from CombinatorialFunction
iiexp from ElementaryFunction
iifact from CombinatorialFunction
iilog from ElementaryFunction
iiperm from CombinatorialFunction
iipolygamma from FunctionalSpecialFunction
iipow from CombinatorialFunction
iisec from ElementaryFunction
iisech from ElementaryFunction
iisin from ElementaryFunction
iisinh from ElementaryFunction
iisqrt2 from ElementaryFunction
iisqrt3 from ElementaryFunction
iitan from ElementaryFunction
iitanh from ElementaryFunction
imag from ComplexCategory
imag from ComplexTrigonometricManipulations
imag from TrigonometricManipulations
imagE from OctonionCategory
imagI from OctonionCategory
imagI from QuaternionCategory
imagJ from OctonionCategory
imagJ from QuaternionCategory
imagK from OctonionCategory
imagK from QuaternionCategory
imagi from OctonionCategory
imaginary from ComplexCategory
imagj from OctonionCategory
imagk from OctonionCategory
implies from Boolean
in? from ExpertSystemContinuityPackage1
in? from ExpertSystemToolsPackage
in? from PolynomialIdeals
inGroundField? from ExtensionField
inHallBasis? from HallBasis
inR? from Pattern
inRadical? from PolynomialIdeals
inc from IntegerNumberSystem
inconsistent? from ParametricLinearEquations
incr from SegmentCategory
increase from AttributeButtons
increasePrecision from FloatingPointSystem
increment from IncrementingMaps
incrementBy from IncrementingMaps
incrementKthElement from SetOfMIntegersInOneToN
index from Finite
index from InnerNormalBasisFieldFunctions
index from ModuleMonomial
index? from IndexedAggregate
indiceSubResultant from PseudoRemainderSequence
indiceSubResultantEuclidean from PseudoRemainderSequence
indices from IndexedAggregate
indicialEquation from PrimitiveRatDE
indicialEquationAtInfinity from RationalLODE
indicialEquations from PrimitiveRatDE
inf from IntervalCategory
infLex? from SplittingNode
infRittWu? from QuasiComponentPackage
infRittWu? from RecursivePolynomialCategory
infRittWu? from SquareFreeQuasiComponentPackage
infRittWu? from TriangularSetCategory
infieldIntegrate from RationalFunctionIntegration
infieldint from RationalIntegration
infinite? from OnePointCompletion
infinite? from OrderedCompletion
infiniteProduct from InfiniteProductCharacteristicZero
infiniteProduct from InfiniteProductFiniteField
infiniteProduct from InfiniteProductPrimeField
infiniteProduct from StreamInfiniteProduct
infinity from Infinity
infinity from OnePointCompletion
infinityNorm from GaloisGroupFactorizationUtilities
infix from OutputForm
infix? from OutputForm
init from RecursivePolynomialCategory
init from StepThrough
initTable! from TabulatedComputationPackage
initial from DifferentialPolynomialCategory
initializeGroupForWordProblem from PermutationGroup
initiallyReduce from RecursivePolynomialCategory
initiallyReduce from TriangularSetCategory
initiallyReduced? from RecursivePolynomialCategory
initiallyReduced? from TriangularSetCategory
initials from TriangularSetCategory
innerEigenvectors from InnerNumericEigenPackage
innerSolve from InnerNumericFloatSolvePackage
innerSolve1 from InnerNumericFloatSolvePackage
innerint from ElementaryFunctionDefiniteIntegration
input from BasicOperator
inrootof from AlgebraicFunction
insert from LinearAggregate
insert! from BagAggregate
insert! from ExtensibleLinearAggregate
insert! from IntegrationFunctionsTable
insert! from MultiDictionary
insert! from ODEIntensityFunctionsTable
insert! from TabulatedComputationPackage
insertBottom! from DequeueAggregate
insertMatch from PatternMatchResult
insertTop! from DequeueAggregate
insertionSort! from SortPackage
inspect from BagAggregate
int from ODEIntegration
int from OutputForm
int from StreamTaylorSeriesOperations
intChoose from MultivariateSquareFree
intPatternMatch from IntegrationTools
intcompBasis from LinGroebnerPackage
integer from IntegerRetractions
integer from SExpressionCategory
integer? from FortranScalarType
integer? from IntegerRetractions
integer? from SExpressionCategory
integerBound from BoundIntegerRoots
integerIfCan from IntegerRetractions
integers from StreamTaylorSeriesOperations
integral from IntegrationResult
integral from LiouvillianFunction
integral from PrimitiveFunctionCategory
integral? from FunctionFieldCategory
integralAtInfinity? from FunctionFieldCategory
integralBasis from FunctionFieldIntegralBasis
integralBasis from NumberFieldIntegralBasis
integralBasis from PAdicWildFunctionFieldIntegralBasis
integralBasis from WildFunctionFieldIntegralBasis
integralCoordinates from FunctionFieldCategory
integralDerivationMatrix from FunctionFieldCategory
integralLastSubResultant from RegularTriangularSetGcdPackage
integralRepresents from FunctionFieldCategory
integrate from AnnaNumericalIntegrationPackage
integrate from ElementaryFunctionDefiniteIntegration
integrate from FunctionSpaceIntegration
integrate from GeneralUnivariatePowerSeries
integrate from InnerSparseUnivariatePowerSeries
integrate from IntegrationResultRFToFunction
integrate from MultivariateTaylorSeriesCategory
integrate from Polynomial
integrate from RationalFunctionDefiniteIntegration
integrate from RationalIntegration
integrate from SparseMultivariateTaylorSeries
integrate from SparseUnivariateLaurentSeries
integrate from SparseUnivariatePuiseuxSeries
integrate from SparseUnivariateTaylorSeries
integrate from StreamTaylorSeriesOperations
integrate from TaylorSeries
integrate from UnivariateLaurentSeries
integrate from UnivariateLaurentSeriesCategory
integrate from UnivariatePolynomialCategory
integrate from UnivariatePuiseuxSeries
integrate from UnivariatePuiseuxSeriesCategory
integrate from UnivariateTaylorSeries
integrate from UnivariateTaylorSeriesCategory
intensity from ThreeDimensionalViewport
interReduce from PolynomialSetUtilitiesPackage
intermediateResultsIF from d02AgentsPackage
internal? from SubSpace
internalAugment from RegularTriangularSet
internalAugment from RegularTriangularSetCategory
internalAugment from SquareFreeRegularTriangularSet
internalDecompose from RegularSetDecompositionPackage
internalDecompose from SquareFreeRegularSetDecompositionPackage
internalInfRittWu? from QuasiComponentPackage
internalInfRittWu? from SquareFreeQuasiComponentPackage
internalIntegrate from FunctionSpaceComplexIntegration
internalIntegrate from RationalFunctionIntegration
internalIntegrate0 from FunctionSpaceComplexIntegration
internalLastSubResultant from RegularTriangularSetGcdPackage
internalSubPolSet? from QuasiComponentPackage
internalSubPolSet? from SquareFreeQuasiComponentPackage
internalSubQuasiComponent? from QuasiComponentPackage
internalSubQuasiComponent? from SquareFreeQuasiComponentPackage
internalZeroSetSplit from RegularTriangularSet
internalZeroSetSplit from SquareFreeRegularTriangularSet
interpolate from PolynomialInterpolation
interpolate from RationalInterpolation
interpret from InputForm
interpret from InputFormFunctions1
interpretString from TemplateUtilities
intersect from PolynomialIdeals
intersect from RegularTriangularSetCategory
intersect from SetAggregate
interval from IntervalCategory
inv from DivisionRing
inv from Equation
inv from EuclideanModularRing
inv from Group
inv from InnerNormalBasisFieldFunctions
inv from ModularRing
inv from OctonionCategory
inverse from InnerMatrixLinearAlgebraFunctions
inverse from InnerMatrixQuotientFieldFunctions
inverse from Matrix
inverse from MatrixCategory
inverse from MatrixLinearAlgebraFunctions
inverse from SquareMatrixCategory
inverse from TableauxBumpers
inverseColeman from SymmetricGroupCombinatoricFunctions
inverseLaplace from InverseLaplaceTransform
invertIfCan from MatrixLinearAlgebraFunctions
invertible? from RegularTriangularSetCategory
invertibleElseSplit? from RegularTriangularSetCategory
invertibleSet from RegularTriangularSetCategory
invmod from IntegerNumberSystem
invmultisect from StreamTaylorSeriesOperations
invmultisect from UnivariateTaylorSeries
iomode from FileCategory
ipow from CombinatorialFunction
iprint from InternalPrintPackage
iroot from AlgebraicFunction
irreducible? from DistinctDegreeFactorize
irreducibleFactors from PolynomialSetUtilitiesPackage
irreducibleRepresentation from IrrRepSymNatPackage
is? from BasicOperator
is? from ExpressionSpace
is? from Kernel
is? from PatternMatch
isAbsolutelyIrreducible? from RepresentationPackage2
isExpt from FunctionSpace
isExpt from Pattern
isExpt from PolynomialCategory
isExpt from PolynomialCategoryQuotientFunctions
isList from Pattern
isMult from FunctionSpace
isOp from Pattern
isPlus from FunctionSpace
isPlus from Pattern
isPlus from PolynomialCategory
isPlus from PolynomialCategoryQuotientFunctions
isPower from FunctionSpace
isPower from Pattern
isPower from PolynomialCategoryQuotientFunctions
isQuotient from ExpertSystemToolsPackage
isQuotient from Pattern
isTimes from FunctionSpace
isTimes from Pattern
isTimes from PolynomialCategory
isTimes from PolynomialCategoryQuotientFunctions
isobaric? from DifferentialPolynomialCategory
iter from MappingPackageInternalHacks1
iteratedInitials from RecursivePolynomialCategory

jacobi from IntegerNumberTheoryFunctions
jacobiIdentity? from FiniteRankNonAssociativeAlgebra
jacobiIdentity? from FiniteRankNonAssociativeAlgebra&
jacobian from MultiVariableCalculusFunctions
jacobian from d02AgentsPackage
janko2 from PermutationGroupExamples
jordanAdmissible? from FiniteRankNonAssociativeAlgebra
jordanAdmissible? from FiniteRankNonAssociativeAlgebra&
jordanAlgebra? from FiniteRankNonAssociativeAlgebra
jordanAlgebra? from FiniteRankNonAssociativeAlgebra&

karatsuba from UnivariatePolynomialMultiplicationPackage
karatsubaDivide from UnivariatePolynomialCategory
karatsubaOnce from UnivariatePolynomialMultiplicationPackage
kernel from ExpressionSpace
kernel from Kernel
kernels from ExpressionSpace
key from GraphImage
key from ThreeDimensionalViewport
key from TwoDimensionalViewport
key? from KeyedDictionary
keys from IntegrationFunctionsTable
keys from KeyedDictionary
keys from ODEIntensityFunctionsTable
kmax from IntegrationTools
knownInfBasis from AlgebraicFunctionField
kovacic from Kovacic
kroneckerDelta from CartesianTensor
ksec from IntegrationTools

lSpaceBasis from FiniteDivisor
label from OutputForm
lagrange from StreamTaylorSeriesOperations
lagrange from UnivariateTaylorSeries
laguerre from PolynomialNumberTheoryFunctions
laguerreL from OrthogonalPolynomialFunctions
lambda from InputForm
lambert from StreamTaylorSeriesOperations
lambert from UnivariateTaylorSeries
laplace from LaplaceTransform
laplacian from MultiVariableCalculusFunctions
largest from UserDefinedPartialOrdering
last from DoublyLinkedAggregate
last from TriangularSetCategory
last from UnaryRecursiveAggregate
lastSubResultant from NewSparseUnivariatePolynomial
lastSubResultant from PseudoRemainderSequence
lastSubResultant from RecursivePolynomialCategory
lastSubResultant from RegularTriangularSetCategory
lastSubResultantElseSplit from RegularTriangularSetCategory
lastSubResultantEuclidean from PseudoRemainderSequence
latex from SetCategory
laurent from ExpressionToUnivariatePowerSeries
laurent from GenerateUnivariatePowerSeries
laurent from UnivariateLaurentSeriesConstructorCategory
laurent from UnivariatePuiseuxSeriesConstructorCategory
laurentIfCan from UnivariatePuiseuxSeriesConstructorCategory
laurentRep from UnivariatePuiseuxSeriesConstructorCategory
lazy? from LazyStreamAggregate
lazyEvaluate from LazyStreamAggregate
lazyGintegrate from StreamTaylorSeriesOperations
lazyIntegrate from StreamTaylorSeriesOperations
lazyIrreducibleFactors from PolynomialSetUtilitiesPackage
lazyPquo from RecursivePolynomialCategory
lazyPrem from RecursivePolynomialCategory
lazyPremWithDefault from RecursivePolynomialCategory
lazyPseudoDivide from NewSparseUnivariatePolynomial
lazyPseudoDivide from RecursivePolynomialCategory
lazyPseudoQuotient from NewSparseUnivariatePolynomial
lazyPseudoRemainder from NewSparseUnivariatePolynomial
lazyResidueClass from NewSparseUnivariatePolynomial
lazyResidueClass from RecursivePolynomialCategory
lazyVariations from RealPolynomialUtilitiesPackage
lcm from GcdDomain
ldf2lst from ExpertSystemContinuityPackage
ldf2lst from ExpertSystemToolsPackage
ldf2lst from d01AgentsPackage
ldf2vmf from ExpertSystemToolsPackage
leader from DifferentialPolynomialCategory
leadingBasisTerm from AntiSymm
leadingBasisTerm from DeRhamComplex
leadingCoefficient from AbelianMonoidRing
leadingCoefficient from AntiSymm
leadingCoefficient from DeRhamComplex
leadingCoefficient from FreeModuleCat
leadingCoefficient from GeneralModulePolynomial
leadingCoefficient from IndexedDirectProductCategory
leadingCoefficient from LaurentPolynomial
leadingCoefficient from MonogenicLinearOperator
leadingCoefficient from MonoidRing
leadingCoefficient from PowerSeriesCategory
leadingCoefficient from RecursivePolynomialCategory
leadingCoefficient from UnivariateSkewPolynomialCategory
leadingCoefficientRicDE from PrimitiveRatRicDE
leadingExponent from GeneralModulePolynomial
leadingIdeal from PolynomialIdeals
leadingIndex from GeneralModulePolynomial
leadingMonomial from AbelianMonoidRing
leadingMonomial from FreeModuleCat
leadingMonomial from GeneralModulePolynomial
leadingMonomial from MonoidRing
leadingMonomial from PowerSeriesCategory
leadingSupport from IndexedDirectProductCategory
leadingTerm from FreeModuleCat
leaf? from RecursiveAggregate
leaf? from SubSpace
leastAffineMultiple from FiniteFieldPolynomialPackage
leastMonomial from RecursivePolynomialCategory
leastPower from IntegralBasisTools
leaves from RecursiveAggregate
left from BinaryRecursiveAggregate
left from LyndonWord
left from Magma
left from OutputForm
left from RightOpenIntervalRootCharacterization
leftAlternative? from FiniteRankNonAssociativeAlgebra
leftAlternative? from FiniteRankNonAssociativeAlgebra&
leftCharacteristicPolynomial from FiniteRankNonAssociativeAlgebra
leftDiscriminant from FiniteRankNonAssociativeAlgebra
leftDiscriminant from FramedNonAssociativeAlgebra
leftDiscriminant from FramedNonAssociativeAlgebra&
leftDivide from NonCommutativeOperatorDivision
leftDivide from UnivariateSkewPolynomialCategory
leftDivide from UnivariateSkewPolynomialCategoryOps
leftExactQuotient from NonCommutativeOperatorDivision
leftExactQuotient from UnivariateSkewPolynomialCategory
leftExtendedGcd from UnivariateSkewPolynomialCategory
leftFactor from PolynomialDecomposition
leftFactorIfCan from UnivariatePolynomialDecompositionPackage
leftGcd from NonCommutativeOperatorDivision
leftGcd from UnivariateSkewPolynomialCategory
leftLcm from NonCommutativeOperatorDivision
leftLcm from UnivariateSkewPolynomialCategory
leftMinimalPolynomial from FiniteRankNonAssociativeAlgebra
leftMult from ListMonoidOps
leftNorm from FiniteRankNonAssociativeAlgebra
leftOne from Equation
leftPower from Monad
leftPower from MonadWithUnit
leftQuotient from NonCommutativeOperatorDivision
leftQuotient from UnivariateSkewPolynomialCategory
leftRank from AlgebraPackage
leftRankPolynomial from FramedNonAssociativeAlgebra
leftRankPolynomial from FramedNonAssociativeAlgebra&
leftRankPolynomial from GenericNonAssociativeAlgebra
leftRecip from FiniteRankNonAssociativeAlgebra
leftRecip from MonadWithUnit
leftRegularRepresentation from FiniteRankNonAssociativeAlgebra
leftRegularRepresentation from FramedNonAssociativeAlgebra
leftRemainder from NonCommutativeOperatorDivision
leftRemainder from UnivariateSkewPolynomialCategory
leftScalarTimes! from StorageEfficientMatrixOperations
leftTrace from FiniteRankNonAssociativeAlgebra
leftTraceMatrix from FiniteRankNonAssociativeAlgebra
leftTraceMatrix from FramedNonAssociativeAlgebra
leftTraceMatrix from FramedNonAssociativeAlgebra&
leftTrim from StringAggregate
leftUnit from FiniteRankNonAssociativeAlgebra
leftUnits from FiniteRankNonAssociativeAlgebra
leftUnits from GenericNonAssociativeAlgebra
leftZero from Equation
legendre from IntegerNumberTheoryFunctions
legendre from PolynomialNumberTheoryFunctions
legendreP from OrthogonalPolynomialFunctions
length from GaloisGroupFactorizationUtilities
length from IntegerNumberSystem
length from LyndonWord
length from Magma
length from OrderedFreeMonoid
length from PoincareBirkhoffWittLyndonBasis
length from QueueAggregate
length from VectorCategory
lepol from GroebnerInternalPackage
less? from Aggregate
less? from UserDefinedPartialOrdering
level from SubSpace
leviCivitaSymbol from CartesianTensor
lex from TableauxBumpers
lexGroebner from PolyGroebner
lexTriangular from LexTriangularPackage
lexico from LyndonWord
lexico from Magma
lexico from OrderedFreeMonoid
lfextendedint from ElementaryIntegration
lfextlimint from ElementaryIntegration
lfinfieldint from ElementaryIntegration
lfintegrate from ElementaryIntegration
lflimitedint from ElementaryIntegration
lfunc from HallBasis
lhs from Equation
lhs from RewriteRule
lhs from SuchThat
li from LiouvillianFunction
li from LiouvillianFunctionCategory
library from Library
lieAdmissible? from FiniteRankNonAssociativeAlgebra
lieAdmissible? from FiniteRankNonAssociativeAlgebra&
lieAlgebra? from FiniteRankNonAssociativeAlgebra
lieAlgebra? from FiniteRankNonAssociativeAlgebra&
lift from GenusZeroIntegration
lift from ModMonic
lift from MonogenicAlgebra
lift from MultivariateSquareFree
lift from ResidueRing
lifting from MultivariateLifting
lifting1 from MultivariateLifting
light from Palette
lighting from ThreeDimensionalViewport
limit from PowerSeriesLimitPackage
limit from RationalFunctionLimitPackage
limitPlus from ExponentialExpansion
limitPlus from UnivariatePuiseuxSeriesWithExponentialSingularity
limitedIntegrate from RationalFunctionIntegration
limitedint from RationalIntegration
linGenPos from LinGroebnerPackage
linSolve from LinearSystemPolynomialPackage
lineColorDefault from ViewDefaultsPackage
linear from PolynomialSolveByFormulas
linear? from PolynomialSetUtilitiesPackage
linear? from e04AgentsPackage
linearAssociatedExp from FiniteAlgebraicExtensionField
linearAssociatedLog from FiniteAlgebraicExtensionField
linearAssociatedOrder from FiniteAlgebraicExtensionField
linearDependence from LinearDependence
linearDependenceOverZ from IntegerLinearDependence
linearMatrix from e04AgentsPackage
linearPart from e04AgentsPackage
linearPolynomials from PolynomialSetUtilitiesPackage
linearlyDependent? from LinearDependence
linearlyDependentOverZ? from IntegerLinearDependence
linears from ModularDistinctDegreeFactorizer
linkToFortran from FortranPackage
lintgcd from HeuGcd
list from ListAggregate
list from Symbol
list? from SExpressionCategory
listBranches from PlottablePlaneCurveCategory
listBranches from PlottableSpaceCurveCategory
listConjugateBases from ChineseRemainderToolsForIntegralBases
listLoops from TubePlot
listOfLists from MatrixCategory
listOfLists from RectangularMatrixCategory
listOfLists from Tableau
listOfMonoms from ListMonoidOps
listRepresentation from Permutation
listYoungTableaus from SymmetricGroupCombinatoricFunctions
listexp from NPCoef
lists from PatternMatchListResult
lllip from ThreeSpaceCategory
lllp from ThreeSpaceCategory
llprop from ThreeSpaceCategory
lo from SegmentCategory
localAbs from FunctionSpaceToExponentialExpansion
localAbs from FunctionSpaceToUnivariatePowerSeries
localIntegralBasis from FunctionFieldIntegralBasis
localIntegralBasis from NumberFieldIntegralBasis
localIntegralBasis from PAdicWildFunctionFieldIntegralBasis
localIntegralBasis from WildFunctionFieldIntegralBasis
localReal? from ElementaryFunction
localUnquote from ApplyRules
log from ElementaryFunction
log from ElementaryFunctionCategory
log from ElementaryFunctionsUnivariateLaurentSeries
log from ElementaryFunctionsUnivariatePuiseuxSeries
log from FactoredFunctions
log from FortranExpression
log from LieExponentials
log from StreamTranscendentalFunctions
log from StreamTranscendentalFunctionsNonCommutative
log from XExponentialPackage
log from XPBWPolynomial
log10 from DoubleFloat
log10 from Float
log10 from FortranExpression
log2 from DoubleFloat
log2 from Float
logGamma from DoubleFloatSpecialFunctions
logIfCan from PartialTranscendentalFunctions
logical? from FortranScalarType
logpart from IntegrationResult
lookup from Finite
lookup from InnerNormalBasisFieldFunctions
loopPoints from TubePlotTools
low from SegmentCategory
lowerCase from CharacterClass
lowerCase from StringAggregate
lowerCase! from StringAggregate
lowerPolynomial from FactoringUtilities
lp from ThreeSpaceCategory
lprop from ThreeSpaceCategory
lquo from FreeLieAlgebra
lquo from FreeMonoid
lquo from OrderedFreeMonoid
lquo from XFreeAlgebra
lyndon from LyndonWord
lyndon? from LyndonWord
lyndonIfCan from LyndonWord

magnitude from VectorCategory
mainCharacterization from RealClosure
mainCoefficients from RecursivePolynomialCategory
mainContent from RecursivePolynomialCategory
mainDefiningPolynomial from RealClosedField
mainForm from RealClosedField
mainKernel from ExpressionSpace
mainMonomial from RecursivePolynomialCategory
mainMonomials from RecursivePolynomialCategory
mainPrimitivePart from RecursivePolynomialCategory
mainSquareFreePart from RecursivePolynomialCategory
mainValue from RealClosedField
mainVariable from PolynomialCategory
mainVariable from PolynomialCategoryQuotientFunctions
mainVariable from RationalFunction
mainVariable? from PolynomialSetCategory
mainVariables from PolynomialSetCategory
makeCos from FourierSeries
makeCrit from GroebnerInternalPackage
makeEq from InnerNumericFloatSolvePackage
makeFR from GaloisGroupFactorizer
makeFloatFunction from MakeFloatCompiledFunction
makeGraphImage from GraphImage
makeMulti from ListMonoidOps
makeObject from TopLevelDrawFunctions
makeObject from TopLevelDrawFunctionsForCompiledFunctions
makeRecord from MakeRecord
makeResult from PatternMatchListResult
makeSUP from UnivariatePolynomialCategory
makeSeries from InnerSparseUnivariatePowerSeries
makeSin from FourierSeries
makeSketch from PlaneAlgebraicCurvePlot
makeTerm from ListMonoidOps
makeUnit from ListMonoidOps
makeVariable from DifferentialPolynomialCategory
makeVariable from DifferentialVariableCategory
makeViewport2D from TwoDimensionalViewport
makeViewport3D from ThreeDimensionalViewport
makeYoungTableau from SymmetricGroupCombinatoricFunctions
makeop from ModuleOperator
makeop from Operator
makeprod from Product
makingStats? from TabulatedComputationPackage
mantissa from FloatingPointSystem
mantissa from MachineFloat
map from AbelianMonoidRing
map from AntiSymm
map from CartesianTensorFunctions2
map from ComplexFunctions2
map from DeRhamComplex
map from DirectProductFunctions2
map from Equation
map from EquationFunctions2
map from ExpertSystemToolsPackage2
map from ExpressionFunctions2
map from ExpressionSpace
map from ExpressionSpaceFunctions1
map from ExpressionSpaceFunctions2
map from FactoredFunctions2
map from FiniteDivisorFunctions2
map from FiniteLinearAggregateFunctions2
map from FiniteSetAggregateFunctions2
map from FractionFunctions2
map from FractionalIdealFunctions2
map from FramedNonAssociativeAlgebraFunctions2
map from FreeModuleCat
map from FullyEvalableOver
map from FunctionFieldCategoryFunctions2
map from FunctionSpaceFunctions2
map from HomogeneousAggregate
map from IndexedDirectProductCategory
map from InfiniteTuple
map from InfiniteTupleFunctions2
map from InfiniteTupleFunctions3
map from IntegrationResultFunctions2
map from LinearAggregate
map from ListFunctions2
map from ListFunctions3
map from MPolyCatFunctions2
map from MPolyCatFunctions3
map from MatrixCategoryFunctions2
map from MonoidRing
map from MonoidRingFunctions2
map from MultipleMap
map from NewSparseUnivariatePolynomialFunctions2
map from OctonionCategoryFunctions2
map from OnePointCompletionFunctions2
map from OrderedCompletionFunctions2
map from ParametricPlaneCurveFunctions2
map from ParametricSpaceCurveFunctions2
map from ParametricSurfaceFunctions2
map from PatternFunctions2
map from PatternMatchResultFunctions2
map from PointFunctions2
map from PolynomialCategoryLifting
map from PolynomialFunctions2
map from PushVariables
map from QuaternionCategoryFunctions2
map from QuotientFieldCategoryFunctions2
map from RectangularMatrixCategory
map from RectangularMatrixCategoryFunctions2
map from SegmentBindingFunctions2
map from SegmentExpansionCategory
map from SegmentFunctions2
map from SparseUnivariatePolynomialFunctions2
map from StreamFunctions2
map from StreamFunctions3
map from TableAggregate
map from UnivariateLaurentSeriesFunctions2
map from UnivariatePolynomialCategoryFunctions2
map from UnivariatePolynomialFunctions2
map from UnivariatePuiseuxSeriesFunctions2
map from UnivariateTaylorSeriesFunctions2
map from UniversalSegmentFunctions2
map from VectorFunctions2
map from XFreeAlgebra
map from XPolynomialRing
map! from HomogeneousAggregate
mapBivariate from IntegralBasisPolynomialTools
mapCoef from FreeAbelianMonoidCategory
mapExpon from FreeGroup
mapExpon from FreeMonoid
mapExpon from ListMonoidOps
mapExponents from FiniteAbelianMonoidRing
mapGen from FreeAbelianMonoidCategory
mapGen from FreeGroup
mapGen from FreeMonoid
mapGen from ListMonoidOps
mapMatrixIfCan from IntegralBasisPolynomialTools
mapSolve from PolynomialSolveByFormulas
mapUnivariate from IntegralBasisPolynomialTools
mapUnivariateIfCan from IntegralBasisPolynomialTools
mapdiv from StreamTaylorSeriesOperations
mapmult from StreamTaylorSeriesOperations
mask from IntegerNumberSystem
mat from ExpertSystemToolsPackage
match from ListToMap
match from StringAggregate
match? from StringAggregate
mathieu11 from PermutationGroupExamples
mathieu12 from PermutationGroupExamples
mathieu22 from PermutationGroupExamples
mathieu23 from PermutationGroupExamples
mathieu24 from PermutationGroupExamples
matrix from MatrixCategory
matrix from OutputForm
matrix from QuadraticForm
matrix from RectangularMatrixCategory
matrixConcat3D from ThreeDimensionalMatrix
matrixDimensions from ThreeDimensionalMatrix
matrixGcd from IntegralBasisTools
max from FiniteSetAggregate
max from FloatingPointSystem
max from OrderedSet
max from PriorityQueueAggregate
max from SingleInteger
maxColIndex from RectangularMatrixCategory
maxIndex from IndexedAggregate
maxPoints from GraphicsDefaults
maxPoints from Plot
maxPoints3D from Plot3D
maxRowIndex from RectangularMatrixCategory
maxdeg from XPolynomialRing
maxdeg from XPolynomialsCat
maximumExponent from MachineFloat
maxint from MachineInteger
maxrank from ParametricLinearEquations
maxrow from TableauxBumpers
mdeg from RecursivePolynomialCategory
measure from AnnaNumericalIntegrationPackage
measure from AnnaNumericalOptimizationPackage
measure from AnnaOrdinaryDifferentialEquationPackage
measure from AnnaPartialDifferentialEquationPackage
measure from NumericalIntegrationCategory
measure from NumericalOptimizationCategory
measure from OrdinaryDifferentialEquationsSolverCategory
measure from PartialDifferentialEquationsSolverCategory
measure2Result from ExpertSystemToolsPackage
meatAxe from RepresentationPackage2
medialSet from WuWenTsunTriangularSet
member? from HomogeneousAggregate
member? from PermutationGroup
member? from SetOfMIntegersInOneToN
members from HomogeneousAggregate
members from Multiset
merge from FiniteLinearAggregate
merge from PriorityQueueAggregate
merge from SubSpace
merge from ThreeSpaceCategory
merge! from ExtensibleLinearAggregate
merge! from PriorityQueueAggregate
mergeDifference from MergeThing
mergeFactors from FactoredFunctionUtilities
mesh from ThreeSpaceCategory
mesh? from ThreeSpaceCategory
meshFun2Var from MeshCreationRoutinesForThreeDimensions
meshPar1Var from MeshCreationRoutinesForThreeDimensions
meshPar2Var from MeshCreationRoutinesForThreeDimensions
message from OutputForm
messagePrint from OutputForm
middle from RightOpenIntervalRootCharacterization
midpoint from RealZeroPackage
midpoints from RealZeroPackage
mightHaveRoots from RightOpenIntervalRootCharacterization
min from FiniteSetAggregate
min from FloatingPointSystem
min from OrderedMultisetAggregate
min from OrderedSet
min from SingleInteger
minColIndex from RectangularMatrixCategory
minGbasis from GroebnerInternalPackage
minIndex from IndexedAggregate
minPoints from GraphicsDefaults
minPoints from Plot
minPoints3D from Plot3D
minPol from LinGroebnerPackage
minPoly from AlgebraicFunction
minPoly from Ring
minRowIndex from RectangularMatrixCategory
mindeg from XFreeAlgebra
mindeg from XPolynomialRing
mindegTerm from XFreeAlgebra
minimalPolynomial from FiniteAlgebraicExtensionField
minimalPolynomial from FiniteRankAlgebra
minimalPolynomial from InnerNormalBasisFieldFunctions
minimize from FractionalIdeal
minimumDegree from FiniteAbelianMonoidRing
minimumDegree from MonogenicLinearOperator
minimumDegree from PolynomialCategory
minimumDegree from UnivariateSkewPolynomialCategory
minimumExponent from MachineFloat
minordet from MatrixCategory
minordet from MatrixLinearAlgebraFunctions
minordet from SquareMatrixCategory
minrank from ParametricLinearEquations
minset from ParametricLinearEquations
minus! from StorageEfficientMatrixOperations
minusInfinity from Infinity
minusInfinity from OrderedCompletion
mirror from FreeLieAlgebra
mirror from LieExponentials
mirror from Magma
mirror from OrderedFreeMonoid
mirror from XFreeAlgebra
mix from PointsOfFiniteOrderTools
mkAnswer from IntegrationResult
mkIntegral from ChangeOfVariable
mkPrim from IntegrationTools
mkcomm from Commutator
modTree from CRApackage
modifyPoint from SubSpace
modifyPointData from ThreeDimensionalViewport
modifyPointData from ThreeSpaceCategory
modularFactor from GaloisGroupFactorizer
modularGcd from InnerModularGcd
modularGcdPrimitive from InnerModularGcd
module from FramedModule
moduleSum from IntegralBasisTools
moduloP from PAdicIntegerCategory
modulus from EuclideanModularRing
modulus from ModMonic
modulus from ModularField
modulus from ModularRing
modulus from PAdicIntegerCategory
moebius from MoebiusTransform
moebiusMu from IntegerNumberTheoryFunctions
monic? from GaloisGroupPolynomialUtilities
monic? from RecursivePolynomialCategory
monicCompleteDecompose from UnivariatePolynomialDecompositionPackage
monicDecomposeIfCan from UnivariatePolynomialDecompositionPackage
monicDivide from PolynomialCategory
monicDivide from UnivariatePolynomialCategory
monicLeftDivide from UnivariateSkewPolynomialCategory
monicLeftDivide from UnivariateSkewPolynomialCategoryOps
monicModulo from NewSparseUnivariatePolynomial
monicModulo from RecursivePolynomialCategory
monicRightDivide from UnivariateSkewPolynomialCategory
monicRightDivide from UnivariateSkewPolynomialCategoryOps
monicRightFactorIfCan from UnivariatePolynomialDecompositionPackage
monom from FreeModuleCat
monom from StreamTaylorSeriesOperations
monom from XFreeAlgebra
monomRDE from TranscendentalRischDE
monomRDEsys from TranscendentalRischDESystem
monomial from AbelianMonoidRing
monomial from CliffordAlgebra
monomial from GeneralModulePolynomial
monomial from IndexedDirectProductCategory
monomial from LaurentPolynomial
monomial from MonogenicLinearOperator
monomial from MonoidRing
monomial from MultivariateTaylorSeriesCategory
monomial from PolynomialCategory
monomial from PowerSeriesCategory
monomial from UnivariateSkewPolynomialCategory
monomial? from AbelianMonoidRing
monomial? from FreeModuleCat
monomial? from InnerSparseUnivariatePowerSeries
monomial? from LaurentPolynomial
monomial? from MonoidRing
monomial? from XFreeAlgebra
monomialIntPoly from TranscendentalIntegration
monomialIntegrate from TranscendentalIntegration
monomials from FreeModuleCat
monomials from MonoidRing
monomials from PolynomialCategory
more? from Aggregate
more? from UserDefinedPartialOrdering
moreAlgebraic? from QuasiComponentPackage
moreAlgebraic? from SquareFreeQuasiComponentPackage
morphism from Automorphism
move from ThreeDimensionalViewport
move from TwoDimensionalViewport
movedPoints from Permutation
movedPoints from PermutationGroup
mpsode from UnivariateTaylorSeriesODESolver
mr from TableauxBumpers
mulmod from IntegerNumberSystem
multMonom from GeneralModulePolynomial
multiEuclidean from EuclideanDomain
multiEuclideanTree from CRApackage
multiServ from AxiomServer
multinomial from IntegerCombinatoricFunctions
multiple from FunctionSpaceAssertions
multiple from PatternMatchAssertions
multiple? from Pattern
multiplyCoefficients from InnerSparseUnivariatePowerSeries
multiplyCoefficients from UnivariateLaurentSeriesCategory
multiplyCoefficients from UnivariateTaylorSeriesCategory
multiplyExponents from UnivariatePolynomialCategory
multiplyExponents from UnivariatePowerSeriesCategory
multiplyExponents from UnivariatePuiseuxSeriesCategory
multisect from StreamTaylorSeriesOperations
multisect from UnivariateTaylorSeries
multiset from Multiset
multivariate from GenusZeroIntegration
multivariate from PolynomialCategory
multivariate from PolynomialCategoryQuotientFunctions
multivariate from RationalFunction
musserTrials from GaloisGroupFactorizer
mvar from PolynomialSetCategory
mvar from RecursivePolynomialCategory
myDegree from MultivariateSquareFree

name from BasicOperator
name from FileCategory
name from FileNameCategory
name from FunctionCalled
name from Kernel
name from RuleCalled
name from Symbol
nand from BitAggregate
nand from Boolean
nary? from BasicOperator
ncols from RectangularMatrixCategory
negative? from IntervalCategory
negative? from OrderedRing
negative? from RealRootCharacterizationCategory
neglist from ExpertSystemToolsPackage1
new from FileNameCategory
new from LinearAggregate
new from PatternMatchListResult
new from PatternMatchResult
new from ScriptFormulaFormat
new from SubSpace
new from SubSpaceComponentProperty
new from Symbol
new from TexFormat
newLine from DisplayPackage
newReduc from FunctionSpaceReduce
newSubProgram from TheSymbolTable
newTypeLists from SymbolTable
newton from NewtonInterpolation
next from DoublyLinkedAggregate
nextColeman from SymmetricGroupCombinatoricFunctions
nextIrreduciblePoly from FiniteFieldPolynomialPackage
nextItem from StepThrough
nextLatticePermutation from SymmetricGroupCombinatoricFunctions
nextNormalPoly from FiniteFieldPolynomialPackage
nextNormalPrimitivePoly from FiniteFieldPolynomialPackage
nextPartition from SymmetricGroupCombinatoricFunctions
nextPrime from IntegerPrimesPackage
nextPrimitiveNormalPoly from FiniteFieldPolynomialPackage
nextPrimitivePoly from FiniteFieldPolynomialPackage
nextSublist from ParametricLinearEquations
nextSubsetGray from GrayCode
nextsousResultant2 from PseudoRemainderSequence
nextsubResultant2 from RecursivePolynomialCategory
nil from List
nlde from StreamTaylorSeriesOperations
noKaratsuba from UnivariatePolynomialMultiplicationPackage
noLinearFactor? from BrillhartTests
node from BinaryTreeCategory
node? from RecursiveAggregate
nodeOf? from SplittingTree
nodes from RecursiveAggregate
nonLinearPart from e04AgentsPackage
nonQsign from ToolsForSign
nonSingularModel from FunctionFieldCategory
nonSingularModel from FunctionFieldCategory&
noncommutativeJordanAlgebra? from FiniteRankNonAssociativeAlgebra
noncommutativeJordanAlgebra? from FiniteRankNonAssociativeAlgebra&
nor from BitAggregate
nor from Boolean
norm from AlgebraicNumber
norm from ComplexCategory
norm from ComplexRootFindingPackage
norm from FiniteAlgebraicExtensionField
norm from FiniteRankAlgebra
norm from FractionalIdeal
norm from FramedModule
norm from GaloisGroupFactorizationUtilities
norm from InnerAlgebraicNumber
norm from InnerNormalBasisFieldFunctions
norm from NormInMonogenicAlgebra
norm from OctonionCategory
norm from QuaternionCategory
norm from RealNumberSystem
normDeriv2 from MultivariateSquareFree
normFactors from NormRetractPackage
normInvertible? from NormalizationPackage
normal from RandomFloatDistributions
normal01 from RandomFloatDistributions
normal? from FiniteAlgebraicExtensionField
normal? from FiniteFieldPolynomialPackage
normal? from InnerNormalBasisFieldFunctions
normalDenom from MonomialExtensionTools
normalDeriv from FactoringUtilities
normalElement from FiniteAlgebraicExtensionField
normalElement from InnerNormalBasisFieldFunctions
normalForm from GroebnerPackage
normalForm from PseudoLinearNormalForm
normalise from RadicalEigenPackage
normalize from ElementaryFunctionStructurePackage
normalize from Float
normalize from NormalizationPackage
normalizeAtInfinity from FunctionFieldCategory
normalizeIfCan from LazardSetSolvingPackage
normalized? from RecursivePolynomialCategory
normalized? from TriangularSetCategory
normalizedAssociate from NormalizationPackage
normalizedDivide from MatrixLinearAlgebraFunctions
normalizedDivide from ModularHermitianRowReduction
not from BitAggregate
not from Boolean
not from OutputForm
not from SingleInteger
notelem from IntegrationResult
npcoef from NPCoef
nrows from RectangularMatrixCategory
nsqfree from MultivariateSquareFree
nthCoef from FreeAbelianMonoidCategory
nthExpon from FreeGroup
nthExpon from FreeMonoid
nthExpon from ListMonoidOps
nthExpon from OrderedFreeMonoid
nthFactor from FreeAbelianMonoidCategory
nthFactor from FreeGroup
nthFactor from FreeMonoid
nthFactor from ListMonoidOps
nthFactor from OrderedFreeMonoid
nthFractionalTerm from PartialFraction
nthRoot from FactoredFunctions
nthRoot from RadicalCategory
nthRootIfCan from PartialTranscendentalFunctions
nthr from PolynomialRoots
null from List
null? from SExpressionCategory
nullSpace from InnerMatrixLinearAlgebraFunctions
nullSpace from InnerMatrixQuotientFieldFunctions
nullSpace from MatrixCategory
nullSpace from MatrixLinearAlgebraFunctions
nullSpace from RectangularMatrixCategory
nullary from MappingPackage1
nullary? from BasicOperator
nullity from InnerMatrixLinearAlgebraFunctions
nullity from MatrixCategory
nullity from MatrixLinearAlgebraFunctions
nullity from RectangularMatrixCategory
numFunEvals from Plot
numFunEvals3D from Plot3D
number? from Expression
numberOfChildren from SubSpace
numberOfComponents from FunctionFieldCategory&
numberOfComponents from ThreeSpaceCategory
numberOfComposites from ThreeSpaceCategory
numberOfComputedEntries from LazyStreamAggregate
numberOfCycles from Permutation
numberOfDivisors from IntegerNumberTheoryFunctions
numberOfFactors from GaloisGroupFactorizer
numberOfFractionalTerms from PartialFraction
numberOfHues from Color
numberOfImproperPartitions from SymmetricGroupCombinatoricFunctions
numberOfIrreduciblePoly from FiniteFieldPolynomialPackage
numberOfMonomials from FiniteAbelianMonoidRing
numberOfMonomials from FreeModuleCat
numberOfMonomials from MonoidRing
numberOfNormalPoly from FiniteFieldPolynomialPackage
numberOfOperations from ExpertSystemToolsPackage
numberOfPrimitivePoly from FiniteFieldPolynomialPackage
numberOfVariables from RegularSetDecompositionPackage
numberOfVariables from SquareFreeRegularSetDecompositionPackage
numer from AlgebraicNumber
numer from FractionalIdeal
numer from FunctionSpace
numer from InnerAlgebraicNumber
numer from LocalAlgebra
numer from Localize
numer from QuotientFieldCategory
numerator from FunctionSpace
numerator from QuotientFieldCategory
numerators from ContinuedFraction
numeric from Numeric
numericIfCan from Numeric
numericalIntegration from NumericalIntegrationCategory
numericalOptimization from NumericalOptimizationCategory

obj from Any
objectOf from Any
objects from ThreeSpaceCategory
oblateSpheroidal from CoordinateSystems
ocf2ocdf from ExpertSystemToolsPackage
octon from Octonion
octon from OctonionCategory
odd? from IntegerNumberSystem
odd? from Permutation
odd? from RetractableTo
oddInfiniteProduct from InfiniteProductCharacteristicZero
oddInfiniteProduct from InfiniteProductFiniteField
oddInfiniteProduct from InfiniteProductPrimeField
oddInfiniteProduct from StreamInfiniteProduct
oddintegers from StreamTaylorSeriesOperations
oddlambert from StreamTaylorSeriesOperations
oddlambert from UnivariateTaylorSeries
ode from UnivariateTaylorSeriesODESolver
ode1 from UnivariateTaylorSeriesODESolver
ode2 from UnivariateTaylorSeriesODESolver
omError from OpenMathError
one? from MonadWithUnit
one? from Monoid
one? from PolynomialIdeals
op from OppositeMonogenicLinearOperator
open from FileCategory
open? from TubePlot
operation from FortranCode
operator from AlgebraicFunction
operator from BasicOperator
operator from CombinatorialFunction
operator from CommonOperators
operator from ElementaryFunction
operator from ExpressionSpace
operator from ExpressionSpace&
operator from FunctionSpace&
operator from FunctionalSpecialFunction
operator from Kernel
operator from LiouvillianFunction
operators from ExpressionSpace
opeval from ModuleOperator
opeval from Operator
optAttributes from e04AgentsPackage
optimize from AnnaNumericalOptimizationPackage
option from DrawOption
option from DrawOptionFunctions1
option? from DrawOption
optional from FunctionSpaceAssertions
optional from PatternMatchAssertions
optional? from Pattern
options from ThreeDimensionalViewport
options from TwoDimensionalViewport
optpair from Pattern
or from BitAggregate
or from Boolean
or from OutputForm
orbit from PermutationCategory
orbit from PermutationGroup
orbits from PermutationGroup
order from DifferentialPolynomialCategory
order from DifferentialVariableCategory
order from FieldOfPrimeCharacteristic
order from FindOrderFinite
order from FiniteFieldCategory
order from FloatingPointSystem
order from InnerTaylorSeries
order from LaurentPolynomial
order from MultivariateTaylorSeriesCategory
order from PAdicIntegerCategory
order from Permutation
order from PermutationGroup
order from PointsOfFiniteOrder
order from PointsOfFiniteOrderRational
order from ReducedDivisor
order from UnivariatePolynomialCategory
order from UnivariatePowerSeriesCategory
orthonormalBasis from RadicalEigenPackage
outerProduct from VectorCategory
outlineRender from ThreeDimensionalViewport
output from OutputPackage
output from Stream
outputArgs from NormalizationPackage
outputAsFortran from Asp12
outputAsFortran from Asp29
outputAsFortran from Asp33
outputAsFortran from FortranPackage
outputAsFortran from FortranProgramCategory
outputAsFortran from SpecialOutputPackage
outputAsScript from SpecialOutputPackage
outputAsTex from SpecialOutputPackage
outputFixed from Float
outputFloating from Float
outputForm from ListMonoidOps
outputForm from OutputForm
outputForm from SparseUnivariatePolynomial
outputForm from SparseUnivariateSkewPolynomial
outputGeneral from Float
outputList from OutputPackage
outputMeasure from ExpertSystemToolsPackage
outputSpacing from Float
over from OutputForm
overbar from OutputForm
overlabel from OutputForm
overlap from FreeMonoid
overlap from OrderedFreeMonoid
overset? from ParametricLinearEquations

pToDmp from PolToPol
pToHdmp from PolToPol
pack! from KeyedAccessFile
pack! from Library
packageCall from InputFormFunctions1
pade from PadeApproximantPackage
pade from PadeApproximants
padecf from PadeApproximants
padicFraction from PartialFraction
padicallyExpand from PartialFraction
pair? from SExpressionCategory
palgLODE from PureAlgebraicIntegration
palgLODE0 from GenusZeroIntegration
palgRDE from PureAlgebraicIntegration
palgRDE0 from GenusZeroIntegration
palgextint from PureAlgebraicIntegration
palgextint0 from GenusZeroIntegration
palginfieldint from AlgebraicIntegrate
palgint from PureAlgebraicIntegration
palgint0 from GenusZeroIntegration
palgintegrate from AlgebraicIntegrate
palglimint from PureAlgebraicIntegration
palglimint0 from GenusZeroIntegration
parabolic from CoordinateSystems
parabolicCylindrical from CoordinateSystems
paraboloidal from CoordinateSystems
parametersOf from SymbolTable
parametric? from Plot
paren from ExpressionSpace
paren from OutputForm
parent from SubSpace
partialDenominators from ContinuedFraction
partialFraction from PartialFraction
partialFraction from PartialFractionPackage
partialNumerators from ContinuedFraction
partialQuotients from ContinuedFraction
particularSolution from LinearSystemMatrixPackage
particularSolution from LinearSystemMatrixPackage1
particularSolution from ODETools
particularSolution from PolynomialSolveByFormulas
partition from IntegerCombinatoricFunctions
partition from Partition
partitions from PartitionsAndPermutations
parts from HomogeneousAggregate
pascalTriangle from GaloisGroupUtilities
pastel from Palette
pattern from RewriteRule
patternMatch from ComplexPatternMatch
patternMatch from PatternMatchFunctionSpace
patternMatch from PatternMatchIntegerNumberSystem
patternMatch from PatternMatchKernel
patternMatch from PatternMatchListAggregate
patternMatch from PatternMatchPolynomialCategory
patternMatch from PatternMatchPushDown
patternMatch from PatternMatchQuotientFieldCategory
patternMatch from PatternMatchSymbol
patternMatch from PatternMatchTools
patternMatch from PatternMatchable
patternMatchTimes from PatternMatchTools
patternVariable from Pattern
pdct from Partition
pdf2df from ExpertSystemToolsPackage
pdf2ef from ExpertSystemToolsPackage
perfectNthPower? from IntegerRoots
perfectNthRoot from IntegerRoots
perfectSqrt from IntegerRoots
perfectSquare? from IntegerRoots
permanent from Permanent
permutation from CombinatorialFunction
permutation from CombinatorialFunctionCategory
permutation from IntegerCombinatoricFunctions
permutationGroup from PermutationGroup
permutationRepresentation from RepresentationPackage1
permutations from PartitionsAndPermutations
perspective from ThreeDimensionalViewport
phiCoord from PointPackage
physicalLength from FlexibleArray
physicalLength! from FlexibleArray
pi from ElementaryFunction
pi from FortranExpression
pi from Pi
pi from TranscendentalFunctionCategory
pile from OutputForm
plenaryPower from NonAssociativeAlgebra
pleskenSplit from ComplexRootFindingPackage
plot from Plot3D
plot from PlotFunctions1
plotPolar from Plot
plotPolar from PlotFunctions1
plus from ListMonoidOps
plus from ThreeDimensionalMatrix
plus! from StorageEfficientMatrixOperations
plusInfinity from Infinity
plusInfinity from OrderedCompletion
pmComplexintegrate from PatternMatchIntegration
pmintegrate from PatternMatchIntegration
po from OppositeMonogenicLinearOperator
point from GraphImage
point from PointCategory
point from ThreeSpaceCategory
point from TubePlotTools
point? from ThreeSpaceCategory
pointColor from DrawOption
pointColorDefault from ViewDefaultsPackage
pointColorPalette from DrawOptionFunctions0
pointData from SubSpace
pointLists from GraphImage
pointPlot from Plot
pointPlot from Plot3D
pointSizeDefault from ViewDefaultsPackage
points from TwoDimensionalViewport
poisson from RandomIntegerDistributions
pol from InnerNormalBasisFieldFunctions
polCase from LeadingCoefDetermination
polar from CoordinateSystems
polarCoordinates from ComplexCategory
pole? from InnerTaylorSeries
pole? from PowerSeriesCategory
polyPart from FullPartialFractionExpansion
polyRDE from TranscendentalRischDE
polyRicDE from PrimitiveRatRicDE
polyRicDE from RationalRicDE
polygamma from DoubleFloatSpecialFunctions
polygamma from FunctionalSpecialFunction
polygamma from SpecialFunctionCategory
polygon from ThreeSpaceCategory
polygon? from ThreeSpaceCategory
polynomial from MultivariateTaylorSeriesCategory
polynomial from UnivariateTaylorSeriesCategory
polynomialZeros from ExpertSystemContinuityPackage
polyred from PointsOfFiniteOrderTools
pomopo! from FiniteAbelianMonoidRing
pop! from StackAggregate
popFortranOutputStack from FortranOutputStackPackage
position from BinaryFile
position from CachableSet
position from FiniteLinearAggregate
position from StringAggregate
position! from BinaryFile
positive? from IntervalCategory
positive? from OrderedRing
positive? from RealRootCharacterizationCategory
positiveRemainder from IntegerNumberSystem
positiveSolve from ZeroDimensionalSolvePackage
possiblyInfinite? from StreamAggregate
possiblyNewVariety? from PolynomialSetUtilitiesPackage
postfix from OutputForm
pow from ModMonic
power from StreamTaylorSeriesOperations
power! from StorageEfficientMatrixOperations
powerAssociative? from FiniteRankNonAssociativeAlgebra
powerSum from CycleIndicators
powern from StreamTaylorSeriesOperations
powers from Partition
powmod from IntegerNumberSystem
pquo from RecursivePolynomialCategory
pr2dmp from ParametricLinearEquations
precision from FloatingPointSystem
precision from MachineFloat
predicate from PatternFunctions1
predicates from Pattern
prefix from OutputForm
prefix? from StringAggregate
prefixRagits from RadixExpansion
prem from RecursivePolynomialCategory
prepareDecompose from QuasiComponentPackage
prepareDecompose from SquareFreeQuasiComponentPackage
prepareSubResAlgo from RegularTriangularSetGcdPackage
preprocess from RegularTriangularSet
preprocess from SquareFreeRegularTriangularSet
presub from OutputForm
presuper from OutputForm
prevPrime from IntegerPrimesPackage
previous from DoublyLinkedAggregate
primPartElseUnitCanonical from RecursivePolynomialCategory
primPartElseUnitCanonical! from RecursivePolynomialCategory
primaryDecomp from IdealDecompositionPackage
prime from OutputForm
prime? from GaussianFactorizationPackage
prime? from IdealDecompositionPackage
prime? from IntegerPrimesPackage
prime? from UniqueFactorizationDomain
primeFrobenius from FieldOfPrimeCharacteristic
primes from IntegerPrimesPackage
primextendedint from TranscendentalIntegration
primextintfrac from TranscendentalIntegration
primintegrate from TranscendentalIntegration
primintfldpoly from TranscendentalIntegration
primitive? from FiniteFieldCategory
primitive? from FiniteFieldPolynomialPackage
primitiveElement from FiniteFieldCategory
primitiveElement from FunctionSpacePrimitiveElement
primitiveElement from PrimitiveElement
primitiveMonomials from PolynomialCategory
primitivePart from FiniteAbelianMonoidRing
primitivePart from FunctionFieldCategory
primitivePart from PolynomialCategory
primitivePart from SubResultantPackage
primitivePart from UnivariateSkewPolynomialCategory
primitivePart! from RecursivePolynomialCategory
primlimintfrac from TranscendentalIntegration
primlimitedint from TranscendentalIntegration
prinb from GroebnerInternalPackage
principal? from FiniteDivisorCategory
principalIdeal from PrincipalIdealDomain
prindINFO from GroebnerInternalPackage
prinpolINFO from GroebnerInternalPackage
prinshINFO from GroebnerInternalPackage
print from OutputForm
print from PrintPackage
printCode from FortranCode
printHeader from TheSymbolTable
printInfo from RegularSetDecompositionPackage
printInfo from SquareFreeRegularSetDecompositionPackage
printInfo! from TabulatedComputationPackage
printStatement from FortranCode
printStats! from TabulatedComputationPackage
printTypes from SymbolTable
printTypes from TheSymbolTable
printingInfo? from TabulatedComputationPackage
probablyZeroDim? from PolynomialSetUtilitiesPackage
problemPoints from ExpertSystemContinuityPackage
problemPoints from d01AgentsPackage
processTemplate from FortranTemplate
prod from OutputForm
product from CartesianTensor
product from CombinatorialFunction
product from CombinatorialOpsCategory
product from GradedAlgebra
product from XPBWPolynomial
prolateSpheroidal from CoordinateSystems
prologue from ScriptFormulaFormat
prologue from TexFormat
properties from BasicOperator
property from BasicOperator
pseudoDivide from PseudoRemainderSequence
pseudoDivide from RecursivePolynomialCategory
pseudoDivide from UnivariatePolynomialCategory
pseudoQuotient from UnivariatePolynomialCategory
pseudoRemainder from UnivariatePolynomialCategory
psolve from ParametricLinearEquations
ptFunc from MeshCreationRoutinesForThreeDimensions
puiseux from ExpressionToUnivariatePowerSeries
puiseux from GenerateUnivariatePowerSeries
puiseux from UnivariatePuiseuxSeriesConstructorCategory
pureLex from OrderingFunctions
purelyAlgebraic? from RegularTriangularSetCategory
purelyAlgebraicLeadingMonomial? from RegularTriangularSetCategory
purelyTranscendental? from RegularTriangularSetCategory
push! from StackAggregate
pushFortranOutputStack from FortranOutputStackPackage
pushdown from MPolyCatRationalFunctionFactorizer
pushdown from PushVariables
pushdterm from MPolyCatRationalFunctionFactorizer
pushucoef from MPolyCatRationalFunctionFactorizer
pushuconst from MPolyCatRationalFunctionFactorizer
pushup from MPolyCatRationalFunctionFactorizer
pushup from PushVariables
putColorInfo from GraphImage
putGraph from TwoDimensionalViewport

qPot from InnerNormalBasisFieldFunctions
qelt from EltableAggregate
qelt from RectangularMatrixCategory
qfactor from FunctionSpaceUnivariatePolynomialFactor
qinterval from IntervalCategory
qqq from WeierstrassPreparation
qroot from PolynomialRoots
qsetelt! from EltableAggregate
quadratic from PolynomialSolveByFormulas
quadratic? from e04AgentsPackage
quadraticForm from QuadraticForm
quadraticNorm from GaloisGroupFactorizationUtilities
quartic from PolynomialSolveByFormulas
quasiAlgebraicSet from QuasiAlgebraicSet
quasiComponent from TriangularSetCategory
quasiMonic? from RecursivePolynomialCategory
quasiMonicPolynomials from PolynomialSetUtilitiesPackage
quasiRegular from XFreeAlgebra
quasiRegular from XPolynomialRing
quasiRegular? from XFreeAlgebra
quasiRegular? from XPolynomialRing
quatern from QuaternionCategory
quickSort from FiniteLinearAggregateSort
quo from EuclideanDomain
quo from NonNegativeInteger
quo from OutputForm
quoByVar from UnivariateTaylorSeriesCategory
quote from OutputForm
quoted? from Pattern
quotedOperators from RewriteRule
quotient from PolynomialIdeals
quotientByP from PAdicIntegerCategory

rCoord from PointPackage
radPoly from ChangeOfVariable
radical from IdealDecompositionPackage
radicalEigenvalues from RadicalEigenPackage
radicalEigenvector from RadicalEigenPackage
radicalEigenvectors from RadicalEigenPackage
radicalOfLeftTraceForm from AlgebraPackage
radicalRoots from RadicalSolvePackage
radicalSimplify from QuasiAlgebraicSet2
radicalSolve from RadicalSolvePackage
radix from RadixUtilities
raisePolynomial from FactoringUtilities
ramified? from FunctionFieldCategory
ramifiedAtInfinity? from FunctionFieldCategory
ran from FactoringUtilities
randnum from RandomNumberSource
random from Finite
random from FiniteFieldPolynomialPackage
random from InnerNormalBasisFieldFunctions
random from Integer
random from IntegerNumberSystem
random from NonNegativeInteger
random from PermutationGroup
random from QuotientFieldCategory
randomLC from FractionalIdeal
randomR from GeneralPolynomialGcdPackage
randomR from PolynomialFactorizationByRecursion
randomR from PolynomialFactorizationByRecursionUnivariate
range from DrawOption
rangeIsFinite from d01AgentsPackage
rangePascalTriangle from GaloisGroupUtilities
ranges from DrawOption
ranges from DrawOptionFunctions0
ranges from GraphImage
rank from CartesianTensor
rank from ComplexCategory&
rank from FiniteRankAlgebra
rank from FiniteRankNonAssociativeAlgebra
rank from InnerMatrixLinearAlgebraFunctions
rank from LinearSystemMatrixPackage
rank from LinearSystemMatrixPackage1
rank from MatrixCategory
rank from MatrixLinearAlgebraFunctions
rank from RectangularMatrixCategory
rarrow from OutputForm
ratDenom from AlgebraicManipulations
ratDsolve from RationalLODE
ratPoly from AlgebraicManipulations
rational from ComplexCategory
rational from Factored
rational from IntegerNumberSystem
rational from OctonionCategory
rational from OnePointCompletion
rational from OrderedCompletion
rational from QuaternionCategory
rational from RationalRetractions
rational? from ComplexCategory
rational? from Factored
rational? from IntegerNumberSystem
rational? from OctonionCategory
rational? from OnePointCompletion
rational? from OrderedCompletion
rational? from QuaternionCategory
rational? from RationalRetractions
rationalApproximation from DoubleFloat
rationalApproximation from Float
rationalFunction from UnivariateLaurentSeriesCategory
rationalIfCan from ComplexCategory
rationalIfCan from Factored
rationalIfCan from IntegerNumberSystem
rationalIfCan from OctonionCategory
rationalIfCan from OnePointCompletion
rationalIfCan from OrderedCompletion
rationalIfCan from QuaternionCategory
rationalIfCan from RationalRetractions
rationalPoint? from FunctionFieldCategory&
rationalPoints from FunctionFieldCategory
rationalPoints from FunctionFieldCategory&
rationalPower from UnivariatePuiseuxSeriesConstructorCategory
ratpart from IntegrationResult
ravel from CartesianTensor
rdHack1 from RandomDistributions
rdregime from ParametricLinearEquations
read! from FileCategory
readIfCan! from BinaryFile
readIfCan! from File
readIfCan! from TextFile
readLine! from TextFile
readLineIfCan! from TextFile
readable? from FileNameCategory
real from ComplexCategory
real from ComplexTrigonometricManipulations
real from OctonionCategory
real from QuaternionCategory
real from TrigonometricManipulations
real? from ComplexTrigonometricManipulations
real? from FortranScalarType
real? from TrigonometricManipulations
realEigenvalues from NumericRealEigenPackage
realEigenvectors from NumericRealEigenPackage
realElementary from ElementaryFunctionStructurePackage
realRoots from FloatingRealPackage
realSolve from RealSolvePackage
realSolve from ZeroDimensionalSolvePackage
realZeros from RealZeroPackage
realZeros from RealZeroPackageQ
recip from CliffordAlgebra
recip from EuclideanModularRing
recip from FiniteRankNonAssociativeAlgebra
recip from ModularRing
recip from MoebiusTransform
recip from MonadWithUnit
recip from Monoid
recip from NormalizationPackage
recip from RealRootCharacterizationCategory
recip from StreamTaylorSeriesOperations
reciprocalPolynomial from ComplexRootFindingPackage
recolor from TopLevelDrawFunctionsForCompiledFunctions
recoverAfterFail from RoutinesTable
rectangularMatrix from RectangularMatrix
recur from MappingPackage1
recur from MappingPackageInternalHacks1
red from Color
redPo from GroebnerInternalPackage
redPol from GroebnerInternalPackage
redmat from ParametricLinearEquations
redpps from ParametricLinearEquations
reduce from AlgebraicNumber
reduce from Collection
reduce from DegreeReductionPackage
reduce from DirectProductFunctions2
reduce from EuclideanModularRing
reduce from Expression
reduce from FiniteDivisorCategory
reduce from FiniteLinearAggregateFunctions2
reduce from FiniteSetAggregateFunctions2
reduce from InnerAlgebraicNumber
reduce from ListFunctions2
reduce from MatrixCategoryFunctions2
reduce from ModMonic
reduce from ModularField
reduce from ModularRing
reduce from MonogenicAlgebra
reduce from RectangularMatrixCategoryFunctions2
reduce from ResidueRing
reduce from StreamFunctions2
reduce from TriangularSetCategory
reduce from VectorFunctions2
reduceBasisAtInfinity from FunctionFieldCategory
reduceByQuasiMonic from TriangularSetCategory
reduceLODE from ReduceLODE
reduced? from RecursivePolynomialCategory
reduced? from TriangularSetCategory
reducedContinuedFraction from ContinuedFraction
reducedDiscriminant from PAdicWildFunctionFieldIntegralBasis
reducedForm from ContinuedFraction
reducedQPowers from FiniteFieldPolynomialPackage
reducedSystem from LinearlyExplicitRingOver
reduction from GenExEuclid
reduction from GeneralHenselPackage
reduction from InnerModularGcd
reductum from AbelianMonoidRing
reductum from AntiSymm
reductum from DeRhamComplex
reductum from FreeModuleCat
reductum from GeneralModulePolynomial
reductum from IndexedDirectProductCategory
reductum from LaurentPolynomial
reductum from MonogenicLinearOperator
reductum from MonoidRing
reductum from RecursivePolynomialCategory
reductum from UnivariateSkewPolynomialCategory
reductum from XPolynomialRing
ref from Reference
refine from FactoredFunctionUtilities
refine from PlaneAlgebraicCurvePlot
refine from Plot
refine from Plot3D
refine from RealZeroPackage
refine from RealZeroPackageQ
refine from RightOpenIntervalRootCharacterization
regime from ParametricLinearEquations
region from TwoDimensionalViewport
regularRepresentation from FiniteRankAlgebra
regularRepresentation from FramedAlgebra
reindex from CartesianTensor
relationsIdeal from PolynomialIdeals
relativeApprox from RealClosure
relativeApprox from RealRootCharacterizationCategory
relativeApprox from RightOpenIntervalRootCharacterization
relerror from Float
rem from EuclideanDomain
rem from NonNegativeInteger
rem from OutputForm
remainder from PolynomialSetCategory
remove from Collection
remove from LazyStreamAggregate
remove from Multiset
remove from SplittingTree
remove! from DictionaryOperations
remove! from ExtensibleLinearAggregate
remove! from KeyedDictionary
remove! from Multiset
remove! from SplittingTree
removeConstantTerm from IntegrationTools
removeCosSq from TranscendentalManipulations
removeCoshSq from TranscendentalManipulations
removeDuplicates from Collection
removeDuplicates! from ExtensibleLinearAggregate
removeDuplicates! from MultiDictionary
removeIrreducibleRedundantFactors from PolynomialSetUtilitiesPackage
removeRedundantFactors from PolynomialSetUtilitiesPackage
removeRedundantFactorsInContents from PolynomialSetUtilitiesPackage
removeRedundantFactorsInPols from PolynomialSetUtilitiesPackage
removeRoughlyRedundantFactorsInContents from PolynomialSetUtilitiesPackage
removeRoughlyRedundantFactorsInPol from PolynomialSetUtilitiesPackage
removeRoughlyRedundantFactorsInPols from PolynomialSetUtilitiesPackage
removeSinSq from TranscendentalManipulations
removeSinhSq from TranscendentalManipulations
removeSquaresIfCan from PolynomialSetUtilitiesPackage
removeSuperfluousCases from QuasiComponentPackage
removeSuperfluousCases from SquareFreeQuasiComponentPackage
removeSuperfluousQuasiComponents from QuasiComponentPackage
removeSuperfluousQuasiComponents from SquareFreeQuasiComponentPackage
removeZero from TriangularSetCategory
removeZeroes from BalancedPAdicRational
removeZeroes from PAdicRational
removeZeroes from PAdicRationalConstructor
removeZeroes from UnivariateLaurentSeriesConstructorCategory
rename from RealClosedField
rename! from RealClosedField
reopen! from FileCategory
reorder from DistributedMultivariatePolynomial
reorder from GeneralDistributedMultivariatePolynomial
reorder from HomogeneousDistributedMultivariatePolynomial
repSq from InnerNormalBasisFieldFunctions
repeatUntilLoop from FortranCode
repeating from Stream
repeating? from Stream
replace from StringAggregate
replaceKthElement from SetOfMIntegersInOneToN
representationType from FiniteFieldCategory
represents from FiniteAlgebraicExtensionField
represents from FiniteRankAlgebra
represents from FiniteRankNonAssociativeAlgebra
represents from FramedAlgebra
represents from FramedNonAssociativeAlgebra
represents from FunctionFieldCategory
reseed from RandomNumberSource
reset from ThreeDimensionalViewport
reset from TwoDimensionalViewport
resetAttributeButtons from AttributeButtons
resetBadValues from Pattern
resetNew from Symbol
resetVariableOrder from UserDefinedVariableOrdering
reshape from CartesianTensorFunctions2
reshape from MPolyCatFunctions2
resize from ThreeDimensionalViewport
resize from TwoDimensionalViewport
rest from Magma
rest from OrderedFreeMonoid
rest from PoincareBirkhoffWittLyndonBasis
rest from TriangularSetCategory
rest from UnaryRecursiveAggregate
restorePrecision from NAGLinkSupportPackage
result from SplittingTree
resultant from PolynomialCategory
resultant from PseudoRemainderSequence
resultant from RecursivePolynomialCategory
resultant from UnivariatePolynomialCategory
resultantEuclidean from PseudoRemainderSequence
resultantEuclideannaif from PseudoRemainderSequence
resultantReduit from PseudoRemainderSequence
resultantReduitEuclidean from PseudoRemainderSequence
resultantnaif from PseudoRemainderSequence
retract from AnyFunctions1
retract from FortranExpression
retract from FortranFunctionCategory
retract from FortranMatrixFunctionCategory
retract from FortranVectorFunctionCategory
retract from NumericalIntegrationProblem
retract from NumericalODEProblem
retract from NumericalOptimizationProblem
retract from NumericalPDEProblem
retract from PolynomialSetCategory
retract from RecursivePolynomialCategory
retract from RetractableTo
retractIfCan from AnyFunctions1
retractIfCan from FortranExpression
retractIfCan from FortranFunctionCategory
retractIfCan from FortranMatrixFunctionCategory
retractIfCan from FortranVectorFunctionCategory
retractIfCan from NormRetractPackage
retractIfCan from PolynomialSetCategory
retractIfCan from RecursivePolynomialCategory
retractIfCan from RetractableTo
retractable? from AntiSymm
retractable? from AnyFunctions1
retractable? from DeRhamComplex
retractable? from LyndonWord
retractable? from Magma
retractable? from PoincareBirkhoffWittLyndonBasis
returnType! from TheSymbolTable
returnTypeOf from TheSymbolTable
returns from FortranCode
reverse from FiniteLinearAggregate
reverse from GaloisGroupPolynomialUtilities
reverse from ListMonoidOps
reverse! from DequeueAggregate
reverse! from FiniteLinearAggregate
reverse! from ListMonoidOps
reverseLex from OrderingFunctions
revert from StreamTaylorSeriesOperations
revert from UnivariateTaylorSeries
rewriteIdealWithHeadRemainder from PolynomialSetCategory
rewriteIdealWithQuasiMonicGenerators from PolynomialSetUtilitiesPackage
rewriteIdealWithRemainder from PolynomialSetCategory
rewriteSetByReducingWithParticularGenerators from PolynomialSetUtilitiesPackage
rewriteSetWithReduction from TriangularSetCategory
rhs from Equation
rhs from RewriteRule
rhs from SuchThat
ricDsolve from RationalRicDE
ridHack1 from RandomIntegerDistributions
right from BinaryRecursiveAggregate
right from LyndonWord
right from Magma
right from OutputForm
right from RightOpenIntervalRootCharacterization
rightAlternative? from FiniteRankNonAssociativeAlgebra
rightAlternative? from FiniteRankNonAssociativeAlgebra&
rightCharacteristicPolynomial from FiniteRankNonAssociativeAlgebra
rightDiscriminant from FiniteRankNonAssociativeAlgebra
rightDiscriminant from FramedNonAssociativeAlgebra
rightDiscriminant from FramedNonAssociativeAlgebra&
rightDivide from UnivariateSkewPolynomialCategory
rightDivide from UnivariateSkewPolynomialCategoryOps
rightExactQuotient from UnivariateSkewPolynomialCategory
rightExtendedGcd from UnivariateSkewPolynomialCategory
rightFactorCandidate from PolynomialDecomposition
rightFactorIfCan from UnivariatePolynomialDecompositionPackage
rightGcd from UnivariateSkewPolynomialCategory
rightLcm from UnivariateSkewPolynomialCategory
rightMinimalPolynomial from FiniteRankNonAssociativeAlgebra
rightMult from ListMonoidOps
rightNorm from FiniteRankNonAssociativeAlgebra
rightOne from Equation
rightPower from Monad
rightPower from MonadWithUnit
rightQuotient from UnivariateSkewPolynomialCategory
rightRank from AlgebraPackage
rightRankPolynomial from FramedNonAssociativeAlgebra
rightRankPolynomial from FramedNonAssociativeAlgebra&
rightRankPolynomial from GenericNonAssociativeAlgebra
rightRecip from FiniteRankNonAssociativeAlgebra
rightRecip from MonadWithUnit
rightRegularRepresentation from FiniteRankNonAssociativeAlgebra
rightRegularRepresentation from FramedNonAssociativeAlgebra
rightRemainder from UnivariateSkewPolynomialCategory
rightScalarTimes! from StorageEfficientMatrixOperations
rightTrace from FiniteRankNonAssociativeAlgebra
rightTraceMatrix from FiniteRankNonAssociativeAlgebra
rightTraceMatrix from FramedNonAssociativeAlgebra
rightTraceMatrix from FramedNonAssociativeAlgebra&
rightTrim from StringAggregate
rightUnit from FiniteRankNonAssociativeAlgebra
rightUnits from FiniteRankNonAssociativeAlgebra
rightUnits from GenericNonAssociativeAlgebra
rightZero from Equation
rischDE from ElementaryRischDE
rischDEsys from ElementaryRischDESystem
rischNormalize from ElementaryFunctionStructurePackage
rk4 from NumericalOrdinaryDifferentialEquations
rk4a from NumericalOrdinaryDifferentialEquations
rk4f from NumericalOrdinaryDifferentialEquations
rk4qc from NumericalOrdinaryDifferentialEquations
roman from RomanNumeral
romberg from NumericalQuadrature
rombergo from NumericalQuadrature
root from OutputForm
root from PAdicIntegerCategory
root? from SubSpace
rootBound from GaloisGroupFactorizationUtilities
rootKerSimp from AlgebraicManipulations
rootNormalize from ElementaryFunctionStructurePackage
rootOf from AlgebraicFunction
rootOf from AlgebraicallyClosedField
rootOf from AlgebraicallyClosedFunctionSpace
rootOf from RealClosedField
rootOf from RealRootCharacterizationCategory
rootOfIrreduciblePoly from FiniteFieldPolynomialPackage2
rootPoly from ChangeOfVariable
rootPower from AlgebraicManipulations
rootProduct from AlgebraicManipulations
rootRadius from ComplexRootFindingPackage
rootSimp from AlgebraicManipulations
rootSplit from AlgebraicManipulations
rootsOf from AlgebraicallyClosedField
rootsOf from AlgebraicallyClosedFunctionSpace
rotate from ThreeDimensionalViewport
rotate! from QueueAggregate
rotatex from DenavitHartenbergMatrix
rotatey from DenavitHartenbergMatrix
rotatez from DenavitHartenbergMatrix
roughBase? from PolynomialSetCategory
roughBasicSet from PolynomialSetUtilitiesPackage
roughEqualIdeals? from PolynomialSetCategory
roughSubIdeal? from PolynomialSetCategory
roughUnitIdeal? from PolynomialSetCategory
round from RealNumberSystem
routines from RoutinesTable
row from RectangularMatrixCategory
rowEch from ModularHermitianRowReduction
rowEchLocal from ModularHermitianRowReduction
rowEchelon from InnerMatrixLinearAlgebraFunctions
rowEchelon from InnerMatrixQuotientFieldFunctions
rowEchelon from MatrixCategory
rowEchelon from MatrixLinearAlgebraFunctions
rowEchelon from ModularHermitianRowReduction
rowEchelon from RectangularMatrixCategory
rowEchelonLocal from ModularHermitianRowReduction
rquo from FreeLieAlgebra
rquo from FreeMonoid
rquo from OrderedFreeMonoid
rquo from XFreeAlgebra
rroot from PolynomialRoots
rspace from OutputForm
rst from LazyStreamAggregate
rubiksGroup from PermutationGroupExamples
rule from RewriteRule
rules from Ruleset
ruleset from Ruleset
rur from InternalRationalUnivariateRepresentationPackage
rur from RationalUnivariateRepresentationPackage

s01eaf from NagSpecialFunctionsPackage
s13aaf from NagSpecialFunctionsPackage
s13acf from NagSpecialFunctionsPackage
s13adf from NagSpecialFunctionsPackage
s14aaf from NagSpecialFunctionsPackage
s14abf from NagSpecialFunctionsPackage
s14baf from NagSpecialFunctionsPackage
s15adf from NagSpecialFunctionsPackage
s15aef from NagSpecialFunctionsPackage
s17acf from NagSpecialFunctionsPackage
s17adf from NagSpecialFunctionsPackage
s17aef from NagSpecialFunctionsPackage
s17aff from NagSpecialFunctionsPackage
s17agf from NagSpecialFunctionsPackage
s17ahf from NagSpecialFunctionsPackage
s17ajf from NagSpecialFunctionsPackage
s17akf from NagSpecialFunctionsPackage
s17dcf from NagSpecialFunctionsPackage
s17def from NagSpecialFunctionsPackage
s17dgf from NagSpecialFunctionsPackage
s17dhf from NagSpecialFunctionsPackage
s17dlf from NagSpecialFunctionsPackage
s18acf from NagSpecialFunctionsPackage
s18adf from NagSpecialFunctionsPackage
s18aef from NagSpecialFunctionsPackage
s18aff from NagSpecialFunctionsPackage
s18dcf from NagSpecialFunctionsPackage
s18def from NagSpecialFunctionsPackage
s19aaf from NagSpecialFunctionsPackage
s19abf from NagSpecialFunctionsPackage
s19acf from NagSpecialFunctionsPackage
s19adf from NagSpecialFunctionsPackage
s20acf from NagSpecialFunctionsPackage
s20adf from NagSpecialFunctionsPackage
s21baf from NagSpecialFunctionsPackage
s21bbf from NagSpecialFunctionsPackage
s21bcf from NagSpecialFunctionsPackage
s21bdf from NagSpecialFunctionsPackage
sPol from GroebnerInternalPackage
safeCeiling from GaloisGroupUtilities
safeFloor from GaloisGroupUtilities
safetyMargin from GaloisGroupUtilities
sample from AbelianMonoid
sample from Aggregate
sample from CartesianTensor
sample from Monoid
sample from Symbol
satisfy? from PatternFunctions1
satisfy? from PatternMatchResult
saturate from PolynomialIdeals
save from FortranCode
say from DisplayPackage
sayLength from DisplayPackage
scalarMatrix from MatrixCategory
scalarMatrix from SquareMatrixCategory
scalarTypeOf from FortranType
scale from DenavitHartenbergMatrix
scale from MoebiusTransform
scale from TwoDimensionalViewport
scaleRoots from GaloisGroupPolynomialUtilities
scan from DirectProductFunctions2
scan from FiniteLinearAggregateFunctions2
scan from FiniteSetAggregateFunctions2
scan from ListFunctions2
scan from StreamFunctions2
scan from VectorFunctions2
scanOneDimSubspaces from RepresentationPackage2
schema from PseudoRemainderSequence
schwerpunkt from ComplexRootFindingPackage
screenResolution from GraphicsDefaults
screenResolution from Plot
screenResolution3D from Plot3D
script from Symbol
scripted? from Symbol
scripts from OutputForm
scripts from Symbol
sdf2lst from ExpertSystemContinuityPackage
sdf2lst from ExpertSystemToolsPackage
sdf2lst from d01AgentsPackage
se2rfi from ParametricLinearEquations
search from KeyedDictionary
sec from ElementaryFunction
sec from ElementaryFunctionsUnivariateLaurentSeries
sec from ElementaryFunctionsUnivariatePuiseuxSeries
sec from StreamTranscendentalFunctions
sec from StreamTranscendentalFunctionsNonCommutative
sec from TrigonometricFunctionCategory
sec2cos from TranscendentalManipulations
secIfCan from PartialTranscendentalFunctions
sech from ElementaryFunction
sech from ElementaryFunctionsUnivariateLaurentSeries
sech from ElementaryFunctionsUnivariatePuiseuxSeries
sech from HyperbolicFunctionCategory
sech from StreamTranscendentalFunctions
sech from StreamTranscendentalFunctionsNonCommutative
sech2cosh from TranscendentalManipulations
sechIfCan from PartialTranscendentalFunctions
second from UnaryRecursiveAggregate
seed from RandomNumberSource
segment from SegmentBinding
segment from SegmentCategory
segment from UniversalSegment
select from Collection
select from InfiniteTuple
select from LazyStreamAggregate
select from TriangularSetCategory
select! from DictionaryOperations
select! from ExtensibleLinearAggregate
selectAndPolynomials from PolynomialSetUtilitiesPackage
selectFiniteRoutines from RoutinesTable
selectIntegrationRoutines from RoutinesTable
selectMultiDimensionalRoutines from RoutinesTable
selectNonFiniteRoutines from RoutinesTable
selectODEIVPRoutines from RoutinesTable
selectOptimizationRoutines from RoutinesTable
selectOrPolynomials from PolynomialSetUtilitiesPackage
selectPDERoutines from RoutinesTable
selectPolynomials from PolynomialSetUtilitiesPackage
selectSumOfSquaresRoutines from RoutinesTable
selectfirst from Product
selectsecond from Product
semiDegreeSubResultantEuclidean from PseudoRemainderSequence
semiDiscriminantEuclidean from PseudoRemainderSequence
semiIndiceSubResultantEuclidean from PseudoRemainderSequence
semiLastSubResultantEuclidean from PseudoRemainderSequence
semiResultantEuclidean1 from PseudoRemainderSequence
semiResultantEuclidean2 from PseudoRemainderSequence
semiResultantEuclideannaif from PseudoRemainderSequence
semiResultantReduitEuclidean from PseudoRemainderSequence
semiSubResultantGcdEuclidean1 from PseudoRemainderSequence
semiSubResultantGcdEuclidean2 from PseudoRemainderSequence
semicolonSeparate from OutputForm
separant from DifferentialPolynomialCategory
separate from LaurentPolynomial
separate from SubSpace
separate from UnivariatePolynomialCategory
separateDegrees from DistinctDegreeFactorize
separateFactors from DistinctDegreeFactorize
separateFactors from ModularDistinctDegreeFactorizer
sequences from PartitionsAndPermutations
series from ExpressionToUnivariatePowerSeries
series from GenerateUnivariatePowerSeries
series from InnerSparseUnivariatePowerSeries
series from InnerTaylorSeries
series from UnivariateLaurentSeriesCategory
series from UnivariatePuiseuxSeriesCategory
series from UnivariateTaylorSeriesCategory
seriesSolve from ExpressionSpaceODESolver
seriesToOutputForm from InnerSparseUnivariatePowerSeries
set from SetAggregate
setAdaptive from Plot
setAdaptive3D from Plot3D
setAttributeButtonStep from AttributeButtons
setButtonValue from AttributeButtons
setClipValue from DrawComplex
setClosed from TubePlot
setCondition! from SplittingNode
setDifference from List
setEmpty! from SplittingNode
setEpilogue! from ScriptFormulaFormat
setEpilogue! from TexFormat
setErrorBound from ComplexRootFindingPackage
setFieldInfo from InnerNormalBasisFieldFunctions
setFormula! from ScriptFormulaFormat
setImagSteps from DrawComplex
setIntersection from List
setLabelValue from FortranCode
setLegalFortranSourceExtensions from FortranPackage
setMaxPoints from Plot
setMaxPoints3D from Plot3D
setMinPoints from Plot
setMinPoints3D from Plot3D
setOfMinN from SetOfMIntegersInOneToN
setOrder from UserDefinedPartialOrdering
setPoly from ModMonic
setPosition from CachableSet
setPredicates from Pattern
setPrologue! from ScriptFormulaFormat
setPrologue! from TexFormat
setProperties from BasicOperator
setProperty from BasicOperator
setRealSteps from DrawComplex
setScreenResolution from Plot
setScreenResolution3D from Plot3D
setStatus from QuasiAlgebraicSet
setStatus! from SplittingNode
setTex! from TexFormat
setTopPredicate from Pattern
setUnion from List
setValue! from SplittingNode
setVariableOrder from UserDefinedVariableOrdering
setchildren! from RecursiveAggregate
setelt from BinaryRecursiveAggregate
setelt from EltableAggregate
setelt from Library
setelt from LinearAggregate
setelt from MatrixCategory
setelt from RecursiveAggregate
setelt from Reference
setelt from TableAggregate
setelt from UnaryRecursiveAggregate
setelt! from ThreeDimensionalMatrix
setfirst! from UnaryRecursiveAggregate
setlast! from UnaryRecursiveAggregate
setleft! from BinaryRecursiveAggregate
setnext! from DoublyLinkedAggregate
setprevious! from DoublyLinkedAggregate
setref from Reference
setrest! from Stream
setrest! from UnaryRecursiveAggregate
setright! from BinaryRecursiveAggregate
setsubMatrix! from MatrixCategory
setvalue! from RecursiveAggregate
sh from XFreeAlgebra
shade from Palette
shade from PointPackage
shallowCopy from SubSpace
shallowExpand from FreeNilpotentLie
shanksDiscLogAlgorithm from DiscreteLogarithmPackage
shellSort from FiniteLinearAggregateSort
shift from Float
shift from IntegerNumberSystem
shift from MoebiusTransform
shift from NonNegativeInteger
shiftLeft from UnivariatePolynomialCategory
shiftRight from UnivariatePolynomialCategory
shiftRoots from GaloisGroupPolynomialUtilities
show from TwoDimensionalViewport
showAll? from Stream
showAllElements from Stream
showArrayValues from Result
showAttributes from IntegrationFunctionsTable
showClipRegion from ThreeDimensionalViewport
showFortranOutputStack from FortranOutputStackPackage
showIntensityFunctions from ODEIntensityFunctionsTable
showRegion from ThreeDimensionalViewport
showScalarValues from Result
showTheFTable from IntegrationFunctionsTable
showTheIFTable from ODEIntensityFunctionsTable
showTheRoutinesTable from RoutinesTable
showTheSymbolTable from TheSymbolTable
showTypeInOutput from Any
shrinkable from FlexibleArray
shuffle from PartitionsAndPermutations
shufflein from PartitionsAndPermutations
sign from ElementaryFunctionSign
sign from OrderedRing
sign from Permutation
sign from RationalFunctionSign
sign from RealRootCharacterizationCategory
sign from ToolsForSign
signAround from InnerPolySign
simpleBounds? from e04AgentsPackage
simplify from QuasiAlgebraicSet
simplify from SimplifyAlgebraicNumberConvertPackage
simplify from TranscendentalManipulations
simplifyExp from TranscendentalManipulations
simplifyLog from TranscendentalManipulations
simplifyPower from Expression
simpson from NumericalQuadrature
simpsono from NumericalQuadrature
sin from ElementaryFunction
sin from ElementaryFunctionsUnivariateLaurentSeries
sin from ElementaryFunctionsUnivariatePuiseuxSeries
sin from FortranExpression
sin from FourierComponent
sin from StreamTranscendentalFunctions
sin from StreamTranscendentalFunctionsNonCommutative
sin from TrigonometricFunctionCategory
sin2csc from TranscendentalManipulations
sin? from FourierComponent
sinIfCan from PartialTranscendentalFunctions
sincos from StreamTranscendentalFunctions
singRicDE from PrimitiveRatRicDE
singRicDE from RationalRicDE
singleFactorBound from GaloisGroupFactorizationUtilities
singular? from FunctionFieldCategory
singularAtInfinity? from FunctionFieldCategory
singularitiesOf from ExpertSystemContinuityPackage
singularitiesOf from d01AgentsPackage
sinh from ElementaryFunction
sinh from ElementaryFunctionsUnivariateLaurentSeries
sinh from ElementaryFunctionsUnivariatePuiseuxSeries
sinh from FortranExpression
sinh from HyperbolicFunctionCategory
sinh from StreamTranscendentalFunctions
sinh from StreamTranscendentalFunctionsNonCommutative
sinh2csch from TranscendentalManipulations
sinhIfCan from PartialTranscendentalFunctions
sinhcosh from StreamTranscendentalFunctions
size from DirectProductCategory&
size from Finite
size from FiniteAlgebraicExtensionField&
size from FiniteSetAggregate&
size from FreeAbelianMonoidCategory
size from FreeGroup
size from FreeMonoid
size from ListMonoidOps
size from MonogenicAlgebra&
size from OrderedFreeMonoid
size from RandomNumberSource
size from RightOpenIntervalRootCharacterization
size? from Aggregate
sizeLess? from EuclideanDomain
sizeMultiplication from FiniteFieldFunctions
sizeMultiplication from FiniteFieldNormalBasis
sizeMultiplication from FiniteFieldNormalBasisExtension
sizeMultiplication from FiniteFieldNormalBasisExtensionByPolynomial
sizePascalTriangle from GaloisGroupUtilities
skewSFunction from CycleIndicators
slash from OutputForm
slex from TableauxBumpers
smith from SmithNormalForm
sn from EllipticFunctionsUnivariateTaylorSeries
sncndn from EllipticFunctionsUnivariateTaylorSeries
socf2socdf from ExpertSystemToolsPackage
solid from SubSpaceComponentProperty
solid? from SubSpaceComponentProperty
solve from AnnaOrdinaryDifferentialEquationPackage
solve from AnnaPartialDifferentialEquationPackage
solve from ElementaryFunctionLODESolver
solve from ElementaryFunctionODESolver
solve from FloatingRealPackage
solve from LinearSystemMatrixPackage
solve from LinearSystemMatrixPackage1
solve from NonLinearFirstOrderODESolver
solve from NonLinearSolvePackage
solve from PolynomialSolveByFormulas
solve from RealSolvePackage
solve from SystemODESolver
solve from SystemSolvePackage
solve from TransSolvePackage
solve1 from InnerNumericEigenPackage
solveInField from NonLinearSolvePackage
solveInField from SystemODESolver
solveLinear from LinearDependence
solveLinearPolynomialEquation from ComplexIntegerSolveLinearPolynomialEquation
solveLinearPolynomialEquation from FiniteFieldSolveLinearPolynomialEquation
solveLinearPolynomialEquation from IntegerSolveLinearPolynomialEquation
solveLinearPolynomialEquation from PolynomialFactorizationExplicit
solveLinearPolynomialEquationByFractions from LinearPolynomialEquationByFractions
solveLinearPolynomialEquationByRecursion from PolynomialFactorizationByRecursion
solveLinearPolynomialEquationByRecursion from PolynomialFactorizationByRecursionUnivariate
solveLinearlyOverQ from IntegerLinearDependence
solveRetract from RetractSolvePackage
solveid from GenExEuclid
someBasis from FiniteRankNonAssociativeAlgebra
sort from FiniteLinearAggregate
sort from Permutation
sort from PolynomialSetCategory
sort! from FiniteLinearAggregate
sortConstraints from e04AgentsPackage
sorted? from FiniteLinearAggregate
space from DrawOption
space from DrawOptionFunctions0
sparsityIF from d02AgentsPackage
specialTrigs from ElementaryFunction
spherical from CoordinateSystems
split from AlgFactor
split from IntegrationResultRFToFunction
split from IntegrationResultToFunction
split from MonomialExtensionTools
split from RepresentationPackage2
split from StringAggregate
split! from UnaryRecursiveAggregate
splitConstant from PatternMatchIntegration
splitDenominator from CommonDenominator
splitDenominator from InnerCommonDenominator
splitDenominator from MatrixCommonDenominator
splitDenominator from PrimitiveRatDE
splitDenominator from UnivariatePolynomialCommonDenominator
splitLinear from e04AgentsPackage
splitNodeOf! from SplittingTree
splitSquarefree from MonomialExtensionTools
sqfree from ParametricLinearEquations
sqrt from FortranExpression
sqrt from PAdicIntegerCategory
sqrt from RadicalCategory
sqrt from RealClosedField
square? from MatrixCategory
square? from RectangularMatrixCategory
squareFree from IntegerFactorizationPackage
squareFree from MultivariateSquareFree
squareFree from PolynomialCategory
squareFree from PolynomialSquareFree
squareFree from SupFractionFactorizer
squareFree from UniqueFactorizationDomain
squareFree from UnivariatePolynomialSquareFree
squareFree from ZeroDimensionalSolvePackage
squareFreeFactors from PolynomialSetUtilitiesPackage
squareFreeLexTriangular from LexTriangularPackage
squareFreePart from PolynomialCategory
squareFreePart from RegularTriangularSetCategory
squareFreePart from UniqueFactorizationDomain
squareFreePart from UnivariatePolynomialSquareFree
squareFreePolynomial from Expression
squareFreePolynomial from PolynomialFactorizationExplicit
squareFreePrim from MultivariateSquareFree
squareMatrix from SquareMatrix
squareTop from MatrixCategory
stFunc1 from UnivariateTaylorSeriesODESolver
stFunc2 from UnivariateTaylorSeriesODESolver
stFuncN from UnivariateTaylorSeriesODESolver
standardBasisOfCyclicSubmodule from RepresentationPackage2
startPolynomial from ComplexRootFindingPackage
startStats! from TabulatedComputationPackage
startTable! from QuasiComponentPackage
startTable! from SquareFreeQuasiComponentPackage
startTableGcd! from RegularTriangularSetGcdPackage
startTableGcd! from SquareFreeRegularTriangularSetGcdPackage
startTableInvSet! from RegularTriangularSetGcdPackage
startTableInvSet! from SquareFreeRegularTriangularSetGcdPackage
status from QuasiAlgebraicSet
status from SplittingNode
stiffnessAndStabilityFactor from d02AgentsPackage
stiffnessAndStabilityOfODEIF from d02AgentsPackage
stirling1 from IntegerCombinatoricFunctions
stirling2 from IntegerCombinatoricFunctions
stop from FortranCode
stopMusserTrials from GaloisGroupFactorizer
stopTable! from QuasiComponentPackage
stopTable! from SquareFreeQuasiComponentPackage
stopTableGcd! from RegularTriangularSetGcdPackage
stopTableGcd! from SquareFreeRegularTriangularSetGcdPackage
stopTableInvSet! from RegularTriangularSetGcdPackage
stopTableInvSet! from SquareFreeRegularTriangularSetGcdPackage
stoseIntegralLastSubResultant from SquareFreeRegularTriangularSetGcdPackage
stoseInternalLastSubResultant from SquareFreeRegularTriangularSetGcdPackage
stoseInvertible? from SquareFreeRegularTriangularSetGcdPackage
stoseInvertible?reg from SquareFreeRegularTriangularSetGcdPackage
stoseInvertible?sqfreg from SquareFreeRegularTriangularSetGcdPackage
stoseInvertibleSet from SquareFreeRegularTriangularSetGcdPackage
stoseInvertibleSetreg from SquareFreeRegularTriangularSetGcdPackage
stoseInvertibleSetsqfreg from SquareFreeRegularTriangularSetGcdPackage
stoseLastSubResultant from SquareFreeRegularTriangularSetGcdPackage
stosePrepareSubResAlgo from SquareFreeRegularTriangularSetGcdPackage
stoseSquareFreePart from SquareFreeRegularTriangularSetGcdPackage
string from OutputForm
string from SExpressionCategory
string from StringCategory
string from Symbol
string? from SExpressionCategory
stripCommentsAndBlanks from TemplateUtilities
strongGenerators from PermutationGroup
stronglyReduce from TriangularSetCategory
stronglyReduced? from TriangularSetCategory
structuralConstants from FiniteRankNonAssociativeAlgebra
structuralConstants from FramedNonAssociativeAlgebra
structuralConstants from FramedNonAssociativeAlgebra&
structuralConstants from StructuralConstantsPackage
sts2stst from WeierstrassPreparation
sturmSequence from RealPolynomialUtilitiesPackage
sturmVariationsOf from RealPolynomialUtilitiesPackage
style from DrawOption
style from DrawOptionFunctions0
sub from OutputForm
subCase? from QuasiComponentPackage
subCase? from SquareFreeQuasiComponentPackage
subHeight from OutputForm
subMatrix from MatrixCategory
subNode? from SplittingNode
subNodeOf? from SplittingTree
subPolSet? from QuasiComponentPackage
subPolSet? from SquareFreeQuasiComponentPackage
subQuasiComponent? from QuasiComponentPackage
subQuasiComponent? from SquareFreeQuasiComponentPackage
subResultantChain from RecursivePolynomialCategory
subResultantGcd from PseudoRemainderSequence
subResultantGcd from RecursivePolynomialCategory
subResultantGcd from UnivariatePolynomialCategory
subResultantGcdEuclidean from PseudoRemainderSequence
subResultantsChain from NewSparseUnivariatePolynomial
subSet from SymmetricGroupCombinatoricFunctions
subTriSet? from QuasiComponentPackage
subTriSet? from SquareFreeQuasiComponentPackage
submod from IntegerNumberSystem
subresultantSequence from SturmHabichtPackage
subresultantVector from SubResultantPackage
subscript from Symbol
subscriptedVariables from d03AgentsPackage
subset? from SetAggregate
subspace from SubSpace
subspace from ThreeDimensionalViewport
subspace from ThreeSpaceCategory
subst from Equation
subst from ExpressionSpace
substitute from ListMultiDictionary
substring? from StringAggregate
subtractIfCan from CancellationAbelianMonoid
suchThat from AttachPredicates
suchThat from FunctionSpaceAttachPredicates
suchThat from PatternFunctions1
suchThat from RewriteRule
suffix? from StringAggregate
sum from FunctionSpaceSum
sum from InnerPolySum
sum from OutputForm
sum from RationalFunctionSum
sumOfDivisors from IntegerNumberTheoryFunctions
sumOfKthPowerDivisors from IntegerNumberTheoryFunctions
sumOfSquares from e04AgentsPackage
sumSquares from GaussianFactorizationPackage
summation from CombinatorialFunction
summation from CombinatorialOpsCategory
sup from IntervalCategory
sup from OrderedAbelianMonoidSup
supDimElseRittWu? from QuasiComponentPackage
supDimElseRittWu? from SquareFreeQuasiComponentPackage
supRittWu? from RecursivePolynomialCategory
super from OutputForm
superHeight from OutputForm
superscript from Symbol
supersub from OutputForm
surface from ParametricSurface
swap from CommuteUnivariatePolynomialCategory
swap from Equation
swap! from IndexedAggregate
swapColumns! from MatrixCategory
swapRows! from MatrixCategory
sylvesterMatrix from BezoutMatrix
sylvesterSequence from RealPolynomialUtilitiesPackage
symFunc from SymmetricFunctions
symbol from SExpressionCategory
symbol? from Pattern
symbol? from SExpressionCategory
symbolIfCan from Kernel
symbolTable from SymbolTable
symbolTableOf from TheSymbolTable
symmetric? from MatrixCategory
symmetric? from RectangularMatrixCategory
symmetricDifference from SetAggregate
symmetricGroup from PermutationGroupExamples
symmetricPower from LinearOrdinaryDifferentialOperatorCategory
symmetricPower from LinearOrdinaryDifferentialOperatorsOps
symmetricProduct from LinearOrdinaryDifferentialOperatorCategory
symmetricProduct from LinearOrdinaryDifferentialOperatorsOps
symmetricRemainder from IntegerNumberSystem
symmetricSquare from LinearOrdinaryDifferentialOperatorCategory
symmetricTensors from RepresentationPackage1
systemCommand from MoreSystemCommands
systemSizeIF from d02AgentsPackage

t from RandomFloatDistributions
tRange from Plot
tRange from Plot3D
tValues from Plot3D
tab from TableauxBumpers
tab1 from TableauxBumpers
tableForDiscreteLogarithm from FiniteFieldCategory
tablePow from GenExEuclid
tableau from Tableau
tail from DoublyLinkedAggregate
tail from RecursivePolynomialCategory
tail from UnaryRecursiveAggregate
tan from ElementaryFunction
tan from ElementaryFunctionsUnivariateLaurentSeries
tan from ElementaryFunctionsUnivariatePuiseuxSeries
tan from FortranExpression
tan from StreamTranscendentalFunctions
tan from StreamTranscendentalFunctionsNonCommutative
tan from TrigonometricFunctionCategory
tan2cot from TranscendentalManipulations
tan2trig from TranscendentalManipulations
tanAn from TangentExpansions
tanIfCan from PartialTranscendentalFunctions
tanNa from TangentExpansions
tanQ from ElementaryFunctionStructurePackage
tanSum from TangentExpansions
tanh from ElementaryFunction
tanh from ElementaryFunctionsUnivariateLaurentSeries
tanh from ElementaryFunctionsUnivariatePuiseuxSeries
tanh from FortranExpression
tanh from HyperbolicFunctionCategory
tanh from StreamTranscendentalFunctions
tanh from StreamTranscendentalFunctionsNonCommutative
tanh2coth from TranscendentalManipulations
tanh2trigh from TranscendentalManipulations
tanhIfCan from PartialTranscendentalFunctions
tanintegrate from TranscendentalIntegration
taylor from ExpressionToUnivariatePowerSeries
taylor from GenerateUnivariatePowerSeries
taylor from UnivariateLaurentSeriesConstructorCategory
taylorIfCan from UnivariateLaurentSeriesConstructorCategory
taylorQuoByVar from InnerSparseUnivariatePowerSeries
taylorRep from UnivariateLaurentSeriesConstructorCategory
tensorProduct from RepresentationPackage1
terms from FreeAbelianMonoidCategory
terms from MonoidRing
terms from UnivariatePowerSeriesCategory
test from Boolean
testDim from GroebnerSolve
testModulus from GenExEuclid
tex from TexFormat
thetaCoord from PointPackage
third from UnaryRecursiveAggregate
times from UnivariateSkewPolynomialCategoryOps
times! from StorageEfficientMatrixOperations
title from DrawOption
title from DrawOptionFunctions0
title from ThreeDimensionalViewport
title from TwoDimensionalViewport
toScale from DrawOption
toScale from DrawOptionFunctions0
top from StackAggregate
top! from DequeueAggregate
topFortranOutputStack from FortranOutputStackPackage
topPredicate from Pattern
toroidal from CoordinateSystems
torsion? from PointsOfFiniteOrder
torsion? from PointsOfFiniteOrderRational
torsionIfCan from PointsOfFiniteOrder
torsionIfCan from PointsOfFiniteOrderRational
toseInvertible? from RegularTriangularSetGcdPackage
toseInvertibleSet from RegularTriangularSetGcdPackage
toseLastSubResultant from RegularTriangularSetGcdPackage
toseSquareFreePart from RegularTriangularSetGcdPackage
totalDegree from PolynomialCategory
totalDifferential from DeRhamComplex
totalGroebner from PolyGroebner
totalLex from OrderingFunctions
totalfract from MPolyCatRationalFunctionFactorizer
totolex from LinGroebnerPackage
tower from ExpressionSpace
trace from FiniteAlgebraicExtensionField
trace from FiniteRankAlgebra
trace from InnerNormalBasisFieldFunctions
trace from SquareMatrixCategory
trace2PowMod from DistinctDegreeFactorize
traceMatrix from FiniteRankAlgebra
traceMatrix from FramedAlgebra
traceMatrix from FramedAlgebra&
tracePowMod from DistinctDegreeFactorize
trailingCoefficient from LaurentPolynomial
transcendenceDegree from ExtensionField
transcendenceDegree from FiniteAlgebraicExtensionField&
transcendent? from ExtensionField
transcendentalDecompose from RegularSetDecompositionPackage
transcendentalDecompose from SquareFreeRegularSetDecompositionPackage
transform from LinGroebnerPackage
translate from DenavitHartenbergMatrix
translate from ThreeDimensionalViewport
translate from TwoDimensionalViewport
transpose from CartesianTensor
transpose from MatrixCategory
transpose from SquareMatrix
trapezoidal from NumericalQuadrature
trapezoidalo from NumericalQuadrature
traverse from SubSpace
triangSolve from ZeroDimensionalSolvePackage
triangular? from PolynomialSetCategory
triangularSystems from SystemSolvePackage
triangulate from SystemODESolver
trigs from ComplexTrigonometricManipulations
trigs from TrigonometricManipulations
trigs2explogs from InnerTrigonometricManipulations
trim from StringAggregate
trivialIdeal? from PolynomialSetCategory
true from Boolean
trueEqual from InnerAlgebraicNumber
trunc from FreeLieAlgebra
trunc from XPolynomialsCat
truncate from RealNumberSystem
truncate from UnivariatePowerSeriesCategory
tryFunctionalDecomposition from GaloisGroupFactorizer
tryFunctionalDecomposition? from GaloisGroupFactorizer
tube from NumericTubePlot
tube from TubePlot
tubePlot from ExpressionTubePlot
tubePoints from DrawOption
tubePoints from DrawOptionFunctions0
tubePointsDefault from ViewDefaultsPackage
tubeRadius from DrawOption
tubeRadius from DrawOptionFunctions0
tubeRadiusDefault from ViewDefaultsPackage
twist from MappingPackage3
twoFactor from TwoFactorize
typeList from SymbolTable
typeLists from SymbolTable

unary? from BasicOperator
unaryFunction from MakeUnaryCompiledFunction
uncouplingMatrices from AssociatedEquations
unexpand from XPolynomial
unexpand from XRecursivePolynomial
uniform from RandomDistributions
uniform from RandomFloatDistributions
uniform from RandomIntegerDistributions
uniform01 from RandomFloatDistributions
union from IntegrationTools
union from PatternMatchResult
union from SetAggregate
unit from DrawOption
unit from FiniteRankNonAssociativeAlgebra
unit? from IntegralDomain
unitCanonical from IntegralDomain
unitNormal from IntegralDomain
unitNormalize from Factored
unitVector from DirectProductCategory
unitVector from GeneralModulePolynomial
unitVector from TubePlotTools
units from DrawOptionFunctions0
units from GraphImage
units from TwoDimensionalViewport
unitsColorDefault from ViewDefaultsPackage
univariate from FunctionSpace
univariate from GenusZeroIntegration
univariate from PolynomialCategory
univariate from PolynomialCategoryQuotientFunctions
univariate from PolynomialToUnivariatePolynomial
univariate from RationalFunction
univariate? from PolynomialSetUtilitiesPackage
univariatePolynomial from SparseUnivariateTaylorSeries
univariatePolynomial from UnivariateTaylorSeries
univariatePolynomials from PolynomialSetUtilitiesPackage
univariatePolynomialsGcds from PolynomialSetUtilitiesPackage
univariateSolve from ZeroDimensionalSolvePackage
univcase from MultivariateSquareFree
universe from FiniteSetAggregate
unmakeSUP from UnivariatePolynomialCategory
unparse from InputForm
unprotectedRemoveRedundantFactors from PolynomialSetUtilitiesPackage
unrankImproperPartitions0 from SymmetricGroupCombinatoricFunctions
unrankImproperPartitions1 from SymmetricGroupCombinatoricFunctions
unravel from CartesianTensor
untab from TableauxBumpers
unvectorise from GaloisGroupPolynomialUtilities
unvectorise from TransSolvePackageService
upDateBranches from RegularSetDecompositionPackage
upDateBranches from SquareFreeRegularSetDecompositionPackage
updatD from GroebnerInternalPackage
updatF from GroebnerInternalPackage
update from TwoDimensionalViewport
updateStatus! from SplittingTree
upperCase from CharacterClass
upperCase from StringAggregate
upperCase! from StringAggregate
useEisensteinCriterion from GaloisGroupFactorizer
useEisensteinCriterion? from GaloisGroupFactorizer
useNagFunctions from FortranExpression
useSingleFactorBound from GaloisGroupFactorizer
useSingleFactorBound? from GaloisGroupFactorizer
userOrdered? from UserDefinedPartialOrdering
usingTable? from TabulatedComputationPackage

validExponential from ElementaryFunctionStructurePackage
value from OrdSetInts
value from QueryEquation
value from RecursiveAggregate
value from SplittingNode
var1Steps from DrawOption
var1Steps from DrawOptionFunctions0
var1StepsDefault from ViewDefaultsPackage
var2Steps from DrawOption
var2Steps from DrawOptionFunctions0
var2StepsDefault from ViewDefaultsPackage
varList from FreeLieAlgebra
varList from LieExponentials
varList from LyndonWord
varList from Magma
varList from OrderedFreeMonoid
varList from PoincareBirkhoffWittLyndonBasis
varList from XFreeAlgebra
varList from d03AgentsPackage
varList from e04AgentsPackage
variable from DifferentialVariableCategory
variable from OrderedVariableList
variable from QueryEquation
variable from SegmentBinding
variable from UnivariatePowerSeriesCategory
variable from Variable
variables from FactoringUtilities
variables from FortranExpression
variables from FunctionSpace
variables from Pattern
variables from PolynomialCategory
variables from PolynomialCategoryQuotientFunctions
variables from PolynomialSetCategory
variables from PowerSeriesCategory
variables from RationalFunction
variables from e04AgentsPackage
variationOfParameters from ODETools
vark from IntegrationTools
varselect from IntegrationTools
vconcat from OutputForm
vector from Vector
vectorise from UnivariatePolynomialCategory
vedf2vef from ExpertSystemToolsPackage
vertConcat from MatrixCategory
viewDefaults from ViewDefaultsPackage
viewDeltaXDefault from ThreeDimensionalViewport
viewDeltaYDefault from ThreeDimensionalViewport
viewPhiDefault from ThreeDimensionalViewport
viewPosDefault from ViewDefaultsPackage
viewSizeDefault from ViewDefaultsPackage
viewThetaDefault from ThreeDimensionalViewport
viewWriteAvailable from ViewDefaultsPackage
viewWriteDefault from ViewDefaultsPackage
viewZoomDefault from ThreeDimensionalViewport
viewpoint from DrawOption
viewpoint from DrawOptionFunctions0
viewpoint from ThreeDimensionalViewport
viewport2D from TwoDimensionalViewport
viewport3D from ThreeDimensionalViewport
virtualDegree from GroebnerInternalPackage
void from Void
vspace from OutputForm

weakBiRank from AlgebraPackage
weierstrass from WeierstrassPreparation
weight from BasicOperator
weight from DifferentialPolynomialCategory
weight from DifferentialVariableCategory
weighted from RandomDistributions
weights from DifferentialPolynomialCategory
whatInfinity from OrderedCompletion
whileLoop from FortranCode
wholePart from ContinuedFraction
wholePart from PartialFraction
wholePart from QuotientFieldCategory
wholePart from RealNumberSystem
wholeRadix from RadixExpansion
wholeRagits from RadixExpansion
width from IntervalCategory
width from OutputForm
withPredicates from Pattern
wordInGenerators from PermutationGroup
wordInStrongGenerators from PermutationGroup
wordsForStrongGenerators from PermutationGroup
wreath from CycleIndicators
writable? from FileNameCategory
write from ThreeDimensionalViewport
write from TwoDimensionalViewport
write! from FileCategory
writeLine! from TextFile
wronskianMatrix from ODETools
wrregime from ParametricLinearEquations

xCoord from PointPackage
xRange from PlottablePlaneCurveCategory
xRange from PlottableSpaceCurveCategory
xn from InnerNormalBasisFieldFunctions
xor from BitAggregate
xor from Boolean
xor from SingleInteger

yCoord from PointPackage
yCoordinates from FunctionFieldCategory
yRange from PlottablePlaneCurveCategory
yRange from PlottableSpaceCurveCategory
yellow from Color
youngGroup from PermutationGroupExamples

zCoord from PointPackage
zRange from PlottableSpaceCurveCategory
zag from OutputForm
zero from MatrixCategory
zero from VectorCategory
zero? from AbelianMonoid
zero? from PolynomialIdeals
zero? from RealRootCharacterizationCategory
zeroDim? from PolynomialIdeals
zeroDimPrimary? from IdealDecompositionPackage
zeroDimPrime? from IdealDecompositionPackage
zeroDimensional? from FGLMIfCanPackage
zeroDimensional? from LexTriangularPackage
zeroMatrix from FortranCodePackage1
zeroMatrix from ThreeDimensionalMatrix
zeroOf from AlgebraicallyClosedField
zeroOf from AlgebraicallyClosedFunctionSpace
zeroSetSplit from LazardSetSolvingPackage
zeroSetSplit from LexTriangularPackage
zeroSetSplit from RegularChain
zeroSetSplit from RegularTriangularSet
zeroSetSplit from RegularTriangularSetCategory
zeroSetSplit from SquareFreeRegularTriangularSet
zeroSetSplit from TriangularSetCategory
zeroSetSplitIntoTriangularSystems from TriangularSetCategory
zeroSquareMatrix from FortranCodePackage1
zeroVector from FortranCodePackage1
zerosOf from AlgebraicallyClosedField
zerosOf from AlgebraicallyClosedFunctionSpace
zerosOf from ExpertSystemContinuityPackage
zoom from Plot
zoom from Plot3D
zoom from ThreeDimensionalViewport

~ from Logic
~ from SingleInteger

~= from BasicType



From MAILER-DAEMON Mon Aug 18 03:25:01 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KUz6r-0008KA-4g
	for mharc-axiom-developer@gnu.org; Mon, 18 Aug 2008 03:25:01 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KUz6p-0008Ji-4Q
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 03:24:59 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KUz6o-0008IP-2O
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 03:24:58 -0400
Received: from [199.232.76.173] (port=59250 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KUz6n-0008IM-Si
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 03:24:57 -0400
Received: from mx20.gnu.org ([199.232.41.8]:44870)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <ralf@hemmecke.de>) id 1KUz6n-0000kH-Vy
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 03:24:58 -0400
Received: from mo-p05-ob.rzone.de ([81.169.146.181])
	by mx20.gnu.org with esmtp (Exim 4.60)
	(envelope-from <ralf@hemmecke.de>) id 1KUz6l-0003j6-Im
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 03:24:55 -0400
X-RZG-CLASS-ID: mo05
X-RZG-AUTH: :PmQcMEitdvJk4Q5CJd22y2+5o33+jZtqGPj+dLDXcZnAbB/AzeknBcN+0g==
Received: from [10.0.0.1] (62-47-38-157.adsl.highway.telekom.at [62.47.38.157])
	by post.webmailer.de (fruni mo13) (RZmta 16.47)
	with ESMTP id y06949k7I6HUuw ; Mon, 18 Aug 2008 09:24:39 +0200 (MEST)
	(envelope-from: <ralf@hemmecke.de>)
Message-ID: <48A9239D.4000005@hemmecke.de>
Date: Mon, 18 Aug 2008 09:24:13 +0200
From: Ralf Hemmecke <ralf@hemmecke.de>
User-Agent: Thunderbird 2.0.0.16 (X11/20080707)
MIME-Version: 1.0
To: daly@axiom-developer.org
References: <200808180457.m7I4vLWl014580@axiom-developer.org>
In-Reply-To: <200808180457.m7I4vLWl014580@axiom-developer.org>
X-Sent-by-Hemmecke: ralf@hemmecke.de
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit
X-detected-kernel: by mx20.gnu.org: Solaris 10 (beta)
X-detected-kernel: by monty-python.gnu.org: Linux 2.6, seldom 2.4 (older, 4)
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Executed Examples in documentation ---> Testsuite
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 18 Aug 2008 07:24:59 -0000

Dear Tim,

 > there is a new extension to the syntax to add examples. Essentially
 > any line that begins with ++E will be output as Example documentation
 > to the display command. So the coerce from Tuple now reads:
 >
 >    coerce: PrimitiveArray S -> %
 >     ++ coerce(a) makes a tuple from primitive array a
 >     ++
 >     ++E t1:PrimitiveArray(Integer):= [i for i in 1..10]
 >     ++E t2:=coerce(t1)$Tuple(Integer)

That seems to be common nowadays. But what if for some reason the output 
is wrong? Then the user sees that in the documentation. So, personally, 
I would rather add another tag like ++R, for example, that lists the 
explicit (expected) output.

Why I think ++R is a good idea, is that the ++E and ++R could be used
for the TestSuite.

You could also move some checking time to the users machine. At the time 
the documentation is rendered, the commands in ++E are executed and 
compared internally with the ++R stuff.
Since execution might take some time, first show the ++R output and 
spawn a background process that compares the output of ++E with ++R.
If that is equal, everything is fine. If it is different. That is a bug. 
So notify the user with all the information (about his system) that s/he 
should send to a bugtracker.

Just some strange ideas...

Ralf



From MAILER-DAEMON Mon Aug 18 07:41:27 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KV371-00045D-76
	for mharc-axiom-developer@gnu.org; Mon, 18 Aug 2008 07:41:27 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KV36z-00044t-NG
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 07:41:25 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KV36x-00044h-1N
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 07:41:24 -0400
Received: from [199.232.76.173] (port=44940 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KV36w-00044e-QP
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 07:41:22 -0400
Received: from mx-7.zoominternet.net ([24.154.1.26]:46886
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KV36w-0006KU-FQ
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 07:41:22 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=e3nQAW1Q4iEA:10 a=LgYztuhCWg4A:10
	a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=wBkSxYh-AsB95sY8E9MA:9 a=NfmuTKkwkO32fN0F_KQuyjfloRYA:4
	a=MxZ3bB5I4kYA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.45] ([24.154.1.45:57962] helo=pop-2.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 90/CE-12184-4DF59A84; Mon, 18 Aug 2008 07:41:08 -0400
Received: (qmail 11759 invoked from network); 18 Aug 2008 11:41:13 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-2.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 18 Aug 2008 11:41:13 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id m7ID6e926562;
	Mon, 18 Aug 2008 09:06:40 -0400
Date: Mon, 18 Aug 2008 09:06:40 -0400
Message-Id: <200808181306.m7ID6e926562@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: ralf@hemmecke.de
In-reply-to: <48A9239D.4000005@hemmecke.de> (message from Ralf Hemmecke on
	Mon, 18 Aug 2008 09:24:13 +0200)
References: <200808180457.m7I4vLWl014580@axiom-developer.org>
	<48A9239D.4000005@hemmecke.de>
X-detected-kernel: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Executed Examples in documentation --->
	Testsuite
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 18 Aug 2008 11:41:25 -0000

> > there is a new extension to the syntax to add examples. Essentially
> > any line that begins with ++E will be output as Example documentation
> > to the display command. So the coerce from Tuple now reads:
> >
> >    coerce: PrimitiveArray S -> %
> >     ++ coerce(a) makes a tuple from primitive array a
> >     ++
> >     ++E t1:PrimitiveArray(Integer):= [i for i in 1..10]
> >     ++E t2:=coerce(t1)$Tuple(Integer)
>
>That seems to be common nowadays. But what if for some reason the output 
>is wrong? Then the user sees that in the documentation. So, personally, 
>I would rather add another tag like ++R, for example, that lists the 
>explicit (expected) output.
>
>Why I think ++R is a good idea, is that the ++E and ++R could be used
>for the TestSuite.

An EXCELLENT idea. I had planned to sweep up all of the ++E expressions
into algebra test suites since these explicitly test each of the exported
functions. I've uncovered some bugs already from the documentation
process. I think it is vital that we test the exposed functions at build
time as they are the first line of defense against breakage.

Your idea makes it MUCH easier to integrate the tests into the existing
regression test framework. I'll see if I can automate this.




>You could also move some checking time to the users machine. At the time 
>the documentation is rendered, the commands in ++E are executed and 
>compared internally with the ++R stuff.
>Since execution might take some time, first show the ++R output and 
>spawn a background process that compares the output of ++E with ++R.
>If that is equal, everything is fine. If it is different. That is a bug. 
>So notify the user with all the information (about his system) that s/he 
>should send to a bugtracker.

This could potentially introduce a lot of overhead into the execution
of the )display operation command. The "map" function, for instance,
has about 80 instances which would introduce 80 background executions.
If we could do that in parallel (since each test is independent) this
might make sense on a multicore machine. But we can certainly test at
build time.





As for bugtracking I plan to have a bug script that the user can run
to collect information about a bug and format a "standard" report that
the user can modify with details. I think this would be useful for the
panaxiom systems also. I have tried wrapping the breakpoint with a
"dump state" function so I can capture backtracking in a file but it
has not hit the trunk code.

The main thing that keeps pushing it down on the list is my relative
weakness in writing shell scripts. Ideally the user just runs "bugreport"
and everything gets sent to us. Axiom used to have such a shell script
when I worked at IBM. I'll see if I can find a copy.

Tim




From MAILER-DAEMON Mon Aug 18 08:08:22 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KV3X4-0008Tq-32
	for mharc-axiom-developer@gnu.org; Mon, 18 Aug 2008 08:08:22 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KV3X2-0008QT-97
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:08:20 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KV3X0-0008Pb-9p
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:08:19 -0400
Received: from [199.232.76.173] (port=47478 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KV3X0-0008PY-61
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:08:18 -0400
Received: from mo-p05-ob.rzone.de ([81.169.146.181]:51633)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <ralf@hemmecke.de>) id 1KV3Wz-00079i-QN
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:08:18 -0400
X-RZG-CLASS-ID: mo05
X-RZG-AUTH: :PmQcMEitdvJk4Q5CJd22y2+5o33+jZtqGPj+dLDXdpIXuAlIRTZF+Phj0FJS
Received: from [193.170.38.119]
	(woodpecker.risc.uni-linz.ac.at [193.170.38.119])
	by post.webmailer.de (fruni mo4) (RZmta 16.47)
	with ESMTP id h004f9k7IAgUrx ; Mon, 18 Aug 2008 14:08:05 +0200 (MEST)
	(envelope-from: <ralf@hemmecke.de>)
Message-ID: <48A9660A.7010905@hemmecke.de>
Date: Mon, 18 Aug 2008 14:07:38 +0200
From: Ralf Hemmecke <ralf@hemmecke.de>
User-Agent: Thunderbird 2.0.0.16 (X11/20080707)
MIME-Version: 1.0
To: daly@axiom-developer.org
References: <200808180457.m7I4vLWl014580@axiom-developer.org>
	<48A9239D.4000005@hemmecke.de>
	<200808181306.m7ID6e926562@localhost.localdomain>
In-Reply-To: <200808181306.m7ID6e926562@localhost.localdomain>
X-Sent-by-Hemmecke: ralf@hemmecke.de
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit
X-detected-kernel: by monty-python.gnu.org: Solaris 10 (beta)
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Executed Examples in documentation --->
	Testsuite
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 18 Aug 2008 12:08:20 -0000

> Ideally the user just runs "bugreport" and everything gets sent to
> us.

Note that people want to see what gets sent to a remote site. No system 
nowadays sends any information of the user system automatically, but 
rather pop up a window. See for example how bugs are sent in firefox.

Ralf



From MAILER-DAEMON Mon Aug 18 08:15:33 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KV3e1-0002mA-5i
	for mharc-axiom-developer@gnu.org; Mon, 18 Aug 2008 08:15:33 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KV3dz-0002lf-4b
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:15:31 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KV3dx-0002lC-9y
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:15:30 -0400
Received: from [199.232.76.173] (port=50263 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KV3dx-0002l9-6Z
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:15:29 -0400
Received: from mo-p05-ob.rzone.de ([81.169.146.182]:62167)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <ralf@hemmecke.de>) id 1KV3dx-00017m-5b
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:15:29 -0400
X-RZG-CLASS-ID: mo05
X-RZG-AUTH: :PmQcMEitdvJk4Q5CJd22y2+5o33+jZtqGPj+dLDXdpIXuAlIRTZF+Phj0FJS
Received: from [193.170.38.119]
	(woodpecker.risc.uni-linz.ac.at [193.170.38.119])
	by post.webmailer.de (fruni mo60) (RZmta 16.47)
	with ESMTP id x01304k7I9rJBZ ; Mon, 18 Aug 2008 14:15:16 +0200 (MEST)
	(envelope-from: <ralf@hemmecke.de>)
Message-ID: <48A967BA.70101@hemmecke.de>
Date: Mon, 18 Aug 2008 14:14:50 +0200
From: Ralf Hemmecke <ralf@hemmecke.de>
User-Agent: Thunderbird 2.0.0.16 (X11/20080707)
MIME-Version: 1.0
To: daly@axiom-developer.org
References: <200808180457.m7I4vLWl014580@axiom-developer.org>
	<48A9239D.4000005@hemmecke.de>
	<200808181306.m7ID6e926562@localhost.localdomain>
In-Reply-To: <200808181306.m7ID6e926562@localhost.localdomain>
X-Sent-by-Hemmecke: ralf@hemmecke.de
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit
X-detected-kernel: by monty-python.gnu.org: Solaris 10 (beta)
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Executed Examples in documentation --->
	Testsuite
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 18 Aug 2008 12:15:31 -0000

>> You could also move some checking time to the users machine. At the time 
>> the documentation is rendered, the commands in ++E are executed and 
>> compared internally with the ++R stuff.
>> Since execution might take some time, first show the ++R output and 
>> spawn a background process that compares the output of ++E with ++R.
>> If that is equal, everything is fine. If it is different. That is a bug. 
>> So notify the user with all the information (about his system) that s/he 
>> should send to a bugtracker.
> 
> This could potentially introduce a lot of overhead into the execution
> of the )display operation command. The "map" function, for instance,
> has about 80 instances which would introduce 80 background executions.
> If we could do that in parallel (since each test is independent) this
> might make sense on a multicore machine. But we can certainly test at
> build time.

Of course you could (and should) test at build time. And failure 
probablility for doc execution tests is certainly low if a user installs 
for example a binary axiom debian package (that was tested at debian.org).

But you remember there were pages in hyperdoc that could be explicitly 
executed by pressing a button. So if that is connected to ++E and ++R 
that would not be a problem, because the user asked for it. Well of 
course, you must check that the user did not modify the ++E stuff before 
you compare with ++R.

Ralf



From MAILER-DAEMON Mon Aug 18 08:48:38 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KV4A2-0002Ra-FM
	for mharc-axiom-developer@gnu.org; Mon, 18 Aug 2008 08:48:38 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KV4A0-0002Qr-AG
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:48:36 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KV49z-0002PX-2u
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:48:35 -0400
Received: from [199.232.76.173] (port=45394 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KV49y-0002PP-R5
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:48:34 -0400
Received: from mx-7.zoominternet.net ([24.154.1.26]:53745
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KV49y-0002cl-MM
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:48:34 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=e3nQAW1Q4iEA:10 a=LgYztuhCWg4A:10
	a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=7GH13aSrQu40hJme2I0A:9 a=7AHZNz4iAToSqXtdRL8wKn97Gh0A:4
	a=qdAb7n3EwmoA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.45] ([24.154.1.45:35714] helo=pop-2.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 0F/E3-12184-39F69A84; Mon, 18 Aug 2008 08:48:19 -0400
Received: (qmail 17252 invoked from network); 18 Aug 2008 12:48:22 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-2.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 18 Aug 2008 12:48:22 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id m7IEDmI26606;
	Mon, 18 Aug 2008 10:13:48 -0400
Date: Mon, 18 Aug 2008 10:13:48 -0400
Message-Id: <200808181413.m7IEDmI26606@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: ralf@hemmecke.de
In-reply-to: <48A967BA.70101@hemmecke.de> (message from Ralf Hemmecke on Mon, 
	18 Aug 2008 14:14:50 +0200)
References: <200808180457.m7I4vLWl014580@axiom-developer.org>
	<48A9239D.4000005@hemmecke.de>
	<200808181306.m7ID6e926562@localhost.localdomain>
	<48A967BA.70101@hemmecke.de>
X-detected-kernel: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Executed Examples in documentation --->
	Testsuite
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 18 Aug 2008 12:48:37 -0000

>But you remember there were pages in hyperdoc that could be explicitly 
>executed by pressing a button. So if that is connected to ++E and ++R 
>that would not be a problem, because the user asked for it. Well of 
>course, you must check that the user did not modify the ++E stuff before 
>you compare with ++R.

I have a "layered" approach to the documentation depending on how
the user is approaching the problem of finding an answer.



Suppose the user is at the command prompt and needs function help:

In the algebra the ++E syntax is only used at the moment to provide
example output for the
  )display operation 
command. Your excellent suggestion integrates that into the testing.
Thus anything the user sees should have passed test in build.



Suppose the user is at the command prompt and needs domain help:

Some algebra files now have )help documentation that gets automatically
extracted and added to the system. So if a user wants help on domains
rather than operations then the 
   )help domain
ascii text documentation is available. These pages are extracted and
tested now as part of the standard build. Thus anything the user sees
should have passed test in build.


Suppose the user is in hyperdoc or firefox:


If the user is in hyperdoc then the usual tests are applied. This is
no longer automated (although it used to be at IBM). However, hyperdoc
pages are rarely ever changed as far as I can tell. Maybe the new PDF
format will make them easier to understand and change.

If the user is in Firefox then the pages are planned to be automatically
extracted and tested but this does not yet exist. There is still a large
buildout of new functionality. 

In either case I could modify the extraction function to elide the
++E/++R lines so testing can be inlined in the pages.




Suppose the user is trying to do a classroom task:

The .input files are used for testing at the moment but the plan is to
expand them into documentation for a particular problem in a
particular domain, as a whitepaper on some subject like doing Binary
Decision Diagrams (in process). These are intended to be more tutorial
in nature. Professors interested in teaching can create tutorials and
have them automatically tested.  Clearly the automated testing syntax
will survive here.




Suppose the user is trying to understand how it all works:

The final layer of documentation is the .pamphlet file PDFs which
will eventually contain all of the source code.




I could take your suggestion for the )display ++E/++R syntax and build
it into the PDF machinery. Currently the hyperdoc pages are taken
directly from the .pamphlet file and soon the firefox html pages will
also come directly from the .pamphlet file. I can modify the extraction
process to filter out the ++E/++R testing syntax lines automatically.
Then they do not show up in user displays but are automatically tested.

Tim



From MAILER-DAEMON Mon Aug 18 08:51:12 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KV4CW-0003Pt-Om
	for mharc-axiom-developer@gnu.org; Mon, 18 Aug 2008 08:51:12 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KV4CU-0003PD-Ke
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:51:10 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KV4CS-0003OU-Ux
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:51:09 -0400
Received: from [199.232.76.173] (port=45490 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KV4CS-0003OR-Ox
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:51:08 -0400
Received: from mx-7.zoominternet.net ([24.154.1.26]:53981
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KV4CS-0003KB-No
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 08:51:08 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=e3nQAW1Q4iEA:10 a=LgYztuhCWg4A:10
	a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=6vMUh3xYqkxMB1gwKNAA:9 a=hlyOW2Lt9dQEBSKZCX1xRslTIV0A:4
	a=WcGY3-TIXCwA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.44] ([24.154.1.44:59928] helo=pop-1.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id A8/EB-12184-D2079A84; Mon, 18 Aug 2008 08:50:54 -0400
Received: (qmail 20003 invoked from network); 18 Aug 2008 12:50:55 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-1.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 18 Aug 2008 12:50:55 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id m7IEGOr26617;
	Mon, 18 Aug 2008 10:16:24 -0400
Date: Mon, 18 Aug 2008 10:16:24 -0400
Message-Id: <200808181416.m7IEGOr26617@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: ralf@hemmecke.de
In-reply-to: <48A9660A.7010905@hemmecke.de> (message from Ralf Hemmecke on
	Mon, 18 Aug 2008 14:07:38 +0200)
References: <200808180457.m7I4vLWl014580@axiom-developer.org>
	<48A9239D.4000005@hemmecke.de>
	<200808181306.m7ID6e926562@localhost.localdomain>
	<48A9660A.7010905@hemmecke.de>
X-detected-kernel: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Executed Examples in documentation --->
	Testsuite
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 18 Aug 2008 12:51:10 -0000

>> Ideally the user just runs "bugreport" and everything gets sent to
>> us.
>
>Note that people want to see what gets sent to a remote site. No system 
>nowadays sends any information of the user system automatically, but 
>rather pop up a window. See for example how bugs are sent in firefox.

Oh, absolutely. All the wrapper program does is dump backtrace 
information. The BUG script would add that information to the body
of the email but the user would have to write and send the email bug.
There is no magic, just some automation of the tedious bits.

There is bug automation in firefox? Interesting. Perhaps I can use
the same mechanism in the new firefox frontend.

Tim



From MAILER-DAEMON Mon Aug 18 09:04:00 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KV4Ou-0000iy-K8
	for mharc-axiom-developer@gnu.org; Mon, 18 Aug 2008 09:04:00 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KV4Os-0000fc-Lm
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 09:03:58 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KV4Or-0000ck-5P
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 09:03:58 -0400
Received: from [199.232.76.173] (port=42058 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KV4Or-0000cU-0m
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 09:03:57 -0400
Received: from mo-p05-ob.rzone.de ([81.169.146.181]:50329)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <ralf@hemmecke.de>) id 1KV4Oq-0007RI-GO
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 09:03:56 -0400
X-RZG-CLASS-ID: mo05
X-RZG-AUTH: :PmQcMEitdvJk4Q5CJd22y2+5o33+jZtqGPj+dLDXdpIXuAlIRTZF+Phj0FJS
Received: from [193.170.38.119]
	(woodpecker.risc.uni-linz.ac.at [193.170.38.119])
	by post.webmailer.de (mrclete mo35) (RZmta 16.47)
	with ESMTP id a029a1k7IBAbLv ; Mon, 18 Aug 2008 15:03:45 +0200 (MEST)
	(envelope-from: <ralf@hemmecke.de>)
Message-ID: <48A97316.2060900@hemmecke.de>
Date: Mon, 18 Aug 2008 15:03:18 +0200
From: Ralf Hemmecke <ralf@hemmecke.de>
User-Agent: Thunderbird 2.0.0.16 (X11/20080707)
MIME-Version: 1.0
To: daly@axiom-developer.org
References: <200808180457.m7I4vLWl014580@axiom-developer.org>
	<48A9239D.4000005@hemmecke.de>
	<200808181306.m7ID6e926562@localhost.localdomain>
	<48A967BA.70101@hemmecke.de>
	<200808181413.m7IEDmI26606@localhost.localdomain>
In-Reply-To: <200808181413.m7IEDmI26606@localhost.localdomain>
X-Sent-by-Hemmecke: ralf@hemmecke.de
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit
X-detected-kernel: by monty-python.gnu.org: Solaris 10 (beta)
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Executed Examples in documentation --->
	Testsuite
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 18 Aug 2008 13:03:59 -0000

> process to filter out the ++E/++R testing syntax lines automatically.

The only thing where I am not so sure about is whether ++E/++R is the 
best syntax. As you may have seen in the ++ or +++ documentation, some 
people dont put a space after the last + so you parser might get confused.

Anyway. You remember that in ALLPROSE it don't write the ++ stuff at 
all. There is a LaTeX environment \begin{+++} ... \end{+++} with a 
certain additional structure. In particular it contains a section
\begin{usage}... \end{usage} which I currently only use to list commands 
that show how a function is to be applied, but, of course another 
environment could include executable code.

The +++ stuff is then generated from a .nw (.pamphlet) file, so that the 
compiler can access it.

All I want to say is. The +++ documentation should not be considered as 
a primary documentation format. It is too unstructured.

Ralf



From MAILER-DAEMON Mon Aug 18 09:04:29 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KV4PM-0001WS-Pl
	for mharc-axiom-developer@gnu.org; Mon, 18 Aug 2008 09:04:28 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KV4PL-0001UB-GY
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 09:04:27 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KV4PJ-0001S7-WE
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 09:04:27 -0400
Received: from [199.232.76.173] (port=42077 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KV4PJ-0001Ry-Sx
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 09:04:25 -0400
Received: from mx-8.zoominternet.net ([24.154.1.27]:39043
	helo=cm-2.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KV4PJ-0007ap-I9
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 09:04:25 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=e3nQAW1Q4iEA:10 a=LgYztuhCWg4A:10
	a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=ozV_q4esNdyemAYNeDMA:9 a=nbvsP6XLRV669epcr8cvMOub5rgA:4
	a=LY0hPdMaydYA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.47] ([24.154.1.47:34237] helo=pop-4.zoominternet.net)
	by mx-8.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 96/82-32526-C4379A84; Mon, 18 Aug 2008 09:04:12 -0400
Received: (qmail 10305 invoked from network); 18 Aug 2008 13:04:14 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-4.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 18 Aug 2008 13:04:14 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id m7IETcl26629;
	Mon, 18 Aug 2008 10:29:38 -0400
Date: Mon, 18 Aug 2008 10:29:38 -0400
Message-Id: <200808181429.m7IETcl26629@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: ralf@hemmecke.de
In-reply-to: <48A967BA.70101@hemmecke.de> (message from Ralf Hemmecke on Mon, 
	18 Aug 2008 14:14:50 +0200)
References: <200808180457.m7I4vLWl014580@axiom-developer.org>
	<48A9239D.4000005@hemmecke.de>
	<200808181306.m7ID6e926562@localhost.localdomain>
	<48A967BA.70101@hemmecke.de>
X-detected-kernel: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Executed Examples in documentation --->
	Testsuite
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 18 Aug 2008 13:04:27 -0000

One "hole" in the documentation layering is that the )help files
should show examples of the use of every function in the export list.
This is currently not the case and I'll look at fixing that as part
of the display test cases.

Tim



From MAILER-DAEMON Mon Aug 18 09:05:57 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KV4Qn-0003Oy-9v
	for mharc-axiom-developer@gnu.org; Mon, 18 Aug 2008 09:05:57 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KV4Ql-0003LP-2W
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 09:05:55 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KV4Qi-0003FV-2m
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 09:05:54 -0400
Received: from [199.232.76.173] (port=42122 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KV4Qh-0003FI-UV
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 09:05:51 -0400
Received: from mo-p05-ob.rzone.de ([81.169.146.182]:38742)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <ralf@hemmecke.de>) id 1KV4Qh-00083g-9K
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 09:05:51 -0400
X-RZG-CLASS-ID: mo05
X-RZG-AUTH: :PmQcMEitdvJk4Q5CJd22y2+5o33+jZtqGPj+dLDXdpIXuAlIRTZF+Phj0FJS
Received: from [193.170.38.119]
	(woodpecker.risc.uni-linz.ac.at [193.170.38.119])
	by post.webmailer.de (klopstock mo33) (RZmta 16.47)
	with ESMTP id c00472k7IALaMo ; Mon, 18 Aug 2008 15:05:39 +0200 (MEST)
	(envelope-from: <ralf@hemmecke.de>)
Message-ID: <48A97389.3060502@hemmecke.de>
Date: Mon, 18 Aug 2008 15:05:13 +0200
From: Ralf Hemmecke <ralf@hemmecke.de>
User-Agent: Thunderbird 2.0.0.16 (X11/20080707)
MIME-Version: 1.0
To: root <daly@axiom-developer.org>
References: <200808180457.m7I4vLWl014580@axiom-developer.org>
	<48A9239D.4000005@hemmecke.de>
	<200808181306.m7ID6e926562@localhost.localdomain>
	<48A9660A.7010905@hemmecke.de>
	<200808181416.m7IEGOr26617@localhost.localdomain>
In-Reply-To: <200808181416.m7IEGOr26617@localhost.localdomain>
X-Sent-by-Hemmecke: ralf@hemmecke.de
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit
X-detected-kernel: by monty-python.gnu.org: Solaris 10 (beta)
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Executed Examples in documentation --->
	Testsuite
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 18 Aug 2008 13:05:55 -0000

> There is bug automation in firefox? Interesting. Perhaps I can use
> the same mechanism in the new firefox frontend.

Well, you have to wait until your firefox crashes... which happened a 
couple of times to me.

Ralf



From MAILER-DAEMON Mon Aug 18 11:43:41 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KV6tR-0004C2-54
	for mharc-axiom-developer@gnu.org; Mon, 18 Aug 2008 11:43:41 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KV6tO-0004AS-9y
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 11:43:38 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KV6tM-00049H-Pe
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 11:43:37 -0400
Received: from [199.232.76.173] (port=36422 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KV6tM-00048z-Ix
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 11:43:36 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:46836
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KV6tL-0004Gv-Qi
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 11:43:36 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7IFhXr3003693;
	Mon, 18 Aug 2008 10:43:33 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7IFhXQg003690;
	Mon, 18 Aug 2008 10:43:33 -0500
Date: Mon, 18 Aug 2008 10:43:33 -0500
Message-Id: <200808181543.m7IFhXQg003690@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080817.03.tpd.patch (exported function
	documentation)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 18 Aug 2008 15:43:38 -0000

The following exposed functions now have )display op documentation:

CartesianTensor: ravel, leviCivitaSymbol, *, kroneckerDelta, reindex,
                 transpose, contract, product, elt, rank, coerce
CardinalNumber: -, **, generalizedContinuumHypothesisAssumed,
                generalizedContinuumHypothesisAssumed?, countable?
                finite, Aleph
BinaryExpansion: binary
InputForm: binary
ExtensibleLinearAggregate: delete!
TableAggregate: table

=======================================================================
diff --git a/changelog b/changelog
index ea20f30..f2bd54b 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,25 @@
+20080817 tpd src/algebra/vector.spad doc ravel from CartesianTensor
+20080817 tpd src/algebra/vector.spad doc leviCivitaSymbol from CartesianTensor
+20080817 tpd src/algebra/vector.spad doc * from CartesianTensor
+20080817 tpd src/algebra/vector.spad doc kroneckerDelta from CartesianTensor
+20080817 tpd src/algebra/vector.spad doc reindex from CartesianTensor
+20080817 tpd src/algebra/vector.spad doc transpose from CartesianTensor
+20080817 tpd src/algebra/vector.spad doc contract from CartesianTensor
+20080817 tpd src/algebra/vector.spad doc product from CartesianTensor
+20080817 tpd src/algebra/vector.spad doc elt from CartesianTensor
+20080817 tpd src/algebra/vector.spad doc rank from CartesianTensor
+20080817 tpd src/algebra/vector.spad doc coerce from CartesianTensor
+20080817 tpd src/algebra/card.spad doc - from CardinalNumber
+20080817 tpd src/algebra/card.spad doc ** from CardinalNumber
+20080817 tpd src/algebra/card.spad doc generalizedContinuumHypothesisAssumed
+20080817 tpd src/algebra/card.spad doc generalizedContinuumHypothesisAssumed?
+20080817 tpd src/algebra/card.spad doc countable? from CardinalNumber
+20080817 tpd src/algebra/card.spad doc finite? from CardinalNumber
+20080817 tpd src/algebra/card.spad doc Aleph from CardinalNumber
+20080817 tpd src/algebra/radix.spad doc binary from BinaryExpansion
+20080817 tpd src/algebra/mkfunc.spad doc binary from InputForm
+20080817 tpd src/algebra/aggcat.spad doc delete! ExtensibleLinearAggregate
+20080817 tpd src/algebra/aggcat.spad doc table from TableAggregate
 20080817 tpd src/input/Makefile add function.regress
 20080817 tpd src/input/function.input fix problems with input file
 20080817 tpd books/bookvol7.1 fix uncompress
diff --git a/src/algebra/aggcat.spad.pamphlet b/src/algebra/aggcat.spad.pamphlet
index ae221f4..0719be4 100644
--- a/src/algebra/aggcat.spad.pamphlet
+++ b/src/algebra/aggcat.spad.pamphlet
@@ -1218,6 +1218,11 @@ TableAggregate(Key:SetCategory, Entry:SetCategory): Category ==
      ++ to \axiom{(insert([k,e],t); e)}.
    table: () -> %
      ++ table()$T creates an empty table of type T.
+     ++
+     ++E Data:=Record(age:Integer,gender:String)
+     ++E a1:AssociationList(String,Data):=table()
+     ++E a1."tim":=[55,"male"]$Data
+
    table: List Record(key:Key,entry:Entry) -> %
      ++ table([x,y,...,z]) creates a table consisting of entries
      ++ \axiom{x,y,...,z}.
@@ -2604,6 +2609,12 @@ ExtensibleLinearAggregate(S:Type):Category == LinearAggregate S with
      ++ v is unchanged
    delete_!: (%,Integer) -> %
      ++ delete!(u,i) destructively deletes the \axiom{i}th element of u.
+     ++
+     ++E Data:=Record(age:Integer,gender:String)
+     ++E a1:AssociationList(String,Data):=table()
+     ++E a1."tim":=[55,"male"]$Data
+     ++E delete!(a1,1)
+
    delete_!: (%,UniversalSegment(Integer)) -> %
      ++ delete!(u,i..j) destructively deletes elements u.i through u.j.
    remove_!: (S->Boolean,%) -> %
diff --git a/src/algebra/card.spad.pamphlet b/src/algebra/card.spad.pamphlet
index 4d02a4d..14c1ae9 100644
--- a/src/algebra/card.spad.pamphlet
+++ b/src/algebra/card.spad.pamphlet
@@ -376,33 +376,67 @@ CardinalNumber: Join(OrderedSet, AbelianMonoid, Monoid,
         commutative "*"
             ++ a domain D has \spad{commutative("*")} if it has an operation
             ++ \spad{"*": (D,D) -> D} which is commutative.
+
         "-": (%,%) -> Union(%,"failed")
-           ++ \spad{x - y} returns an element z such that \spad{z+y=x} or "failed" 
-           ++ if no such element exists.
+            ++ \spad{x - y} returns an element z such that 
+            ++ \spad{z+y=x} or "failed" if no such element exists.
+            ++
+            ++E c2:=2::CardinalNumber
+            ++E c2-c2
+            ++E A1:=Aleph 1
+            ++E A1-c2
+
         "**": (%, %) -> %
             ++ \spad{x**y} returns \spad{#(X**Y)} where \spad{X**Y} is defined
             ++  as \spad{\{g| g:Y->X\}}.
+            ++
+            ++E c2:=2::CardinalNumber
+            ++E c2**c2
+            ++E A1:=Aleph 1
+            ++E A1**c2
+            ++E generalizedContinuumHypothesisAssumed true
+            ++E A1**A1
 
         Aleph: NonNegativeInteger -> %
             ++ Aleph(n) provides the named (infinite) cardinal number.
+            ++
+            ++E A0:=Aleph 0
 
         finite?: % -> Boolean
             ++ finite?(\spad{a}) determines whether 
-            ++ \spad{a} is a finite cardinal,
-            ++ i.e. an integer.
+            ++ \spad{a} is a finite cardinal, i.e. an integer.
+            ++
+            ++E c2:=2::CardinalNumber
+            ++E finite? c2
+            ++E A0:=Aleph 0
+            ++E finite? A0
 
         countable?: % -> Boolean
             ++ countable?(\spad{a}) determines 
             ++ whether \spad{a} is a countable cardinal,
             ++ i.e. an integer or \spad{Aleph 0}.
+            ++
+            ++E c2:=2::CardinalNumber
+            ++E countable? c2
+            ++E A0:=Aleph 0
+            ++E countable? A0
+            ++E A1:=Aleph 1
+            ++E countable? A1
 
         generalizedContinuumHypothesisAssumed?: () -> Boolean
             ++ generalizedContinuumHypothesisAssumed?()
             ++ tests if the hypothesis is currently assumed.
+            ++
+            ++E generalizedContinuumHypothesisAssumed?
 
         generalizedContinuumHypothesisAssumed:  Boolean -> Boolean
             ++ generalizedContinuumHypothesisAssumed(bool)
             ++ is used to dictate whether the hypothesis is to be assumed.
+            ++
+            ++E generalizedContinuumHypothesisAssumed true
+            ++E a:=Aleph 0
+            ++E c:=2**a
+            ++E f:=2**c
     == add
         NNI ==> NonNegativeInteger
         FINord   ==> -1
diff --git a/src/algebra/carten.spad.pamphlet b/src/algebra/carten.spad.pamphlet
index 5dfedb0..8d39805 100644
--- a/src/algebra/carten.spad.pamphlet
+++ b/src/algebra/carten.spad.pamphlet
@@ -1082,42 +1082,108 @@ CartesianTensor(minix, dim, R): Exports == Implementation where
 
         coerce: DP(dim, R) -> %
             ++ coerce(v) views a vector as a rank 1 tensor.
+            ++
+            ++E v:DirectProduct(2,Integer):=directProduct [3,4]
+            ++E tv:CartesianTensor(1,2,Integer):=v
+
         coerce: SM(dim, R)  -> %
             ++ coerce(m) views a matrix as a rank 2 tensor.
+            ++
+            ++E v:SquareMatrix(2,Integer):=[[1,2],[3,4]]
+            ++E tv:CartesianTensor(1,2,Integer):=v
 
         coerce: List R -> %
             ++ coerce([r_1,...,r_dim]) allows tensors to be constructed
             ++ using lists.
+            ++
+            ++E v:=[2,3]
+            ++E tv:CartesianTensor(1,2,Integer):=v
 
         coerce: List % -> %
             ++ coerce([t_1,...,t_dim]) allows tensors to be constructed
             ++ using lists.
+            ++
+            ++E v:=[2,3]
+            ++E tv:CartesianTensor(1,2,Integer):=v
+            ++E tm:CartesianTensor(1,2,Integer):=[tv,tv]
 
         rank: % -> NNI
             ++ rank(t) returns the tensorial rank of t (that is, the
             ++ number of indices).  This is the same as the graded module
             ++ degree.
+            ++
+            ++E CT:=CARTEN(1,2,Integer)
+            ++E t0:CT:=8
+            ++E rank t0
 
         elt: (%) -> R
             ++ elt(t) gives the component of a rank 0 tensor.
+            ++
+            ++E tv:CartesianTensor(1,2,Integer):=8
+            ++E elt(tv)
+            ++E tv[]
+
         elt: (%, I) -> R
             ++ elt(t,i) gives a component of a rank 1 tensor.
+            ++
+            ++E v:=[2,3]
+            ++E tv:CartesianTensor(1,2,Integer):=v
+            ++E elt(tv,2)
+            ++E tv[2]
+
         elt: (%, I, I) -> R
             ++ elt(t,i,j) gives a component of a rank 2 tensor.
+            ++
+            ++E v:=[2,3]
+            ++E tv:CartesianTensor(1,2,Integer):=v
+            ++E tm:CartesianTensor(1,2,Integer):=[tv,tv]
+            ++E elt(tm,2,2)
+            ++E tm[2,2]
+
         elt: (%, I, I, I) -> R
             ++ elt(t,i,j,k) gives a component of a rank 3 tensor.
+            ++
+            ++E v:=[2,3]
+            ++E tv:CartesianTensor(1,2,Integer):=v
+            ++E tm:CartesianTensor(1,2,Integer):=[tv,tv]
+            ++E tn:CartesianTensor(1,2,Integer):=[tm,tm]
+            ++E elt(tn,2,2,2)
+            ++E tn[2,2,2]
+
         elt: (%, I, I, I, I) -> R
             ++ elt(t,i,j,k,l) gives a component of a rank 4 tensor.
+            ++
+            ++E v:=[2,3]
+            ++E tv:CartesianTensor(1,2,Integer):=v
+            ++E tm:CartesianTensor(1,2,Integer):=[tv,tv]
+            ++E tn:CartesianTensor(1,2,Integer):=[tm,tm]
+            ++E tp:CartesianTensor(1,2,Integer):=[tn,tn]
+            ++E elt(tp,2,2,2,2)
+            ++E tp[2,2,2,2]
 
         elt: (%, List I) -> R
             ++ elt(t,[i1,...,iN]) gives a component of a rank \spad{N} tensor.
+            ++
+            ++E v:=[2,3]
+            ++E tv:CartesianTensor(1,2,Integer):=v
+            ++E tm:CartesianTensor(1,2,Integer):=[tv,tv]
+            ++E tn:CartesianTensor(1,2,Integer):=[tm,tm]
+            ++E tp:CartesianTensor(1,2,Integer):=[tn,tn]
+            ++E tq:CartesianTensor(1,2,Integer):=[tp,tp]
+            ++E elt(tq,[2,2,2,2,2])
 
         -- This specializes the documentation from GradedAlgebra.
         product: (%,%) -> %
             ++ product(s,t) is the outer product of the tensors s and t.
-            ++ For example, if \spad{r = product(s,t)} for rank 2 tensors s and t,
-            ++ then \spad{r} is a rank 4 tensor given by
+            ++ For example, if \spad{r = product(s,t)} for rank 2 tensors 
+            ++ s and t, then \spad{r} is a rank 4 tensor given by
             ++     \spad{r(i,j,k,l) = s(i,j)*t(k,l)}.
+            ++
+            ++E m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
+            ++E Tm:CartesianTensor(1,2,Integer):=m
+            ++E n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]]
+            ++E Tn:CartesianTensor(1,2,Integer):=n
+            ++E Tmn:=product(Tm,Tn)
 
         "*": (%, %) -> %
             ++ s*t is the inner product of the tensors s and t which contracts
@@ -1126,6 +1192,12 @@ CartesianTensor(minix, dim, R): Exports == Implementation where
             ++     \spad{t*s = sum(k=1..N, t[i1,..,iN,k]*s[k,j1,..,jM])}
             ++ This is compatible with the use of \spad{M*v} to denote
             ++ the matrix-vector inner product.
+            ++
+            ++E m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
+            ++E Tm:CartesianTensor(1,2,Integer):=m
+            ++E v:DirectProduct(2,Integer):=directProduct [3,4]
+            ++E Tv:CartesianTensor(1,2,Integer):=v
+            ++E Tm*Tv
 
         contract:  (%, Integer, %, Integer) -> %
             ++ contract(t,i,s,j) is the inner product of tenors s and t
@@ -1135,6 +1207,12 @@ CartesianTensor(minix, dim, R): Exports == Implementation where
             ++ rank 3 tensors \spad{s} and \spad{t}, then \spad{r} is
             ++ the rank 4 \spad{(= 3 + 3 - 2)} tensor  given by
             ++     \spad{r(i,j,k,l) = sum(h=1..dim,s(i,h,j)*t(h,k,l))}.
+            ++
+            ++E m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
+            ++E Tm:CartesianTensor(1,2,Integer):=m
+            ++E v:DirectProduct(2,Integer):=directProduct [3,4]
+            ++E Tv:CartesianTensor(1,2,Integer):=v
+            ++E Tmv:=contract(Tm,2,Tv,1)
 
         contract:  (%, Integer, Integer)    -> %
             ++ contract(t,i,j) is the contraction of tensor t which
@@ -1143,18 +1221,34 @@ CartesianTensor(minix, dim, R): Exports == Implementation where
             ++ \spad{r = contract(t,1,3)} for a rank 4 tensor t, then
             ++ \spad{r} is the rank 2 \spad{(= 4 - 2)} tensor given by
             ++     \spad{r(i,j) = sum(h=1..dim,t(h,i,h,j))}.
+            ++
+            ++E m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
+            ++E Tm:CartesianTensor(1,2,Integer):=m
+            ++E v:DirectProduct(2,Integer):=directProduct [3,4]
+            ++E Tv:CartesianTensor(1,2,Integer):=v
+            ++E Tmv:=contract(Tm,2,1)
 
         transpose: % -> %
             ++ transpose(t) exchanges the first and last indices of t.
-            ++ For example, if \spad{r = transpose(t)} for a rank 4 tensor t, then
-            ++ \spad{r} is the rank 4 tensor given by
+            ++ For example, if \spad{r = transpose(t)} for a rank 4 
+            ++ tensor t, then \spad{r} is the rank 4 tensor given by
             ++     \spad{r(i,j,k,l) = t(l,j,k,i)}.
+            ++
+            ++E m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
+            ++E Tm:CartesianTensor(1,2,Integer):=m
+            ++E transpose(Tm)
 
         transpose: (%, Integer, Integer) -> %
-            ++ transpose(t,i,j) exchanges the \spad{i}-th and \spad{j}-th indices of t.
-            ++ For example, if \spad{r = transpose(t,2,3)} for a rank 4 tensor t, then
-            ++ \spad{r} is the rank 4 tensor given by
+            ++ transpose(t,i,j) exchanges the \spad{i}-th and \spad{j}-th 
+            ++ indices of t. For example, if \spad{r = transpose(t,2,3)} 
+            ++ for a rank 4 tensor t, then \spad{r} is the rank 4 tensor 
+            ++ given by
             ++     \spad{r(i,j,k,l) = t(i,k,j,l)}.
+            ++
+            ++E m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
+            ++E tm:CartesianTensor(1,2,Integer):=m
+            ++E tn:CartesianTensor(1,2,Integer):=[tm,tm]
+            ++E transpose(tn,1,2)
 
         reindex: (%, List Integer) -> %
             ++ reindex(t,[i1,...,idim]) permutes the indices of t.
@@ -1162,21 +1256,35 @@ CartesianTensor(minix, dim, R): Exports == Implementation where
             ++ for a rank 4 tensor t,
             ++ then \spad{r} is the rank for tensor given by
             ++     \spad{r(i,j,k,l) = t(l,i,j,k)}.
-
+            ++ 
+            ++E n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]]
+            ++E tn:CartesianTensor(1,2,Integer):=n
+            ++E p:=product(tn,tn)
+            ++E reindex(p,[4,3,2,1])
+ 
         kroneckerDelta:  () -> %
             ++ kroneckerDelta() is the rank 2 tensor defined by
             ++    \spad{kroneckerDelta()(i,j)}
             ++       \spad{= 1  if i = j}
             ++       \spad{= 0 if  i \^= j}
+            ++ 
+            ++E delta:CartesianTensor(1,2,Integer):=kroneckerDelta()
 
         leviCivitaSymbol: () -> %
             ++ leviCivitaSymbol() is the rank \spad{dim} tensor defined by
             ++ \spad{leviCivitaSymbol()(i1,...idim) = +1/0/-1}
             ++ if \spad{i1,...,idim} is an even/is nota /is an odd permutation
             ++ of \spad{minix,...,minix+dim-1}.
+            ++ 
+            ++E lcs:CartesianTensor(1,2,Integer):=leviCivitaSymbol()
+
         ravel:     % -> List R
             ++ ravel(t) produces a list of components from a tensor such that
             ++   \spad{unravel(ravel(t)) = t}.
+            ++ 
+            ++E n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]]
+            ++E tn:CartesianTensor(1,2,Integer):=n
+            ++E ravel tn
 
         unravel:   List R -> %
             ++ unravel(t) produces a tensor from a list of
diff --git a/src/algebra/mkfunc.spad.pamphlet b/src/algebra/mkfunc.spad.pamphlet
index e6db6f4..840aa2e 100644
--- a/src/algebra/mkfunc.spad.pamphlet
+++ b/src/algebra/mkfunc.spad.pamphlet
@@ -33,6 +33,10 @@ InputForm():
     binary   : (%, List %) -> %
       ++ \spad{binary(op, [a1,...,an])} returns the input form
       ++ corresponding to  \spad{a1 op a2 op ... op an}.
+      ++
+      ++E a:=[1,2,3]::List(InputForm)
+      ++E binary(_+::InputForm,a)
+
     function : (%, List Symbol, Symbol) -> %
       ++ \spad{function(code, [x1,...,xn], f)} returns the input form
       ++ corresponding to \spad{f(x1,...,xn) == code}.
diff --git a/src/algebra/radix.spad.pamphlet b/src/algebra/radix.spad.pamphlet
index 1e76d86..28185f1 100644
--- a/src/algebra/radix.spad.pamphlet
+++ b/src/algebra/radix.spad.pamphlet
@@ -344,7 +344,7 @@ RadixExpansion(bb): Exports == Implementation where
     fractRadix: (List Integer, List Integer) -> %
       ++ fractRadix(pre,cyc) creates a fractional radix expansion
       ++ from a list of prefix ragits and a list of cyclic ragits.
-      ++ For example, \spad{fractRadix([1],[6])} will return \spad{0.16666666...}.
+      ++ e.g., \spad{fractRadix([1],[6])} will return \spad{0.16666666...}.
 
   Implementation ==> add
     -- The efficiency of arithmetic operations is poor.
@@ -723,6 +723,8 @@ BinaryExpansion(): Exports == Implementation where
       ++ fractionPart(b) returns the fractional part of a binary expansion.
     binary: Fraction Integer -> %
       ++ binary(r) converts a rational number to a binary expansion.
+      ++
+      ++E binary(22/7)
 
   Implementation ==> RadixExpansion(2) add
     binary r == r :: %



From MAILER-DAEMON Mon Aug 18 16:03:04 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KVAwR-0002Ka-SU
	for mharc-axiom-developer@gnu.org; Mon, 18 Aug 2008 16:03:03 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KVAwP-0002HC-MD
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 16:03:01 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KVAwL-00029Q-Ry
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 16:03:01 -0400
Received: from [199.232.76.173] (port=43853 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KVAwL-000291-DW
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 16:02:57 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:46184
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KVAwK-0008JH-O3
	for axiom-developer@nongnu.org; Mon, 18 Aug 2008 16:02:57 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7IK2pr3013737;
	Mon, 18 Aug 2008 15:02:51 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7IK2p22013734;
	Mon, 18 Aug 2008 15:02:51 -0500
Date: Mon, 18 Aug 2008 15:02:51 -0500
Message-Id: <200808182002.m7IK2p22013734@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080818.01.rhx.patch (demo Axiom type towers
	(Hemmecke))
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 18 Aug 2008 20:03:02 -0000

Demo the Axiom type towers. 
=======================================================================
diff --git a/changelog b/changelog
index f2bd54b..04a4914 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,5 @@
+20080818 tpd src/input/Makefile typetower.input added
+20080818 rhx src/input/typetower.input added
 20080817 tpd src/algebra/vector.spad doc ravel from CartesianTensor
 20080817 tpd src/algebra/vector.spad doc leviCivitaSymbol from CartesianTensor
 20080817 tpd src/algebra/vector.spad doc * from CartesianTensor
diff --git a/src/input/Makefile.pamphlet b/src/input/Makefile.pamphlet
index a4d2218..e70b0d9 100644
--- a/src/input/Makefile.pamphlet
+++ b/src/input/Makefile.pamphlet
@@ -370,7 +370,7 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     tanhcoth.regress  tanatan.regress  tbagg.regress    test.regress \
     textfile.regress  torus.regress \
     triglim.regress   tsetcatvermeer.regress            tutchap1.regress \
-    void.regress      uniseg.regress
+    typetower.regress void.regress      uniseg.regress
 
 IN=     ${SRC}/input
 MID=	${INT}/input
@@ -664,7 +664,8 @@ FILES= ${OUT}/algaggr.input  ${OUT}/algbrbf.input    ${OUT}/algfacob.input \
        ${OUT}/triglim.input  ${OUT}/tschirn.input ${OUT}/tsetcatbutcher.input \
        ${OUT}/tsetcatchemical.input ${OUT}/tsetcatvermeer.input \
        ${OUT}/tutchap1.input ${OUT}/tutchap2.input   ${OUT}/tutchap3.input \
-       ${OUT}/tutchap4.input ${OUT}/tutchap67.input  ${OUT}/typo.input     \
+       ${OUT}/tutchap4.input ${OUT}/tutchap67.input  ${OUT}/typetower.input \
+       ${OUT}/typo.input     \
        ${OUT}/uniseg.input   ${OUT}/up.input \
        ${OUT}/vector.input   ${OUT}/vectors.input    ${OUT}/viewdef.input \
        ${OUT}/void.input     ${OUT}/wiggle.input   \
@@ -1011,7 +1012,8 @@ DOCFILES= \
   ${DOC}/tsetcatvermeer.input.dvi    \
   ${DOC}/tutchap1.input.dvi    ${DOC}/tutchap2.input.dvi   \
   ${DOC}/tutchap3.input.dvi    ${DOC}/tutchap4.input.dvi   \
-  ${DOC}/tutchap67.input.dvi   ${DOC}/typo.input.dvi       \
+  ${DOC}/tutchap67.input.dvi   ${DOC}/typetower.input.dvi  \
+  ${DOC}/typo.input.dvi       \
   ${DOC}/uniseg.input.dvi      ${DOC}/up.input.dvi         \
   ${DOC}/vector.input.dvi      ${DOC}/vectors.input.dvi    \
   ${DOC}/viewdef.input.dvi     ${DOC}/void.input.dvi       \
diff --git a/src/input/typetower.input.pamphlet b/src/input/typetower.input.pamphlet
new file mode 100644
index 0000000..260d206
--- /dev/null
+++ b/src/input/typetower.input.pamphlet
@@ -0,0 +1,253 @@
+\documentclass{article}
+\usepackage{axiom}
+\begin{document}
+\title{\$SPAD/src/input typetower.input}
+\author{Ralf Hemmecke}
+\maketitle
+\begin{abstract}
+This page demonstrates some features of Axiom.
+\end{abstract}
+\eject
+\tableofcontents
+\eject
+@
+Let's begin with the construction of a polynomial ring $R$ in the
+indeterminate $z$ with coefficients from the ring $S$ of square
+matrices with entries that are polynomials $P=F[x]$ where $F$ is
+the Galois field with 3 elements.
+<<*>>=
+)spool typetower.output
+)set message test on
+)set message auto off
+)clear all
+ 
+--S 1 of 17
+F:=PrimeField 3
+--R 
+--R
+--R   (1)  PrimeField 3
+--R                                                                 Type: Domain
+--E 1
+
+--S 2 of 17
+P:=UnivariatePolynomial(x,F)
+--R 
+--R
+--R   (2)  UnivariatePolynomial(x,PrimeField 3)
+--R                                                                 Type: Domain
+--E 2
+
+--S 3 of 17
+S:=SquareMatrix(2,P)
+--R 
+--R
+--R   (3)  SquareMatrix(2,UnivariatePolynomial(x,PrimeField 3))
+--R                                                                 Type: Domain
+--E 3
+
+--S 4 of 17
+R:=UnivariatePolynomial(z,S)
+--R 
+--R
+--R   (4)
+--R   UnivariatePolynomial(z,SquareMatrix(2,UnivariatePolynomial(x,PrimeField 3)))
+--R                                                                 Type: Domain
+--E 4
+
+@
+Ok, now we have the type $R$. Let's construct an element. We start
+with constructing some coefficients first.
+<<*>>=
+
+--S 5 of 17
+s1:S:=matrix [[2*x+1,x^2-1],[0,x-1]]
+--R 
+--R
+--R        +         2    +
+--R   (5)  |2x + 1  x  + 2|
+--R        |              |
+--R        +  0     x + 2 +
+--R                   Type: SquareMatrix(2,UnivariatePolynomial(x,PrimeField 3))
+--E 5
+
+--S 6 of 17
+s2:=transpose s1
+--R 
+--R
+--R        +2x + 1    0  +
+--R   (6)  |             |
+--R        | 2           |
+--R        +x  + 2  x + 2+
+--R                   Type: SquareMatrix(2,UnivariatePolynomial(x,PrimeField 3))
+--E 6
+
+@
+And now we build the polynomial
+<<*>>=
+
+--S 7 of 17
+r:R:=z^2+s1*z+s2
+--R 
+--R
+--R         2   +         2    +    +2x + 1    0  +
+--R   (7)  z  + |2x + 1  x  + 2|z + |             |
+--R             |              |    | 2           |
+--R             +  0     x + 2 +    +x  + 2  x + 2+
+--RType: UnivariatePolynomial(z,SquareMatrix(2,UnivariatePolynomial(x,PrimeField 3)))
+--E 7
+
+@
+Of course, since we work in characteristic 3, the following sum must be zero
+<<*>>=
+--S 8 of 17
+r+2*r
+--R 
+--R
+--R   (8)  0
+--RType: UnivariatePolynomial(z,SquareMatrix(2,UnivariatePolynomial(x,PrimeField 3)))
+--E 8
+
+@
+Note that this is not the integer 0, but it is still a polynomial of type $R$.
+Asking for the degree of $r$ is no problem, because $R$ is a univariate 
+polynomial ring.
+<<*>>=
+
+--S 9 of 17
+degree r
+--R 
+--R
+--R   (9)  2
+--R                                                        Type: PositiveInteger
+--E 9
+
+@
+So let's see what happens if we multiply $r$ by itself.
+<<*>>=
+
+--S 10 of 17
+r2:=r*r
+--R 
+--R
+--R   (10)
+--R                               + 2             +     + 4              +
+--R      4   +         2    + 3   |x  + 2x    0   | 2   |x  + 2x     0   |
+--R     z  + |x + 2  2x  + 1|z  + |               |z  + |                |z
+--R          |              |     |  2       2    |     |          4     |
+--R          +  0    2x + 1 +     +2x  + 1  x  + 2+     +   0     x  + 2x+
+--R   + 
+--R     + 2                    +
+--R     |x  + x + 1      0     |
+--R     |                      |
+--R     |             2        |
+--R     +    0       x  + x + 1+
+--RType: UnivariatePolynomial(z,SquareMatrix(2,UnivariatePolynomial(x,PrimeField 3)))
+--E 10
+
+@
+Well, of course there is a common factor of $r_2$ and $r$. Can Axiom find it?
+<<*>>=
+
+--S 11 of 17
+gcd(r2,r)
+--R 
+--R   There are 4 exposed and 3 unexposed library operations named gcd 
+--R      having 2 argument(s) but none was determined to be applicable. 
+--R      Use HyperDoc Browse, or issue
+--R                               )display op gcd
+--R      to learn more about the available operations. Perhaps 
+--R      package-calling the operation or using coercions on the arguments
+--R      will allow you to apply the operation.
+--R 
+--RDaly Bug
+--R   Cannot find a definition or applicable library operation named gcd 
+--R      with argument type(s) 
+--RUnivariatePolynomial(z,SquareMatrix(2,UnivariatePolynomial(x,PrimeField 3)))
+--RUnivariatePolynomial(z,SquareMatrix(2,UnivariatePolynomial(x,PrimeField 3)))
+--R      
+--R      Perhaps you should use "@" to indicate the required return type, 
+--R      or "$" to specify which version of the function you need.
+--E 11
+
+@
+Ooops. What does that say?
+\begin{verbatim}
+  Cannot find a definition or applicable library operation named gcd
+\end{verbatim}
+Ah, of course, the coefficient ring of $R$ is the matrix ring $S$ and this
+is unfortunately not a field (not even an integral domain) so we cannot
+simply apply Euclid's algorithm. Axiom simply stops by telling you 
+that there is no applicable operation.
+
+Of course, Axiom can compute a gcd of univariate polynmials.
+<<*>>=
+
+--S 12 of 17
+p1:=s1(1,1)
+--R 
+--R
+--R   (11)  2x + 1
+--R                                   Type: UnivariatePolynomial(x,PrimeField 3)
+--E 12
+
+--S 13 of 17
+ps:=s1(1,2)
+--R 
+--R
+--R          2
+--R   (12)  x  + 2
+--R                                   Type: UnivariatePolynomial(x,PrimeField 3)
+--E 13
+
+--S 14 of 17
+gcd(p1,p2)
+--R 
+--R
+--R   (13)  1
+--R          Type: UnivariatePolynomial(p2,UnivariatePolynomial(x,PrimeField 3))
+--E 14
+
+@
+Ok, let us do that again
+<<*>>=
+
+--S 15 of 17
+q1:UP(x,INT):=2*x+1
+--R 
+--R
+--R   (14)  2x + 1
+--R                                        Type: UnivariatePolynomial(x,Integer)
+--E 15
+
+--S 16 of 17
+q2:UP(x,INT):=x^2+2
+--R 
+--R
+--R          2
+--R   (15)  x  + 2
+--R                                        Type: UnivariatePolynomial(x,Integer)
+--E 16
+
+--S 17 of 17
+gcd(q1,q2)
+--R 
+--R
+--R   (16)  1
+--R                                        Type: UnivariatePolynomial(x,Integer)
+--E 17
+
+@
+Nice! Depending on where I compute these polynomials either they have
+a common factor or are coprime. Well, it all depends on the underlying
+ring, of course.
+<<*>>=
+
+)spool 
+)lisp (bye)
+ 
+@
+\eject
+\begin{thebibliography}{99}
+\bibitem{1} nothing
+\end{thebibliography}
+\end{document}



From MAILER-DAEMON Tue Aug 19 00:16:52 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KVIeK-0007c1-Ey
	for mharc-axiom-developer@gnu.org; Tue, 19 Aug 2008 00:16:52 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KVIeI-0007bw-4u
	for axiom-developer@nongnu.org; Tue, 19 Aug 2008 00:16:50 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KVIeE-0007bf-4C
	for axiom-developer@nongnu.org; Tue, 19 Aug 2008 00:16:48 -0400
Received: from [199.232.76.173] (port=37339 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KVIeE-0007bc-15
	for axiom-developer@nongnu.org; Tue, 19 Aug 2008 00:16:46 -0400
Received: from mx-7.zoominternet.net ([24.154.1.26]:59493
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KVIeD-00021D-Re
	for axiom-developer@nongnu.org; Tue, 19 Aug 2008 00:16:46 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=37mPLz1kAAAA:8 a=6dUOLBpHEzUrCfp4N_MA:9
	a=2omJ3hIIQwNVpB81ZfoA:7 a=IW5Jo6Gu4pXoI-SRgnmZ5cdKhZQA:4
	a=yqFbmg6DZFsA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.45] ([24.154.1.45:50190] helo=pop-2.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 92/A0-12184-4294AA84; Tue, 19 Aug 2008 00:16:36 -0400
Received: (qmail 7812 invoked from network); 19 Aug 2008 04:16:39 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-2.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <aldor-l@aldor.org>; 19 Aug 2008 04:16:39 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id m7J5g1V27124;
	Tue, 19 Aug 2008 01:42:01 -0400
Date: Tue, 19 Aug 2008 01:42:01 -0400
Message-Id: <200808190542.m7J5g1V27124@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: pip88nl@gmail.com
In-reply-to: <20080819031657.GV32196@xinutec.org> (pip88nl@gmail.com)
References: <20080819031657.GV32196@xinutec.org>
X-detected-kernel: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org, aldor-l@aldor.org
Subject: [Axiom-developer] Re: [Aldor-l] Literate programming
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 19 Aug 2008 04:16:50 -0000

>I am getting increasingly interested in literate programming. There are a
>few questionmarks I am turning at the idea of turning the aldor compiler
>sources into literate programs.

I have a long term interest in making Aldor be literate when it
becomes part of Axiom. If the code had been released under the
modified BSD I'd already be working on it.

I can tell you some features of literate programming from experience.
One major effect is that I can program much faster and better. I can't
say why this occurs but my measured output in work (where I use lisp
in a literate format) is 56K lines of code and 6k pages of documentation
over a two year period. It is just so much easier to program this way.



Axiom has 2 large chunks of C code, the graphics and hypertex.

I recently compressed the whole src/graph graphics subdirectory
into a single file (bookvol8.pamphlet) and the whole src/hyper
hypertex directory into a single file (bookvol7.pamphlet). See
<http://axiom.axiom-developer.org/axiom-website/documentation.html>
Eventually all of Axiom will be in these books.

Two major side-effects of making C programs like hypertex, into a
literate program is that 
  (a) I no longer need local include files and
  (b) programs are single files.

The first effect (a) comes from the fact that 
   #include "foo.h"
can be replaced by 
   <<foo.h>>
which has the effect of "inlining" the include file. This has two
other effects. First, you'll discover that it is "standard practice"
to start an include file with noise like:
   #ifndef THISFILE
   #define THISFILE 1
which causes the preprocessor to only "enable" the include file once.
However, if you look closely at the preprocessor output you'll find
that include files are frequently included multiple times. This causes
a lot of scan time in the compile and a lot of useless file I/O. Using
a chunk eliminates both times.

The second effect (b) is caused by the standard practice of tiny C files
that get separately compiled and then linked. These can now be replaced by
inlining the file using chunks, so that
    gcc -c file1.c
    gcc -c file2.c ...
turns into
    <<file1.c>>
    <<file2.c>>
and the result becomes a single file per user-visible command.

This approach
   (a) eliminates multiple invocations of the compiler
   (b) eliminates multiple accesses to include files
   (c) eliminates preprocessor time from duplicate includes
   (d) eliminates multiple file reads/writes
   (e) reduces link stage processing
   (f) enables compiler block-optimization processing and inlining.
   (g) allows the use of splink, valgrind and other tools trivially

Proper use of hyperlinking in the literate file allows you to walk
all over the PDF using the adobe reader so you can do quick function
lookups.

The single literate file format eliminates the need for etags or
grep searching in other files. It eliminates the extern lines.
It enables the use of emacs-register tagging to follow jumps.
It trivializes the need for make.

At a conceptual level the literate form gives structure to the
"pile of files". The table of contents can be broken up into logical
sections (e.g. the compiler phases, the platform dependencies, etc)

Additionally you can include graphics. This allows visual explanation
of the file contents. For Axiom graphics I can include images of buttons
near the button code, images of 2D graphs in the 2D section, images
of 3D graphs in the 3D section, examples of the effects of rotation
code as images, etc.

For Axiom hyperdoc, which uses a web-page-link format, I can include 
images of the web pages directly (see bookvol7.1). With the proper
hyperlinks I can walk the static pages of the hyperdoc "web pages"
directly in the PDF file.




In noweb the chunk names are arbitrary. Axiom has looked at 
defining a syntax for chunknames that include functions such as
URLs as in 
   <<http://....>> for external links
   <<xref://....>> for cross-book links
   <<chunk:foo>>   for full chunks
   <<exact:foo>>   for "variable substitution", etc

David Mentre did a simple version of this chunk syntax processor
which lives in the src/doc directory of the Axiom tree. I only
use a single feature of noweb, which is the chunkname mechanism.
Axiom can now process pamphlet files without using noweb at all
since I've added code that understands the format. This allows
me to "read pages" for hypertex directly out of the pamphlet file
rather than using the filesystem. This is much more efficient since
the file generally gets cached in memory and only a single file
handle is used, eliminating the disk I/O.





All of these are simply side-effects of literate programming.  The
primary gain is your ability to organize and control the complexity of
the whole problem. The table of contents mirrors the compiler
structural layout.  Your growing understanding of data structures and
algorithms is documented so you can "recover" that information
quickly.  The AUG information can live next to the code that
implements the feature.  The whole "clever Makefile" problem fades
away.  

These, more than any other features, will enable you and anyone who
follows you, to remember what code does and why decisions were
made. If you lose interest in the compiler then at least your
understanding of it will stay with the code.





Aldor needs to become literate since Stephen and Peter won't be
able to answer questions forever. And the answers they have given
are already sinking into the great morass of mailing list history.

Tim



From MAILER-DAEMON Tue Aug 19 01:50:33 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KVK6z-0001yJ-Ng
	for mharc-axiom-developer@gnu.org; Tue, 19 Aug 2008 01:50:33 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KVK6x-0001x0-1n
	for axiom-developer@nongnu.org; Tue, 19 Aug 2008 01:50:31 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KVK6v-0001vw-7a
	for axiom-developer@nongnu.org; Tue, 19 Aug 2008 01:50:29 -0400
Received: from [199.232.76.173] (port=49206 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KVK6u-0001vt-Ei
	for axiom-developer@nongnu.org; Tue, 19 Aug 2008 01:50:28 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:37111
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KVK6t-0000Vi-C3
	for axiom-developer@nongnu.org; Tue, 19 Aug 2008 01:50:28 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7J5oNr3006076;
	Tue, 19 Aug 2008 00:50:23 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7J5oNni006073;
	Tue, 19 Aug 2008 00:50:23 -0500
Date: Tue, 19 Aug 2008 00:50:23 -0500
Message-Id: <200808190550.m7J5oNni006073@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080818.02.tpd.patch (new input files (Stumbo,
	Cyganski, Hemmecke))
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 19 Aug 2008 05:50:31 -0000

Three new input files are added for regression testing
  biquat.input (David Cyganski)
  ifthenelse.input (Fabio Stumbo)
  sqrt3.input (Ralf Hemmecke)

Fabio Stumbo was added to the credits list in readme and setq.lisp
=======================================================================
diff --git a/changelog b/changelog
index 04a4914..377aa85 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,13 @@
+20080818 tpd src/input/Makefile biquat.input added
+20080818 dxc src/input/biquat.input added
+20080818 dxc "David Cyganski" (no known email)
+20080818 tpd src/input/Makefile ifthenelse.input added
+20080818 fxs src/input/ifthenelse.input added
+20080818 tpd src/interp/setq.lisp add Fabio Stumbo
+20080818 tpd readme add Fabio Stumbo
+20080818 fxs "Fabio Stumbo" (no known email)
+20080818 tpd src/input/Makefile sqrt3.input added
+20080818 rhx src/input/sqrt3.input added
 20080818 tpd src/input/Makefile typetower.input added
 20080818 rhx src/input/typetower.input added
 20080817 tpd src/algebra/vector.spad doc ravel from CartesianTensor
diff --git a/readme b/readme
index b2e20ab..7735016 100644
--- a/readme
+++ b/readme
@@ -240,8 +240,8 @@ at the axiom command prompt will prettyprint the list.
 "Gerhard Schneider      Martin Schoenert       Marshall Schor"
 "Frithjof Schulze       Fritz Schwarz          Nick Simicich"
 "William Sit            Elena Smirnova         Jonathan Steinbach"
-"Christine Sundaresan   Robert Sutor           Moss E. Sweedler"
-"Eugene Surowitz"
+"Fabio Stumbo           Christine Sundaresan   Robert Sutor"
+"Moss E. Sweedler       Eugene Surowitz"
 "Max Tegmark            James Thatcher         Balbir Thomas"
 "Mike Thomas            Dylan Thurston         Barry Trager"
 "Themos T. Tsikas"
diff --git a/src/input/Makefile.pamphlet b/src/input/Makefile.pamphlet
index e70b0d9..0d919d6 100644
--- a/src/input/Makefile.pamphlet
+++ b/src/input/Makefile.pamphlet
@@ -278,7 +278,8 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     arrows.regress    asinatan.regress asinhatanh.regress \
     assign.regress    atansqrt.regress \
     asec.regress      bags.regress     bbtree.regress   besselk.regress \
-    binary.regress    bop.regress      bstree.regress   bouquet.regress \
+    binary.regress    biquat.regress \
+    bop.regress       bstree.regress   bouquet.regress \
     bug100.regress    bug101.regress \
     bug103.regress    bug10069.regress \
     bugs.regress      bug10312.regress bug6357.regress  bug9057.regress \
@@ -315,7 +316,8 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     gstbl.regress     heap.regress     heat.regress     help.regress \
     herm.regress      heugcd.regress \
     hexadec.regress   ico.regress      ideal.regress \
-    ifact.regress     infprod.regress  intaf.regress    intbypart.regress \
+    ifact.regress     ifthenelse.regress \
+    infprod.regress  intaf.regress    intbypart.regress \
     intdeq.regress \
     intef2.regress    intef.regress    intg0.regress    intheory.regress \
     intmix2.regress   intmix.regress   int.regress      intrf.regress \
@@ -363,7 +365,8 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     series2.regress   series.regress   sersolve.regress set.regress \
     sincos.regress    sinhcosh.regress \
     sincosex.regress  sint.regress     skew.regress     slowint.regress \
-    solvetra.regress  space3.regress   sqmatrix.regress sregset.regress \
+    solvetra.regress  space3.regress   sqmatrix.regress sqrt3.regress \
+    sregset.regress \
     stbl.regress      stream2.regress  stream.regress   streams.regress \
     string.regress    strtbl.regress   summation.regress \
     symbol.regress    t111293.regress  table.regress    tancot.regress \
@@ -518,7 +521,8 @@ FILES= ${OUT}/algaggr.input  ${OUT}/algbrbf.input    ${OUT}/algfacob.input \
        ${OUT}/asec.input \
        ${OUT}/bags.input     ${OUT}/bbtree.input     ${OUT}/besselk.input \
        ${OUT}/bern.input \
-       ${OUT}/bernpoly.input ${OUT}/binary.input     ${OUT}/bop.input \
+       ${OUT}/bernpoly.input ${OUT}/binary.input     ${OUT}/biquat.input \
+       ${OUT}/bop.input \
        ${OUT}/bouquet.input  ${OUT}/bstree.input     ${OUT}/bug6357.input \
        ${OUT}/bug9057.input  ${OUT}/bug100.input     ${OUT}/bug101.input \
        ${OUT}/bug103.input \
@@ -574,6 +578,7 @@ FILES= ${OUT}/algaggr.input  ${OUT}/algbrbf.input    ${OUT}/algfacob.input \
        ${OUT}/herm.input     ${OUT}/heugcd.input \
        ${OUT}/hexadec.input    ${OUT}/huang.input \
        ${OUT}/ico.input      ${OUT}/ideal.input      ${OUT}/ifact.input \
+       ${OUT}/ifthenelse.input \
        ${OUT}/images1.input  ${OUT}/images1a.input   ${OUT}/images3a.input \
        ${OUT}/images3.input  ${OUT}/images6.input    ${OUT}/images6a.input \
        ${OUT}/images7.input  ${OUT}/images7a.input   ${OUT}/infprod.input \
@@ -652,7 +657,8 @@ FILES= ${OUT}/algaggr.input  ${OUT}/algbrbf.input    ${OUT}/algfacob.input \
        ${OUT}/sinsin2.input  ${OUT}/sint.input       ${OUT}/skew.input \
        ${OUT}/slowint.input  ${OUT}/solvetra.input   ${OUT}/space3.input \
        ${OUT}/spiral.input \
-       ${OUT}/sqmatrix.input ${OUT}/sregset.input    ${OUT}/stbl.input \
+       ${OUT}/sqmatrix.input ${OUT}/sqrt3.input \
+       ${OUT}/sregset.input  ${OUT}/stbl.input \
        ${OUT}/stream2.input  ${OUT}/stream.input     ${OUT}/streams.input \
        ${OUT}/string.input   ${OUT}/strtbl.input     ${OUT}/summation.input \
        ${OUT}/symbol.input \
@@ -722,6 +728,7 @@ DOCFILES= \
   ${DOC}/bbtree.input.dvi      ${DOC}/besselk.input.dvi    \
   ${DOC}/bern.input.dvi       \
   ${DOC}/bernpoly.input.dvi    ${DOC}/binary.input.dvi     \
+  ${DOC}/biquat.input.dvi \
   ${DOC}/bop.input.dvi         ${DOC}/bouquet.input.dvi    \
   ${DOC}/bstree.input.dvi      ${DOC}/bug10069.input.dvi   \
   ${DOC}/bug100.input.dvi      ${DOC}/bug101.input.dvi     \
@@ -860,6 +867,7 @@ DOCFILES= \
   ${DOC}/hexadec.input.dvi     ${DOC}/hilbert.as.dvi       \
   ${DOC}/huang.input.dvi       ${DOC}/ico.input.dvi        \
   ${DOC}/ideal.input.dvi       ${DOC}/ifact.input.dvi      \
+  ${DOC}/ifthenelse.input.dvi \
   ${DOC}/images1a.input.dvi    ${DOC}/images1.input.dvi    \
   ${DOC}/images2a.input.dvi    ${DOC}/images2.input.dvi    \
   ${DOC}/images3a.input.dvi    ${DOC}/images3.input.dvi    \
@@ -993,7 +1001,8 @@ DOCFILES= \
   ${DOC}/skew.input.dvi        ${DOC}/slowint.input.dvi    \
   ${DOC}/solvetra.input.dvi    ${DOC}/space3.input.dvi     \
   ${DOC}/spadprof.input.dvi    ${DOC}/spiral.input.dvi     \
-  ${DOC}/sqmatrix.input.dvi    ${DOC}/sregset.input.dvi    \
+  ${DOC}/sqmatrix.input.dvi    ${DOC}/sqrt3.input.dvi      \
+  ${DOC}/sregset.input.dvi    \
   ${DOC}/stbl.input.dvi        ${DOC}/stream2.input.dvi    \
   ${DOC}/stream.input.dvi      ${DOC}/streams.input.dvi    \
   ${DOC}/string.input.dvi      ${DOC}/strtbl.input.dvi     \
diff --git a/src/input/biquat.input.pamphlet b/src/input/biquat.input.pamphlet
new file mode 100644
index 0000000..bfb3165
--- /dev/null
+++ b/src/input/biquat.input.pamphlet
@@ -0,0 +1,790 @@
+\documentclass{article}
+\usepackage{axiom}
+\begin{document}
+\title{\$SPAD/src/input biquat.input}
+\author{D. Cyganski}
+\maketitle
+\begin{abstract}
+\end{abstract}
+\eject
+\tableofcontents
+\eject
+@
+<<*>>=
+)spool biquat.output
+)set message test on
+)set message auto off
+)clear all
+ 
+@
+\section{Hamiltonian Biquaternions}
+
+Define the type $Q$ of Hamiltonian biquaternions (not to be confused with
+Clifford biquaternions which are an entirely different object)
+<<*>>=
+
+--S 1 of 43
+C:=Complex Expression Integer
+--R 
+--R
+--R   (1)  Complex Expression Integer
+--R                                                                 Type: Domain
+--E 1
+
+--S 2 of 43
+Q:=Quaternion C
+--R 
+--R
+--R   (2)  Quaternion Complex Expression Integer
+--R                                                                 Type: Domain
+--E 2
+
+--S 3 of 43
+q:Q:=quatern(q0,q1,q2,q3)
+--R 
+--R
+--R   (3)  q0 + q1 i + q2 j + q3 k
+--R                                  Type: Quaternion Complex Expression Integer
+--E 3
+
+@
+Define a function that takes a complex list (parameter l) into a 
+quaternion
+<<*>>=
+
+--S 4 of 43
+qlist(l:List C):Q==quatern(1.1,1.2,1.3,1.4)
+--R 
+--R   Function declaration qlist : List Complex Expression Integer -> 
+--R      Quaternion Complex Expression Integer has been added to 
+--R      workspace.
+--R                                                                   Type: Void
+--E 4
+
+@
+Define a function that takes a quaternion into a list
+<<*>>=
+
+--S 5 of 43
+listq(x:Q):List C == [real x, imagI x, imagJ x, imagK x]
+--R 
+--R   Function declaration listq : Quaternion Complex Expression Integer
+--R       -> List Complex Expression Integer has been added to workspace.
+--R                                                                   Type: Void
+--E 5
+
+@
+Define a function that takes a biquat into a matrix
+<<*>>=
+
+--S 6 of 43
+matrixq(x:Q):Matrix C == matrix _
+             [[real x + %i*imagI(x), imagJ x + %i*imagK(x)],_
+             [-imagJ(x) + %i*imagK(x), real x - %i*imagI(x)]]
+--R 
+--R   Function declaration matrixq : Quaternion Complex Expression Integer
+--R       -> Matrix Complex Expression Integer has been added to 
+--R      workspace.
+--R                                                                   Type: Void
+--E 6
+
+@
+\section{The Pauli basis Biquaternions}
+
+The quaternion package in axiom is based upon the Hamiltonian basis,
+i, j, k, in contrast to the Pauli basis used in the Morgan papers which
+make certain operations correspond more closely (in the sense of
+visualization as ordering of components is more natural so that 
+classical operations can be easily identified) to vector calculus
+functions and connect with more directly with various spinor QM
+formulations. To both follow these papers and obtain these visualization
+benefits, we will define and use the Pauli basis also.
+
+The Pauli basis in terms of the Hamiltonian quaternion basis
+<<*>>=
+
+--S 7 of 43
+sig0:=quatern(1,0,0,0)::Q
+--R 
+--R
+--R   (7)  1
+--R                                  Type: Quaternion Complex Expression Integer
+--E 7
+
+--S 8 of 43
+sig1:=%i*quatern(0,0,0,1)::Q
+--R 
+--R
+--R   (8)  %i k
+--R                                  Type: Quaternion Complex Expression Integer
+--E 8
+
+--S 9 of 43
+sig2:=%i*quatern(0,0,1,0)::Q
+--R 
+--R
+--R   (9)  %i j
+--R                                  Type: Quaternion Complex Expression Integer
+--E 9
+
+--S 10 of 43
+sig3:=-%i*quatern(0,1,0,0)::Q
+--R 
+--R
+--R   (10)  - %i i
+--R                                  Type: Quaternion Complex Expression Integer
+--E 10
+
+@
+For purposes of manipulation and display it would be best if we either
+\begin{enumerate}
+\item Copy the quaternion source code and edit it to use $\sigma_i$ as
+symbols for the basis rather than i, j, k and change the definition of
+multiplication to correspond to this Pauli basis so that all current
+display and entry functions are flipped to the new basis
+\item Use the $\sigma$ basis above with the existing package but define a
+new display function, say sigrep, that can show us the results in Pauli
+form at will, but otherwise show it in Hamiltonian basis
+\end{enumerate}
+
+While 2 is not as natural and convenient, it is easier to code and would
+automatically provide a development that could be seen in the visually 
+appealing Pauli form, or in the standard Hamiltonian form of biquaternions.
+
+After a quick review and finding no fast path to 2, and not wishing to get
+into the mechanics of compiling an axiom package instead of working on
+the physics, I have taken the yet easier path and simply defined the
+simplest display function that gives me access to seeing Pauli basis
+results: a list of the four Pauli basis coefficients.
+
+Define a function that produces the Pauli basis representation of the
+biquaternion.
+<<*>>=
+
+--S 11 of 43
+siglist(x:Q):List C == [real x, -imagK(x)*%i, -imagJ(x)*%i, %i*imagI(x)]
+--R 
+--R   Function declaration siglist : Quaternion Complex Expression Integer
+--R       -> List Complex Expression Integer has been added to workspace.
+--R                                                                   Type: Void
+--E 11
+
+@
+\section{Biquaternion Calculus}
+
+Define the quaternion derivative (Morgan, 2001, Eq. 2)
+<<*>>=
+
+--S 12 of 43
+D(q:Q,x:Symbol,y:Symbol,z:Symbol):Q==sig1*D(q,x)+sig2*D(q,y)+sig3*D(q,z)
+--R 
+--R   Function declaration D : (Quaternion Complex Expression Integer,
+--R      Symbol,Symbol,Symbol) -> Quaternion Complex Expression Integer 
+--R      has been added to workspace.
+--R                                                                   Type: Void
+--E 12
+
+@
+For testing the derivative we define this set of operators
+<<*>>=
+
+--S 13 of 43
+Ft:=operator 'Ft
+--R 
+--R
+--R   (13)  Ft
+--R                                                          Type: BasicOperator
+--E 13
+
+--S 14 of 43
+Fx:=operator 'Fx
+--R 
+--R
+--R   (14)  Fx
+--R                                                          Type: BasicOperator
+--E 14
+
+--S 15 of 43
+Fy:=operator 'Fy
+--R 
+--R
+--R   (15)  Fy
+--R                                                          Type: BasicOperator
+--E 15
+
+--S 16 of 43
+Fz:=operator 'Fz
+--R 
+--R
+--R   (16)  Fz
+--R                                                          Type: BasicOperator
+--E 16
+
+@
+Now form a general quaternion which is a function of x, y, z
+<<*>>=
+
+--S 17 of 43
+F:Q:=Ft(x,y,z)*sig0+Fx(x,y,z)*sig1+Fy(x,y,z)*sig2+Fz(x,y,z)*sig3
+--R 
+--R
+--R   (17)  Ft(x,y,z) - Fz(x,y,z)%i i + Fy(x,y,z)%i j + Fx(x,y,z)%i k
+--R                                  Type: Quaternion Complex Expression Integer
+--E 17
+
+@
+In the Pauli basis the derivative of this biquat should produce
+(Morgan 2001, eq 1):
+\begin{verbatim}
+  D(Ft+F.sigma)=div(F)+(grad(Ft)+%i*curl(F)).sigma
+\end{verbatim}
+<<*>>=
+
+--S 18 of 43
+siglist(D(F,x,y,z))
+--R 
+--R   Compiling function D with type (Quaternion Complex Expression 
+--R      Integer,Symbol,Symbol,Symbol) -> Quaternion Complex Expression 
+--R      Integer 
+--R   Compiling function siglist with type Quaternion Complex Expression 
+--R      Integer -> List Complex Expression Integer 
+--R
+--R   (18)
+--R   [Fz  (x,y,z) + Fy  (x,y,z) + Fx  (x,y,z),
+--R      ,3            ,2            ,1
+--R    Ft  (x,y,z) + (Fz  (x,y,z) - Fy  (x,y,z))%i,
+--R      ,1             ,2            ,3
+--R    Ft  (x,y,z) + (- Fz  (x,y,z) + Fx  (x,y,z))%i,
+--R      ,2               ,1            ,3
+--R    Ft  (x,y,z) + (Fy  (x,y,z) - Fx  (x,y,z))%i]
+--R      ,3             ,1            ,2
+--R                                        Type: List Complex Expression Integer
+--E 18
+
+@
+\section{Biquaternion Exponential}
+
+Define a function that evaluates the Biquat exponential by beginning
+with the biquat rotation.
+
+First let's introduce some refinement to the language we will use. In
+many texts and papers, the i, j, k or $\sigma_1$, $\sigma_2$, $\sigma_3$
+components of the biquaternion are called the imaginary components while
+the scalar or $\sigma_0$ component are called real. This introduces vast
+confusion when dealing with biquaternions in which there is a ``true''
+imaginary unit, \%i being used. We will adopt a variation on the language
+used by Gsponer and others. A biquat $[{\bf a}, {\bf b}, {\bf c}, {\bf d}]$
+has scalar component ${\bf a}$ which may have itself an imaginary component.
+The component $[{\bf 0}, {\bf b}, {\bf c}, {\bf d}]$ is its vector 
+component which again may be complex:
+\begin{verbatim}
+ [0,b,c,d]=[0,Re(b),Re(c),Re(d)]+[0,Im(b),Im(c),Im(d)]=Re(Vec(q))+Im(Vec(q))
+\end{verbatim}
+Thus, for us, a ``real quaternion'' has real scalar and vector components
+and does not refer to a quaternion with only a scalar component as it would
+in the language adopted by the quatern package in Axiom.
+
+The rotation is a function of real number, theta and a unit norm, real
+vector quaternion. It's form is that of a simple complex quaternion
+exponential, R($\theta$,q)=$e^a$ where $a$ is an Imaginary Vector quaternions
+are like exponentials of pure imaginary numbers, resulting in each case in a
+unit norm object of the same type. For many of our purposes in the
+representation of relativistic and quantum mechanics it is the only type
+of quaternion for which we will have to evaluate the exponential.
+
+Define a biquaternion rotation operator that takes a biquat through a
+rotation of $\theta$ radians about the axis defined by the unit $q$ biquat
+(Morgan 2001, Eq 3).
+<<*>>=
+
+--S 19 of 43
+rot(theta:Expression Integer,q:Q):Q==cos(theta/2)-%i::Q*q*sin(theta/2)
+--R 
+--R   Function declaration rot : (Expression Integer,Quaternion Complex 
+--R      Expression Integer) -> Quaternion Complex Expression Integer has 
+--R      been added to workspace.
+--R                                                                   Type: Void
+--E 19
+
+@
+The rotation is a basis for defining the general exponential, since we
+can always extract the unit vector corresponding to a given biquaternion,
+all we need is the biquaternion abs operation, not provided by axiom
+(note, many texts and papers label the abs which is a complex valued
+$norm^2$ by the name ``norm'' -- very bad form -- I've adopted abs as
+the name to avoid this confusion.
+<<*>>=
+
+--S 20 of 43
+((x:Q)/(y:Q)):Q == x*inv(y)
+--R 
+--R   Function declaration ?/? : (Quaternion Complex Expression Integer,
+--R      Quaternion Complex Expression Integer) -> Quaternion Complex 
+--R      Expression Integer has been added to workspace.
+--R                                                                   Type: Void
+--E 20
+
+--S 21 of 43
+abs(q:Q):C == sqrt((q*conjugate(q))::C)
+--R 
+--R   Function declaration abs : Quaternion Complex Expression Integer -> 
+--R      Complex Expression Integer has been added to workspace.
+--R                                                                   Type: Void
+--E 21
+
+--S 22 of 43
+exp(q:Q):Q == (_
+  q-conjugate(q)=0 => exp( (q+conjugate(q))::C/2)$C * sig0; _
+  exp( (q+conjugate(q))::C/2)$C * (sig0*cos(abs(q)) +_
+  (q-conjugate(q))/abs(q-conjugate(q))*sin(abs(q))) )
+--R 
+--R   Function declaration exp : Quaternion Complex Expression Integer -> 
+--R      Quaternion Complex Expression Integer has been added to 
+--R      workspace.
+--R                                                                   Type: Void
+--E 22
+
+@
+If I've defined these correctly, then the rotation about the x axis
+defined by qx below by 2 radians should give the same answer as
+exponentiation of \%i*qx (not a very complete test).
+<<*>>=
+
+--S 23 of 43
+qx:=sig1
+--R 
+--R
+--R   (23)  %i k
+--R                                  Type: Quaternion Complex Expression Integer
+--E 23
+
+--S 24 of 43
+mm:=siglist(rot(2,qx))
+--R 
+--R   Compiling function / with type (Quaternion Complex Expression 
+--R      Integer,Quaternion Complex Expression Integer) -> Quaternion 
+--R      Complex Expression Integer 
+--R   There are 2 exposed and 6 unexposed library operations named cos 
+--R      having 1 argument(s) but none was determined to be applicable. 
+--R      Use HyperDoc Browse, or issue
+--R                               )display op cos
+--R      to learn more about the available operations. Perhaps 
+--R      package-calling the operation or using coercions on the arguments
+--R      will allow you to apply the operation.
+--R   Cannot find a definition or applicable library operation named cos 
+--R      with argument type(s) 
+--R                    Quaternion Complex Expression Integer
+--R      
+--R      Perhaps you should use "@" to indicate the required return type, 
+--R      or "$" to specify which version of the function you need.
+--R   AXIOM will attempt to step through and interpret the code.
+--R   Compiling function rot with type (Expression Integer,Quaternion 
+--R      Complex Expression Integer) -> Quaternion Complex Expression 
+--R      Integer 
+--R
+--R   (24)
+--R                2         3                  3          2
+--R    cos(1)sin(1)  + cos(1)  + cos(1)   sin(1)  + (cos(1)  - 1)sin(1)
+--R   [-------------------------------- + ----------------------------- %i,
+--R                  2          2                     2          2
+--R           2sin(1)  + 2cos(1)               2sin(1)  + 2cos(1)
+--R                  2         3                    3            2
+--R    - cos(1)sin(1)  - cos(1)  + cos(1)   - sin(1)  + (- cos(1)  - 1)sin(1)
+--R    ---------------------------------- + --------------------------------- %i,
+--R                   2          2                        2          2
+--R            2sin(1)  + 2cos(1)                  2sin(1)  + 2cos(1)
+--R    0, 0]
+--R                                        Type: List Complex Expression Integer
+--E 24
+
+--S 25 of 43
+nn:=siglist(exp(-%i::Q*qx))
+--R 
+--R   There are 2 exposed and 7 unexposed library operations named exp 
+--R      having 1 argument(s) but none was determined to be applicable. 
+--R      Use HyperDoc Browse, or issue
+--R                               )display op exp
+--R      to learn more about the available operations. Perhaps 
+--R      package-calling the operation or using coercions on the arguments
+--R      will allow you to apply the operation.
+--R   Cannot find a definition or applicable library operation named exp 
+--R      with argument type(s) 
+--R                    Quaternion Complex Expression Integer
+--R      
+--R      Perhaps you should use "@" to indicate the required return type, 
+--R      or "$" to specify which version of the function you need.
+--R   AXIOM will attempt to step through and interpret the code.
+--R   Compiling function exp with type Quaternion Complex Expression 
+--R      Integer -> Quaternion Complex Expression Integer 
+--R   Compiling function abs with type Quaternion Complex Expression 
+--R      Integer -> Complex Expression Integer 
+--R
+--R   (25)
+--R                2         3                  3          2
+--R    cos(1)sin(1)  + cos(1)  + cos(1)   sin(1)  + (cos(1)  - 1)sin(1)
+--R   [-------------------------------- + ----------------------------- %i,
+--R                  2          2                     2          2
+--R           2sin(1)  + 2cos(1)               2sin(1)  + 2cos(1)
+--R                  2         3                    3            2
+--R    - cos(1)sin(1)  - cos(1)  + cos(1)   - sin(1)  + (- cos(1)  - 1)sin(1)
+--R    ---------------------------------- + --------------------------------- %i,
+--R                   2          2                        2          2
+--R            2sin(1)  + 2cos(1)                  2sin(1)  + 2cos(1)
+--R    0, 0]
+--R                                        Type: List Complex Expression Integer
+--E 25
+
+--S 26 of 43
+(mm=nn)@Boolean
+--R 
+--R
+--R   (26)  true
+--R                                                                Type: Boolean
+--E 26
+
+@
+To express a proof of equality such as:
+\begin{verbatim}
+  rot(theta,q) = exp((-theta/2)*%i*q)
+\end{verbatim}
+for arbitrary real $\theta$ and biquaternion real using vector $q$ as one 
+would in Maple, we need to express the fact that $q$ is a vector quantity
+with real coefficients in the Pauli basis representing a unit magnitude
+vector. One way to represent this is to create a quaternion called $qnv$,
+representing a general normalized (unit length) vector part only biquat with
+two independent variables $q1$ and $q2$ representing its only degrees of
+freedom.
+<<*>>=
+
+--S 27 of 43
+qnv:=q1*sig1+q2*sig2+sqrt(1-q1^2-q2^2)*sig3
+--R 
+--R
+--R            +---------------+
+--R            |    2     2
+--R   (27)  - \|- q2  - q1  + 1 %i i + q2 %i j + q1 %i k
+--R                                  Type: Quaternion Complex Expression Integer
+--E 27
+
+@
+\section{Assumptions about Variables}
+
+Now, in the equations that will result, we will obtain subexpressions of the
+form $\sqrt{\theta^2}$. The positive root will always be appropriate in
+this formula and one way to get it (in other computer algebra systems) 
+would be to restrict $\theta$ to positive values so as to avoid branches
+that would otherwise have to be properly selected to get an equality. Thus,
+one means to get the desired simplification is to perform the restriction
+of $\theta$ to positive values. My current understanding is: Axiom does not
+support variables with properties in the sense that Maple does (the 
+*assume* facility).
+
+\section{Problems}
+
+Returning to the case at hand, let's expand a test of equality to the
+four biquat components and seek a way to prove that each component 
+is zero.
+<<*>>=
+
+--S 28 of 43
+theta:=_\theta
+--R 
+--R
+--R   (28)  \theta
+--R                                                        Type: Variable \theta
+--E 28
+
+--S 29 of 43
+testqeq:=map(simplify,siglist(rot(theta,qnv)-exp((-theta/2)*%i*qnv)))_
+         ::List Expression Complex Integer
+--R 
+--R
+--R   (29)
+--R           +-------+
+--R           |      2
+--R          \|\theta          \theta
+--R   [- cos(----------) + cos(------),
+--R               2               2
+--R                        +-------+
+--R          +-------+     |      2
+--R          |      2     \|\theta                       \theta
+--R    %i q1\|\theta  sin(----------) - %i \theta q1 sin(------)
+--R                            2                            2
+--R    ---------------------------------------------------------,
+--R                              \theta
+--R                        +-------+
+--R          +-------+     |      2
+--R          |      2     \|\theta                       \theta
+--R    %i q2\|\theta  sin(----------) - %i \theta q2 sin(------)
+--R                            2                            2
+--R    ---------------------------------------------------------,
+--R                              \theta
+--R
+--R                                            +-------+
+--R            +---------------+ +-------+     |      2
+--R            |    2     2      |      2     \|\theta
+--R         %i\|- q2  - q1  + 1 \|\theta  sin(----------)
+--R                                                2
+--R       + 
+--R                                 +---------------+
+--R                         \theta  |    2     2
+--R         - %i \theta sin(------)\|- q2  - q1  + 1
+--R                            2
+--R    /
+--R       \theta
+--R     ]
+--R                                        Type: List Expression Complex Integer
+--E 29
+
+@
+As is quite obvious from this result, the two equations would have been
+shown to be equal if positivity of the theta variable was enforced. This
+raises two questions
+\begin{enumerate}
+\item How would one perform a proof such as the above within the
+allowed operations of Axiom?
+\item How can Axiom be called a symbolic algebra system if basic notions
+of algebraic proof such as restrictions of a variable to the semiring
+of non-negative integers is disallowed?
+\end{enumerate}
+How are symbolic manipulations, proofs and solutions to be carried out
+without this basic notion? I am let to think that Axiom can only be
+considered a semi-numerical software system.
+
+\section{Rules and Pattern Matching}
+
+Let's try another way to answer question 1 by using symbolic pattern
+matching ``rules''. Define a rule that recognizes the specific case of
+the variable theta appearing in a construct that should be simplified
+given its positivity.
+<<*>>=
+
+--S 30 of 43
+posthetaRule:=rule sqrt(theta^2)==theta
+--R 
+--R
+--R          +------+
+--R          |     2
+--R   (30)  \|theta   == theta
+--R                        Type: RewriteRule(Integer,Integer,Expression Integer)
+--E 30
+
+@
+But, now we encounter two new problems. First, apparently ``map'' does
+not work with rules, so I can't apply this rule in a simple fashion to
+the entire List generated by our test case above for any x.
+
+The ``map'' function only maps functions but we can easily turn a rule 
+into an anonymous function.
+<<*>>=
+
+--S 31 of 43
+map(x+->posthetaRule(x), [0,sqrt(theta^2),0,sqrt(theta^2)])
+--R 
+--R
+--R   (31)  [0,\theta,0,\theta]
+--R                                                Type: List Expression Integer
+--E 31
+
+@
+But even if we were to split our list above, and try to apply this rule
+to a component, we get this disappointing result:
+<<*>>=
+
+--S 32 of 43
+posthetaRule testqeq.1
+--R 
+--R   There are no library operations named posthetaRule 
+--R      Use HyperDoc Browse or issue
+--R                            )what op posthetaRule
+--R      to learn if there is any operation containing " posthetaRule " in
+--R      its name.
+--R 
+--RDaly Bug
+--R   Cannot find a definition or applicable library operation named 
+--R      posthetaRule with argument type(s) 
+--R                         Expression Complex Integer
+--R      
+--R      Perhaps you should use "@" to indicate the required return type, 
+--R      or "$" to specify which version of the function you need.
+--E 32
+
+@
+Apparently rules have builtin assumptions about the construction of
+the expression. If I override this for a real element of the list
+we are testing I can successfully get one answer.
+<<*>>=
+
+--S 33 of 43
+[posthetaRule (testqeq.i::Expression Integer) for i in 1..1]
+--R 
+--R
+--R   (32)  [0]
+--R                                                Type: List Expression Integer
+--E 33
+
+@
+But this doesn't extend to the remainder of the list.
+<<*>>=
+
+--S 34 of 43
+[posthetaRule (testqeq.i::Expression Integer) for i in 1..4]
+--R 
+--R 
+--RDaly Bug
+--R   Cannot convert from type Expression Complex Integer to Expression 
+--R      Integer for value
+--R                       +-------+
+--R         +-------+     |      2
+--R         |      2     \|\theta                       \theta
+--R   %i q1\|\theta  sin(----------) - %i \theta q1 sin(------)
+--R                           2                            2
+--R   ---------------------------------------------------------
+--R                             \theta
+--R
+--E 34
+
+@
+because obviously we can't coerce an actually complex value into the
+Expression Integer type that the rule seems to want.
+
+Here is one way to create the necessary rule. Like everything else in
+Axiom rules are objects in some domain. We need to specify a domain
+for the rule that is compatible with the domain we wish to manipulate.
+So let's find out more about this domain:
+<<*>>=
+
+--S 35 of 43
+)show RewriteRule
+--R 
+--R RewriteRule(Base: SetCategory,R: Join(Ring,PatternMatchable Base,OrderedSet,ConvertibleTo Pattern Base),F: Join(FunctionSpace R,PatternMatchable Base,ConvertibleTo Pattern Base))  is a domain constructor
+--R Abbreviation for RewriteRule is RULE 
+--R This constructor is exposed in this frame.
+--R Issue )edit rule.spad.pamphlet to see algebra source code for RULE 
+--R
+--R------------------------------- Operations --------------------------------
+--R ?=? : (%,%) -> Boolean                coerce : Equation F -> %
+--R coerce : % -> OutputForm              elt : (%,F,PositiveInteger) -> F
+--R ?.? : (%,F) -> F                      hash : % -> SingleInteger
+--R latex : % -> String                   lhs : % -> F
+--R pattern : % -> Pattern Base           retract : % -> Equation F
+--R rhs : % -> F                          rule : (F,F,List Symbol) -> %
+--R rule : (F,F) -> %                     ?~=? : (%,%) -> Boolean
+--R quotedOperators : % -> List Symbol
+--R retractIfCan : % -> Union(Equation F,"failed")
+--R suchThat : (%,List Symbol,(List F -> Boolean)) -> %
+--R
+--E 35
+
+@
+We can provide satisfactory parameters of this domain constructor as follows:
+<<*>>=
+
+--S 36 of 43
+Complex Integer has PatternMatchable Integer
+--R 
+--R
+--R   (33)  true
+--R                                                                Type: Boolean
+--E 36
+
+--S 37 of 43
+Expression Complex Integer has FunctionSpace Complex Integer
+--R 
+--R
+--R   (34)  true
+--R                                                                Type: Boolean
+--E 37
+
+--S 38 of 43
+Expression Complex Integer has PatternMatchable Integer
+--R 
+--R
+--R   (35)  true
+--R                                                                Type: Boolean
+--E 38
+
+@
+So the following simplification works as hoped:
+<<*>>=
+
+--S 39 of 43
+posxRule:=(rule sqrt('theta^2)==theta)$RewriteRule(Integer,Complex Integer,_
+            Expression Complex Integer)
+--R 
+--R
+--R          +------+
+--R          |     2
+--R   (36)  \|theta   == theta
+--R        Type: RewriteRule(Integer,Complex Integer,Expression Complex Integer)
+--E 39
+
+--S 40 of 43
+map(x+->posxRule x, testqeq)
+--R 
+--R
+--R   (37)  [0,0,0,0]
+--R                                        Type: List Expression Complex Integer
+--E 40
+
+@
+\section{Algebraic Domain of Computation}
+
+Recall that Axiom does things in a fundamentally {\sl algebraic} rather
+than {\sl symbolic} way. So although the pattern matching approach
+works, it goes somewhat against the overall philosophy of Axiom. It is
+possible to do almost anything by using rewrite rules including things
+that are mathematically incorrect. In this case the rule is simple and
+the results obvious but if it gets more complicated this can be a problem.
+
+Is there some ``axiomatic'', i.e. algebraic way to express the fact that
+$\theta$ is a positive real? well, what we really need is that
+$$\sqrt{\theta^2} = \theta$$
+be satisfied. Now consider that by definition $\sqrt{}$:
+<<*>>=
+
+--S 41 of 43
+test (sqrt(x)^2=x)
+--R 
+--R
+--R   (38)  true
+--R                                                                Type: Boolean
+--E 41
+
+@
+and so
+<<*>>=
+
+--S 42 of 43
+test (sqrt(sqrt(x)^2)=sqrt(x))
+--R 
+--R
+--R   (39)  true
+--R                                                                Type: Boolean
+--E 42
+
+@
+for any $x$. So the expression $\sqrt{(x)}$ is one such thing that has
+the desired property in the Expression domain. {\sl With exactly the
+appropriate loss of generality}, let us just suppose that $\theta$ is
+$\sqrt{(\beta)}$ for some $\beta$. Then if necessary we can also
+perform a change of variable back to $\theta$.
+<<*>>=
+
+--S 43 of 43
+eval(eval(testqeq,theta=sqrt(beta)),sqrt(beta)=theta)
+--R 
+--R
+--R   (40)  [0,0,0,0]
+--R                                        Type: List Expression Complex Integer
+--E 43
+
+)spool 
+)lisp (bye)
+ 
+@
+\eject
+\begin{thebibliography}{99}
+\bibitem{1} nothing
+\end{thebibliography}
+\end{document}
diff --git a/src/input/ifthenelse.input.pamphlet b/src/input/ifthenelse.input.pamphlet
new file mode 100644
index 0000000..29c75b4
--- /dev/null
+++ b/src/input/ifthenelse.input.pamphlet
@@ -0,0 +1,299 @@
+\documentclass{article}
+\usepackage{axiom}
+\begin{document}
+\title{\$SPAD/src/input ifthenelse.input}
+\author{Fabio Stumbo}
+\maketitle
+\begin{abstract}
+{\bf if-then-else: what is wrong?}
+\end{abstract}
+\eject
+\tableofcontents
+\eject
+@
+<<*>>=
+)spool ifthenelse.output
+)set message test on
+)set message auto off
+)clear all
+
+@
+I am having some problem with the if-then-else syntax in .input files
+
+{\bf Problem 1}: I refer to the Axiom book which ships with the program
+(version 2005/09). At page 204 it says that the usual rules for piling
+are suspended in conditional expressions and it gives 5 different ways
+which should be equivalent, namely:
+\begin{verbatim}
+
+  if i>0 then output("positive") else output("nonpositive")
+
+  if i>0 then output("positive") 
+    else output("nonpositive")
+
+  if i>0 then output("positive") 
+  else output("nonpositive")
+
+  if i>0 
+  then output("positive") 
+  else output("nonpositive")
+
+  if i>0 
+    then output("positive") 
+    else output("nonpositive")
+\end{verbatim}
+
+Well, I tried all of them, creating each time a blank r.input file with 
+inside only:
+<<*>>=
+ 
+--S 1 of 20
+i:=2
+--R 
+--R
+--R   (1)  2
+--R                                                        Type: PositiveInteger
+--E 1
+
+@
+followed by one of the ``if$\ldots$''.
+
+The result of the first two are ok, whereas the other three
+give some syntax error (different each time).
+<<*>>=
+
+--S 2 of 20
+for i in 2..2 repeat
+  if i>0 then output("positive") else output("nonpositive")
+--R 
+--R   positive
+--R                                                                   Type: Void
+--E 2
+
+--S 3 of 20
+for i in 2..2 repeat
+  if i>0 then output("positive") 
+    else output("nonpositive")
+--R 
+--R   positive
+--R                                                                   Type: Void
+--E 3
+
+--S 4 of 20
+for i in 2..2 repeat
+  if i>0 then output("positive") 
+  else output("nonpositive")
+--R 
+--R   positive
+--R                                                                   Type: Void
+--E 4
+
+--S 5 of 20
+for i in 2..2 repeat
+  if i>0 
+  then output("positive") 
+  else output("nonpositive")
+--R 
+--R   positive
+--R                                                                   Type: Void
+--E 5
+
+--S 6 of 20
+for i in 2..2 repeat
+  if i>0 
+    then output("positive") 
+    else output("nonpositive")
+--R 
+--R  Line  47: --R 
+--R  Line  48: --R   positive
+--R  Line  49: --R                                                                   Type: Void
+--R  Line  50: --E 5
+--R  Line  51: 
+--R  Line  52: --S 6 of 20
+--R  Line  53: for i in 2..2 repeat
+--R  Line  54:   if i>0 
+--R           ..A
+--R  Error  A: (from #\A and on) Ignored from here
+--R  Line  55:     then output("positive") 
+--R           ....A
+--R  Error  A: Improper syntax.
+--R  Error  A: (from #\A up to ) Ignored.
+--R  Line  56:     else output("nonpositive")
+--R           ....A........................B
+--R  Error  A: Improper syntax.
+--R  Error  A: (from #\A up to #\B) Ignored.
+--R  Error  B: Possibly missing a then 
+--R  Error  B: (up to #\B) to here.
+--R   7 error(s) parsing 
+--E 6
+
+--S 7 of 20
+i:=2
+--R 
+--R
+--R   (6)  2
+--R                                                        Type: PositiveInteger
+--E 7
+
+--S 8 of 20
+for i in 2..2 repeat
+  if i>0 then
+    output(i)
+    output("positive") 
+  else
+    output(i)
+    else output("nonpositive")
+--R 
+--R  Line  83: --R 
+--R  Line  84: --R
+--R  Line  85: --R   (6)  2
+--R  Line  86: --R                                                        Type: PositiveInteger
+--R  Line  87: --E 7
+--R  Line  88: 
+--R  Line  89: --S 8 of 20
+--R  Line  90: for i in 2..2 repeat
+--R  Line  91:   if i>0 then
+--R  Line  92:     output(i)
+--R  Line  93:     output("positive") 
+--R  Line  94:   else
+--R  Line  95:     output(i)
+--R  Line  96:     else output("nonpositive")
+--R           ....A
+--R  Error  A: (from #\A up to ) Ignored.
+--R  Error  A: Improper syntax.
+--R   2 error(s) parsing 
+--E 8
+
+--S 9 of 20
+i:=1.5
+--R 
+--R
+--R   (7)  1.5
+--R                                                                  Type: Float
+--E 9
+
+--S 10 of 20
+a:=
+  if i > 0 then
+    j:=sin(i*pi())
+    exp(j+1/j)
+  else
+    j:=cos(i*0.5*pi())
+    log(abs(j)**5+1)
+--R 
+--R
+--R   (8)  0.1353352832 3661269189
+--R                                                                  Type: Float
+--E 10
+
+@
+{\bf Problem 2:} again with if then else, in a complex function I 
+noticed a wrong result (the function itself was ok). Simplifying,
+you can produce the same error with something like:
+<<*>>=
+
+--S 11 of 20
+test: (INT,INT) -> List(INT)
+--R 
+--R                                                                   Type: Void
+--E 11
+
+--S 12 of 20
+test(a,b) ==
+  x:=0; y:=0
+  if (a rem b = 0) and b < 0 then
+    x := 1
+    y := 1
+  [x,y]
+--R 
+--R                                                                   Type: Void
+--E 12
+
+--S 13 of 20
+4 rem -2
+--R 
+--R
+--R   (11)  0
+--R                                                     Type: NonNegativeInteger
+--E 13
+
+--S 14 of 20
+test(4,-2)
+--R 
+--R   Compiling function test with type (Integer,Integer) -> List Integer 
+--R
+--R   (12)  [1,1]
+--R                                                           Type: List Integer
+--E 14
+
+@
+returns correctly [1,1], but
+<<*>>=
+
+--S 15 of 20
+4 rem -3
+--R 
+--R
+--R   (13)  1
+--R                                                        Type: PositiveInteger
+--E 15
+
+--S 16 of 20
+test(4,-3)
+--R 
+--R
+--R   (14)  [0,0]
+--R                                                           Type: List Integer
+--E 16
+
+@
+or
+<<*>>=
+
+--S 17 of 20
+4 rem 2
+--R 
+--R
+--R   (15)  0
+--R                                                     Type: NonNegativeInteger
+--E 17
+
+--S 18 of 20
+test(4,2)
+--R 
+--R
+--R   (16)  [0,0]
+--R                                                           Type: List Integer
+--E 18
+
+@
+wrongly returns [0,1]. The same happens if I write
+<<*>>=
+
+--S 19 of 20
+test1: (INT,INT) -> List(INT)
+--R 
+--R                                                                   Type: Void
+--E 19
+
+--S 20 of 20
+test1(a,b) ==
+  x := 0; y := 0
+  if (a rem b = 0) and b < 0 then x := 1 ; y := 1
+  [x,y]
+--R 
+--R                                                                   Type: Void
+--E 20
+
+@
+Why?
+<<*>>=
+)spool 
+)lisp (bye)
+ 
+@
+\eject
+\begin{thebibliography}{99}
+\bibitem{1} nothing
+\end{thebibliography}
+\end{document}
diff --git a/src/input/sqrt3.input.pamphlet b/src/input/sqrt3.input.pamphlet
new file mode 100644
index 0000000..ad20ab9
--- /dev/null
+++ b/src/input/sqrt3.input.pamphlet
@@ -0,0 +1,249 @@
+\documentclass{article}
+\usepackage{axiom}
+\begin{document}
+\title{\$SPAD/src/input sqrt3.input}
+\author{Ralf Hemmecke}
+\maketitle
+\begin{abstract}
+A demo involving the algebraic number $\sqrt{3}$.
+\end{abstract}
+\eject
+\tableofcontents
+\eject
+@
+<<*>>=
+)spool sqrt3.output
+)set message test on
+)set message auto off
+)clear all
+ 
+--S 1 of 23
+t1:=(sqrt(3)-3)*(sqrt(3)+1)/6
+--R 
+--R
+--R           +-+
+--R          \|3
+--R   (1)  - ----
+--R            3
+--R                                                        Type: AlgebraicNumber
+--E 1
+
+--S 2 of 23
+tt1:=-1/sqrt(3)
+--R 
+--R
+--R           +-+
+--R          \|3
+--R   (2)  - ----
+--R            3
+--R                                                        Type: AlgebraicNumber
+--E 2
+
+--S 3 of 23
+t2:=sqrt(3)/6
+--R 
+--R
+--R         +-+
+--R        \|3
+--R   (3)  ----
+--R          6
+--R                                                        Type: AlgebraicNumber
+--E 3
+
+--S 4 of 23
+t1+t2
+--R 
+--R
+--R           +-+
+--R          \|3
+--R   (4)  - ----
+--R            6
+--R                                                        Type: AlgebraicNumber
+--E 4
+
+--S 5 of 23
+tt1+t2
+--R 
+--R
+--R           +-+
+--R          \|3
+--R   (5)  - ----
+--R            6
+--R                                                        Type: AlgebraicNumber
+--E 5
+
+--S 6 of 23
+RAN ==> RECLOS FRAC INT
+--R 
+--R                                                                   Type: Void
+--E 6
+
+--S 7 of 23
+x1:=(sqrt(3)$RAN-3)*(sqrt(3)$RAN+1)/6
+--R 
+--R
+--R         1  +-+   1  +-+   1  +-+   1
+--R   (7)  (- \|3  - -)\|3  + - \|3  - -
+--R         6        2        6        2
+--R                                           Type: RealClosure Fraction Integer
+--E 7
+
+--S 8 of 23
+xx1:=-1/sqrt(3)$RAN
+--R 
+--R
+--R          1  +-+
+--R   (8)  - - \|3
+--R          3
+--R                                           Type: RealClosure Fraction Integer
+--E 8
+
+--S 9 of 23
+(x1=xx1)@Boolean
+--R 
+--R
+--R   (9)  true
+--R                                                                Type: Boolean
+--E 9
+
+--S 10 of 23
+s3:=sqrt(3)$RAN
+--R 
+--R
+--R          +-+
+--R   (10)  \|3
+--R                                           Type: RealClosure Fraction Integer
+--E 10
+
+--S 11 of 23
+(s3-3)*(s3+1)/6
+--R 
+--R
+--R           1  +-+
+--R   (11)  - - \|3
+--R           3
+--R                                           Type: RealClosure Fraction Integer
+--E 11
+
+--S 12 of 23
+f3:=sqrt(3,5)$RAN
+--R 
+--R
+--R         5+-+
+--R   (12)  \|3
+--R                                           Type: RealClosure Fraction Integer
+--E 12
+
+--S 13 of 23
+f25:=sqrt(1/25,5)$RAN
+--R 
+--R
+--R          +--+
+--R          | 1
+--R   (13)  5|--
+--R         \|25
+--R                                           Type: RealClosure Fraction Integer
+--E 13
+
+--S 14 of 23
+f32:=sqrt(32/5,5)$RAN
+--R 
+--R
+--R          +--+
+--R          |32
+--R   (14)  5|--
+--R         \| 5
+--R                                           Type: RealClosure Fraction Integer
+--E 14
+
+--S 15 of 23
+f27:=sqrt(27/5,5)$RAN
+--R 
+--R
+--R          +--+
+--R          |27
+--R   (15)  5|--
+--R         \| 5
+--R                                           Type: RealClosure Fraction Integer
+--E 15
+
+--S 16 of 23
+expr1:=sqrt(f32-f27,3)
+--R 
+--R
+--R          +---------------+
+--R          |   +--+    +--+
+--R          |   |27     |32
+--R   (16)  3|- 5|--  + 5|--
+--R         \|  \| 5    \| 5
+--R                                           Type: RealClosure Fraction Integer
+--E 16
+
+--S 17 of 23
+expr2:=(1+f3-f3^2)
+--R 
+--R
+--R           5+-+2   5+-+
+--R   (17)  - \|3   + \|3  + 1
+--R                                           Type: RealClosure Fraction Integer
+--E 17
+
+--S 18 of 23
+expr1-f25*expr2
+--R 
+--R
+--R   (18)  0
+--R                                           Type: RealClosure Fraction Integer
+--E 18
+
+--S 19 of 23
+s:=sqrt(190)$RAN+sqrt(1751)$RAN-sqrt(208)$RAN-sqrt(1698)$RAN
+--R 
+--R
+--R            +----+    +---+    +----+    +---+
+--R   (19)  - \|1698  - \|208  + \|1751  + \|190
+--R                                           Type: RealClosure Fraction Integer
+--E 19
+
+--S 20 of 23
+approximate(s,10^-15)::Float
+--R 
+--R
+--R   (20)  - 0.2341060678 6455900874 E -10
+--R                                                                  Type: Float
+--E 20
+
+--S 21 of 23
+t:=sqrt(190)+sqrt(1751)-sqrt(208)-sqrt(1698)
+--R 
+--R
+--R          +----+    +----+    +---+     +--+
+--R   (21)  \|1751  - \|1698  + \|190  - 4\|13
+--R                                                        Type: AlgebraicNumber
+--E 21
+
+--S 22 of 23
+digits(30)
+--R 
+--R
+--R   (22)  20
+--R                                                        Type: PositiveInteger
+--E 22
+
+--S 23 of 23
+numeric t - approximate(s,10^-30)::Float
+--R 
+--R
+--R   (23)  - 0.5522026336 5 E -29
+--R                                                                  Type: Float
+--E 23
+
+)spool 
+)lisp (bye)
+ 
+@
+\eject
+\begin{thebibliography}{99}
+\bibitem{1} nothing
+\end{thebibliography}
+\end{document}
diff --git a/src/interp/setq.lisp.pamphlet b/src/interp/setq.lisp.pamphlet
index f6e1c05..e9b34ec 100644
--- a/src/interp/setq.lisp.pamphlet
+++ b/src/interp/setq.lisp.pamphlet
@@ -651,8 +651,8 @@
 "Gerhard Schneider      Martin Schoenert       Marshall Schor"
 "Frithjof Schulze       Fritz Schwarz          Nick Simicich"
 "William Sit            Elena Smirnova         Jonathan Steinbach"
-"Christine Sundaresan   Robert Sutor           Moss E. Sweedler"
-"Eugene Surowitz"
+"Fabio Stumbo           Christine Sundaresan   Robert Sutor"
+"Moss E. Sweedler       Eugene Surowitz"
 "Max Tegmark            James Thatcher         Balbir Thomas"
 "Mike Thomas            Dylan Thurston         Barry Trager"
 "Themos T. Tsikas"



From MAILER-DAEMON Tue Aug 19 19:20:36 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KVaVA-0005bO-GF
	for mharc-axiom-developer@gnu.org; Tue, 19 Aug 2008 19:20:36 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KVaV6-0005XV-OX
	for axiom-developer@nongnu.org; Tue, 19 Aug 2008 19:20:33 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KVaUz-0005VQ-Pg
	for axiom-developer@nongnu.org; Tue, 19 Aug 2008 19:20:31 -0400
Received: from [199.232.76.173] (port=53291 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KVaUz-0005VM-Jd
	for axiom-developer@nongnu.org; Tue, 19 Aug 2008 19:20:25 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:52368
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KVaUx-00051i-DG
	for axiom-developer@nongnu.org; Tue, 19 Aug 2008 19:20:25 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7JNKFr3007187;
	Tue, 19 Aug 2008 18:20:15 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7JNKDQ7007181;
	Tue, 19 Aug 2008 18:20:13 -0500
Date: Tue, 19 Aug 2008 18:20:13 -0500
Message-Id: <200808192320.m7JNKDQ7007181@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080819.01.tpd.patch (overload.input added
	(Cyganski))
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 19 Aug 2008 23:20:33 -0000

Add overload.input 
=======================================================================
diff --git a/changelog b/changelog
index 377aa85..fc15048 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,5 @@
+20080819 tpd src/input/Makefile overload.input added
+20080819 dxc src/input/overload.input added
 20080818 tpd src/input/Makefile biquat.input added
 20080818 dxc src/input/biquat.input added
 20080818 dxc "David Cyganski" (no known email)
diff --git a/src/input/Makefile.pamphlet b/src/input/Makefile.pamphlet
index 0d919d6..1c2fa8e 100644
--- a/src/input/Makefile.pamphlet
+++ b/src/input/Makefile.pamphlet
@@ -341,6 +341,7 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     nqip.regress      nsfip.regress    numbers.regress  octonion.regress \
     oct.regress       ode.regress      odpol.regress    op1.regress \
     opalg.regress     operator.regress op.regress       ovar.regress \
+    overload.regress  \
     padic.regress     parabola.regress pascal1.regress  pascal.regress \
     patch51.regress   page.regress \
     patmatch.regress  pat.regress      perman.regress   perm.regress \
@@ -613,10 +614,10 @@ FILES= ${OUT}/algaggr.input  ${OUT}/algbrbf.input    ${OUT}/algfacob.input \
        ${OUT}/nepip.input    ${OUT}/newton.input \
        ${OUT}/nlode.input    ${OUT}/none.input       ${OUT}/noonburg.input \
        ${OUT}/noptip.input   ${OUT}/nqip.input       ${OUT}/nsfip.input \
-       ${OUT}/ntube.input    ${OUT}/oct.input      ${OUT}/ode.input \
+       ${OUT}/ntube.input    ${OUT}/oct.input        ${OUT}/ode.input \
        ${OUT}/octonion.input ${OUT}/odpol.input \
        ${OUT}/opalg.input    ${OUT}/operator.input   ${OUT}/op.input \
-       ${OUT}/op1.input      ${OUT}/ovar.input \
+       ${OUT}/op1.input      ${OUT}/ovar.input       ${OUT}/overload.input \
        ${OUT}/padic.input    ${OUT}/palette.input \
        ${OUT}/parpcurv.input ${OUT}/parscurv.input   ${OUT}/parsurf.input \
        ${OUT}/pascal1.input \
@@ -927,6 +928,7 @@ DOCFILES= \
   ${DOC}/odpol.input.dvi       ${DOC}/op1.input.dvi        \
   ${DOC}/opalg.input.dvi       ${DOC}/operator.input.dvi   \
   ${DOC}/op.input.dvi          ${DOC}/ovar.input.dvi       \
+  ${DOC}/overload.input.dvi   \
   ${DOC}/padic.input.dvi       ${DOC}/palette.input.dvi    \
   ${DOC}/parabola.input.dvi    ${DOC}/parpcurv.input.dvi   \
   ${DOC}/parscurv.input.dvi    ${DOC}/parsurf.input.dvi    \
diff --git a/src/input/overload.input.pamphlet b/src/input/overload.input.pamphlet
new file mode 100644
index 0000000..2db85a7
--- /dev/null
+++ b/src/input/overload.input.pamphlet
@@ -0,0 +1,680 @@
+\documentclass{article}
+\usepackage{axiom}
+\begin{document}
+\title{\$SPAD/src/input overload.input}
+\author{David Cyganski}
+\maketitle
+\begin{abstract}
+Type conversion and overload problems
+\end{abstract}
+\eject
+\tableofcontents
+\eject
+<<*>>=
+)spool overload.output
+)set message test on
+)set message auto off
+)clear all
+@
+\section{Type Conversion and Overload problems}
+Several non-intuitive problems with overloading and type conversions
+arose while developing the biquaternion (see biquat.input) support
+function collection. I have extracted the minimum code set to illustrate
+each of these problems.
+
+\section{Implicit and Explicit Type Conversions}
+We begin by illustrating function calling with variously typed 
+arguments and conversion which we will break in various ways, some
+understandable, some not(?), below.
+
+The cos function will produce float outcomes for float arguments
+<<*>>=
+
+--S 1 of 28
+cos(1.237)
+--R 
+--R
+--R   (1)  0.3276321705 9891498386
+--R                                                                  Type: Float
+--E 1
+
+@
+can handle expressions that mix floats and integers
+<<*>>=
+
+--S 2 of 28
+cos(1.237/2)
+--R 
+--R
+--R   (2)  0.8147490934 6341557739
+--R                                                                  Type: Float
+--E 2
+
+@
+but will respect an integer expression, as we would want it to,
+by not evaluating
+<<*>>=
+
+--S 3 of 28
+cos(2/3)
+--R 
+--R
+--R            2
+--R   (3)  cos(-)
+--R            3
+--R                                                     Type: Expression Integer
+--E 3
+
+@
+We can coerce the evaluation as a float by forcing the floating point
+evaluation of the division and typing of the outcome in a variety of
+ways. Each of the following forms is effective in some appropriate
+and understandable way. Some act explicitly on the ``/'' operator
+to force a polymorphic choice, others convert the type of the second
+constand in each expression which results in a proper implicit selection
+of which ``/'' definitition to use.
+<<*>>=
+
+--S 4 of 28
+cos(2/3::Float)
+--R 
+--R
+--R   (4)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 4
+
+--S 5 of 28
+cos((2/3)::Float)
+--R 
+--R
+--R   (5)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 5
+
+--S 6 of 28
+cos(2/3$Float)
+--R 
+--R
+--R   (6)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 6
+
+--S 7 of 28
+cos((2/3)$Float)
+--R 
+--R
+--R   (7)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 7
+
+--S 8 of 28
+cos(2/3@Float)
+--R 
+--R
+--R   (8)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 8
+
+--S 9 of 28
+cos((2/3)@Float)
+--R 
+--R
+--R   (9)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 9
+
+@
+But, as we would expect, it is too late to attempt coercion after the
+fact. Coercion operates ``on the surface and not deeply'' as illustrated
+here.
+<<*>>=
+
+--S 10 of 28
+cos(2/3)::Float
+--R 
+--R 
+--RDaly Bug
+--R   Cannot convert from type Expression Integer to Float for value
+--R       2
+--R   cos(-)
+--R       3
+--R
+--E 10
+
+@
+However, there is a real need for a deep coercion operator that operates
+on the innermost atomic constants. Suppose we define
+<<*>>=
+
+--S 11 of 28
+cosf(x:Expression Integer):Expression Integer == 1+cos(x/2)
+--R 
+--R   Function declaration cosf : Expression Integer -> Expression Integer
+--R      has been added to workspace.
+--R                                                                   Type: Void
+--E 11
+
+@
+which is an example of a simple function that might be defined in the
+course of typical work. We wish to declare functions as having integer
+based fractions, rather than forming approximate decimal expansions, which
+is preferred for purposes of analytic examination and simplification for
+both the human and the Axiom system. The Axiom book and online resources
+are full of examples in which this choice has been made by the authors
+thanks to the power of this form of expression -- even though it amounts
+to lying to Axiom in many cases as to the ultimate destiny of the function
+being defined. But woe to us if we wish later to evaluate it in a more
+general way because it is a tangled web we weave when we practice to
+decieve.
+<<*>>=
+
+--S 12 of 28
+cosf(2/3)
+--R 
+--R   Compiling function cosf with type Expression Integer -> Expression 
+--R      Integer 
+--R
+--R             1
+--R   (11)  cos(-) + 1
+--R             3
+--R                                                     Type: Expression Integer
+--E 12
+
+--S 13 of 28
+cosf((2/3)::Float)
+--R 
+--R   Conversion failed in the compiled user function cosf .
+--R 
+--RDaly Bug
+--R   Cannot convert from type Float to Expression Integer for value
+--R   0.6666666666 6666666667
+--R
+--E 13
+
+@
+Thus in effect once we wrap a function around an integer base definition,
+we are stuck and unable to evaluate it as a float later, unlike the core
+basic functions that can be used either way. This forces us to choose the
+Float type throughout at a loss of comprehensibility and analyzability,
+unless we seek to more than double our development type by supplying an
+overloaded integer base and Float base version of {\bf every} step of a
+sequential development of a formula.
+
+Bizarrely, the draw function seems to have the power to override the
+type problem as shown here
+<<*>>=
+
+--S 14 of 28
+--draw(cosf(x),x=0..15)
+--E 14
+
+@
+Why can't we grant this deep coercion power to some new form of floating
+point conversion operation which can be applied at will? If draw has
+this power, why not put it in the hands of the user?
+
+Alternatively, it would be best to have a {\bf mixed} type -- mixed 
+= Integer/Float. Like Maple expressions it would leave integers as
+integers and floats as floats, unmolested and treated as generic
+constant quantities with distinguishable parts until an {\bf evalf}
+like function that would force them entirely into the Float type. For
+example, in Maple ``cos(2/3)+1.2323'' remains as is, while in Axiom
+we get
+<<*>>=
+
+--S 15 of 28
+cos(2/3)+1.2323
+--R 
+--R
+--R   (12)  2.0181872607 769480007
+--R                                                       Type: Expression Float
+--E 15
+
+@
+In a way, Axiom already has a quantity treated like this -- the constant
+%pi is treated as a special float which remains unevaluated and does not
+force combination of itself with an Integer. It simply results in a new
+kind of Integer evaluation of type Pi
+<<*>>=
+
+--S 16 of 28
+3/4+%pi
+--R 
+--R
+--R         4%pi + 3
+--R   (13)  --------
+--R             4
+--R                                                                     Type: Pi
+--E 16
+
+@
+\section{Overloading problems}
+Now let's examine properties and problems with overloading.
+
+Define the type $Q$ of Hamiltonian biquaternions
+<<*>>=
+
+--S 17 of 28
+C:=Complex Expression Integer
+--R 
+--R
+--R   (14)  Complex Expression Integer
+--R                                                                 Type: Domain
+--E 17
+
+--S 18 of 28
+Q:=Quaternion C
+--R 
+--R
+--R   (15)  Quaternion Complex Expression Integer
+--R                                                                 Type: Domain
+--E 18
+
+@
+While developing the support functions, this definition of biquat
+division was introduced to simplify the format of the formulae
+<<*>>=
+
+--S 19 of 28
+((x:Q)/(y:Q)):Q == x*inv(y)
+--R 
+--R   Function declaration ?/? : (Quaternion Complex Expression Integer,
+--R      Quaternion Complex Expression Integer) -> Quaternion Complex 
+--R      Expression Integer has been added to workspace.
+--R                                                                   Type: Void
+--E 19
+
+@
+But is this typed function in any way actually restricted to quaternions?
+On the face, it would appear all is normal, here's an example of 
+integer division
+<<*>>=
+
+--S 20 of 28
+x:=15/6
+--R 
+--R   Compiling function / with type (Quaternion Complex Expression 
+--R      Integer,Quaternion Complex Expression Integer) -> Quaternion 
+--R      Complex Expression Integer 
+--R
+--R         5
+--R   (17)  -
+--R         2
+--R                                  Type: Quaternion Complex Expression Integer
+--E 20
+
+@
+But though the answer was right, the type is now a biquat. If we don't
+notice this, and proceed, some things seem still to act normally,
+for example, no complaint from Axiom with
+<<*>>=
+
+--S 21 of 28
+cos(x)
+--R 
+--R
+--R             5
+--R   (18)  cos(-)
+--R             2
+--R                                                     Type: Expression Integer
+--E 21
+
+@
+Of course, we still get a correct answer with
+<<*>>=
+
+--S 22 of 28
+cos(1.237)
+--R 
+--R
+--R   (19)  0.3276321705 9891498386
+--R                                                                  Type: Float
+--E 22
+
+@
+But let's try to apply this as a simple mixed float/integer function
+<<*>>=
+
+--S 23 of 28
+cos(15.457/6)
+--R 
+--R   Conversion failed in the compiled user function / .
+--R 
+--RDaly Bug
+--R   Cannot convert from type Float to Quaternion Complex Expression 
+--R      Integer for value
+--R   15.457
+--R
+--E 23
+
+@
+Obviously the quaternion version of ``/'' is being invoked despite
+mismatches of the arguments and the supposed overloading in effect.
+Well, what if we built a new cosine function that forced the form of
+the arguments into certain types to avoid mismatch?
+<<*>>=
+
+--S 24 of 28
+c(y:Float):Float == cos(y)
+--R 
+--R   Function declaration c : Float -> Float has been added to workspace.
+--R                                                                   Type: Void
+--E 24
+
+@
+At first this seems to work, we can still evaluate a float
+<<*>>=
+
+--S 25 of 28
+c(1.237)
+--R 
+--R   Compiling function c with type Float -> Float 
+--R
+--R   (21)  0.3276321705 9891498386
+--R                                                                  Type: Float
+--E 25
+
+@
+and we can even get a float answer when we introduce the integer coercible
+biquat variable value generated from the above.
+<<*>>=
+
+--S 26 of 28
+c(x)
+--R 
+--R
+--R   (22)  - 0.8011436155 4693371483
+--R                                                                  Type: Float
+--E 26
+
+@
+But that was only misdirection, because this breaks down for reasonable
+expressions because of the ``/'' operation still not being resolved
+correctly.
+<<*>>=
+
+--S 27 of 28
+c(1.237/2)
+--R 
+--R   Conversion failed in the compiled user function / .
+--R 
+--RDaly Bug
+--R   Cannot convert from type Float to Quaternion Complex Expression 
+--R      Integer for value
+--R   1.237
+--R
+--E 27
+
+@
+Rather than complaining about it, what if we tried the various coercions
+that served to solve the similar type conversion problem we had when 
+just dealing with Integer Fraction versus Floats at the top of the page.
+Our results are mixed. Recall that each of the following worked in the
+previous case, producing the correct floating result in each case.
+<<*>>=
+
+--S 28 of 28
+cos(2/3::Float)
+--R 
+--R
+--R             2
+--R   (23)  cos(-)
+--R             3
+--R                                                     Type: Expression Integer
+--E 28
+
+--S 29 of 28
+cos((2/3)::Float)
+--R 
+--R
+--R   (24)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 29
+
+--S 30 of 28
+cos(2/3$Float)
+--R 
+--R
+--R             2
+--R   (25)  cos(-)
+--R             3
+--R                                                     Type: Expression Integer
+--E 30
+
+--S 31 of 28
+cos((2/3)$Float)
+--R 
+--R
+--R   (26)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 31
+
+--S 32 of 28
+cos(2/3@Float)
+--R 
+--R
+--R             2
+--R   (27)  cos(-)
+--R             3
+--R                                                     Type: Expression Integer
+--E 32
+
+--S 33 of 28
+cos((2/3)@Float)
+--R 
+--R 
+--RDaly Bug
+--R   An expression involving @ Float actually evaluated to one of type 
+--R      Quaternion Complex Expression Integer . Perhaps you should use ::
+--R      Float .
+--E 33
+
+@
+Try these examples with our type constrained function, which has better
+luck now
+<<*>>=
+
+--S 34 of 28
+c(2/3::Float)
+--R 
+--R
+--R   (28)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 34
+
+--S 35 of 28
+c((2/3)::Float)
+--R 
+--R
+--R   (29)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 35
+
+--S 36 of 28
+c(2/3$Float)
+--R 
+--R
+--R   (30)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 36
+
+--S 37 of 28
+c((2/3)$Float)
+--R 
+--R
+--R   (31)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 37
+
+--S 38 of 28
+c(2/3@Float)
+--R 
+--R
+--R   (32)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 38
+
+--S 39 of 28
+c((2/3)@Float)
+--R 
+--R 
+--RDaly Bug
+--R   An expression involving @ Float actually evaluated to one of type 
+--R      Quaternion Complex Expression Integer . Perhaps you should use ::
+--R      Float .
+--E 39
+
+@
+Could the above problems have been avoided by not assigning types
+to the function we defined? Let's repeat the entire example with
+this single change for the function c2
+<<*>>=
+
+--S 40 of 28
+c2(y) == cos(y)
+--R 
+--R                                                                   Type: Void
+--E 40
+
+--S 41 of 28
+c2(1.237)
+--R 
+--R   Compiling function c2 with type Float -> Float 
+--R
+--R   (34)  0.3276321705 9891498386
+--R                                                                  Type: Float
+--E 41
+
+--S 42 of 28
+c2(x)
+--R 
+--R   There are 2 exposed and 6 unexposed library operations named cos 
+--R      having 1 argument(s) but none was determined to be applicable. 
+--R      Use HyperDoc Browse, or issue
+--R                               )display op cos
+--R      to learn more about the available operations. Perhaps 
+--R      package-calling the operation or using coercions on the arguments
+--R      will allow you to apply the operation.
+--R   Cannot find a definition or applicable library operation named cos 
+--R      with argument type(s) 
+--R                    Quaternion Complex Expression Integer
+--R      
+--R      Perhaps you should use "@" to indicate the required return type, 
+--R      or "$" to specify which version of the function you need.
+--R   AXIOM will attempt to step through and interpret the code.
+--R
+--R             5
+--R   (35)  cos(-)
+--R             2
+--R                                                     Type: Expression Integer
+--E 42
+
+@
+But that was only misdirection, because this breaks down for
+reasonable expressions
+<<*>>=
+
+--S 43 of 28
+c2(1.237/2)
+--R 
+--R   Conversion failed in the compiled user function / .
+--R 
+--RDaly Bug
+--R   Cannot convert from type Float to Quaternion Complex Expression 
+--R      Integer for value
+--R   1.237
+--R
+--E 43
+
+@
+and various attempts at coercion also fail -- compare these results
+to the previous ones
+<<*>>=
+
+--S 44 of 28
+c2(2/3::Float)
+--R 
+--R
+--R             2
+--R   (36)  cos(-)
+--R             3
+--R                                                     Type: Expression Integer
+--E 44
+
+--S 45 of 28
+c2((2/3)::Float)
+--R 
+--R
+--R   (37)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 45
+
+--S 46 of 28
+c2(2/3$Float)
+--R 
+--R
+--R             2
+--R   (38)  cos(-)
+--R             3
+--R                                                     Type: Expression Integer
+--E 46
+
+--S 47 of 28
+c2((2/3)$Float)
+--R 
+--R
+--R   (39)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 47
+
+--S 48 of 28
+c2(2/3@Float)
+--R 
+--R
+--R             2
+--R   (40)  cos(-)
+--R             3
+--R                                                     Type: Expression Integer
+--E 48
+
+--S 49 of 28
+c2((2/3)@Float)
+--R 
+--R 
+--RDaly Bug
+--R   An expression involving @ Float actually evaluated to one of type 
+--R      Quaternion Complex Expression Integer . Perhaps you should use ::
+--R      Float .
+--E 49
+
+@
+Lastly, we cannot now use the graph function, draw, on such a function 
+since the wrong ``/'' function is used, contrary to the bypassing of
+internal types we saw take place with draw in the example prior to the
+introduction of operator overloading.
+<<*>>=
+
+--S 50 of 28
+--draw(c(x),x=0..15)
+--E 50
+
+@
+{\sl Not safe at any speed}. Most oddly, the ordinary cos() function which
+exposes no ``/'' division Now fails to work with draw despite the fact
+that we just saw it above still working with Integer and Float arguments
+applied directly.
+<<*>>=
+
+--S 51 of 28
+--draw(cos(x),x=0..15)
+--E 51
+
+)spool 
+)lisp (bye)
+ 
+@
+\eject
+\begin{thebibliography}{99}
+\bibitem{1} nothing
+\end{thebibliography}
+\end{document}



From MAILER-DAEMON Wed Aug 20 17:21:35 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KVv7X-0003MI-P7
	for mharc-axiom-developer@gnu.org; Wed, 20 Aug 2008 17:21:35 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KVv7W-0003M1-IF
	for axiom-developer@nongnu.org; Wed, 20 Aug 2008 17:21:34 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KVv7T-0003L7-6w
	for axiom-developer@nongnu.org; Wed, 20 Aug 2008 17:21:33 -0400
Received: from [199.232.76.173] (port=41825 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KVv7T-0003L4-4G
	for axiom-developer@nongnu.org; Wed, 20 Aug 2008 17:21:31 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:34120
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KVv7S-0006uX-Fx
	for axiom-developer@nongnu.org; Wed, 20 Aug 2008 17:21:30 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7KLLQr3018490;
	Wed, 20 Aug 2008 16:21:26 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7KLLQlT018487;
	Wed, 20 Aug 2008 16:21:26 -0500
Date: Wed, 20 Aug 2008 16:21:26 -0500
Message-Id: <200808202121.m7KLLQlT018487@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080820.01.tpd.patch (fix typos in latex code)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 20 Aug 2008 21:21:34 -0000

test.input.pamphlet had 2 typos that causes a bad latex.
====================================================================
diff --git a/changelog b/changelog
index fc15048..e65b07c 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,6 @@
+20080820 tpd src/input/test.input fix typos
+20080819 tpd src/input/Makefile overload.input added
+20080819 dxc src/input/overload.input added
 20080819 tpd src/input/Makefile overload.input added
 20080819 dxc src/input/overload.input added
 20080818 tpd src/input/Makefile biquat.input added
diff --git a/src/input/test.input.pamphlet b/src/input/test.input.pamphlet
index ea9b453..eb5bb1c 100644
--- a/src/input/test.input.pamphlet
+++ b/src/input/test.input.pamphlet
@@ -484,7 +484,6 @@ Bracket parsing and empty-set types. Fixed by SCM, verified on 10/30/90
 <<*>>=
 )clear all
 
-@
 --S 35
 {}$(List INT)
 --R 
@@ -1608,7 +1607,7 @@ s - sin(a*x)
 --E 121
 
 @
-Complex & AlgebraicNumber coercions. fixed by SCM 6/91
+Complex \& AlgebraicNumber coercions. fixed by SCM 6/91
 <<*>>=
 )clear all
 



From MAILER-DAEMON Fri Aug 22 00:13:15 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KWO1T-0008P7-0v
	for mharc-axiom-developer@gnu.org; Fri, 22 Aug 2008 00:13:15 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KWO1S-0008OY-AF
	for axiom-developer@nongnu.org; Fri, 22 Aug 2008 00:13:14 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KWO1R-0008Nb-3G
	for axiom-developer@nongnu.org; Fri, 22 Aug 2008 00:13:13 -0400
Received: from [199.232.76.173] (port=43099 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KWO1Q-0008NN-TB
	for axiom-developer@nongnu.org; Fri, 22 Aug 2008 00:13:12 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:60362
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KWO1Q-0007mD-7W
	for axiom-developer@nongnu.org; Fri, 22 Aug 2008 00:13:12 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7M4D6r3011268;
	Thu, 21 Aug 2008 23:13:06 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7M4D61n011265;
	Thu, 21 Aug 2008 23:13:06 -0500
Date: Thu, 21 Aug 2008 23:13:06 -0500
Message-Id: <200808220413.m7M4D61n011265@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080821.01.tpd.patch (add MappingPackage4)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 22 Aug 2008 04:13:14 -0000

Modify mappkg.spad to add MappingPackage4, including algebra test
file and )help documentation. Fix corresponding operation count 
message in test.input regression.
===================================================================
diff --git a/changelog b/changelog
index 377aa85..3ba51a4 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,12 @@
+20080821 tpd src/algebra/Makefile add MappingPackage4
+20080821 tpd src/algebra/exposed.lsp add MappingPackage4
+20080821 tpd src/algebra/mappkg.spad add MAPPKG4
+20080821 tpd src/input/test.input repair regressions
+20080820 tpd src/input/test.input fix typos
+20080819 tpd src/input/Makefile overload.input added
+20080819 dxc src/input/overload.input added
+20080819 tpd src/input/Makefile overload.input added
+20080819 dxc src/input/overload.input added
 20080818 tpd src/input/Makefile biquat.input added
 20080818 dxc src/input/biquat.input added
 20080818 dxc "David Cyganski" (no known email)
diff --git a/src/algebra/Makefile.pamphlet b/src/algebra/Makefile.pamphlet
index d140609..7ea5dea 100644
--- a/src/algebra/Makefile.pamphlet
+++ b/src/algebra/Makefile.pamphlet
@@ -244,7 +244,6 @@ LAYER3=\
 annacat.spad.pamphlet (NIPROB ODEPROB PDEPROB OPTPROB NUMINT ODECAT PDECAT
                        OPTCAT)
 color.spad.pamphlet (COLOR PALETTE)
-mappkg.spad.pamphlet (MAPHACK1 MAPHACK2 MAPHACK3 MAPPKG1 MAPPKG2 MAPPKG3)
 paramete.spad.pamphlet (PARPCURV PARPC2 PARSCURV PARSC2 PARSURF PARSU2
 suchthat.spad.pamphlet (SUCH)
 ystream.spad.pamphlet (YSTREAM)
@@ -388,6 +387,8 @@ drawpak.spad.pamphlet (DRAWCX)
 free.spad.pamphlet (LMOPS FMONOID FGROUP FAMONC IFAMON FAMONOID FAGROUP)
 fourier.spad.pamphlet (FCOMP FSERIES)
 functions.spad.pamphlet (BFUNCT)
+mappkg.spad.pamphlet (MAPHACK1 MAPHACK2 MAPHACK3 MAPHACK4
+                      MAPPKG1 MAPPKG2 MAPPKG3 MAPPKG4)
 mesh.spad.pamphlet (MESH)
 moebius.spad.pamphlet (MOEBIUS)
 mring.spad.pamphlet (MRING MRF2)
@@ -414,6 +415,7 @@ LAYER10=\
   ${OUT}/IPADIC.o   ${OUT}/IROOT.o    ${OUT}/IR2.o      ${OUT}/LEXP.o     \
   ${OUT}/LIECAT.o   ${OUT}/LIECAT-.o  ${OUT}/LIST2.o    ${OUT}/LIST2MAP.o \
   ${OUT}/LMOPS.o    ${OUT}/LZSTAGG.o  ${OUT}/LZSTAGG-.o ${OUT}/MAGMA.o    \
+  ${OUT}/MAPPKG4.o  \
   ${OUT}/MESH.o     ${OUT}/MOEBIUS.o  ${OUT}/MODFIELD.o ${OUT}/MODOP.o    \
   ${OUT}/MRING.o    ${OUT}/MTHING.o   ${OUT}/NCNTFRAC.o ${OUT}/NCODIV.o   \
   ${OUT}/NUMTUBE.o  ${OUT}/ODR.o      ${OUT}/OFMONOID.o ${OUT}/ONECOMP.o  \
@@ -3130,7 +3132,6 @@ check:
 document: ${DOCFILES}
 
 <<genericRules>>
-
 <<spadhelp>>
 <<ps (DOC from SRC)>>
 <<libdb.text (OUT from IN)>>
diff --git a/src/algebra/exposed.lsp.pamphlet b/src/algebra/exposed.lsp.pamphlet
index ed6155a..9701e7f 100644
--- a/src/algebra/exposed.lsp.pamphlet
+++ b/src/algebra/exposed.lsp.pamphlet
@@ -208,6 +208,7 @@
   (|MappingPackage1| . MAPPKG1)
   (|MappingPackage2| . MAPPKG2)
   (|MappingPackage3| . MAPPKG3)
+  (|MappingPackage4| . MAPPKG4)
   (|MathMLFormat| . MMLFORM)
   (|Matrix| . MATRIX)
   (|MatrixCategoryFunctions2| . MATCAT2)
diff --git a/src/algebra/mappkg.spad.pamphlet b/src/algebra/mappkg.spad.pamphlet
index 5ec4358..ca1dc5f 100644
--- a/src/algebra/mappkg.spad.pamphlet
+++ b/src/algebra/mappkg.spad.pamphlet
@@ -2,7 +2,7 @@
 \usepackage{axiom}
 \begin{document}
 \title{\$SPAD/src/algebra mappkg.spad}
-\author{Stephen M. Watt, William Burge}
+\author{Stephen M. Watt, William Burge, Timothy Daly}
 \maketitle
 \begin{abstract}
 \end{abstract}
@@ -83,7 +83,8 @@ MappingPackageInternalHacks3(A: SetCategory, B: SetCategory, C: SetCategory):_
 )set message test on
 )set message auto off
 )clear all
---S 1
+
+--S 1 of 26
 power(q: FRAC INT, n: INT): FRAC INT == q**n
 --R 
 --R   Function declaration power : (Fraction Integer,Integer) -> Fraction 
@@ -91,7 +92,7 @@ power(q: FRAC INT, n: INT): FRAC INT == q**n
 --R                                                                   Type: Void
 --E 1
 
---S 2
+--S 2 of 26
 power(2,3)
 --R 
 --R   Compiling function power with type (Fraction Integer,Integer) -> 
@@ -101,15 +102,15 @@ power(2,3)
 --R                                                       Type: Fraction Integer
 --E 2
 
---S 3
+--S 3 of 26
 rewop := twist power
 --R 
 --R
---R   (3)  theMap(MAPPKG3;twist;MM;5!0)
+--I   (3)  theMap(MAPPKG3;twist;MM;5!0)
 --R                       Type: ((Integer,Fraction Integer) -> Fraction Integer)
 --E 3
 
---S 4
+--S 4 of 26
 rewop(3, 2)
 --R 
 --R
@@ -117,21 +118,21 @@ rewop(3, 2)
 --R                                                       Type: Fraction Integer
 --E 4
 
---S 5
+--S 5 of 26
 square: FRAC INT -> FRAC INT
 --R 
 --R                                                                   Type: Void
 --E 5
 
---S 6
+--S 6 of 26
 square:= curryRight(power, 2)
 --R 
 --R
---R   (6)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
+--I   (6)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
 --R                                 Type: (Fraction Integer -> Fraction Integer)
 --E 6
 
---S 7
+--S 7 of 26
 square 4
 --R 
 --R
@@ -139,15 +140,15 @@ square 4
 --R                                                       Type: Fraction Integer
 --E 7
 
---S 8
+--S 8 of 26
 squirrel:= constantRight(square)$MAPPKG3(FRAC INT,FRAC INT,FRAC INT)
 --R 
 --R
---R   (8)  theMap(MAPPKG3;constantRight;MM;3!0)
+--I   (8)  theMap(MAPPKG3;constantRight;MM;3!0)
 --R              Type: ((Fraction Integer,Fraction Integer) -> Fraction Integer)
 --E 8
 
---S 9
+--S 9 of 26
 squirrel(1/2, 1/3)
 --R 
 --R
@@ -157,15 +158,15 @@ squirrel(1/2, 1/3)
 --R                                                       Type: Fraction Integer
 --E 9
 
---S 10
+--S 10 of 26
 sixteen := curry(square, 4/1)
 --R 
 --R
---R   (10)  theMap(MAPPKG2;curry;MAM;2!0,0)
+--I   (10)  theMap(MAPPKG2;curry;MAM;2!0,0)
 --R                                               Type: (() -> Fraction Integer)
 --E 10
 
---S 11
+--S 11 of 26
 sixteen()
 --R 
 --R
@@ -173,15 +174,15 @@ sixteen()
 --R                                                       Type: Fraction Integer
 --E 11
 
---S 12
+--S 12 of 26
 square2:=square*square
 --R 
 --R
---R   (12)  theMap(MAPPKG3;*;MMM;6!0,0)
+--I   (12)  theMap(MAPPKG3;*;MMM;6!0,0)
 --R                                 Type: (Fraction Integer -> Fraction Integer)
 --E 12
 
---S 13
+--S 13 of 26
 square2 3
 --R 
 --R
@@ -189,7 +190,7 @@ square2 3
 --R                                                       Type: Fraction Integer
 --E 13
 
---S 14
+--S 14 of 26
 sc(x: FRAC INT): FRAC INT == x + 1
 --R 
 --R   Function declaration sc : Fraction Integer -> Fraction Integer has 
@@ -197,23 +198,23 @@ sc(x: FRAC INT): FRAC INT == x + 1
 --R                                                                   Type: Void
 --E 14
 
---S 15
+--S 15 of 26
 incfns := [sc**i for i in 0..10]
 --R 
 --R   Compiling function sc with type Fraction Integer -> Fraction Integer
 --R      
 --R
 --R   (15)
---R   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
---R    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
---R    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
---R    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
---R    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
---R    theMap(MAPPKG1;**;MNniM;6!0,0)]
+--I   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
+--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
+--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
+--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
+--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
+--I    theMap(MAPPKG1;**;MNniM;6!0,0)]
 --R                            Type: List (Fraction Integer -> Fraction Integer)
 --E 15
 
---S 16
+--S 16 of 26
 [f 4 for f in incfns]
 --R 
 --R
@@ -221,7 +222,7 @@ incfns := [sc**i for i in 0..10]
 --R                                                  Type: List Fraction Integer
 --E 16
 
---S 17
+--S 17 of 26
 times(n:NNI, i:INT):INT == n*i
 --R 
 --R   Function declaration times : (NonNegativeInteger,Integer) -> Integer
@@ -229,25 +230,25 @@ times(n:NNI, i:INT):INT == n*i
 --R                                                                   Type: Void
 --E 17
 
---S 18
+--S 18 of 26
 r := recur(times)
 --R 
 --R   Compiling function times with type (NonNegativeInteger,Integer) -> 
 --R      Integer 
 --R
---R   (18)  theMap(MAPPKG1;recur;2M;7!0,0)
+--I   (18)  theMap(MAPPKG1;recur;2M;7!0,0)
 --R                              Type: ((NonNegativeInteger,Integer) -> Integer)
 --E 18
 
---S 19
+--S 19 of 26
 fact := curryRight(r, 1)
 --R 
 --R
---R   (19)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
+--I   (19)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
 --R                                        Type: (NonNegativeInteger -> Integer)
 --E 19
 
---S 20
+--S 20 of 26
 fact 4
 --R 
 --R
@@ -255,7 +256,7 @@ fact 4
 --R                                                        Type: PositiveInteger
 --E 20
 
---S 21
+--S 21 of 26
 mto2ton(m, n) ==
   raiser := square^n
   raiser m
@@ -263,7 +264,7 @@ mto2ton(m, n) ==
 --R                                                                   Type: Void
 --E 21
 
---S 22
+--S 22 of 26
 mto2ton(3, 3)
 --R 
 --R   Compiling function mto2ton with type (PositiveInteger,
@@ -273,7 +274,7 @@ mto2ton(3, 3)
 --R                                                       Type: Fraction Integer
 --E 22
 
---S 23
+--S 23 of 26
 shiftfib(r: List INT) : INT ==
   t := r.1
   r.1 := r.2
@@ -285,7 +286,7 @@ shiftfib(r: List INT) : INT ==
 --R                                                                   Type: Void
 --E 23
 
---S 24
+--S 24 of 26
 fibinit: List INT := [0, 1]
 --R 
 --R
@@ -293,16 +294,16 @@ fibinit: List INT := [0, 1]
 --R                                                           Type: List Integer
 --E 24
 
---S 25
+--S 25 of 26
 fibs := curry(shiftfib, fibinit)
 --R 
 --R   Compiling function shiftfib with type List Integer -> Integer 
 --R
---R   (25)  theMap(MAPPKG2;curry;MAM;2!0,0)
+--I   (25)  theMap(MAPPKG2;curry;MAM;2!0,0)
 --R                                                        Type: (() -> Integer)
 --E 25
 
---S 26
+--S 26 of 26
 [fibs() for i in 0..30]
 --R 
 --R
@@ -312,6 +313,16 @@ fibs := curry(shiftfib, fibinit)
 --R    317811, 514229, 832040]
 --R                                                           Type: List Integer
 --E 26
+ 
+)spool 
+)lisp (bye)
+ 
+@
+\eject
+\begin{thebibliography}{99}
+\bibitem{1} nothing
+\end{thebibliography}
+\end{document}
 )spool
 )lisp (bye)
 @
@@ -486,9 +497,10 @@ By currying over the argument we get a function with private state.
                        Type: List Integer
 
 See Also:
+o )show MappingPackage1
 o )help MappingPackage2
 o )help MappingPackage3
-o )show MappingPackage1
+o )help MappingPackage4
 o $AXIOM/doc/src/algebra/mappkg.spad.dvi
 
 @
@@ -595,7 +607,7 @@ power(2,3)
 rewop := twist power
 --R 
 --R
---R   (3)  theMap(MAPPKG3;twist;MM;5!0)
+--I   (3)  theMap(MAPPKG3;twist;MM;5!0)
 --R                       Type: ((Integer,Fraction Integer) -> Fraction Integer)
 --E 3
 
@@ -617,7 +629,7 @@ square: FRAC INT -> FRAC INT
 square:= curryRight(power, 2)
 --R 
 --R
---R   (6)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
+--I   (6)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
 --R                                 Type: (Fraction Integer -> Fraction Integer)
 --E 6
 
@@ -633,7 +645,7 @@ square 4
 squirrel:= constantRight(square)$MAPPKG3(FRAC INT,FRAC INT,FRAC INT)
 --R 
 --R
---R   (8)  theMap(MAPPKG3;constantRight;MM;3!0)
+--I   (8)  theMap(MAPPKG3;constantRight;MM;3!0)
 --R              Type: ((Fraction Integer,Fraction Integer) -> Fraction Integer)
 --E 8
 
@@ -651,7 +663,7 @@ squirrel(1/2, 1/3)
 sixteen := curry(square, 4/1)
 --R 
 --R
---R   (10)  theMap(MAPPKG2;curry;MAM;2!0,0)
+--I   (10)  theMap(MAPPKG2;curry;MAM;2!0,0)
 --R                                               Type: (() -> Fraction Integer)
 --E 10
 
@@ -667,7 +679,7 @@ sixteen()
 square2:=square*square
 --R 
 --R
---R   (12)  theMap(MAPPKG3;*;MMM;6!0,0)
+--I   (12)  theMap(MAPPKG3;*;MMM;6!0,0)
 --R                                 Type: (Fraction Integer -> Fraction Integer)
 --E 12
 
@@ -694,12 +706,12 @@ incfns := [sc**i for i in 0..10]
 --R      
 --R
 --R   (15)
---R   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
---R    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
---R    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
---R    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
---R    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
---R    theMap(MAPPKG1;**;MNniM;6!0,0)]
+--I   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
+--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
+--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
+--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
+--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
+--I    theMap(MAPPKG1;**;MNniM;6!0,0)]
 --R                            Type: List (Fraction Integer -> Fraction Integer)
 --E 15
 
@@ -725,7 +737,7 @@ r := recur(times)
 --R   Compiling function times with type (NonNegativeInteger,Integer) -> 
 --R      Integer 
 --R
---R   (18)  theMap(MAPPKG1;recur;2M;7!0,0)
+--I   (18)  theMap(MAPPKG1;recur;2M;7!0,0)
 --R                              Type: ((NonNegativeInteger,Integer) -> Integer)
 --E 18
 
@@ -733,7 +745,7 @@ r := recur(times)
 fact := curryRight(r, 1)
 --R 
 --R
---R   (19)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
+--I   (19)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
 --R                                        Type: (NonNegativeInteger -> Integer)
 --E 19
 
@@ -788,7 +800,7 @@ fibs := curry(shiftfib, fibinit)
 --R 
 --R   Compiling function shiftfib with type List Integer -> Integer 
 --R
---R   (25)  theMap(MAPPKG2;curry;MAM;2!0,0)
+--I   (25)  theMap(MAPPKG2;curry;MAM;2!0,0)
 --R                                                        Type: (() -> Integer)
 --E 25
 
@@ -977,8 +989,9 @@ By currying over the argument we get a function with private state.
 
 See Also:
 o )help MappingPackage1
-o )help MappingPackage3
 o )show MappingPackage2
+o )help MappingPackage3
+o )help MappingPackage4
 o $AXIOM/doc/src/algebra/mappkg.spad.dvi
 
 @
@@ -1052,7 +1065,7 @@ power(2,3)
 rewop := twist power
 --R 
 --R
---R   (3)  theMap(MAPPKG3;twist;MM;5!0)
+--I   (3)  theMap(MAPPKG3;twist;MM;5!0)
 --R                       Type: ((Integer,Fraction Integer) -> Fraction Integer)
 --E 3
 
@@ -1074,7 +1087,7 @@ square: FRAC INT -> FRAC INT
 square:= curryRight(power, 2)
 --R 
 --R
---R   (6)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
+--I   (6)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
 --R                                 Type: (Fraction Integer -> Fraction Integer)
 --E 6
 
@@ -1090,7 +1103,7 @@ square 4
 squirrel:= constantRight(square)$MAPPKG3(FRAC INT,FRAC INT,FRAC INT)
 --R 
 --R
---R   (8)  theMap(MAPPKG3;constantRight;MM;3!0)
+--I   (8)  theMap(MAPPKG3;constantRight;MM;3!0)
 --R              Type: ((Fraction Integer,Fraction Integer) -> Fraction Integer)
 --E 8
 
@@ -1108,7 +1121,7 @@ squirrel(1/2, 1/3)
 sixteen := curry(square, 4/1)
 --R 
 --R
---R   (10)  theMap(MAPPKG2;curry;MAM;2!0,0)
+--I   (10)  theMap(MAPPKG2;curry;MAM;2!0,0)
 --R                                               Type: (() -> Fraction Integer)
 --E 10
 
@@ -1124,7 +1137,7 @@ sixteen()
 square2:=square*square
 --R 
 --R
---R   (12)  theMap(MAPPKG3;*;MMM;6!0,0)
+--I   (12)  theMap(MAPPKG3;*;MMM;6!0,0)
 --R                                 Type: (Fraction Integer -> Fraction Integer)
 --E 12
 
@@ -1151,12 +1164,12 @@ incfns := [sc**i for i in 0..10]
 --R      
 --R
 --R   (15)
---R   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
---R    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
---R    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
---R    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
---R    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
---R    theMap(MAPPKG1;**;MNniM;6!0,0)]
+--I   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
+--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
+--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
+--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
+--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
+--I    theMap(MAPPKG1;**;MNniM;6!0,0)]
 --R                            Type: List (Fraction Integer -> Fraction Integer)
 --E 15
 
@@ -1182,7 +1195,7 @@ r := recur(times)
 --R   Compiling function times with type (NonNegativeInteger,Integer) -> 
 --R      Integer 
 --R
---R   (18)  theMap(MAPPKG1;recur;2M;7!0,0)
+--I   (18)  theMap(MAPPKG1;recur;2M;7!0,0)
 --R                              Type: ((NonNegativeInteger,Integer) -> Integer)
 --E 18
 
@@ -1190,7 +1203,7 @@ r := recur(times)
 fact := curryRight(r, 1)
 --R 
 --R
---R   (19)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
+--I   (19)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
 --R                                        Type: (NonNegativeInteger -> Integer)
 --E 19
 
@@ -1245,7 +1258,7 @@ fibs := curry(shiftfib, fibinit)
 --R 
 --R   Compiling function shiftfib with type List Integer -> Integer 
 --R
---R   (25)  theMap(MAPPKG2;curry;MAM;2!0,0)
+--I   (25)  theMap(MAPPKG2;curry;MAM;2!0,0)
 --R                                                        Type: (() -> Integer)
 --E 25
 
@@ -1436,6 +1449,7 @@ See Also:
 o )help MappingPackage1
 o )help MappingPackage2
 o )show MappingPackage3
+o )help MappingPackage4
 o $AXIOM/doc/src/algebra/mappkg.spad.dvi
 
 @
@@ -1499,6 +1513,320 @@ MappingPackage3(A:SetCategory, B:SetCategory, C:SetCategory):_
         fbc*fab == comp(fbc,fab,#1)
 
 @
+\section{package MAPPKG4 MappingPackage4}
+<<MappingPackage4.input>>=
+-- mappkg.spad.pamphlet MappingPackage4.input
+)spool MappingPackage4.output
+)set message test on
+)set message auto off
+)clear all
+
+--S 1 of 21
+p:=(x:EXPR(INT)):EXPR(INT)+->3*x
+--R 
+--R
+--R   (1)  theMap(Closure)
+--R                             Type: (Expression Integer -> Expression Integer)
+--E 1
+
+--S 2 of 21
+q:=(x:EXPR(INT)):EXPR(INT)+->2*x+3
+--R 
+--R
+--R   (2)  theMap(Closure)
+--R                             Type: (Expression Integer -> Expression Integer)
+--E 2
+
+--S 3 of 21
+(p+q)(4)-(p(4)+q(4))
+--R 
+--R
+--R   (3)  0
+--R                                                     Type: Expression Integer
+--E 3
+
+--S 4 of 21
+(p+q)(x)-(p(x)+q(x))
+--R 
+--R
+--R   (4)  0
+--R                                                     Type: Expression Integer
+--E 4
+
+--S 5 of 21
+(p-q)(4)-(p(4)-q(4))
+--R 
+--R
+--R   (5)  0
+--R                                                     Type: Expression Integer
+--E 5
+
+--S 6 of 21
+(p-q)(x)-(p(x)-q(x))
+--R 
+--R
+--R   (6)  0
+--R                                                     Type: Expression Integer
+--E 6
+
+--S 7 of 21
+(p*q)(4)-(p(4)*q(4))
+--R 
+--R
+--R   (7)  0
+--R                                                     Type: Expression Integer
+--E 7
+
+--S 8 of 21
+(p*q)(x)-(p(x)*q(x))
+--R 
+--R
+--R   (8)  0
+--R                                                     Type: Expression Integer
+--E 8
+
+--S 9 of 21
+(p/q)(4)-(p(4)/q(4))
+--R 
+--R
+--R   (9)  0
+--R                                                     Type: Expression Integer
+--E 9
+
+--S 10 of 21
+(p/q)(x)-(p(x)/q(x))
+--R 
+--R
+--R   (10)  0
+--R                                                     Type: Expression Integer
+--E 10
+
+--S 11 of 21
+r:=(x:INT):INT+-> (x*x*x)
+--R 
+--R
+--R   (11)  theMap(Closure)
+--R                                                   Type: (Integer -> Integer)
+--E 11
+
+--S 12 of 21
+s:=(y:INT):INT+-> (y*y+3)
+--R 
+--R
+--R   (12)  theMap(Closure)
+--R                                                   Type: (Integer -> Integer)
+--E 12
+
+--S 13 of 21
+(r+s)(4)-(r(4)+s(4))
+--R 
+--R
+--R   (13)  0
+--R                                                     Type: NonNegativeInteger
+--E 13
+
+--S 14 of 21
+(r-s)(4)-(r(4)-s(4))
+--R 
+--R
+--R   (14)  0
+--R                                                     Type: NonNegativeInteger
+--E 14
+
+--S 15 of 21
+(r*s)(4)-(r(4)*s(4))
+--R 
+--R
+--R   (15)  0
+--R                                                     Type: NonNegativeInteger
+--E 15
+
+--S 16 of 21
+t:=(x:INT):EXPR(INT)+-> (x*x*x)
+--R 
+--R
+--R   (16)  theMap(Closure)
+--R                                        Type: (Integer -> Expression Integer)
+--E 16
+
+--S 17 of 21
+u:=(y:INT):EXPR(INT)+-> (y*y+3)
+--R 
+--R
+--R   (17)  theMap(Closure)
+--R                                        Type: (Integer -> Expression Integer)
+--E 17
+
+--S 18 of 21
+(t/u)(4)-(t(4)/u(4))
+--R 
+--R
+--R   (18)  0
+--R                                                     Type: Expression Integer
+--E 18
+
+--S 19 of 21
+h:=(x:EXPR(INT)):EXPR(INT)+->1
+--R
+--R   (19)  theMap(Closure)
+--R                             Type: (Expression Integer -> Expression Integer)
+--E 19
+
+--S 20 of 21
+(p/h)(x)
+--R
+--R   (20)  3x
+--R                                                     Type: Expression Integer
+--E 20
+
+--S 21 of 21
+(q/h)(x)
+--R
+--R   (21)  2x + 3
+--R                                                     Type: Expression Integer
+--E 21
+
+)spool 
+)lisp (bye)
+ 
+@
+\eject
+\begin{thebibliography}{99}
+\bibitem{1} nothing
+\end{thebibliography}
+\end{document}
+)spool
+)lisp (bye)
+@
+<<MappingPackage4.help>>=
+====================================================================
+MappingPackage examples
+====================================================================
+
+We can construct some simple maps that take a variable x
+into an equation:
+
+  p:=(x:EXPR(INT)):EXPR(INT)+->3*x
+  q:=(x:EXPR(INT)):EXPR(INT)+->2*x+3
+
+Now we can do the four arithmetic operations, +, -, *, / on these
+newly constructed mappings. Since the maps are from the domain
+Expression Integer to the same domain we can also use symbolic
+values for the argument. All of the following will return 0,
+showing that function composition is equivalent to the result
+of doing the operations individually.
+
+  (p+q)(4)-(p(4)+q(4))
+  (p+q)(x)-(p(x)+q(x))
+  
+  (p-q)(4)-(p(4)-q(4))
+  (p-q)(x)-(p(x)-q(x))
+
+  (p*q)(4)-(p(4)*q(4))
+  (p*q)(x)-(p(x)*q(x))
+
+  (p/q)(4)-(p(4)/q(4))
+  (p/q)(x)-(p(x)/q(x))
+
+We can construct simple maps from Integer to Integer but this
+limits our ability to do division.
+
+  r:=(x:INT):INT+-> (x*x*x)
+  s:=(y:INT):INT+-> (y*y+3)
+
+Again, all of these will return 0:
+
+  (r+s)(4)-(r(4)+s(4))
+  (r-s)(4)-(r(4)-s(4))
+  (r*s)(4)-(r(4)*s(4))
+
+If we want to do division with Integer inputs we create the
+appropriate map:
+
+  t:=(x:INT):EXPR(INT)+-> (x*x*x)
+  u:=(y:INT):EXPR(INT)+-> (y*y+3)
+
+  (t/u)(4)-(t(4)/u(4))
+
+We can even recover the original functions if we make a map
+that always returns the constant 1:
+
+  h:=(x:EXPR(INT)):EXPR(INT)+->1
+
+    theMap(Closure)
+             Type: (Expression Integer -> Expression Integer)
+
+  (p/h)(x)
+
+     3x
+                                     Type: Expression Integer
+  (q/h)(x)
+
+    2x + 3
+                                     Type: Expression Integer
+
+See Also:
+o )show MappingPackage1
+o )help MappingPackage2
+o )help MappingPackage3
+o )help MappingPackage4
+o $AXIOM/doc/src/algebra/mappkg.spad.dvi
+
+@
+<<package MAPPKG4 MappingPackage4>>=
+)abbrev package MAPPKG4 MappingPackage4
+++ Author: Timothy Daly
+++ Description: Functional Composition
+++ Given functions f and g, returns the applicable closure
+MappingPackage4(A:SetCategory, B:Ring):
+ with
+   "+": (A->B, A->B) -> (A->B) 
+        ++ \spad(+) does functional addition
+        ++
+        ++E f:=(x:INT):INT +-> 3*x
+        ++E g:=(x:INT):INT +-> 2*x+3
+        ++E (f+g)(4)
+   "-": (A->B, A->B) -> (A->B) 
+        ++ \spad(+) does functional addition
+        ++
+        ++E f:=(x:INT):INT +-> 3*x
+        ++E g:=(x:INT):INT +-> 2*x+3
+        ++E (f-g)(4)
+   "*": (A->B, A->B) -> (A->B) 
+        ++ \spad(+) does functional addition
+        ++
+        ++E f:=(x:INT):INT +-> 3*x
+        ++E g:=(x:INT):INT +-> 2*x+3
+        ++E (f*g)(4)
+   "/": (A->Expression(Integer), A->Expression(Integer)) -> (A->Expression(Integer))
+        ++ \spad(+) does functional addition
+        ++
+        ++E p:=(x:EXPR(INT)):EXPR(INT)+->3*x
+        ++E q:=(x:EXPR(INT)):EXPR(INT)+->2*x+3
+        ++E (p/q)(4)
+        ++E (p/q)(x)
+  == add
+    fab ==> (A -> B)
+    faei ==> (A -> Expression(Integer))
+
+    funcAdd(g:fab,h:fab,x:A):B == ((g x) + (h x))$B
+
+    (a:fab)+(b:fab) == funcAdd(a,b,#1)
+
+    funcSub(g:fab,h:fab,x:A):B == ((g x) - (h x))$B
+
+    (a:fab)-(b:fab) == funcSub(a,b,#1)
+
+    funcMul(g:fab,h:fab,x:A):B == ((g x) * (h x))$B
+
+    (a:fab)*(b:fab) == funcMul(a,b,#1)
+
+    funcDiv(g:faei,h:faei,x:A):Expression(Integer)
+           == ((g x) / (h x))$Expression(Integer)
+
+    (a:faei)/(b:faei) == funcDiv(a,b,#1)
+
+@
 \section{License}
 <<license>>=
 --Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
@@ -1541,6 +1869,7 @@ MappingPackage3(A:SetCategory, B:SetCategory, C:SetCategory):_
 <<package MAPPKG1 MappingPackage1>>
 <<package MAPPKG2 MappingPackage2>>
 <<package MAPPKG3 MappingPackage3>>
+<<package MAPPKG4 MappingPackage4>>
 @
 \eject
 \begin{thebibliography}{99}
diff --git a/src/input/test.input.pamphlet b/src/input/test.input.pamphlet
index ea9b453..7ffe5b8 100644
--- a/src/input/test.input.pamphlet
+++ b/src/input/test.input.pamphlet
@@ -484,7 +484,6 @@ Bracket parsing and empty-set types. Fixed by SCM, verified on 10/30/90
 <<*>>=
 )clear all
 
-@
 --S 35
 {}$(List INT)
 --R 
@@ -827,7 +826,7 @@ m = [[1,2],[2,3]]  -- Should return type EQ POLY SQMATRIX(2, INT)
 --S 64
 1+"asd"  -- These should both fail in the same way
 --R 
---R   There are 11 exposed and 5 unexposed library operations named + 
+--R   There are 12 exposed and 5 unexposed library operations named + 
 --R      having 2 argument(s) but none was determined to be applicable. 
 --R      Use HyperDoc Browse, or issue
 --R                                )display op +
@@ -847,7 +846,7 @@ m = [[1,2],[2,3]]  -- Should return type EQ POLY SQMATRIX(2, INT)
 --S 65
 1/"asd"
 --R 
---R   There are 12 exposed and 12 unexposed library operations named / 
+--R   There are 13 exposed and 12 unexposed library operations named / 
 --R      having 2 argument(s) but none was determined to be applicable. 
 --R      Use HyperDoc Browse, or issue
 --R                                )display op /
@@ -1608,7 +1607,7 @@ s - sin(a*x)
 --E 121
 
 @
-Complex & AlgebraicNumber coercions. fixed by SCM 6/91
+Complex \& AlgebraicNumber coercions. fixed by SCM 6/91
 <<*>>=
 )clear all
 



From MAILER-DAEMON Fri Aug 22 02:49:32 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KWQSi-00035a-BJ
	for mharc-axiom-developer@gnu.org; Fri, 22 Aug 2008 02:49:32 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KWQSf-00035E-6g
	for axiom-developer@nongnu.org; Fri, 22 Aug 2008 02:49:29 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KWQSc-00034p-3S
	for axiom-developer@nongnu.org; Fri, 22 Aug 2008 02:49:27 -0400
Received: from [199.232.76.173] (port=33994 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KWQSb-00034m-LA
	for axiom-developer@nongnu.org; Fri, 22 Aug 2008 02:49:25 -0400
Received: from mx20.gnu.org ([199.232.41.8]:40703)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <daly@axiom-developer.org>)
	id 1KWQSZ-0006Ne-Hh
	for axiom-developer@nongnu.org; Fri, 22 Aug 2008 02:49:25 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]
	helo=axiom-developer.org) by mx20.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KWQSV-0004ym-06
	for axiom-developer@nongnu.org; Fri, 22 Aug 2008 02:49:19 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7M6nCr3003445;
	Fri, 22 Aug 2008 01:49:12 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7M6nC8d003442;
	Fri, 22 Aug 2008 01:49:12 -0500
Date: Fri, 22 Aug 2008 01:49:12 -0500
Message-Id: <200808220649.m7M6nC8d003442@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by mx20.gnu.org: Linux 2.6? (barebone, rare!)
X-detected-kernel: by monty-python.gnu.org: Linux 2.6, seldom 2.4 (older, 4)
Cc: 
Subject: [Axiom-developer] 20080822.01.tpd.patch (add linalg,
	overload regressions)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 22 Aug 2008 06:49:30 -0000

linalg.input and overload.input are two new regression test files
=================================================================
diff --git a/changelog b/changelog
index 3ba51a4..965fce8 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,6 @@
+20080822 tpd src/input/Makefile add linalg, overload regression tests
+20080822 tpd src/input/linalg.input recovered
+20080822 tpd src/input/overload.input recovered
 20080821 tpd src/algebra/Makefile add MappingPackage4
 20080821 tpd src/algebra/exposed.lsp add MappingPackage4
 20080821 tpd src/algebra/mappkg.spad add MAPPKG4
diff --git a/src/input/Makefile.pamphlet b/src/input/Makefile.pamphlet
index 0d919d6..3f80d67 100644
--- a/src/input/Makefile.pamphlet
+++ b/src/input/Makefile.pamphlet
@@ -244,9 +244,6 @@ WRAPPED=loop.output
 # Error: Value stack overflow.
 VALUESTACK=tutchap67.output
 
-# Broken at |MATCAT-;*;3S;29|.  Type :H for Help.
-MATCAT=linalg.output    
-
 # Broken at |STAGG-;ELT;AIS;5|.  Type :H for Help.
 STAGG=reductio.output
 
@@ -326,7 +323,8 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     kamke0.regress    kamke1.regress   kamke2.regress   kamke3.regress \
     kamke4.regress    kamke5.regress   kamke6.regress   kamke7.regress \
     kernel.regress    knot2.regress    kovacic.regress  kuipers.regress \
-    laplace.regress   leg.regress      limit.regress    lindep.regress \
+    laplace.regress   leg.regress      limit.regress    linalg.regress \
+    lindep.regress \
     list.regress      lode.regress     lodesys.regress  lodo1.regress \
     lodo2.regress     lodo3.regress    lodof.regress    lodo.regress \
     log.regress \
@@ -341,6 +339,7 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     nqip.regress      nsfip.regress    numbers.regress  octonion.regress \
     oct.regress       ode.regress      odpol.regress    op1.regress \
     opalg.regress     operator.regress op.regress       ovar.regress \
+    overload.regress  \
     padic.regress     parabola.regress pascal1.regress  pascal.regress \
     patch51.regress   page.regress \
     patmatch.regress  pat.regress      perman.regress   perm.regress \
@@ -594,6 +593,7 @@ FILES= ${OUT}/algaggr.input  ${OUT}/algbrbf.input    ${OUT}/algfacob.input \
        ${OUT}/kovacic.input  ${OUT}/kuipers.input  \
        ${OUT}/laplace.input  ${OUT}/leg.input        ${OUT}/lexp.input \
        ${OUT}/lextripk.input ${OUT}/lib.input        ${OUT}/limit.input \
+       ${OUT}/linalg.input \
        ${OUT}/lindep.input   ${OUT}/liss1.input      ${OUT}/liss2.input \
        ${OUT}/list.input     ${OUT}/lode.input       ${OUT}/lodesys.input \
        ${OUT}/lodo1.input    ${OUT}/lodo2.input      ${OUT}/lodof.input \
@@ -613,10 +613,10 @@ FILES= ${OUT}/algaggr.input  ${OUT}/algbrbf.input    ${OUT}/algfacob.input \
        ${OUT}/nepip.input    ${OUT}/newton.input \
        ${OUT}/nlode.input    ${OUT}/none.input       ${OUT}/noonburg.input \
        ${OUT}/noptip.input   ${OUT}/nqip.input       ${OUT}/nsfip.input \
-       ${OUT}/ntube.input    ${OUT}/oct.input      ${OUT}/ode.input \
+       ${OUT}/ntube.input    ${OUT}/oct.input        ${OUT}/ode.input \
        ${OUT}/octonion.input ${OUT}/odpol.input \
        ${OUT}/opalg.input    ${OUT}/operator.input   ${OUT}/op.input \
-       ${OUT}/op1.input      ${OUT}/ovar.input \
+       ${OUT}/op1.input      ${OUT}/ovar.input       ${OUT}/overload.input \
        ${OUT}/padic.input    ${OUT}/palette.input \
        ${OUT}/parpcurv.input ${OUT}/parscurv.input   ${OUT}/parsurf.input \
        ${OUT}/pascal1.input \
@@ -927,6 +927,7 @@ DOCFILES= \
   ${DOC}/odpol.input.dvi       ${DOC}/op1.input.dvi        \
   ${DOC}/opalg.input.dvi       ${DOC}/operator.input.dvi   \
   ${DOC}/op.input.dvi          ${DOC}/ovar.input.dvi       \
+  ${DOC}/overload.input.dvi   \
   ${DOC}/padic.input.dvi       ${DOC}/palette.input.dvi    \
   ${DOC}/parabola.input.dvi    ${DOC}/parpcurv.input.dvi   \
   ${DOC}/parscurv.input.dvi    ${DOC}/parsurf.input.dvi    \
diff --git a/src/input/linalg.input.pamphlet b/src/input/linalg.input.pamphlet
index c39e5c7..17156fe 100644
--- a/src/input/linalg.input.pamphlet
+++ b/src/input/linalg.input.pamphlet
@@ -10,104 +10,929 @@
 \tableofcontents
 \eject
 <<*>>=
+)spool linalg.output
+)set message test on
+)set message auto off
+)set break resume
+)clear all
 
 -- Input for page MatrixMoreFunctionsPage
 )clear all
 
+--S 1 of 82
 m1 := matrix([[1,-2,1],[4,2,-4]])
+--R
+--R        +1  - 2   1 +
+--R   (1)  |           |
+--R        +4   2   - 4+
+--R                                                         Type: Matrix Integer
+--E 1
+
+--S 2 of 82
 m2 := matrix([[0,1,2],[2,3,4],[3,4,5]])
+--R
+--R        +0  1  2+
+--R        |       |
+--R   (2)  |2  3  4|
+--R        |       |
+--R        +3  4  5+
+--R                                                         Type: Matrix Integer
+--E 2
+
+--S 3 of 82
 m3 := matrix([[1,2,3],[2,4,6]])
+--R
+--R        +1  2  3+
+--R   (3)  |       |
+--R        +2  4  6+
+--R                                                         Type: Matrix Integer
+--E 3
+
+--S 4 of 82
 m1 + m3
+--R
+--R        +2  0  4+
+--R   (4)  |       |
+--R        +6  6  2+
+--R                                                         Type: Matrix Integer
+--E 4
+
+--S 5 of 82
 100 * m1
+--R
+--R        +100  - 200   100 +
+--R   (5)  |                 |
+--R        +400   200   - 400+
+--R                                                         Type: Matrix Integer
+--E 5
+
+--S 6 of 82
 m1 * m2
+--R
+--R        +- 1  - 1  - 1+
+--R   (6)  |             |
+--R        +- 8  - 6  - 4+
+--R                                                         Type: Matrix Integer
+--E 6
+
+--S 7 of 82
 -m1 + m3 * m2
+--R
+--R        +12  21  24+
+--R   (7)  |          |
+--R        +22  36  54+
+--R                                                         Type: Matrix Integer
+--E 7
+
+--S 8 of 82
 m2 * m1
+--R 
+--R 
+--RDaly Bug
+--R   >> Error detected within library code:
+--R   can't multiply matrices of incompatible dimensions
+--R
+--R   Continuing to read the file...
+--R
+--E 8
+
+--S 9 of 82
 v := vector([1,0,1])
+--R
+--R   (8)  [1,0,1]
+--R                                              Type: Vector NonNegativeInteger
+--E 9
+
+--S 10 of 82
 m3 * v
+--R
+--R   (9)  [4,8]
+--R                                                         Type: Vector Integer
+--E 10
+
+--S 11 of 82
 m5 : MATRIX POLY INT := new(4,4,1)
+--R
+--R         +1  1  1  1+
+--R         |          |
+--R         |1  1  1  1|
+--R   (10)  |          |
+--R         |1  1  1  1|
+--R         |          |
+--R         +1  1  1  1+
+--R                                              Type: Matrix Polynomial Integer
+--E 11
+
+--S 12 of 82
 vars : LIST POLY INT := [x,y,z,u]
+--R
+--R   (11)  [x,y,z,u]
+--R                                                Type: List Polynomial Integer
+--E 12
+
+--S 13 of 82
 for i in 1..4 repeat for j in 1..3 repeat m5(i,j + 1) := (vars.i)**j
+--R                                                                   Type: Void
+--E 13
+
+--S 14 of 82
 m5
+--R
+--R         +       2   3+
+--R         |1  x  x   x |
+--R         |            |
+--R         |       2   3|
+--R         |1  y  y   y |
+--R   (13)  |            |
+--R         |       2   3|
+--R         |1  z  z   z |
+--R         |            |
+--R         |       2   3|
+--R         +1  u  u   u +
+--R                                              Type: Matrix Polynomial Integer
+--E 14
+
+--S 15 of 82
 trace(m5)
+--R
+--R          2        3
+--R   (14)  z  + y + u  + 1
+--R                                                     Type: Polynomial Integer
+--E 15
+
+--S 16 of 82
 det := determinant(m5)
+--R
+--R   (15)
+--R                2     2    2        2    2   3
+--R     ((- x + u)y  + (x  - u )y - u x  + u x)z
+--R   + 
+--R              3       3    3        3    3   2
+--R     ((x - u)y  + (- x  + u )y + u x  - u x)z
+--R   + 
+--R          2    2  3     3    3  2    2 3    3 2         2    2   3
+--R     ((- x  + u )y  + (x  - u )y  - u x  + u x )z + (u x  - u x)y
+--R   + 
+--R           3    3   2     2 3    3 2
+--R     (- u x  + u x)y  + (u x  - u x )y
+--R                                                     Type: Polynomial Integer
+--E 16
+
+--S 17 of 82
 factor(det)
+--R
+--R   (16)  - (x - u)(y - x)(y - u)(z - y)(z - x)(z - u)
+--R                                            Type: Factored Polynomial Integer
+--E 17
+
+--S 18 of 82
 m6 := matrix([[1,2,1],[-2,3,4],[-1,5,6]])
+--R
+--R         + 1   2  1+
+--R         |         |
+--R   (17)  |- 2  3  4|
+--R         |         |
+--R         +- 1  5  6+
+--R                                                         Type: Matrix Integer
+--E 18
+
+--S 19 of 82
 m6inv := inverse(m6)
+--R
+--R         +  2        5 +
+--R         |- -  - 1   - |
+--R         |  7        7 |
+--R         |             |
+--R   (18)  | 8          6|
+--R         | -    1   - -|
+--R         | 7          7|
+--R         |             |
+--R         +- 1  - 1   1 +
+--R                                     Type: Union(Matrix Fraction Integer,...)
+--E 19
+
+--S 20 of 82
 m6 * m6inv
+--R
+--R         +1  0  0+
+--R         |       |
+--R   (19)  |0  1  0|
+--R         |       |
+--R         +0  0  1+
+--R                                                Type: Matrix Fraction Integer
+--E 20
+
+--S 21 of 82
 m7 := matrix([[1,2,1],[-2,3,4],[-1,5,5]])
+--R
+--R         + 1   2  1+
+--R         |         |
+--R   (20)  |- 2  3  4|
+--R         |         |
+--R         +- 1  5  5+
+--R                                                         Type: Matrix Integer
+--E 21
+
+--S 22 of 82
 inverse(m7)
+--R
+--R   (21)  "failed"
+--R                                                    Type: Union("failed",...)
+--E 22
+
+--S 23 of 82
 determinant(m7)
+--R
+--R   (22)  0
+--R                                                     Type: NonNegativeInteger
+--E 23
+
+--S 24 of 82
 m8 : SQMATRIX(2,INT) := matrix([[1,2],[2,3]])
+--R
+--R         +1  2+
+--R   (23)  |    |
+--R         +2  3+
+--R                                                Type: SquareMatrix(2,Integer)
+--E 24
+
+--S 25 of 82
 m9 : SQMATRIX(2,INT) := matrix([[1,1],[0,1]])
+--R
+--R         +1  1+
+--R   (24)  |    |
+--R         +0  1+
+--R                                                Type: SquareMatrix(2,Integer)
+--E 25
+
+--S 26 of 82
 m8 ** 2
+--R
+--R         +5  8 +
+--R   (25)  |     |
+--R         +8  13+
+--R                                                Type: SquareMatrix(2,Integer)
+--E 26
+
+--S 27 of 82
 m9 ** 3
+--R
+--R         +1  3+
+--R   (26)  |    |
+--R         +0  1+
+--R                                                Type: SquareMatrix(2,Integer)
+--E 27
+
+--S 28 of 82
 mm : SQMATRIX(2,SQMATRIX(2,INT)) := matrix([[1,m8],[m9,0]])
+--R
+--R         ++1  0+  +1  2++
+--R         ||    |  |    ||
+--R         |+0  1+  +2  3+|
+--R   (27)  |              |
+--R         |+1  1+  +0  0+|
+--R         ||    |  |    ||
+--R         ++0  1+  +0  0++
+--R                                Type: SquareMatrix(2,SquareMatrix(2,Integer))
+--E 28
+
+--S 29 of 82
 100 * mm
+--R
+--R         ++100   0 +  +100  200++
+--R         ||        |  |        ||
+--R         |+ 0   100+  +200  300+|
+--R   (28)  |                      |
+--R         |+100  100+    +0  0+  |
+--R         ||        |    |    |  |
+--R         ++ 0   100+    +0  0+  +
+--R                                Type: SquareMatrix(2,SquareMatrix(2,Integer))
+--E 29
+
+--S 30 of 82
 m8 * mm
+--R
+--R         ++1  2+  +5  8 ++
+--R         ||    |  |     ||
+--R         |+2  3+  +8  13+|
+--R   (29)  |               |
+--R         |+1  3+  +0  0+ |
+--R         ||    |  |    | |
+--R         ++2  5+  +0  0+ +
+--R                                Type: SquareMatrix(2,SquareMatrix(2,Integer))
+--E 30
+
+--S 31 of 82
 mm * mm
+--R
+--R         ++2  3+  +1  2++
+--R         ||    |  |    ||
+--R         |+2  6+  +2  3+|
+--R   (30)  |              |
+--R         |+1  1+  +3  5+|
+--R         ||    |  |    ||
+--R         ++0  1+  +2  3++
+--R                                Type: SquareMatrix(2,SquareMatrix(2,Integer))
+--E 31
+
+--S 32 of 82
 p : POLY SQMATRIX(2,INT) := m8 * x**2 + m9 * x + m8 * m9
+--R
+--R         +1  2+ 2   +1  1+    +1  3+
+--R   (31)  |    |x  + |    |x + |    |
+--R         +2  3+     +0  1+    +2  5+
+--R                                     Type: Polynomial SquareMatrix(2,Integer)
+--E 32
+
+--S 33 of 82
 100 * p
+--R
+--R         +100  200+ 2   +100  100+    +100  300+
+--R   (32)  |        |x  + |        |x + |        |
+--R         +200  300+     + 0   100+    +200  500+
+--R                                     Type: Polynomial SquareMatrix(2,Integer)
+--E 33
+
+--S 34 of 82
 m8 * p
+--R
+--R         +5  8 + 2   +1  3+    +5  13+
+--R   (33)  |     |x  + |    |x + |     |
+--R         +8  13+     +2  5+    +8  21+
+--R                                     Type: Polynomial SquareMatrix(2,Integer)
+--E 34
+
+--S 35 of 82
 p * p
+--R
+--R         +5  8 + 4   +4  8+ 3   +13  26+ 2   +4  12+    +7   18+
+--R   (34)  |     |x  + |    |x  + |      |x  + |     |x + |      |
+--R         +8  13+     +4  8+     +20  41+     +4  12+    +12  31+
+--R                                     Type: Polynomial SquareMatrix(2,Integer)
+--E 35
 
 -- Input for page MatrixCanonicalFormsPage
 )clear all
 
+--S 36 of 82
 m1 := matrix([[0,4,1],[5,3,-7],[-5,5,9]])
+--R
+--R        + 0   4   1 +
+--R        |           |
+--R   (1)  | 5   3  - 7|
+--R        |           |
+--R        +- 5  5   9 +
+--R                                                         Type: Matrix Integer
+--E 36
+
+--S 37 of 82
 rank(m1)
+--R
+--R   (2)  2
+--R                                                        Type: PositiveInteger
+--E 37
+
+--S 38 of 82
 rowEchelon(m1)
+--R
+--R        +5  3  - 7+
+--R        |         |
+--R   (3)  |0  4   1 |
+--R        |         |
+--R        +0  0   0 +
+--R                                                         Type: Matrix Integer
+--E 38
+
+--S 39 of 82
 nullSpace(m1)
+--R
+--R   (4)  [[31,- 5,20]]
+--R                                                    Type: List Vector Integer
+--E 39
+
+--S 40 of 82
 t := eigenMatrix(m1)
+--R
+--R        + +----+          +----+          +
+--R        |\|- 11  + 2   - \|- 11  + 2   31 |
+--R        |-----------   -------------   -- |
+--R        |     5              5         20 |
+--R        |                                 |
+--R   (5)  |  +----+          +----+         |
+--R        |2\|- 11  - 1  - 2\|- 11  - 1    1|
+--R        |------------  --------------  - -|
+--R        |      5              5          4|
+--R        |                                 |
+--R        +     1              1          1 +
+--R                                   Type: Union(Matrix Expression Integer,...)
+--E 40
+
+--S 41 of 82
 inverse(t) * m1 * t
+--R
+--R        +           +----+                                +
+--R        |5581634906\|- 11  - 55255461173                  |
+--R        |-------------------------------        0        0|
+--R        |            +----+                               |
+--R        | 1888197247\|- 11  - 5747548576                  |
+--R        |                                                 |
+--R   (6)  |                                   +----+        |
+--R        |                                 6\|- 11  + 11   |
+--R        |               0                 -------------  0|
+--R        |                                     +----+      |
+--R        |                                    \|- 11       |
+--R        |                                                 |
+--R        +               0                       0        0+
+--R                                              Type: Matrix Expression Integer
+--E 41
 
 -- Input for page MatrixBasicFunctionsPage
 )clear all
 
+--S 42 of 82
 m1 := matrix([[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7]])
+--R
+--R        +1  2  3  4+
+--R        |          |
+--R        |2  3  4  5|
+--R   (1)  |          |
+--R        |3  4  5  6|
+--R        |          |
+--R        +4  5  6  7+
+--R                                                         Type: Matrix Integer
+--E 42
+
+--S 43 of 82
 m2 := matrix([[1,0,2],[20,30,10],[0,200,100]])
+--R
+--R        +1    0    2 +
+--R        |            |
+--R   (2)  |20  30   10 |
+--R        |            |
+--R        +0   200  100+
+--R                                                         Type: Matrix Integer
+--E 43
+
+--S 44 of 82
 (m3,m4) : MATRIX PF 7
+--R                                                                   Type: Void
+--E 44
+
+--S 45 of 82
 m3 := matrix([[1,0,1],[5,0,1]])
+--R
+--R        +1  0  1+
+--R   (4)  |       |
+--R        +5  0  1+
+--R                                                    Type: Matrix PrimeField 7
+--E 45
+
+--S 46 of 82
 m4 := matrix([[1],[2],[5],[6]])
+--R
+--R        +1+
+--R        | |
+--R        |2|
+--R   (5)  | |
+--R        |5|
+--R        | |
+--R        +6+
+--R                                                    Type: Matrix PrimeField 7
+--E 46
+
+--S 47 of 82
 m2(1,1)
+--R
+--R   (6)  1
+--R                                                        Type: PositiveInteger
+--E 47
+
+--S 48 of 82
 m2(1,1) := 99
+--R
+--R   (7)  99
+--R                                                        Type: PositiveInteger
+--E 48
+
+--S 49 of 82
 m2
+--R
+--R        +99   0    2 +
+--R        |            |
+--R   (8)  |20  30   10 |
+--R        |            |
+--R        +0   200  100+
+--R                                                         Type: Matrix Integer
+--E 49
+
+--S 50 of 82
 row(m2,2)
+--R
+--R   (9)  [20,30,10]
+--R                                                         Type: Vector Integer
+--E 50
+
+--S 51 of 82
 setRow!(m2,2,vector [66,77,88])
+--R
+--R         +99   0    2 +
+--R         |            |
+--R   (10)  |66  77   88 |
+--R         |            |
+--R         +0   200  100+
+--R                                                         Type: Matrix Integer
+--E 51
+
+--S 52 of 82
 r := column(m2,1)
+--R
+--R   (11)  [99,66,0]
+--R                                                         Type: Vector Integer
+--E 52
+
+--S 53 of 82
 setColumn!(m2,2,r)
+--R
+--R         +99  99   2 +
+--R         |           |
+--R   (12)  |66  66  88 |
+--R         |           |
+--R         +0   0   100+
+--R                                                         Type: Matrix Integer
+--E 53
+
+--S 54 of 82
 nrows(m1)
+--R
+--R   (13)  4
+--R                                                        Type: PositiveInteger
+--E 54
+
+--S 55 of 82
 m5 : MATRIX INT := new(12,12,0)
+--R
+--R         +0  0  0  0  0  0  0  0  0  0  0  0+
+--R         |                                  |
+--R         |0  0  0  0  0  0  0  0  0  0  0  0|
+--R         |                                  |
+--R         |0  0  0  0  0  0  0  0  0  0  0  0|
+--R         |                                  |
+--R         |0  0  0  0  0  0  0  0  0  0  0  0|
+--R         |                                  |
+--R         |0  0  0  0  0  0  0  0  0  0  0  0|
+--R         |                                  |
+--R         |0  0  0  0  0  0  0  0  0  0  0  0|
+--R   (14)  |                                  |
+--R         |0  0  0  0  0  0  0  0  0  0  0  0|
+--R         |                                  |
+--R         |0  0  0  0  0  0  0  0  0  0  0  0|
+--R         |                                  |
+--R         |0  0  0  0  0  0  0  0  0  0  0  0|
+--R         |                                  |
+--R         |0  0  0  0  0  0  0  0  0  0  0  0|
+--R         |                                  |
+--R         |0  0  0  0  0  0  0  0  0  0  0  0|
+--R         |                                  |
+--R         +0  0  0  0  0  0  0  0  0  0  0  0+
+--R                                                         Type: Matrix Integer
+--E 55
+
+--S 56 of 82
 for i in 2..nrows(m5) repeat m5(i-1,i):= 1
+--R                                                                   Type: Void
+--E 56
+
+--S 57 of 82
 m5
+--R
+--R         +0  1  0  0  0  0  0  0  0  0  0  0+
+--R         |                                  |
+--R         |0  0  1  0  0  0  0  0  0  0  0  0|
+--R         |                                  |
+--R         |0  0  0  1  0  0  0  0  0  0  0  0|
+--R         |                                  |
+--R         |0  0  0  0  1  0  0  0  0  0  0  0|
+--R         |                                  |
+--R         |0  0  0  0  0  1  0  0  0  0  0  0|
+--R         |                                  |
+--R         |0  0  0  0  0  0  1  0  0  0  0  0|
+--R   (16)  |                                  |
+--R         |0  0  0  0  0  0  0  1  0  0  0  0|
+--R         |                                  |
+--R         |0  0  0  0  0  0  0  0  1  0  0  0|
+--R         |                                  |
+--R         |0  0  0  0  0  0  0  0  0  1  0  0|
+--R         |                                  |
+--R         |0  0  0  0  0  0  0  0  0  0  1  0|
+--R         |                                  |
+--R         |0  0  0  0  0  0  0  0  0  0  0  1|
+--R         |                                  |
+--R         +0  0  0  0  0  0  0  0  0  0  0  0+
+--R                                                         Type: Matrix Integer
+--E 57
+
+--S 58 of 82
 d : MATRIX INT := diagonalMatrix([1,2,3,2,1])
+--R
+--R         +1  0  0  0  0+
+--R         |             |
+--R         |0  2  0  0  0|
+--R         |             |
+--R   (17)  |0  0  3  0  0|
+--R         |             |
+--R         |0  0  0  2  0|
+--R         |             |
+--R         +0  0  0  0  1+
+--R                                                         Type: Matrix Integer
+--E 58
+
+--S 59 of 82
 m6 := matrix([[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14]])
+--R
+--R         +0   1   2   3   4 +
+--R         |                  |
+--R   (18)  |5   6   7   8   9 |
+--R         |                  |
+--R         +10  11  12  13  14+
+--R                                                         Type: Matrix Integer
+--E 59
+
+--S 60 of 82
 m7 := subMatrix(m6,1,3,2,4)
+--R
+--R         +1   2   3 +
+--R         |          |
+--R   (19)  |6   7   8 |
+--R         |          |
+--R         +11  12  13+
+--R                                                         Type: Matrix Integer
+--E 60
+
+--S 61 of 82
 horizConcat(m6,m7)
+--R
+--R         +0   1   2   3   4   1   2   3 +
+--R         |                              |
+--R   (20)  |5   6   7   8   9   6   7   8 |
+--R         |                              |
+--R         +10  11  12  13  14  11  12  13+
+--R                                                         Type: Matrix Integer
+--E 61
+
+--S 62 of 82
 vertConcat(m6,subMatrix(m6,1,1,1,5))
+--R
+--R         +0   1   2   3   4 +
+--R         |                  |
+--R         |5   6   7   8   9 |
+--R   (21)  |                  |
+--R         |10  11  12  13  14|
+--R         |                  |
+--R         +0   1   2   3   4 +
+--R                                                         Type: Matrix Integer
+--E 62
+
+--S 63 of 82
 transpose(m6)
-setsubMatrix(m6,1,3,1,3,transpose(subMatrix(m6,1,3,1,3)))
+--R
+--R         +0  5  10+
+--R         |        |
+--R         |1  6  11|
+--R         |        |
+--R   (22)  |2  7  12|
+--R         |        |
+--R         |3  8  13|
+--R         |        |
+--R         +4  9  14+
+--R                                                         Type: Matrix Integer
+--E 63
+
+--S 64 of 82
+setsubMatrix!(m6,1,3,transpose(subMatrix(m6,1,3,1,3)))
+--R
+--R         +0   1   0  5  10+
+--R         |                |
+--R   (23)  |5   6   1  6  11|
+--R         |                |
+--R         +10  11  2  7  12+
+--R                                                         Type: Matrix Integer
+--E 64
+
+--S 65 of 82
 m6
+--R
+--R         +0   1   0  5  10+
+--R         |                |
+--R   (24)  |5   6   1  6  11|
+--R         |                |
+--R         +10  11  2  7  12+
+--R                                                         Type: Matrix Integer
+--E 65
+
+--S 66 of 82
 m8 := matrix([[1,2],[3,4]])
+--R
+--R         +1  2+
+--R   (25)  |    |
+--R         +3  4+
+--R                                                         Type: Matrix Integer
+--E 66
+
+--S 67 of 82
 m9 := m8
+--R
+--R         +1  2+
+--R   (26)  |    |
+--R         +3  4+
+--R                                                         Type: Matrix Integer
+--E 67
+
+--S 68 of 82
 m10 := copy(m8)
+--R
+--R         +1  2+
+--R   (27)  |    |
+--R         +3  4+
+--R                                                         Type: Matrix Integer
+--E 68
+
+--S 69 of 82
 m8(1,1) := 1000000
+--R
+--R   (28)  1000000
+--R                                                        Type: PositiveInteger
+--E 69
+
+--S 70 of 82
 m8
+--R
+--R         +1000000  2+
+--R   (29)  |          |
+--R         +   3     4+
+--R                                                         Type: Matrix Integer
+--E 70
+
+--S 71 of 82
 m9
+--R
+--R         +1000000  2+
+--R   (30)  |          |
+--R         +   3     4+
+--R                                                         Type: Matrix Integer
+--E 71
+
+--S 72 of 82
 m10
+--R
+--R         +1  2+
+--R   (31)  |    |
+--R         +3  4+
+--R                                                         Type: Matrix Integer
+--E 72
 
 -- Input for page EigenPage
 )clear all
 
+--S 73 of 82
 m1 : MATRIX FRAC INT := [[1,2,1],[2,1,-2],[1,-2,4]]
+--R
+--R        +1   2    1 +
+--R        |           |
+--R   (1)  |2   1   - 2|
+--R        |           |
+--R        +1  - 2   4 +
+--R                                                Type: Matrix Fraction Integer
+--E 73
+
+--S 74 of 82
 leig := eigenvalues(m1)
+--R
+--R                  2
+--I   (2)  [5,%A | %A  - %A - 5]
+--RType: List Union(Fraction Polynomial Integer,SuchThat(Symbol,Polynomial Integer))
+--E 74
+
+--S 75 of 82
 eigenvector(first(leig),m1)
+--R
+--R         + 0 +
+--R         |   |
+--R         |  1|
+--R   (3)  [|- -|]
+--R         |  2|
+--R         |   |
+--R         + 1 +
+--R                       Type: List Matrix Fraction Polynomial Fraction Integer
+--E 75
+
+--S 76 of 82
 eigenvectors(m1)
+--R
+--R   (4)
+--R                                   + 0 +
+--R                                   |   |
+--R                                   |  1|
+--R   [[eigval= 5,eigmult= 1,eigvec= [|- -|]],
+--R                                   |  2|
+--R                                   |   |
+--R                                   + 1 +
+--R                                                     +%C+
+--R                     2                               |  |
+--R    [eigval= (%C | %C  - %C - 5),eigmult= 1,eigvec= [|2 |]]]
+--R                                                     |  |
+--R                                                     +1 +
+--RType: List Record(eigval: Union(Fraction Polynomial Integer,SuchThat(Symbol,Polynomial Integer)),eigmult: NonNegativeInteger,eigvec: List Matrix Fraction Polynomial Integer)
+--E 76
+
+--S 77 of 82
 radicalEigenvectors(m1)
+--R
+--R   (5)
+--R                                            + +--+    +
+--R              +--+                          |\|21  + 1|
+--R             \|21  + 1                      |---------|
+--R   [[radval= ---------,radmult= 1,radvect= [|    2    |]],
+--R                 2                          |         |
+--R                                            |    2    |
+--R                                            |         |
+--R                                            +    1    +
+--R                                              +   +--+    +
+--R                +--+                          |- \|21  + 1|
+--R             - \|21  + 1                      |-----------|
+--R    [radval= -----------,radmult= 1,radvect= [|     2     |]],
+--R                  2                           |           |
+--R                                              |     2     |
+--R                                              |           |
+--R                                              +     1     +
+--R                                    + 0 +
+--R                                    |   |
+--R                                    |  1|
+--R    [radval= 5,radmult= 1,radvect= [|- -|]]]
+--R                                    |  2|
+--R                                    |   |
+--R                                    + 1 +
+--RType: List Record(radval: Expression Integer,radmult: Integer,radvect: List Matrix Expression Integer)
+--E 77
+
+--S 78 of 82
 eigenMatrix(m1)
+--R
+--R        + +--+         +--+         +
+--R        |\|21  + 1  - \|21  + 1     |
+--R        |---------  -----------   0 |
+--R        |    2           2          |
+--R   (6)  |                           |
+--R        |                          1|
+--R        |    2           2       - -|
+--R        |                          2|
+--R        |                           |
+--R        +    1           1        1 +
+--R                                   Type: Union(Matrix Expression Integer,...)
+--E 78
+
+--S 79 of 82
 m2 : MATRIX FRAC INT := [[-5,-2],[18,7]]
+--R
+--R        +- 5  - 2+
+--R   (7)  |        |
+--R        +18    7 +
+--R                                                Type: Matrix Fraction Integer
+--E 79
+
+--S 80 of 82
 eigenMatrix(m2)
+--R
+--R   (8)  "failed"
+--R                                                    Type: Union("failed",...)
+--E 80
+
+--S 81 of 82
 m3 : MATRIX FRAC INT := [[1,2],[2,1]]
+--R
+--R        +1  2+
+--R   (9)  |    |
+--R        +2  1+
+--R                                                Type: Matrix Fraction Integer
+--E 81
+
+--S 82 of 82
 orthonormalBasis(m3)
+--R
+--R          +    1 + +  1 +
+--R          |- ----| |----|
+--R          |   +-+| | +-+|
+--R          |  \|2 | |\|2 |
+--R   (10)  [|      |,|    |]
+--R          |   1  | |  1 |
+--R          | ---- | |----|
+--R          |  +-+ | | +-+|
+--R          + \|2  + +\|2 +
+--R                                         Type: List Matrix Expression Integer
+--E 82
+
+)spool 
+)lisp (bye)
+ 
 @
 \eject
 \begin{thebibliography}{99}
diff --git a/src/input/overload.input.pamphlet b/src/input/overload.input.pamphlet
new file mode 100644
index 0000000..2db85a7
--- /dev/null
+++ b/src/input/overload.input.pamphlet
@@ -0,0 +1,680 @@
+\documentclass{article}
+\usepackage{axiom}
+\begin{document}
+\title{\$SPAD/src/input overload.input}
+\author{David Cyganski}
+\maketitle
+\begin{abstract}
+Type conversion and overload problems
+\end{abstract}
+\eject
+\tableofcontents
+\eject
+<<*>>=
+)spool overload.output
+)set message test on
+)set message auto off
+)clear all
+@
+\section{Type Conversion and Overload problems}
+Several non-intuitive problems with overloading and type conversions
+arose while developing the biquaternion (see biquat.input) support
+function collection. I have extracted the minimum code set to illustrate
+each of these problems.
+
+\section{Implicit and Explicit Type Conversions}
+We begin by illustrating function calling with variously typed 
+arguments and conversion which we will break in various ways, some
+understandable, some not(?), below.
+
+The cos function will produce float outcomes for float arguments
+<<*>>=
+
+--S 1 of 28
+cos(1.237)
+--R 
+--R
+--R   (1)  0.3276321705 9891498386
+--R                                                                  Type: Float
+--E 1
+
+@
+can handle expressions that mix floats and integers
+<<*>>=
+
+--S 2 of 28
+cos(1.237/2)
+--R 
+--R
+--R   (2)  0.8147490934 6341557739
+--R                                                                  Type: Float
+--E 2
+
+@
+but will respect an integer expression, as we would want it to,
+by not evaluating
+<<*>>=
+
+--S 3 of 28
+cos(2/3)
+--R 
+--R
+--R            2
+--R   (3)  cos(-)
+--R            3
+--R                                                     Type: Expression Integer
+--E 3
+
+@
+We can coerce the evaluation as a float by forcing the floating point
+evaluation of the division and typing of the outcome in a variety of
+ways. Each of the following forms is effective in some appropriate
+and understandable way. Some act explicitly on the ``/'' operator
+to force a polymorphic choice, others convert the type of the second
+constand in each expression which results in a proper implicit selection
+of which ``/'' definitition to use.
+<<*>>=
+
+--S 4 of 28
+cos(2/3::Float)
+--R 
+--R
+--R   (4)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 4
+
+--S 5 of 28
+cos((2/3)::Float)
+--R 
+--R
+--R   (5)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 5
+
+--S 6 of 28
+cos(2/3$Float)
+--R 
+--R
+--R   (6)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 6
+
+--S 7 of 28
+cos((2/3)$Float)
+--R 
+--R
+--R   (7)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 7
+
+--S 8 of 28
+cos(2/3@Float)
+--R 
+--R
+--R   (8)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 8
+
+--S 9 of 28
+cos((2/3)@Float)
+--R 
+--R
+--R   (9)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 9
+
+@
+But, as we would expect, it is too late to attempt coercion after the
+fact. Coercion operates ``on the surface and not deeply'' as illustrated
+here.
+<<*>>=
+
+--S 10 of 28
+cos(2/3)::Float
+--R 
+--R 
+--RDaly Bug
+--R   Cannot convert from type Expression Integer to Float for value
+--R       2
+--R   cos(-)
+--R       3
+--R
+--E 10
+
+@
+However, there is a real need for a deep coercion operator that operates
+on the innermost atomic constants. Suppose we define
+<<*>>=
+
+--S 11 of 28
+cosf(x:Expression Integer):Expression Integer == 1+cos(x/2)
+--R 
+--R   Function declaration cosf : Expression Integer -> Expression Integer
+--R      has been added to workspace.
+--R                                                                   Type: Void
+--E 11
+
+@
+which is an example of a simple function that might be defined in the
+course of typical work. We wish to declare functions as having integer
+based fractions, rather than forming approximate decimal expansions, which
+is preferred for purposes of analytic examination and simplification for
+both the human and the Axiom system. The Axiom book and online resources
+are full of examples in which this choice has been made by the authors
+thanks to the power of this form of expression -- even though it amounts
+to lying to Axiom in many cases as to the ultimate destiny of the function
+being defined. But woe to us if we wish later to evaluate it in a more
+general way because it is a tangled web we weave when we practice to
+decieve.
+<<*>>=
+
+--S 12 of 28
+cosf(2/3)
+--R 
+--R   Compiling function cosf with type Expression Integer -> Expression 
+--R      Integer 
+--R
+--R             1
+--R   (11)  cos(-) + 1
+--R             3
+--R                                                     Type: Expression Integer
+--E 12
+
+--S 13 of 28
+cosf((2/3)::Float)
+--R 
+--R   Conversion failed in the compiled user function cosf .
+--R 
+--RDaly Bug
+--R   Cannot convert from type Float to Expression Integer for value
+--R   0.6666666666 6666666667
+--R
+--E 13
+
+@
+Thus in effect once we wrap a function around an integer base definition,
+we are stuck and unable to evaluate it as a float later, unlike the core
+basic functions that can be used either way. This forces us to choose the
+Float type throughout at a loss of comprehensibility and analyzability,
+unless we seek to more than double our development type by supplying an
+overloaded integer base and Float base version of {\bf every} step of a
+sequential development of a formula.
+
+Bizarrely, the draw function seems to have the power to override the
+type problem as shown here
+<<*>>=
+
+--S 14 of 28
+--draw(cosf(x),x=0..15)
+--E 14
+
+@
+Why can't we grant this deep coercion power to some new form of floating
+point conversion operation which can be applied at will? If draw has
+this power, why not put it in the hands of the user?
+
+Alternatively, it would be best to have a {\bf mixed} type -- mixed 
+= Integer/Float. Like Maple expressions it would leave integers as
+integers and floats as floats, unmolested and treated as generic
+constant quantities with distinguishable parts until an {\bf evalf}
+like function that would force them entirely into the Float type. For
+example, in Maple ``cos(2/3)+1.2323'' remains as is, while in Axiom
+we get
+<<*>>=
+
+--S 15 of 28
+cos(2/3)+1.2323
+--R 
+--R
+--R   (12)  2.0181872607 769480007
+--R                                                       Type: Expression Float
+--E 15
+
+@
+In a way, Axiom already has a quantity treated like this -- the constant
+%pi is treated as a special float which remains unevaluated and does not
+force combination of itself with an Integer. It simply results in a new
+kind of Integer evaluation of type Pi
+<<*>>=
+
+--S 16 of 28
+3/4+%pi
+--R 
+--R
+--R         4%pi + 3
+--R   (13)  --------
+--R             4
+--R                                                                     Type: Pi
+--E 16
+
+@
+\section{Overloading problems}
+Now let's examine properties and problems with overloading.
+
+Define the type $Q$ of Hamiltonian biquaternions
+<<*>>=
+
+--S 17 of 28
+C:=Complex Expression Integer
+--R 
+--R
+--R   (14)  Complex Expression Integer
+--R                                                                 Type: Domain
+--E 17
+
+--S 18 of 28
+Q:=Quaternion C
+--R 
+--R
+--R   (15)  Quaternion Complex Expression Integer
+--R                                                                 Type: Domain
+--E 18
+
+@
+While developing the support functions, this definition of biquat
+division was introduced to simplify the format of the formulae
+<<*>>=
+
+--S 19 of 28
+((x:Q)/(y:Q)):Q == x*inv(y)
+--R 
+--R   Function declaration ?/? : (Quaternion Complex Expression Integer,
+--R      Quaternion Complex Expression Integer) -> Quaternion Complex 
+--R      Expression Integer has been added to workspace.
+--R                                                                   Type: Void
+--E 19
+
+@
+But is this typed function in any way actually restricted to quaternions?
+On the face, it would appear all is normal, here's an example of 
+integer division
+<<*>>=
+
+--S 20 of 28
+x:=15/6
+--R 
+--R   Compiling function / with type (Quaternion Complex Expression 
+--R      Integer,Quaternion Complex Expression Integer) -> Quaternion 
+--R      Complex Expression Integer 
+--R
+--R         5
+--R   (17)  -
+--R         2
+--R                                  Type: Quaternion Complex Expression Integer
+--E 20
+
+@
+But though the answer was right, the type is now a biquat. If we don't
+notice this, and proceed, some things seem still to act normally,
+for example, no complaint from Axiom with
+<<*>>=
+
+--S 21 of 28
+cos(x)
+--R 
+--R
+--R             5
+--R   (18)  cos(-)
+--R             2
+--R                                                     Type: Expression Integer
+--E 21
+
+@
+Of course, we still get a correct answer with
+<<*>>=
+
+--S 22 of 28
+cos(1.237)
+--R 
+--R
+--R   (19)  0.3276321705 9891498386
+--R                                                                  Type: Float
+--E 22
+
+@
+But let's try to apply this as a simple mixed float/integer function
+<<*>>=
+
+--S 23 of 28
+cos(15.457/6)
+--R 
+--R   Conversion failed in the compiled user function / .
+--R 
+--RDaly Bug
+--R   Cannot convert from type Float to Quaternion Complex Expression 
+--R      Integer for value
+--R   15.457
+--R
+--E 23
+
+@
+Obviously the quaternion version of ``/'' is being invoked despite
+mismatches of the arguments and the supposed overloading in effect.
+Well, what if we built a new cosine function that forced the form of
+the arguments into certain types to avoid mismatch?
+<<*>>=
+
+--S 24 of 28
+c(y:Float):Float == cos(y)
+--R 
+--R   Function declaration c : Float -> Float has been added to workspace.
+--R                                                                   Type: Void
+--E 24
+
+@
+At first this seems to work, we can still evaluate a float
+<<*>>=
+
+--S 25 of 28
+c(1.237)
+--R 
+--R   Compiling function c with type Float -> Float 
+--R
+--R   (21)  0.3276321705 9891498386
+--R                                                                  Type: Float
+--E 25
+
+@
+and we can even get a float answer when we introduce the integer coercible
+biquat variable value generated from the above.
+<<*>>=
+
+--S 26 of 28
+c(x)
+--R 
+--R
+--R   (22)  - 0.8011436155 4693371483
+--R                                                                  Type: Float
+--E 26
+
+@
+But that was only misdirection, because this breaks down for reasonable
+expressions because of the ``/'' operation still not being resolved
+correctly.
+<<*>>=
+
+--S 27 of 28
+c(1.237/2)
+--R 
+--R   Conversion failed in the compiled user function / .
+--R 
+--RDaly Bug
+--R   Cannot convert from type Float to Quaternion Complex Expression 
+--R      Integer for value
+--R   1.237
+--R
+--E 27
+
+@
+Rather than complaining about it, what if we tried the various coercions
+that served to solve the similar type conversion problem we had when 
+just dealing with Integer Fraction versus Floats at the top of the page.
+Our results are mixed. Recall that each of the following worked in the
+previous case, producing the correct floating result in each case.
+<<*>>=
+
+--S 28 of 28
+cos(2/3::Float)
+--R 
+--R
+--R             2
+--R   (23)  cos(-)
+--R             3
+--R                                                     Type: Expression Integer
+--E 28
+
+--S 29 of 28
+cos((2/3)::Float)
+--R 
+--R
+--R   (24)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 29
+
+--S 30 of 28
+cos(2/3$Float)
+--R 
+--R
+--R             2
+--R   (25)  cos(-)
+--R             3
+--R                                                     Type: Expression Integer
+--E 30
+
+--S 31 of 28
+cos((2/3)$Float)
+--R 
+--R
+--R   (26)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 31
+
+--S 32 of 28
+cos(2/3@Float)
+--R 
+--R
+--R             2
+--R   (27)  cos(-)
+--R             3
+--R                                                     Type: Expression Integer
+--E 32
+
+--S 33 of 28
+cos((2/3)@Float)
+--R 
+--R 
+--RDaly Bug
+--R   An expression involving @ Float actually evaluated to one of type 
+--R      Quaternion Complex Expression Integer . Perhaps you should use ::
+--R      Float .
+--E 33
+
+@
+Try these examples with our type constrained function, which has better
+luck now
+<<*>>=
+
+--S 34 of 28
+c(2/3::Float)
+--R 
+--R
+--R   (28)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 34
+
+--S 35 of 28
+c((2/3)::Float)
+--R 
+--R
+--R   (29)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 35
+
+--S 36 of 28
+c(2/3$Float)
+--R 
+--R
+--R   (30)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 36
+
+--S 37 of 28
+c((2/3)$Float)
+--R 
+--R
+--R   (31)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 37
+
+--S 38 of 28
+c(2/3@Float)
+--R 
+--R
+--R   (32)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 38
+
+--S 39 of 28
+c((2/3)@Float)
+--R 
+--R 
+--RDaly Bug
+--R   An expression involving @ Float actually evaluated to one of type 
+--R      Quaternion Complex Expression Integer . Perhaps you should use ::
+--R      Float .
+--E 39
+
+@
+Could the above problems have been avoided by not assigning types
+to the function we defined? Let's repeat the entire example with
+this single change for the function c2
+<<*>>=
+
+--S 40 of 28
+c2(y) == cos(y)
+--R 
+--R                                                                   Type: Void
+--E 40
+
+--S 41 of 28
+c2(1.237)
+--R 
+--R   Compiling function c2 with type Float -> Float 
+--R
+--R   (34)  0.3276321705 9891498386
+--R                                                                  Type: Float
+--E 41
+
+--S 42 of 28
+c2(x)
+--R 
+--R   There are 2 exposed and 6 unexposed library operations named cos 
+--R      having 1 argument(s) but none was determined to be applicable. 
+--R      Use HyperDoc Browse, or issue
+--R                               )display op cos
+--R      to learn more about the available operations. Perhaps 
+--R      package-calling the operation or using coercions on the arguments
+--R      will allow you to apply the operation.
+--R   Cannot find a definition or applicable library operation named cos 
+--R      with argument type(s) 
+--R                    Quaternion Complex Expression Integer
+--R      
+--R      Perhaps you should use "@" to indicate the required return type, 
+--R      or "$" to specify which version of the function you need.
+--R   AXIOM will attempt to step through and interpret the code.
+--R
+--R             5
+--R   (35)  cos(-)
+--R             2
+--R                                                     Type: Expression Integer
+--E 42
+
+@
+But that was only misdirection, because this breaks down for
+reasonable expressions
+<<*>>=
+
+--S 43 of 28
+c2(1.237/2)
+--R 
+--R   Conversion failed in the compiled user function / .
+--R 
+--RDaly Bug
+--R   Cannot convert from type Float to Quaternion Complex Expression 
+--R      Integer for value
+--R   1.237
+--R
+--E 43
+
+@
+and various attempts at coercion also fail -- compare these results
+to the previous ones
+<<*>>=
+
+--S 44 of 28
+c2(2/3::Float)
+--R 
+--R
+--R             2
+--R   (36)  cos(-)
+--R             3
+--R                                                     Type: Expression Integer
+--E 44
+
+--S 45 of 28
+c2((2/3)::Float)
+--R 
+--R
+--R   (37)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 45
+
+--S 46 of 28
+c2(2/3$Float)
+--R 
+--R
+--R             2
+--R   (38)  cos(-)
+--R             3
+--R                                                     Type: Expression Integer
+--E 46
+
+--S 47 of 28
+c2((2/3)$Float)
+--R 
+--R
+--R   (39)  0.7858872607 7694800072
+--R                                                                  Type: Float
+--E 47
+
+--S 48 of 28
+c2(2/3@Float)
+--R 
+--R
+--R             2
+--R   (40)  cos(-)
+--R             3
+--R                                                     Type: Expression Integer
+--E 48
+
+--S 49 of 28
+c2((2/3)@Float)
+--R 
+--R 
+--RDaly Bug
+--R   An expression involving @ Float actually evaluated to one of type 
+--R      Quaternion Complex Expression Integer . Perhaps you should use ::
+--R      Float .
+--E 49
+
+@
+Lastly, we cannot now use the graph function, draw, on such a function 
+since the wrong ``/'' function is used, contrary to the bypassing of
+internal types we saw take place with draw in the example prior to the
+introduction of operator overloading.
+<<*>>=
+
+--S 50 of 28
+--draw(c(x),x=0..15)
+--E 50
+
+@
+{\sl Not safe at any speed}. Most oddly, the ordinary cos() function which
+exposes no ``/'' division Now fails to work with draw despite the fact
+that we just saw it above still working with Integer and Float arguments
+applied directly.
+<<*>>=
+
+--S 51 of 28
+--draw(cos(x),x=0..15)
+--E 51
+
+)spool 
+)lisp (bye)
+ 
+@
+\eject
+\begin{thebibliography}{99}
+\bibitem{1} nothing
+\end{thebibliography}
+\end{document}



From MAILER-DAEMON Sat Aug 23 12:59:56 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KWwSy-0005Q5-CK
	for mharc-axiom-developer@gnu.org; Sat, 23 Aug 2008 12:59:56 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KWwSw-0005P8-CY
	for axiom-developer@nongnu.org; Sat, 23 Aug 2008 12:59:54 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KWwSv-0005Oe-QZ
	for axiom-developer@nongnu.org; Sat, 23 Aug 2008 12:59:53 -0400
Received: from [199.232.76.173] (port=45256 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KWwSv-0005OZ-Dc
	for axiom-developer@nongnu.org; Sat, 23 Aug 2008 12:59:53 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:47263
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KWwSv-0000rC-4I
	for axiom-developer@nongnu.org; Sat, 23 Aug 2008 12:59:53 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7NGxor3013902;
	Sat, 23 Aug 2008 11:59:50 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7NGxoQM013899;
	Sat, 23 Aug 2008 11:59:50 -0500
Date: Sat, 23 Aug 2008 11:59:50 -0500
Message-Id: <200808231659.m7NGxoQM013899@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080823.01.tpd.patch (UnaryRecursiveAggregate
	API examples)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 23 Aug 2008 16:59:54 -0000

document   concat, first, rest, last, tail, second, third, cycleEntry,
           cycleLength, cycleTail, concat!, cycleSplit!, setfirst!, 
           setrest!, setlast!, split!
from UnaryRecursiveAggregate with API examples
=======================================================================
diff --git a/changelog b/changelog
index 965fce8..e7bbee8 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,4 @@
+20080823 tpd src/algebra/aggcat.spad UnaryRecursiveAggregate API examples
 20080822 tpd src/input/Makefile add linalg, overload regression tests
 20080822 tpd src/input/linalg.input recovered
 20080822 tpd src/input/overload.input recovered
diff --git a/src/algebra/aggcat.spad.pamphlet b/src/algebra/aggcat.spad.pamphlet
index 0719be4..69b8371 100644
--- a/src/algebra/aggcat.spad.pamphlet
+++ b/src/algebra/aggcat.spad.pamphlet
@@ -1,3 +1,4 @@
+
 \documentclass{article}
 \usepackage{axiom}
 \begin{document}
@@ -1618,90 +1619,196 @@ DoublyLinkedAggregate(S:Type): Category == RecursiveAggregate S with
 ++ Since these aggregates are recursive aggregates, they may be cyclic.
 UnaryRecursiveAggregate(S:Type): Category == RecursiveAggregate S with
    concat: (%,%) -> %
-      ++ concat(u,v) returns an aggregate w consisting of the elements of u
-      ++ followed by the elements of v.
-      ++ Note: \axiom{v = rest(w,#a)}.
+     ++ concat(u,v) returns an aggregate w consisting of the elements of u
+     ++ followed by the elements of v.
+     ++ Note: \axiom{v = rest(w,#a)}.
+     ++
+     ++E m:=[1,2,3]      
+     ++E concat(5,m)
+
    concat: (S,%) -> %
-      ++ concat(x,u) returns aggregate consisting of x followed by
-      ++ the elements of u.
-      ++ Note: if \axiom{v = concat(x,u)} then \axiom{x = first v}
-      ++ and \axiom{u = rest v}.
+     ++ concat(x,u) returns aggregate consisting of x followed by
+     ++ the elements of u.
+     ++ Note: if \axiom{v = concat(x,u)} then \axiom{x = first v}
+     ++ and \axiom{u = rest v}.
+     ++
+     ++E m:=[1,2,3]      
+     ++E concat(m,m)
+
    first: % -> S
-      ++ first(u) returns the first element of u
-      ++ (equivalently, the value at the current node).
+     ++ first(u) returns the first element of u
+     ++ (equivalently, the value at the current node).
+     ++
+     ++E m:=[1,2,3]      
+     ++E first(m)
+
    elt: (%,"first") -> S
-      ++ elt(u,"first") (also written: \axiom{u . first}) is equivalent to first u.
+     ++ elt(u,"first") (also written: \axiom{u . first}) is 
+     ++equivalent to first u.
+
    first: (%,NonNegativeInteger) -> %
-      ++ first(u,n) returns a copy of the first n (\axiom{n >= 0}) elements of u.
+     ++ first(u,n) returns a copy of the first n 
+     ++ (\axiom{n >= 0}) elements of u.
+     ++
+     ++E m:=[1,2,3]      
+     ++E first(m,2)
+
    rest: % -> %
-      ++ rest(u) returns an aggregate consisting of all but the first
-      ++ element of u
-      ++ (equivalently, the next node of u).
+     ++ rest(u) returns an aggregate consisting of all but the first
+     ++ element of u
+     ++ (equivalently, the next node of u).
+     ++
+     ++E m:=[1,2,3]      
+     ++E rest m
+
    elt: (%,"rest") -> %
-      ++ elt(%,"rest") (also written: \axiom{u.rest}) is
-      ++ equivalent to \axiom{rest u}.
+     ++ elt(%,"rest") (also written: \axiom{u.rest}) is
+     ++ equivalent to \axiom{rest u}.
+
    rest: (%,NonNegativeInteger) -> %
-      ++ rest(u,n) returns the \axiom{n}th (n >= 0) node of u.
-      ++ Note: \axiom{rest(u,0) = u}.
+     ++ rest(u,n) returns the \axiom{n}th (n >= 0) node of u.
+     ++ Note: \axiom{rest(u,0) = u}.
+     ++
+     ++E m:=[1,2,3]      
+     ++E rest(m,2)
+
    last: % -> S
-      ++ last(u) resturn the last element of u.
-      ++ Note: for lists, \axiom{last(u) = u . (maxIndex u) = u . (# u - 1)}.
+     ++ last(u) resturn the last element of u.
+     ++ Note: for lists, \axiom{last(u) = u . (maxIndex u) = u . (# u - 1)}.
+     ++
+     ++E m:=[1,2,3]      
+     ++E last m
+
    elt: (%,"last") -> S
-      ++ elt(u,"last") (also written: \axiom{u . last}) is equivalent to last u.
+     ++ elt(u,"last") (also written: \axiom{u . last}) is equivalent to last u.
+
    last: (%,NonNegativeInteger) -> %
-      ++ last(u,n) returns a copy of the last n (\axiom{n >= 0}) nodes of u.
-      ++ Note: \axiom{last(u,n)} is a list of n elements.
+     ++ last(u,n) returns a copy of the last n (\axiom{n >= 0}) nodes of u.
+     ++ Note: \axiom{last(u,n)} is a list of n elements.
+     ++
+     ++E m:=[1,2,3]      
+     ++E last(m,2)
+
    tail: % -> %
-      ++ tail(u) returns the last node of u.
-      ++ Note: if u is \axiom{shallowlyMutable},
-      ++ \axiom{setrest(tail(u),v) = concat(u,v)}.
+     ++ tail(u) returns the last node of u.
+     ++ Note: if u is \axiom{shallowlyMutable},
+     ++ \axiom{setrest(tail(u),v) = concat(u,v)}.
+     ++
+     ++E m:=[1,2,3]      
+     ++E last(m,2)
+
    second: % -> S
-      ++ second(u) returns the second element of u.
-      ++ Note: \axiom{second(u) = first(rest(u))}.
+     ++ second(u) returns the second element of u.
+     ++ Note: \axiom{second(u) = first(rest(u))}.
+     ++
+     ++E m:=[1,2,3]      
+     ++E second m
+
    third: % -> S
-      ++ third(u) returns the third element of u.
-      ++ Note: \axiom{third(u) = first(rest(rest(u)))}.
+     ++ third(u) returns the third element of u.
+     ++ Note: \axiom{third(u) = first(rest(rest(u)))}.
+     ++
+     ++E m:=[1,2,3]      
+     ++E third m
+
    cycleEntry: % -> %
-      ++ cycleEntry(u) returns the head of a top-level cycle contained in
-      ++ aggregate u, or \axiom{empty()} if none exists.
+     ++ cycleEntry(u) returns the head of a top-level cycle contained in
+     ++ aggregate u, or \axiom{empty()} if none exists.
+     ++
+     ++E m:=[1,2,3]      
+     ++E concat!(m,tail(m))
+     ++E cycleEntry m
+
    cycleLength: % -> NonNegativeInteger
-      ++ cycleLength(u) returns the length of a top-level cycle
-      ++ contained  in aggregate u, or 0 is u has no such cycle.
+     ++ cycleLength(u) returns the length of a top-level cycle
+     ++ contained  in aggregate u, or 0 is u has no such cycle.
+     ++
+     ++E m:=[1,2,3]      
+     ++E concat!(m,tail(m))
+     ++E cycleLength m
+
    cycleTail: % -> %
-      ++ cycleTail(u) returns the last node in the cycle, or
-      ++ empty if none exists.
+     ++ cycleTail(u) returns the last node in the cycle, or
+     ++ empty if none exists.
+     ++
+     ++E m:=[1,2,3]      
+     ++E concat!(m,tail(m))
+     ++E cycleTail m
+
    if % has shallowlyMutable then
       concat_!: (%,%) -> %
 	++ concat!(u,v) destructively concatenates v to the end of u.
 	++ Note: \axiom{concat!(u,v) = setlast_!(u,v)}.
+        ++
+        ++E m:=[1,2,3]
+        ++E n:=[4,5,6]
+        ++E concat!(m,n)
+
       concat_!: (%,S) -> %
 	++ concat!(u,x) destructively adds element x to the end of u.
 	++ Note: \axiom{concat!(a,x) = setlast!(a,[x])}.
+        ++
+        ++E m:=[1,2,3]      
+        ++E concat!(m,5)
+
       cycleSplit_!: % -> %
 	++ cycleSplit!(u) splits the aggregate by dropping off the cycle.
 	++ The value returned is the cycle entry, or nil if none exists.
-	++ For example, if \axiom{w = concat(u,v)} is the cyclic list where v is
+	++ If \axiom{w = concat(u,v)} is the cyclic list where v is
 	++ the head of the cycle, \axiom{cycleSplit!(w)} will drop v off w thus
 	++ destructively changing w to u, and returning v.
+        ++
+        ++E m:=[1,2,3]
+        ++E concat!(m,m)
+        ++E n:=[4,5,6]
+        ++E p:=concat(n,m)
+        ++E q:=cycleSplit! p
+        ++E p
+        ++E q
+
       setfirst_!: (%,S) -> S
 	++ setfirst!(u,x) destructively changes the first element of a to x.
+        ++ 
+        ++E m:=[1,2,3]
+        ++E setfirst!(m,4)
+        ++E m
+
       setelt: (%,"first",S) -> S
 	++ setelt(u,"first",x) (also written: \axiom{u.first := x}) is
 	++ equivalent to \axiom{setfirst!(u,x)}.
+
       setrest_!: (%,%) -> %
 	++ setrest!(u,v) destructively changes the rest of u to v.
+        ++
+        ++E m:=[1,2,3]
+        ++E setrest!(m,[4,5,6])
+        ++E m
+
       setelt: (%,"rest",%) -> %
-	++ setelt(u,"rest",v) (also written: \axiom{u.rest := v}) is equivalent to
-	++ \axiom{setrest!(u,v)}.
+	++ setelt(u,"rest",v) (also written: \axiom{u.rest := v}) 
+	++ is equivalent to \axiom{setrest!(u,v)}.
+
       setlast_!: (%,S) -> S
 	++ setlast!(u,x) destructively changes the last element of u to x.
+        ++
+        ++E m:=[1,2,3]
+        ++E setlast!(m,4)
+        ++E m
+
       setelt: (%,"last",S) -> S
 	++ setelt(u,"last",x) (also written: \axiom{u.last := b})
 	++ is equivalent to \axiom{setlast!(u,v)}.
+
       split_!: (%,Integer) -> %
-	 ++ split!(u,n) splits u into two aggregates: \axiom{v = rest(u,n)}
-	 ++ and \axiom{w = first(u,n)}, returning \axiom{v}.
-	 ++ Note: afterwards \axiom{rest(u,n)} returns \axiom{empty()}.
+	++ split!(u,n) splits u into two aggregates: \axiom{v = rest(u,n)}
+	++ and \axiom{w = first(u,n)}, returning \axiom{v}.
+	++ Note: afterwards \axiom{rest(u,n)} returns \axiom{empty()}.
+        ++
+        ++E m:=[1,2,3,4]
+        ++E n:=split!(m,2)
+        ++E m
+        ++E n
+
  add
   cycleMax ==> 1000
 



From MAILER-DAEMON Sat Aug 23 18:02:18 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KX1Ba-0008OU-BQ
	for mharc-axiom-developer@gnu.org; Sat, 23 Aug 2008 18:02:18 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KX1BY-0008OG-W7
	for axiom-developer@nongnu.org; Sat, 23 Aug 2008 18:02:17 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KX1BY-0008O4-70
	for axiom-developer@nongnu.org; Sat, 23 Aug 2008 18:02:16 -0400
Received: from [199.232.76.173] (port=52062 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KX1BY-0008O1-3L
	for axiom-developer@nongnu.org; Sat, 23 Aug 2008 18:02:16 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:56209
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KX1BX-0007P9-IM
	for axiom-developer@nongnu.org; Sat, 23 Aug 2008 18:02:15 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7NM2Cr3025056;
	Sat, 23 Aug 2008 17:02:12 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7NM2Coa025053;
	Sat, 23 Aug 2008 17:02:12 -0500
Date: Sat, 23 Aug 2008 17:02:12 -0500
Message-Id: <200808232202.m7NM2Coa025053@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080823.02.tpd.patch (stream API examples)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 23 Aug 2008 22:02:17 -0000

For each of these functions there is an example of use printed with
   )d op functionname

document remove, select, explicitEntries?, explicitlyEmpty?, lazy?,
         frst, rst, numberOfComputedEntries, extend, complete
    from LazyStreamAggregate

document cycleElt, computeCycleLength, computeCycleEntry
    from CyclicStreamTools

document coerce, repeating, repeating? findCycle, cons, output,
         showAllElements, setrest!, generate, filterWhile, filterUntil
    from Stream

document concat
    from StreamFunctions1

document map, scan, reduce
    from StreamFunctions2

document map
    from StreamFunctions3

========================================================================
diff --git a/changelog b/changelog
index e7bbee8..776b956 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,4 @@
+20080823 tpd src/algebra/stream.spad stream API examples
 20080823 tpd src/algebra/aggcat.spad UnaryRecursiveAggregate API examples
 20080822 tpd src/input/Makefile add linalg, overload regression tests
 20080822 tpd src/input/linalg.input recovered
diff --git a/src/algebra/stream.spad.pamphlet b/src/algebra/stream.spad.pamphlet
index 1d68e08..d69cbfb 100644
--- a/src/algebra/stream.spad.pamphlet
+++ b/src/algebra/stream.spad.pamphlet
@@ -29,21 +29,42 @@ LazyStreamAggregate(S:Type): Category == StreamAggregate(S) with
     ++ remove(f,st) returns a stream consisting of those elements of stream
     ++ st which do not satisfy the predicate f.
     ++ Note: \spad{remove(f,st) = [x for x in st | not f(x)]}.
+    ++
+    ++E m:=[i for i in 1..]
+    ++E f(i:PositiveInteger):Boolean == even? i
+    ++E remove(f,m)
+
   select: (S -> Boolean,%) -> %
     ++ select(f,st) returns a stream consisting of those elements of stream
     ++ st satisfying the predicate f.
     ++ Note: \spad{select(f,st) = [x for x in st | f(x)]}.
+    ++
+    ++E m:=[i for i in 0..]
+    ++E select(x+->prime? x,m)
+
   explicitEntries?: % -> Boolean
     ++ explicitEntries?(s) returns true if the stream s has
     ++ explicitly computed entries, and false otherwise.
+    ++
+    ++E m:=[i for i in 0..]
+    ++E explicitEntries? m
+
   explicitlyEmpty?: % -> Boolean
     ++ explicitlyEmpty?(s) returns true if the stream is an
     ++ (explicitly) empty stream.
     ++ Note: this is a null test which will not cause lazy evaluation.
+    ++
+    ++E m:=[i for i in 0..]
+    ++E explicitlyEmpty? m
+
   lazy?: % -> Boolean
     ++ lazy?(s) returns true if the first node of the stream s
     ++ is a lazy evaluation mechanism which could produce an
     ++ additional entry to s.
+    ++
+    ++E m:=[i for i in 0..]
+    ++E lazy? m
+
   lazyEvaluate: % -> %
     ++ lazyEvaluate(s) causes one lazy evaluation of stream s.
     ++ Caution: the first node must be a lazy evaluation mechanism
@@ -54,23 +75,47 @@ LazyStreamAggregate(S:Type): Category == StreamAggregate(S) with
     ++ frst(s) returns the first element of stream s.
     ++ Caution: this function should only be called after a \spad{empty?} test
     ++ has been made since there no error check.
+    ++
+    ++E m:=[i for i in 0..]
+    ++E frst m
+
   rst: % -> %
     ++ rst(s) returns a pointer to the next node of stream s.
     ++ Caution: this function should only be called after a \spad{empty?} test
     ++ has been made since there no error check.
+    ++
+    ++E m:=[i for i in 0..]
+    ++E rst m
+
   numberOfComputedEntries: % -> NonNegativeInteger
     ++ numberOfComputedEntries(st) returns the number of explicitly
     ++ computed entries of stream st which exist immediately prior to the time
     ++ this function is called.
+    ++
+    ++E m:=[i for i in 0..]
+    ++E numberOfComputedEntries m
+
   extend: (%,Integer) -> %
     ++ extend(st,n) causes entries to be computed, if necessary,
     ++ so that 'st' will have at least 'n' explicit entries or so
     ++ that all entries of 'st' will be computed if 'st' is finite
     ++ with length <= n.
+    ++
+    ++E m:=[i for i in 0..]
+    ++E numberOfComputedEntries m
+    ++E extend(m,20)
+    ++E numberOfComputedEntries m
+
   complete: % -> %
     ++ complete(st) causes all entries of 'st' to be computed.
     ++ this function should only be called on streams which are
     ++ known to be finite.
+    ++
+    ++E m:=[i for i in 1..]
+    ++E n:=filterUntil(i+->i>100,m)
+    ++E numberOfComputedEntries n
+    ++E complete n
+    ++E numberOfComputedEntries n
 
  add
 
@@ -503,16 +548,32 @@ CyclicStreamTools(S,ST): Exports == Implementation where
   Exports ==> with
 
     cycleElt: ST -> Union(ST,"failed")
-      ++ cycleElt(s) returns a pointer to a node in the cycle if the stream s is
-      ++ cyclic and returns "failed" if s is not cyclic
+      ++ cycleElt(s) returns a pointer to a node in the cycle if the stream 
+      ++ s is cyclic and returns "failed" if s is not cyclic
+      ++
+      ++E p:=repeating([1,2,3])
+      ++E q:=cons(4,p)
+      ++E cycleElt q
+      ++E r:=[1,2,3]::Stream(Integer)
+      ++E cycleElt r
+
     computeCycleLength: ST -> NonNegativeInteger
       ++ computeCycleLength(s) returns the length of the cycle of a
       ++ cyclic stream t, where s is a pointer to a node in the
       ++ cyclic part of t.
+      ++
+      ++E p:=repeating([1,2,3])
+      ++E q:=cons(4,p)
+      ++E computeCycleLength(cycleElt(q))
+
     computeCycleEntry: (ST,ST) -> ST
       ++ computeCycleEntry(x,cycElt), where cycElt is a pointer to a
       ++ node in the cyclic part of the cyclic stream x, returns a
       ++ pointer to the first node in the cycle
+      ++
+      ++E p:=repeating([1,2,3])
+      ++E q:=cons(4,p)
+      ++E computeCycleEntry(q,cycleElt(q))
 
   Implementation ==> add
 
@@ -755,28 +816,63 @@ Stream(S): Exports == Implementation where
 
     coerce: L S -> %
       ++ coerce(l) converts a list l to a stream.
+      ++
+      ++E m:=[1,2,3,4,5,6,7,8,9,10,11,12]
+      ++E coerce(m)@Stream(Integer)
+      ++E m::Stream(Integer)
+
     repeating: L S -> %
       ++ repeating(l) is a repeating stream whose period is the list l.
+      ++
+      ++E m:=repeating([-1,0,1,2,3])
+
     if S has SetCategory then
       repeating?: (L S,%) -> B
         ++ repeating?(l,s) returns true if a stream s is periodic
         ++ with period l, and false otherwise.
+        ++
+        ++E m:=[1,2,3]
+        ++E n:=repeating(m)
+        ++E repeating?(m,n)
+
     findCycle: (NNI,%) -> Record(cycle?: B, prefix: NNI, period: NNI)
       ++ findCycle(n,st) determines if st is periodic within n.
+      ++
+      ++E m:=[1,2,3]
+      ++E n:=repeating(m)
+      ++E findCycle(3,n)
+      ++E findCycle(2,n)
+
     delay: (() -> %) -> %
-      ++ delay(f) creates a stream with a lazy evaluation defined by function f.
+      ++ delay(f) creates a stream with a lazy evaluation defined by 
+      ++ function f.
       ++ Caution: This function can only be called in compiled code.
     cons: (S,%) -> %
       ++ cons(a,s) returns a stream whose \spad{first} is \spad{a}
       ++ and whose \spad{rest} is s.
       ++ Note: \spad{cons(a,s) = concat(a,s)}.
+      ++
+      ++E m:=[1,2,3]
+      ++E n:=repeating(m)
+      ++E cons(4,n)
+
     if S has SetCategory then
       output: (I, %) -> Void
         ++ output(n,st) computes and displays the first n entries
         ++ of st.
+        ++
+        ++E m:=[1,2,3]
+        ++E n:=repeating(m)
+        ++E output(5,n)
+
       showAllElements: % -> OUT
         ++ showAllElements(s) creates an output form which displays all
         ++ computed elements.
+        ++
+        ++E m:=[1,2,3,4,5,6,7,8,9,10,11,12]
+        ++E n:=m::Stream(PositiveInteger)
+        ++E showAllElements n
+
       showAll?: () -> B
         ++ showAll?() returns true if all computed entries of streams
         ++ will be displayed.
@@ -784,22 +880,46 @@ Stream(S): Exports == Implementation where
     setrest_!: (%,I,%) -> %
       ++ setrest!(x,n,y) sets rest(x,n) to y. The function will expand
       ++ cycles if necessary.
+      ++
+      ++E p:=[i for i in 1..]
+      ++E q:=[i for i in 9..]
+      ++E setrest!(p,4,q)
+      ++E p
+
     generate: (() -> S) -> %
       ++ generate(f) creates an infinite stream all of whose elements are
       ++ equal to \spad{f()}.
       ++ Note: \spad{generate(f) = [f(),f(),f(),...]}.
+      ++
+      ++E f():Integer == 1
+      ++E generate(f)
+
     generate: (S -> S,S) -> %
       ++ generate(f,x) creates an infinite stream whose first element is
       ++ x and whose nth element (\spad{n > 1}) is f applied to the previous
       ++ element. Note: \spad{generate(f,x) = [x,f(x),f(f(x)),...]}.
+      ++
+      ++E f(x:Integer):Integer == x+10
+      ++E generate(f,10)
+
     filterWhile: (S -> Boolean,%) -> %
       ++ filterWhile(p,s) returns \spad{[x0,x1,...,x(n-1)]} where
       ++ \spad{s = [x0,x1,x2,..]} and
       ++ n is the smallest index such that \spad{p(xn) = false}.
+      ++
+      ++E m:=[i for i in 1..]
+      ++E f(x:PositiveInteger):Boolean ==  x < 5
+      ++E filterWhile(f,m)
+
     filterUntil: (S -> Boolean,%) -> %
       ++ filterUntil(p,s) returns \spad{[x0,x1,...,x(n)]} where
       ++ \spad{s = [x0,x1,x2,..]} and
       ++ n is the smallest index such that \spad{p(xn) = true}.
+      ++
+      ++E m:=[i for i in 1..]
+      ++E f(x:PositiveInteger):Boolean ==  x < 5
+      ++E filterUntil(f,m)
+
 --    if S has SetCategory then
 --      map: ((S,S) -> S,%,%,S) -> %
 --       ++ map(f,x,y,a) is equivalent to map(f,x,y)
@@ -1323,8 +1443,13 @@ StreamFunctions1(S:Type): Exports == Implementation where
 
   Exports ==> with
     concat: ST ST S -> ST S
-      ++ concat(u) returns the left-to-right concatentation of the streams in u.
-      ++ Note: \spad{concat(u) = reduce(concat,u)}.
+      ++ concat(u) returns the left-to-right concatentation of the 
+      ++ streams in u. Note: \spad{concat(u) = reduce(concat,u)}.
+      ++
+      ++E m:=[i for i in 10..]
+      ++E n:=[j for j in 1.. | prime? j]
+      ++E p:=[m,n]::Stream(Stream(PositiveInteger))
+      ++E concat(p)
 
   Implementation ==> add
 
@@ -1350,17 +1475,32 @@ StreamFunctions2(A:Type,B:Type): Exports == Implementation where
       ++ map(f,s) returns a stream whose elements are the function f applied
       ++ to the corresponding elements of s.
       ++ Note: \spad{map(f,[x0,x1,x2,...]) = [f(x0),f(x1),f(x2),..]}.
+      ++
+      ++E m:=[i for i in 1..]
+      ++E f(i:PositiveInteger):PositiveInteger==i**2
+      ++E map(f,m)
+
     scan: (B,((A,B) -> B),ST A) -> ST B
       ++ scan(b,h,[x0,x1,x2,...]) returns \spad{[y0,y1,y2,...]}, where
       ++ \spad{y0 = h(x0,b)},
       ++ \spad{y1 = h(x1,y0)},\spad{...}
       ++ \spad{yn = h(xn,y(n-1))}.
+      ++
+      ++E m:=[i for i in 1..]::Stream(Integer)
+      ++E f(i:Integer,j:Integer):Integer==i+j
+      ++E scan(1,f,m)
+
     reduce:  (B,(A,B) -> B,ST A) -> B
       ++ reduce(b,f,u), where u is a finite stream \spad{[x0,x1,...,xn]},
       ++ returns the value \spad{r(n)} computed as follows:
       ++ \spad{r0 = f(x0,b),
       ++ r1 = f(x1,r0),...,
       ++ r(n) = f(xn,r(n-1))}.
+      ++
+      ++E m:=[i for i in 1..300]::Stream(Integer)
+      ++E f(i:Integer,j:Integer):Integer==i+j
+      ++E reduce(1,f,m)
+
 --  rreduce: (B,(A,B) -> B,ST A) -> B
 --    ++ reduce(b,h,[x0,x1,..,xn]) = h(x1,h(x2(..,h(x(n-1),h(xn,b))..)
 --  reshape: (ST B,ST A) -> ST B
@@ -1411,7 +1551,13 @@ StreamFunctions3(A,B,C): Exports == Implementation where
     map: ((A,B) -> C,ST A,ST B) -> ST C
       ++ map(f,st1,st2) returns the stream whose elements are the
       ++ function f applied to the corresponding elements of st1 and st2.
-      ++ Note: \spad{map(f,[x0,x1,x2,..],[y0,y1,y2,..]) = [f(x0,y0),f(x1,y1),..]}.
+      ++ \spad{map(f,[x0,x1,x2,..],[y0,y1,y2,..]) = [f(x0,y0),f(x1,y1),..]}.
+      ++
+      ++S
+      ++E m:=[i for i in 1..]::Stream(Integer)
+      ++E n:=[i for i in 1..]::Stream(Integer)
+      ++E f(i:Integer,j:Integer):Integer == i+j
+      ++E map(f,m,n)
 
   Implementation ==> add
 



From MAILER-DAEMON Sat Aug 23 18:55:46 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KX21K-0006GC-P7
	for mharc-axiom-developer@gnu.org; Sat, 23 Aug 2008 18:55:46 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KX21I-0006Fs-4W
	for axiom-developer@nongnu.org; Sat, 23 Aug 2008 18:55:44 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KX21H-0006Fg-7M
	for axiom-developer@nongnu.org; Sat, 23 Aug 2008 18:55:43 -0400
Received: from [199.232.76.173] (port=44102 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KX21H-0006Fd-1t
	for axiom-developer@nongnu.org; Sat, 23 Aug 2008 18:55:43 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:60126
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KX21G-00084u-EN
	for axiom-developer@nongnu.org; Sat, 23 Aug 2008 18:55:42 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7NMtdr3032717;
	Sat, 23 Aug 2008 17:55:39 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7NMtdN4032714;
	Sat, 23 Aug 2008 17:55:39 -0500
Date: Sat, 23 Aug 2008 17:55:39 -0500
Message-Id: <200808232255.m7NMtdN4032714@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080823.03.tpd.patch (++CapitalLetter syntax
	change)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 23 Aug 2008 22:55:44 -0000

Within Axiom, the use of ++[A-Z], that is ++ followed by any capital
letter is now restricted to documentation and regression testing use
within the .spad file syntax.

The current ++E examples will be changed to run automated testing
of all of the exported APIs that have documentation. There is an
ongoing process to document the APIs for all 5090 exposed function
names (over 10k actual functions since the names are not unique,
e.g. map).

There is a change in the pipeline to use the ++[A-Z] syntax to
dynamically regress these test cases at build time.

In order to do that I needed to remove the use of ++[A-Z] in
existing spad files. This patch does that.
======================================================================
diff --git a/changelog b/changelog
index 776b956..43b1f80 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,20 @@
+20080823 tpd src/algebra/s.spad remove ++CapitalLetter syntax
+20080823 tpd src/algebra/multsqfr.spad remove ++CapitalLetter syntax
+20080823 tpd src/algebra/f07.spad remove ++CapitalLetter syntax
+20080823 tpd src/algebra/f04.spad remove ++CapitalLetter syntax
+20080823 tpd src/algebra/f02.spad remove ++CapitalLetter syntax
+20080823 tpd src/algebra/f01.spad remove ++CapitalLetter syntax
+20080823 tpd src/algebra/e04.spad remove ++CapitalLetter syntax
+20080823 tpd src/algebra/e02.spad remove ++CapitalLetter syntax
+20080823 tpd src/algebra/e01.spad remove ++CapitalLetter syntax
+20080823 tpd src/algebra/d03.spad remove ++CapitalLetter syntax
+20080823 tpd src/algebra/d02.spad remove ++CapitalLetter syntax
+20080823 tpd src/algebra/d01.spad remove ++CapitalLetter syntax
+20080823 tpd src/algebra/c06.spad remove ++CapitalLetter syntax
+20080823 tpd src/algebra/c05.spad remove ++CapitalLetter syntax
+20080823 tpd src/algebra/c02.spad remove ++CapitalLetter syntax
+20080823 tpd src/algebra/axtimer.as remove ++CapitalLetter syntax
+20080823 tpd src/algebra/asp.spad remove ++CapitalLetter syntax
 20080823 tpd src/algebra/stream.spad stream API examples
 20080823 tpd src/algebra/aggcat.spad UnaryRecursiveAggregate API examples
 20080822 tpd src/input/Makefile add linalg, overload regression tests
diff --git a/src/algebra/asp.spad.pamphlet b/src/algebra/asp.spad.pamphlet
index 7899fb3..220c4ab 100644
--- a/src/algebra/asp.spad.pamphlet
+++ b/src/algebra/asp.spad.pamphlet
@@ -18,9 +18,9 @@
 ++                     6 October 1994
 ++ Related Constructors: FortranFunctionCategory, FortranProgramCategory.
 ++ Description: 
-++\spadtype{Asp1} produces Fortran for Type 1 ASPs, needed for various
-++NAG routines. Type 1 ASPs take a univariate expression (in the symbol
-++X) and turn it into a Fortran Function like the following:
+++ \spadtype{Asp1} produces Fortran for Type 1 ASPs, needed for various
+++ NAG routines. Type 1 ASPs take a univariate expression (in the symbol
+++ X) and turn it into a Fortran Function like the following:
 ++\begin{verbatim}
 ++      DOUBLE PRECISION FUNCTION F(X)
 ++      DOUBLE PRECISION X
@@ -2941,10 +2941,10 @@ Asp55(name): Exports == Implementation where
 ++                     6 October 1994
 ++ Related Constructors: FortranVectorFunctionCategory, FortranProgramCategory
 ++ Description:
-++\spadtype{Asp6} produces Fortran for Type 6 ASPs, needed for NAG routines
-++\axiomOpFrom{c05nbf}{c05Package}, \axiomOpFrom{c05ncf}{c05Package}.
-++These represent vectors of functions of X(i) and look like:
-++\begin{verbatim}
+++ \spadtype{Asp6} produces Fortran for Type 6 ASPs, needed for NAG routines
+++ \axiomOpFrom{c05nbf}{c05Package}, \axiomOpFrom{c05ncf}{c05Package}.
+++ These represent vectors of functions of X(i) and look like:
+++ \begin{verbatim}
 ++      SUBROUTINE FCN(N,X,FVEC,IFLAG)
 ++      DOUBLE PRECISION X(N),FVEC(N)
 ++      INTEGER N,IFLAG
@@ -2966,7 +2966,7 @@ Asp55(name): Exports == Implementation where
 ++      FVEC(9)=(-2.0D0*X(9)**2)+3.0D0*X(9)+(-1.0D0*X(8))+1.0D0
 ++      RETURN
 ++      END
-++\end{verbatim}
+++ \end{verbatim}
 
 Asp6(name): Exports == Implementation where
   name : Symbol
@@ -3088,11 +3088,11 @@ Asp6(name): Exports == Implementation where
 ++                     6 October 1994
 ++ Related Constructors: FortranVectorFunctionCategory, FortranProgramCategory
 ++ Description:
-++\spadtype{Asp7} produces Fortran for Type 7 ASPs, needed for NAG routines
-++\axiomOpFrom{d02bbf}{d02Package}, \axiomOpFrom{d02gaf}{d02Package}.
-++These represent a vector of functions of the scalar X and
-++the array Z, and look like:
-++\begin{verbatim}
+++ \spadtype{Asp7} produces Fortran for Type 7 ASPs, needed for NAG routines
+++ \axiomOpFrom{d02bbf}{d02Package}, \axiomOpFrom{d02gaf}{d02Package}.
+++ These represent a vector of functions of the scalar X and
+++ the array Z, and look like:
+++ \begin{verbatim}
 ++      SUBROUTINE FCN(X,Z,F)
 ++      DOUBLE PRECISION F(*),X,Z(*)
 ++      F(1)=DTAN(Z(3))
@@ -3101,7 +3101,7 @@ Asp6(name): Exports == Implementation where
 ++      F(3)=-0.03199999999999999D0/(X*Z(2)**2)
 ++      RETURN
 ++      END
-++\end{verbatim}
+++ \end{verbatim}
 
 Asp7(name): Exports == Implementation where
   name : Symbol
@@ -4106,19 +4106,21 @@ Asp80(name): Exports == Implementation where
 ++                     6 October 1994
 ++ Related Constructors: FortranVectorFunctionCategory, FortranProgramCategory
 ++ Description:
-++\spadtype{Asp9} produces Fortran for Type 9 ASPs, needed for NAG routines
-++\axiomOpFrom{d02bhf}{d02Package}, \axiomOpFrom{d02cjf}{d02Package}, \axiomOpFrom{d02ejf}{d02Package}.
-++These ASPs represent a function of a scalar X and a vector Y, for example:
-++\begin{verbatim}
+++ \spadtype{Asp9} produces Fortran for Type 9 ASPs, needed for NAG routines
+++ \axiomOpFrom{d02bhf}{d02Package}, 
+++ \axiomOpFrom{d02cjf}{d02Package}, 
+++ \axiomOpFrom{d02ejf}{d02Package}.
+++ These ASPs represent a function of a scalar X and a vector Y, for example:
+++ \begin{verbatim}
 ++      DOUBLE PRECISION FUNCTION G(X,Y)
 ++      DOUBLE PRECISION X,Y(*)
 ++      G=X+Y(1)
 ++      RETURN
 ++      END
-++\end{verbatim}
-++If the user provides a constant value for G, then extra information is added
-++via COMMON blocks used by certain routines.  This specifies that the value
-++returned by G in this case is to be ignored.
+++ \end{verbatim}
+++ If the user provides a constant value for G, then extra information is added
+++ via COMMON blocks used by certain routines.  This specifies that the value
+++ returned by G in this case is to be ignored.
 
 Asp9(name): Exports == Implementation where
   name : Symbol
diff --git a/src/algebra/axtimer.as.pamphlet b/src/algebra/axtimer.as.pamphlet
index b05a3aa..1f046bb 100644
--- a/src/algebra/axtimer.as.pamphlet
+++ b/src/algebra/axtimer.as.pamphlet
@@ -81,7 +81,7 @@ Timer: BasicType with {
 		++ and t is not stopped or affected.
 	reset!: %  -> %;
 		++ Resets the timer t to 0 and stops it if it is running.
-		++Returns the timer t after it is reset.
+		++ Returns the timer t after it is reset.
 	start!: %  -> Z;
 		++ Starts or restarts t, without resetting it to 0,
 		++ It has no effect on t if it is already running.
diff --git a/src/algebra/c02.spad.pamphlet b/src/algebra/c02.spad.pamphlet
index f51481a..f3adcc8 100644
--- a/src/algebra/c02.spad.pamphlet
+++ b/src/algebra/c02.spad.pamphlet
@@ -15,10 +15,10 @@
 ++ Author: Godfrey Nolan and Mike Dewar
 ++ Date Created: Jan 1994
 ++ Date Last Updated: Thu May 12 17:44:27 1994
-++Description:
-++This package uses the NAG Library to compute the zeros of a
-++polynomial with real or complex coefficients.
-++See \downlink{Manual Page}{manpageXXc02}.
+++ Description:
+++ This package uses the NAG Library to compute the zeros of a
+++ polynomial with real or complex coefficients.
+++ See \downlink{Manual Page}{manpageXXc02}.
 
 NagPolynomialRootsPackage(): Exports == Implementation where
   S ==> Symbol
diff --git a/src/algebra/c05.spad.pamphlet b/src/algebra/c05.spad.pamphlet
index 61e2337..591b1fc 100644
--- a/src/algebra/c05.spad.pamphlet
+++ b/src/algebra/c05.spad.pamphlet
@@ -15,12 +15,12 @@
 ++ Author: Godfrey Nolan and Mike Dewar
 ++ Date Created: Jan 1994
 ++ Date Last Updated: Thu May 12 17:44:28 1994
-++Description: 
-++This package uses the NAG Library to calculate real zeros of
-++continuous real functions of one or more variables. (Complex
-++equations must be expressed in terms of the equivalent larger
-++system of real equations.)
-++See \downlink{Manual Page}{manpageXXc05}.
+++ Description: 
+++ This package uses the NAG Library to calculate real zeros of
+++ continuous real functions of one or more variables. (Complex
+++ equations must be expressed in terms of the equivalent larger
+++ system of real equations.)
+++ See \downlink{Manual Page}{manpageXXc05}.
 
 NagRootFindingPackage(): Exports == Implementation where
   S ==> Symbol
diff --git a/src/algebra/c06.spad.pamphlet b/src/algebra/c06.spad.pamphlet
index be504dd..a4ed2fe 100644
--- a/src/algebra/c06.spad.pamphlet
+++ b/src/algebra/c06.spad.pamphlet
@@ -15,11 +15,11 @@
 ++ Author: Godfrey Nolan and Mike Dewar
 ++ Date Created: Jan 1994
 ++ Date Last Updated: Thu May 12 17:44:30 1994
-++Description:
-++This package uses the NAG Library to calculate the discrete Fourier
-++transform of a sequence of real or complex data values, and
-++applies it to calculate convolutions and correlations.
-++See \downlink{Manual Page}{manpageXXc06}.
+++ Description:
+++ This package uses the NAG Library to calculate the discrete Fourier
+++ transform of a sequence of real or complex data values, and
+++ applies it to calculate convolutions and correlations.
+++ See \downlink{Manual Page}{manpageXXc06}.
 
 NagSeriesSummationPackage(): Exports == Implementation where
   S ==> Symbol
diff --git a/src/algebra/d01.spad.pamphlet b/src/algebra/d01.spad.pamphlet
index d3770e1..f3f99c5 100644
--- a/src/algebra/d01.spad.pamphlet
+++ b/src/algebra/d01.spad.pamphlet
@@ -15,11 +15,11 @@
 ++ Author: Godfrey Nolan and Mike Dewar
 ++ Date Created: Jan 1994
 ++ Date Last Updated: Thu May 12 17:44:37 1994
-++Description:
-++This package uses the NAG Library to calculate the numerical value of
-++definite integrals in one or more dimensions and to evaluate
-++weights and abscissae of integration rules.
-++See \downlink{Manual Page}{manpageXXd01}.
+++ Description:
+++ This package uses the NAG Library to calculate the numerical value of
+++ definite integrals in one or more dimensions and to evaluate
+++ weights and abscissae of integration rules.
+++ See \downlink{Manual Page}{manpageXXd01}.
 
 NagIntegrationPackage(): Exports == Implementation where
   S ==> Symbol
diff --git a/src/algebra/d02.spad.pamphlet b/src/algebra/d02.spad.pamphlet
index 2b4e3d2..3238c4c 100644
--- a/src/algebra/d02.spad.pamphlet
+++ b/src/algebra/d02.spad.pamphlet
@@ -15,16 +15,16 @@
 ++ Author: Godfrey Nolan and Mike Dewar
 ++ Date Created: Jan 1994
 ++ Date Last Updated: Mon Jun 20 17:56:33 1994
-++Description:
-++This package uses the NAG Library to calculate the numerical solution of ordinary
-++differential equations. There are two main types of problem,
-++those in which all boundary conditions are specified at one point
-++(initial-value problems), and those in which the boundary
-++conditions are distributed between two or more points (boundary-
-++value problems and eigenvalue problems). Routines are available
-++for initial-value problems, two-point boundary-value problems and
-++Sturm-Liouville eigenvalue problems.
-++See \downlink{Manual Page}{manpageXXd02}.
+++ Description:
+++ This package uses the NAG Library to calculate the numerical solution of 
+++ ordinary differential equations. There are two main types of problem,
+++ those in which all boundary conditions are specified at one point
+++ (initial-value problems), and those in which the boundary
+++ conditions are distributed between two or more points (boundary-
+++ value problems and eigenvalue problems). Routines are available
+++ for initial-value problems, two-point boundary-value problems and
+++ Sturm-Liouville eigenvalue problems.
+++ See \downlink{Manual Page}{manpageXXd02}.
 NagOrdinaryDifferentialEquationsPackage(): Exports == Implementation where
   S ==> Symbol
   FOP ==> FortranOutputStackPackage
diff --git a/src/algebra/d03.spad.pamphlet b/src/algebra/d03.spad.pamphlet
index 9f4e0cb..15eba88 100644
--- a/src/algebra/d03.spad.pamphlet
+++ b/src/algebra/d03.spad.pamphlet
@@ -15,10 +15,10 @@
 ++ Author: Godfrey Nolan and Mike Dewar
 ++ Date Created: Jan 1994
 ++ Date Last Updated: Thu May 12 17:44:51 1994
-++Description:
-++This package uses the NAG Library to solve partial
-++differential equations.
-++See \downlink{Manual Page}{manpageXXd03}.
+++ Description:
+++ This package uses the NAG Library to solve partial
+++ differential equations.
+++ See \downlink{Manual Page}{manpageXXd03}.
 NagPartialDifferentialEquationsPackage(): Exports == Implementation where
   S ==> Symbol
   FOP ==> FortranOutputStackPackage
diff --git a/src/algebra/e01.spad.pamphlet b/src/algebra/e01.spad.pamphlet
index 9ad62c8..47a4131 100644
--- a/src/algebra/e01.spad.pamphlet
+++ b/src/algebra/e01.spad.pamphlet
@@ -15,16 +15,16 @@
 ++ Author: Godfrey Nolan and Mike Dewar
 ++ Date Created: Jan 1994
 ++ Date Last Updated: Thu May 12 17:44:53 1994
-++Description:
-++This package uses the NAG Library to calculate the interpolation of a function of
-++one or two variables. When provided with the value of the
-++function (and possibly one or more of its lowest-order
-++derivatives) at each of a number of values of the variable(s),
-++the routines provide either an interpolating function or an
-++interpolated value. For some of the interpolating functions,
-++there are supporting routines to evaluate, differentiate or
-++integrate them.
-++See \downlink{Manual Page}{manpageXXe01}.
+++ Description:
+++ This package uses the NAG Library to calculate the interpolation of a 
+++ function of one or two variables. When provided with the value of the
+++ function (and possibly one or more of its lowest-order
+++ derivatives) at each of a number of values of the variable(s),
+++ the routines provide either an interpolating function or an
+++ interpolated value. For some of the interpolating functions,
+++ there are supporting routines to evaluate, differentiate or
+++ integrate them.
+++ See \downlink{Manual Page}{manpageXXe01}.
 
 
 NagInterpolationPackage(): Exports == Implementation where
diff --git a/src/algebra/e02.spad.pamphlet b/src/algebra/e02.spad.pamphlet
index e09dfca..dfe3306 100644
--- a/src/algebra/e02.spad.pamphlet
+++ b/src/algebra/e02.spad.pamphlet
@@ -15,31 +15,31 @@
 ++ Author: Godfrey Nolan and Mike Dewar
 ++ Date Created: Jan 1994
 ++ Date Last Updated: Thu May 12 17:44:59 1994
-++Description:
-++This package uses the NAG Library to find a
-++function which approximates a set of data points. Typically the
-++data contain random errors, as of experimental measurement, which
-++need to be smoothed out. To seek an approximation to the data, it
-++is first necessary to specify for the approximating function a
-++mathematical form (a polynomial, for example) which contains a
-++number of unspecified coefficients: the appropriate fitting
-++routine then derives for the coefficients the values which
-++provide the best fit of that particular form. The package deals
-++mainly with curve and surface fitting (i.e., fitting with
-++functions of one and of two variables) when a polynomial or a
-++cubic spline is used as the fitting function, since these cover
-++the most common needs. However, fitting with other functions
-++and/or more variables can be undertaken by means of general
-++linear or nonlinear routines (some of which are contained in
-++other packages) depending on whether the coefficients in the
-++function occur linearly or nonlinearly. Cases where a graph
-++rather than a set of data points is given can be treated simply
-++by first reading a suitable set of points from the graph.
-++The package also contains routines for evaluating,
-++differentiating and integrating polynomial and spline curves and
-++surfaces, once the numerical values of their coefficients have
-++been determined.
-++See \downlink{Manual Page}{manpageXXe02}.
+++ Description:
+++ This package uses the NAG Library to find a
+++ function which approximates a set of data points. Typically the
+++ data contain random errors, as of experimental measurement, which
+++ need to be smoothed out. To seek an approximation to the data, it
+++ is first necessary to specify for the approximating function a
+++ mathematical form (a polynomial, for example) which contains a
+++ number of unspecified coefficients: the appropriate fitting
+++ routine then derives for the coefficients the values which
+++ provide the best fit of that particular form. The package deals
+++ mainly with curve and surface fitting (i.e., fitting with
+++ functions of one and of two variables) when a polynomial or a
+++ cubic spline is used as the fitting function, since these cover
+++ the most common needs. However, fitting with other functions
+++ and/or more variables can be undertaken by means of general
+++ linear or nonlinear routines (some of which are contained in
+++ other packages) depending on whether the coefficients in the
+++ function occur linearly or nonlinearly. Cases where a graph
+++ rather than a set of data points is given can be treated simply
+++ by first reading a suitable set of points from the graph.
+++ The package also contains routines for evaluating,
+++ differentiating and integrating polynomial and spline curves and
+++ surfaces, once the numerical values of their coefficients have
+++ been determined.
+++ See \downlink{Manual Page}{manpageXXe02}.
 
 
 NagFittingPackage(): Exports == Implementation where
diff --git a/src/algebra/e04.spad.pamphlet b/src/algebra/e04.spad.pamphlet
index e0f482f..e8fd934 100644
--- a/src/algebra/e04.spad.pamphlet
+++ b/src/algebra/e04.spad.pamphlet
@@ -15,16 +15,16 @@
 ++ Author: Godfrey Nolan and Mike Dewar
 ++ Date Created: Jan 1994
 ++ Date Last Updated: Thu May 12 17:45:09 1994
-++Description:
-++This package uses the NAG Library to perform optimization.
-++An optimization problem involves minimizing a function (called
-++the objective function) of several variables, possibly subject to
-++restrictions on the values of the variables defined by a set of
-++constraint functions. The routines in the NAG Foundation Library
-++are concerned with function minimization only, since the problem
-++of maximizing a given function can be transformed into a
-++minimization problem simply by multiplying the function by -1.
-++See \downlink{Manual Page}{manpageXXe04}.
+++ Description:
+++ This package uses the NAG Library to perform optimization.
+++ An optimization problem involves minimizing a function (called
+++ the objective function) of several variables, possibly subject to
+++ restrictions on the values of the variables defined by a set of
+++ constraint functions. The routines in the NAG Foundation Library
+++ are concerned with function minimization only, since the problem
+++ of maximizing a given function can be transformed into a
+++ minimization problem simply by multiplying the function by -1.
+++ See \downlink{Manual Page}{manpageXXe04}.
 NagOptimisationPackage(): Exports == Implementation where
   S ==> Symbol
   FOP ==> FortranOutputStackPackage
diff --git a/src/algebra/f01.spad.pamphlet b/src/algebra/f01.spad.pamphlet
index edbbc35..2799673 100644
--- a/src/algebra/f01.spad.pamphlet
+++ b/src/algebra/f01.spad.pamphlet
@@ -15,10 +15,10 @@
 ++ Author: Godfrey Nolan and Mike Dewar
 ++ Date Created: Jan 1994
 ++ Date Last Updated: Thu May 12 17:45:15 1994
-++Description:
-++This package uses the NAG Library to provide facilities for matrix factorizations and
-++associated transformations.
-++See \downlink{Manual Page}{manpageXXf01}.
+++ Description:
+++ This package uses the NAG Library to provide facilities for matrix 
+++ factorizations and associated transformations.
+++ See \downlink{Manual Page}{manpageXXf01}.
 NagMatrixOperationsPackage(): Exports == Implementation where
   S ==> Symbol
   FOP ==> FortranOutputStackPackage
diff --git a/src/algebra/f02.spad.pamphlet b/src/algebra/f02.spad.pamphlet
index e5db779..36c0a08 100644
--- a/src/algebra/f02.spad.pamphlet
+++ b/src/algebra/f02.spad.pamphlet
@@ -15,15 +15,15 @@
 ++ Author: Godfrey Nolan and Mike Dewar
 ++ Date Created: Jan 1994
 ++ Date Last Updated: Thu May 12 17:45:20 1994
-++Description:
-++This package uses the NAG Library to compute
-++\begin{items}
-++\item eigenvalues and eigenvectors of a matrix
-++\item eigenvalues and eigenvectors of generalized matrix
-++eigenvalue problems
-++\item singular values and singular vectors of a matrix.
-++\end{items}
-++See \downlink{Manual Page}{manpageXXf02}. 
+++ Description:
+++ This package uses the NAG Library to compute
+++ \begin{items}
+++ \item eigenvalues and eigenvectors of a matrix
+++ \item eigenvalues and eigenvectors of generalized matrix
+++ eigenvalue problems
+++ \item singular values and singular vectors of a matrix.
+++ \end{items}
+++ See \downlink{Manual Page}{manpageXXf02}. 
 
 NagEigenPackage(): Exports == Implementation where
   S ==> Symbol
diff --git a/src/algebra/f04.spad.pamphlet b/src/algebra/f04.spad.pamphlet
index 8be3d92..bbd3374 100644
--- a/src/algebra/f04.spad.pamphlet
+++ b/src/algebra/f04.spad.pamphlet
@@ -15,13 +15,14 @@
 ++ Author: Godfrey Nolan and Mike Dewar
 ++ Date Created: Jan 1994
 ++ Date Last Updated: Thu May 12 17:45:31 1994
-++Description:
-++This package uses the NAG Library to solve the matrix equation \axiom{AX=B}, where \axiom{B}
-++may be a single vector or a matrix of multiple right-hand sides.
-++The matrix \axiom{A} may be real, complex, symmetric, Hermitian positive-
-++definite, or sparse. It may also be rectangular, in which case a
-++least-squares solution is obtained.
-++See \downlink{Manual Page}{manpageXXf04}.
+++ Description:
+++ This package uses the NAG Library to solve the matrix equation 
+++ \axiom{AX=B}, where \axiom{B}
+++ may be a single vector or a matrix of multiple right-hand sides.
+++ The matrix \axiom{A} may be real, complex, symmetric, Hermitian positive-
+++ definite, or sparse. It may also be rectangular, in which case a
+++ least-squares solution is obtained.
+++ See \downlink{Manual Page}{manpageXXf04}.
 NagLinearEquationSolvingPackage(): Exports == Implementation where
   S ==> Symbol
   FOP ==> FortranOutputStackPackage
diff --git a/src/algebra/f07.spad.pamphlet b/src/algebra/f07.spad.pamphlet
index bc8f4ae..7b94a78 100644
--- a/src/algebra/f07.spad.pamphlet
+++ b/src/algebra/f07.spad.pamphlet
@@ -15,11 +15,11 @@
 ++ Author: Godfrey Nolan and Mike Dewar
 ++ Date Created: Jan 1994
 ++ Date Last Updated: Thu May 12 17:45:42 1994
-++Description:
-++This package uses the NAG Library to compute matrix
-++factorizations, and to solve systems of linear equations
-++following the matrix factorizations.
-++See \downlink{Manual Page}{manpageXXf07}.
+++ Description:
+++ This package uses the NAG Library to compute matrix
+++ factorizations, and to solve systems of linear equations
+++ following the matrix factorizations.
+++ See \downlink{Manual Page}{manpageXXf07}.
 NagLapack(): Exports == Implementation where
   S ==> Symbol
   FOP ==> FortranOutputStackPackage
diff --git a/src/algebra/multsqfr.spad.pamphlet b/src/algebra/multsqfr.spad.pamphlet
index fbc32ee..271d61b 100644
--- a/src/algebra/multsqfr.spad.pamphlet
+++ b/src/algebra/multsqfr.spad.pamphlet
@@ -12,7 +12,7 @@
 \section{package MULTSQFR MultivariateSquareFree}
 <<package MULTSQFR MultivariateSquareFree>>=
 )abbrev package MULTSQFR MultivariateSquareFree
-++Author : P.Gianni
+++ Author : P.Gianni
 ++ This package provides the functions for the computation of the square
 ++ free decomposition of a multivariate polynomial.
 ++ It uses the package GenExEuclid for the resolution of
diff --git a/src/algebra/s.spad.pamphlet b/src/algebra/s.spad.pamphlet
index 7da7e73..785bb5f 100644
--- a/src/algebra/s.spad.pamphlet
+++ b/src/algebra/s.spad.pamphlet
@@ -15,10 +15,10 @@
 ++ Author: Godfrey Nolan and Mike Dewar
 ++ Date Created: Jan 1994
 ++ Date Last Updated: Thu May 12 17:45:44 1994
-++Description:
-++This package uses the NAG Library to compute some commonly
-++occurring physical and mathematical functions.
-++See \downlink{Manual Page}{manpageXXs}.
+++ Description:
+++ This package uses the NAG Library to compute some commonly
+++ occurring physical and mathematical functions.
+++ See \downlink{Manual Page}{manpageXXs}.
 NagSpecialFunctionsPackage(): Exports == Implementation where
   S ==> Symbol
   FOP ==> FortranOutputStackPackage



From MAILER-DAEMON Mon Aug 25 17:08:14 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KXjIM-0003R0-0E
	for mharc-axiom-developer@gnu.org; Mon, 25 Aug 2008 17:08:14 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KXjIJ-0003PU-Bg
	for axiom-developer@nongnu.org; Mon, 25 Aug 2008 17:08:11 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KXjIH-0003Oe-L8
	for axiom-developer@nongnu.org; Mon, 25 Aug 2008 17:08:10 -0400
Received: from [199.232.76.173] (port=39833 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KXjIH-0003OT-E1
	for axiom-developer@nongnu.org; Mon, 25 Aug 2008 17:08:09 -0400
Received: from mx-8.zoominternet.net ([24.154.1.27]:59955
	helo=cm-2.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KXjIH-0006rC-BN
	for axiom-developer@nongnu.org; Mon, 25 Aug 2008 17:08:09 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=2DStYHonAAAA:8 a=R33Wn3GuRB4ULX4qp60A:9
	a=6HMK8FbUFYA4QsBwa36dS9JJWJoA:4 a=WB9azuIV8zIA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.47] ([24.154.1.47:49787] helo=pop-4.zoominternet.net)
	by mx-8.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 8D/9B-31557-53F13B84; Mon, 25 Aug 2008 17:08:05 -0400
Received: (qmail 12849 invoked from network); 25 Aug 2008 21:08:05 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-4.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 25 Aug 2008 21:08:05 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id m7PMY4h07117;
	Mon, 25 Aug 2008 18:34:04 -0400
Date: Mon, 25 Aug 2008 18:34:04 -0400
Message-Id: <200808252234.m7PMY4h07117@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: 
Subject: [Axiom-developer] must see
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 25 Aug 2008 21:08:11 -0000

you really have to see this series of videos.
these people have done a truly amazing job.

http://www.dimensions-math.org/Dim_regarder_E_E.htm



From MAILER-DAEMON Mon Aug 25 21:38:50 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KXnWE-0002ve-BG
	for mharc-axiom-developer@gnu.org; Mon, 25 Aug 2008 21:38:50 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KXnWA-0002uU-IB
	for axiom-developer@nongnu.org; Mon, 25 Aug 2008 21:38:46 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KXnW4-0002sk-Vt
	for axiom-developer@nongnu.org; Mon, 25 Aug 2008 21:38:45 -0400
Received: from [199.232.76.173] (port=54673 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KXnW4-0002sh-N3
	for axiom-developer@nongnu.org; Mon, 25 Aug 2008 21:38:40 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:49668
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KXnVw-0002sz-Kv
	for axiom-developer@nongnu.org; Mon, 25 Aug 2008 21:38:40 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7Q1cMr3004221;
	Mon, 25 Aug 2008 20:38:22 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7Q1cMxs004218;
	Mon, 25 Aug 2008 20:38:22 -0500
Date: Mon, 25 Aug 2008 20:38:22 -0500
Message-Id: <200808260138.m7Q1cMxs004218@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080824.01.tpd.patch (use ++X for examples lines)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 26 Aug 2008 01:38:47 -0000

This change makes the syntax of regression tests and the syntax of
example tests equal. The ++(letter) and --(letter) will have the
same meaning. An upcoming change will automate testing functions which
are exposed in the algebra API, making the user examples serve a dual
purpose and providing better regression coverage of the algebra.

So far, the assigned letters mean:

C -- command line, not part of the test
E -- end of test block
R -- result line to compare against the actual result
S -- start of the text block
X -- example line from algebra


Use ++X for example lines. Reserve ++E to mark the end of the regression
test block.
=======================================================================
diff --git a/changelog b/changelog
index 43b1f80..e2cd290 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,20 @@
+20080824 tpd src/interp/format.boot use ++X
+20080824 tpd src/algebra/tree.spad use ++X
+20080824 tpd src/algebra/string.spad use ++X
+20080824 tpd src/algebra/stream.spad use ++X
+20080824 tpd src/algebra/radix.spad use ++X
+20080824 tpd src/algebra/plot.spad use ++X
+20080824 tpd src/algebra/mkfunc.spad use ++X
+20080824 tpd src/algebra/mappkg.spad use ++X
+20080824 tpd src/algebra/listgcd.spad use ++X
+20080824 tpd src/algebra/fr.spad use ++X
+20080824 tpd src/algebra/curve.spad use ++X
+20080824 tpd src/algebra/carten.spad use ++X
+20080824 tpd src/algebra/card.spad use ++X
+20080824 tpd src/algebra/bags.spad use ++X
+20080824 tpd src/algebra/array2.spad use ++X
+20080824 tpd src/algebra/array1.spad use ++X
+20080824 tpd src/algebra/aggcat.spad use ++X
 20080823 tpd src/algebra/s.spad remove ++CapitalLetter syntax
 20080823 tpd src/algebra/multsqfr.spad remove ++CapitalLetter syntax
 20080823 tpd src/algebra/f07.spad remove ++CapitalLetter syntax
diff --git a/src/algebra/aggcat.spad.pamphlet b/src/algebra/aggcat.spad.pamphlet
index 69b8371..ee39ddd 100644
--- a/src/algebra/aggcat.spad.pamphlet
+++ b/src/algebra/aggcat.spad.pamphlet
@@ -1220,9 +1220,9 @@ TableAggregate(Key:SetCategory, Entry:SetCategory): Category ==
    table: () -> %
      ++ table()$T creates an empty table of type T.
      ++
-     ++E Data:=Record(age:Integer,gender:String)
-     ++E a1:AssociationList(String,Data):=table()
-     ++E a1."tim":=[55,"male"]$Data
+     ++X Data:=Record(age:Integer,gender:String)
+     ++X a1:AssociationList(String,Data):=table()
+     ++X a1."tim":=[55,"male"]$Data
 
    table: List Record(key:Key,entry:Entry) -> %
      ++ table([x,y,...,z]) creates a table consisting of entries
@@ -1623,8 +1623,8 @@ UnaryRecursiveAggregate(S:Type): Category == RecursiveAggregate S with
      ++ followed by the elements of v.
      ++ Note: \axiom{v = rest(w,#a)}.
      ++
-     ++E m:=[1,2,3]      
-     ++E concat(5,m)
+     ++X m:=[1,2,3]      
+     ++X concat(5,m)
 
    concat: (S,%) -> %
      ++ concat(x,u) returns aggregate consisting of x followed by
@@ -1632,15 +1632,15 @@ UnaryRecursiveAggregate(S:Type): Category == RecursiveAggregate S with
      ++ Note: if \axiom{v = concat(x,u)} then \axiom{x = first v}
      ++ and \axiom{u = rest v}.
      ++
-     ++E m:=[1,2,3]      
-     ++E concat(m,m)
+     ++X m:=[1,2,3]      
+     ++X concat(m,m)
 
    first: % -> S
      ++ first(u) returns the first element of u
      ++ (equivalently, the value at the current node).
      ++
-     ++E m:=[1,2,3]      
-     ++E first(m)
+     ++X m:=[1,2,3]      
+     ++X first(m)
 
    elt: (%,"first") -> S
      ++ elt(u,"first") (also written: \axiom{u . first}) is 
@@ -1650,16 +1650,16 @@ UnaryRecursiveAggregate(S:Type): Category == RecursiveAggregate S with
      ++ first(u,n) returns a copy of the first n 
      ++ (\axiom{n >= 0}) elements of u.
      ++
-     ++E m:=[1,2,3]      
-     ++E first(m,2)
+     ++X m:=[1,2,3]      
+     ++X first(m,2)
 
    rest: % -> %
      ++ rest(u) returns an aggregate consisting of all but the first
      ++ element of u
      ++ (equivalently, the next node of u).
      ++
-     ++E m:=[1,2,3]      
-     ++E rest m
+     ++X m:=[1,2,3]      
+     ++X rest m
 
    elt: (%,"rest") -> %
      ++ elt(%,"rest") (also written: \axiom{u.rest}) is
@@ -1669,15 +1669,15 @@ UnaryRecursiveAggregate(S:Type): Category == RecursiveAggregate S with
      ++ rest(u,n) returns the \axiom{n}th (n >= 0) node of u.
      ++ Note: \axiom{rest(u,0) = u}.
      ++
-     ++E m:=[1,2,3]      
-     ++E rest(m,2)
+     ++X m:=[1,2,3]      
+     ++X rest(m,2)
 
    last: % -> S
      ++ last(u) resturn the last element of u.
      ++ Note: for lists, \axiom{last(u) = u . (maxIndex u) = u . (# u - 1)}.
      ++
-     ++E m:=[1,2,3]      
-     ++E last m
+     ++X m:=[1,2,3]      
+     ++X last m
 
    elt: (%,"last") -> S
      ++ elt(u,"last") (also written: \axiom{u . last}) is equivalent to last u.
@@ -1686,70 +1686,70 @@ UnaryRecursiveAggregate(S:Type): Category == RecursiveAggregate S with
      ++ last(u,n) returns a copy of the last n (\axiom{n >= 0}) nodes of u.
      ++ Note: \axiom{last(u,n)} is a list of n elements.
      ++
-     ++E m:=[1,2,3]      
-     ++E last(m,2)
+     ++X m:=[1,2,3]      
+     ++X last(m,2)
 
    tail: % -> %
      ++ tail(u) returns the last node of u.
      ++ Note: if u is \axiom{shallowlyMutable},
      ++ \axiom{setrest(tail(u),v) = concat(u,v)}.
      ++
-     ++E m:=[1,2,3]      
-     ++E last(m,2)
+     ++X m:=[1,2,3]      
+     ++X last(m,2)
 
    second: % -> S
      ++ second(u) returns the second element of u.
      ++ Note: \axiom{second(u) = first(rest(u))}.
      ++
-     ++E m:=[1,2,3]      
-     ++E second m
+     ++X m:=[1,2,3]      
+     ++X second m
 
    third: % -> S
      ++ third(u) returns the third element of u.
      ++ Note: \axiom{third(u) = first(rest(rest(u)))}.
      ++
-     ++E m:=[1,2,3]      
-     ++E third m
+     ++X m:=[1,2,3]      
+     ++X third m
 
    cycleEntry: % -> %
      ++ cycleEntry(u) returns the head of a top-level cycle contained in
      ++ aggregate u, or \axiom{empty()} if none exists.
      ++
-     ++E m:=[1,2,3]      
-     ++E concat!(m,tail(m))
-     ++E cycleEntry m
+     ++X m:=[1,2,3]      
+     ++X concat!(m,tail(m))
+     ++X cycleEntry m
 
    cycleLength: % -> NonNegativeInteger
      ++ cycleLength(u) returns the length of a top-level cycle
      ++ contained  in aggregate u, or 0 is u has no such cycle.
      ++
-     ++E m:=[1,2,3]      
-     ++E concat!(m,tail(m))
-     ++E cycleLength m
+     ++X m:=[1,2,3]      
+     ++X concat!(m,tail(m))
+     ++X cycleLength m
 
    cycleTail: % -> %
      ++ cycleTail(u) returns the last node in the cycle, or
      ++ empty if none exists.
      ++
-     ++E m:=[1,2,3]      
-     ++E concat!(m,tail(m))
-     ++E cycleTail m
+     ++X m:=[1,2,3]      
+     ++X concat!(m,tail(m))
+     ++X cycleTail m
 
    if % has shallowlyMutable then
       concat_!: (%,%) -> %
 	++ concat!(u,v) destructively concatenates v to the end of u.
 	++ Note: \axiom{concat!(u,v) = setlast_!(u,v)}.
         ++
-        ++E m:=[1,2,3]
-        ++E n:=[4,5,6]
-        ++E concat!(m,n)
+        ++X m:=[1,2,3]
+        ++X n:=[4,5,6]
+        ++X concat!(m,n)
 
       concat_!: (%,S) -> %
 	++ concat!(u,x) destructively adds element x to the end of u.
 	++ Note: \axiom{concat!(a,x) = setlast!(a,[x])}.
         ++
-        ++E m:=[1,2,3]      
-        ++E concat!(m,5)
+        ++X m:=[1,2,3]      
+        ++X concat!(m,5)
 
       cycleSplit_!: % -> %
 	++ cycleSplit!(u) splits the aggregate by dropping off the cycle.
@@ -1758,20 +1758,20 @@ UnaryRecursiveAggregate(S:Type): Category == RecursiveAggregate S with
 	++ the head of the cycle, \axiom{cycleSplit!(w)} will drop v off w thus
 	++ destructively changing w to u, and returning v.
         ++
-        ++E m:=[1,2,3]
-        ++E concat!(m,m)
-        ++E n:=[4,5,6]
-        ++E p:=concat(n,m)
-        ++E q:=cycleSplit! p
-        ++E p
-        ++E q
+        ++X m:=[1,2,3]
+        ++X concat!(m,m)
+        ++X n:=[4,5,6]
+        ++X p:=concat(n,m)
+        ++X q:=cycleSplit! p
+        ++X p
+        ++X q
 
       setfirst_!: (%,S) -> S
 	++ setfirst!(u,x) destructively changes the first element of a to x.
         ++ 
-        ++E m:=[1,2,3]
-        ++E setfirst!(m,4)
-        ++E m
+        ++X m:=[1,2,3]
+        ++X setfirst!(m,4)
+        ++X m
 
       setelt: (%,"first",S) -> S
 	++ setelt(u,"first",x) (also written: \axiom{u.first := x}) is
@@ -1780,9 +1780,9 @@ UnaryRecursiveAggregate(S:Type): Category == RecursiveAggregate S with
       setrest_!: (%,%) -> %
 	++ setrest!(u,v) destructively changes the rest of u to v.
         ++
-        ++E m:=[1,2,3]
-        ++E setrest!(m,[4,5,6])
-        ++E m
+        ++X m:=[1,2,3]
+        ++X setrest!(m,[4,5,6])
+        ++X m
 
       setelt: (%,"rest",%) -> %
 	++ setelt(u,"rest",v) (also written: \axiom{u.rest := v}) 
@@ -1791,9 +1791,9 @@ UnaryRecursiveAggregate(S:Type): Category == RecursiveAggregate S with
       setlast_!: (%,S) -> S
 	++ setlast!(u,x) destructively changes the last element of u to x.
         ++
-        ++E m:=[1,2,3]
-        ++E setlast!(m,4)
-        ++E m
+        ++X m:=[1,2,3]
+        ++X setlast!(m,4)
+        ++X m
 
       setelt: (%,"last",S) -> S
 	++ setelt(u,"last",x) (also written: \axiom{u.last := b})
@@ -1804,10 +1804,10 @@ UnaryRecursiveAggregate(S:Type): Category == RecursiveAggregate S with
 	++ and \axiom{w = first(u,n)}, returning \axiom{v}.
 	++ Note: afterwards \axiom{rest(u,n)} returns \axiom{empty()}.
         ++
-        ++E m:=[1,2,3,4]
-        ++E n:=split!(m,2)
-        ++E m
-        ++E n
+        ++X m:=[1,2,3,4]
+        ++X n:=split!(m,2)
+        ++X m
+        ++X n
 
  add
   cycleMax ==> 1000
@@ -2717,10 +2717,10 @@ ExtensibleLinearAggregate(S:Type):Category == LinearAggregate S with
    delete_!: (%,Integer) -> %
      ++ delete!(u,i) destructively deletes the \axiom{i}th element of u.
      ++
-     ++E Data:=Record(age:Integer,gender:String)
-     ++E a1:AssociationList(String,Data):=table()
-     ++E a1."tim":=[55,"male"]$Data
-     ++E delete!(a1,1)
+     ++X Data:=Record(age:Integer,gender:String)
+     ++X a1:AssociationList(String,Data):=table()
+     ++X a1."tim":=[55,"male"]$Data
+     ++X delete!(a1,1)
 
    delete_!: (%,UniversalSegment(Integer)) -> %
      ++ delete!(u,i..j) destructively deletes elements u.i through u.j.
diff --git a/src/algebra/array1.spad.pamphlet b/src/algebra/array1.spad.pamphlet
index b4adc3d..7f4be27 100644
--- a/src/algebra/array1.spad.pamphlet
+++ b/src/algebra/array1.spad.pamphlet
@@ -232,9 +232,9 @@ PrimitiveArrayFunctions2(A, B): Exports == Implementation where
     ++ \spad{scan(f,a,r)} returns
     ++ \spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
     ++
-    ++E T1:=PrimitiveArrayFunctions2(Integer,Integer)
-    ++E adder(a:Integer,b:Integer):Integer == a+b
-    ++E scan(adder,[i for i in 1..10],0)$T1
+    ++X T1:=PrimitiveArrayFunctions2(Integer,Integer)
+    ++X adder(a:Integer,b:Integer):Integer == a+b
+    ++X scan(adder,[i for i in 1..10],0)$T1
    
    reduce : ((A, B) -> B, VA, B) -> B
     ++ reduce(f,a,r) applies function f to each
@@ -244,17 +244,17 @@ PrimitiveArrayFunctions2(A, B): Exports == Implementation where
     ++ does \spad{3+(2+(1+0))}. Note: third argument r
     ++ may be regarded as the identity element for the function f.
     ++
-    ++E T1:=PrimitiveArrayFunctions2(Integer,Integer)
-    ++E adder(a:Integer,b:Integer):Integer == a+b
-    ++E reduce(adder,[i for i in 1..10],0)$T1
+    ++X T1:=PrimitiveArrayFunctions2(Integer,Integer)
+    ++X adder(a:Integer,b:Integer):Integer == a+b
+    ++X reduce(adder,[i for i in 1..10],0)$T1
 
    map : (A -> B, VA) -> VB
     ++ map(f,a) applies function f to each member of primitive array
     ++ \spad{a} resulting in a new primitive array over a
     ++ possibly different underlying domain.
     ++
-    ++E T1:=PrimitiveArrayFunctions2(Integer,Integer)
-    ++E map(x+->x+2,[i for i in 1..10])$T1
+    ++X T1:=PrimitiveArrayFunctions2(Integer,Integer)
+    ++X map(x+->x+2,[i for i in 1..10])$T1
 
   Implementation ==> add
     map(f, v)       == map(f, v)$O2
@@ -271,23 +271,23 @@ Tuple(S:Type): CoercibleTo(PrimitiveArray S) with
   coerce: PrimitiveArray S -> %
    ++ coerce(a) makes a tuple from primitive array a
    ++
-   ++E t1:PrimitiveArray(Integer):= [i for i in 1..10]
-   ++E t2:=coerce(t1)$Tuple(Integer)
+   ++X t1:PrimitiveArray(Integer):= [i for i in 1..10]
+   ++X t2:=coerce(t1)$Tuple(Integer)
 
   select: (%, NonNegativeInteger) -> S
    ++ select(x,n) returns the n-th element of tuple x.
    ++ tuples are 0-based
    ++
-   ++E t1:PrimitiveArray(Integer):= [i for i in 1..10]
-   ++E t2:=coerce(t1)$Tuple(Integer)
-   ++E select(t2,3)
+   ++X t1:PrimitiveArray(Integer):= [i for i in 1..10]
+   ++X t2:=coerce(t1)$Tuple(Integer)
+   ++X select(t2,3)
 
   length: % -> NonNegativeInteger
    ++ length(x) returns the number of elements in tuple x
    ++
-   ++E t1:PrimitiveArray(Integer):= [i for i in 1..10]
-   ++E t2:=coerce(t1)$Tuple(Integer)
-   ++E length(t2)
+   ++X t1:PrimitiveArray(Integer):= [i for i in 1..10]
+   ++X t2:=coerce(t1)$Tuple(Integer)
+   ++X length(t2)
 
   if S has SetCategory then SetCategory
  == add
@@ -337,31 +337,31 @@ IndexedFlexibleArray(S:Type, mn: Integer): Exports == Implementation where
     flexibleArray : List S -> %
      ++ flexibleArray(l) creates a flexible array from the list of elements l
      ++
-     ++E T1:=IndexedFlexibleArray(Integer,20)
-     ++E flexibleArray([i for i in 1..10])$T1
+     ++X T1:=IndexedFlexibleArray(Integer,20)
+     ++X flexibleArray([i for i in 1..10])$T1
 
     physicalLength : % -> NonNegativeInteger
      ++ physicalLength(x) returns the number of elements x can 
      ++ accomodate before growing
      ++
-     ++E T1:=IndexedFlexibleArray(Integer,20)
-     ++E t2:=flexibleArray([i for i in 1..10])$T1
-     ++E physicalLength t2
+     ++X T1:=IndexedFlexibleArray(Integer,20)
+     ++X t2:=flexibleArray([i for i in 1..10])$T1
+     ++X physicalLength t2
 
     physicalLength_!: (%, I) -> %
      ++ physicalLength!(x,n) changes the physical length of x to be n and
      ++ returns the new array.
      ++
-     ++E T1:=IndexedFlexibleArray(Integer,20)
-     ++E t2:=flexibleArray([i for i in 1..10])$T1
-     ++E physicalLength!(t2,15)
+     ++X T1:=IndexedFlexibleArray(Integer,20)
+     ++X t2:=flexibleArray([i for i in 1..10])$T1
+     ++X physicalLength!(t2,15)
 
     shrinkable: Boolean -> Boolean
      ++ shrinkable(b) sets the shrinkable attribute of flexible arrays to b
      ++ and returns the previous value
      ++
-     ++E T1:=IndexedFlexibleArray(Integer,20)
-     ++E shrinkable(false)$T1
+     ++X T1:=IndexedFlexibleArray(Integer,20)
+     ++X shrinkable(false)$T1
 
   Implementation == add
     Rep := Record(physLen:I, logLen:I, f:A)
@@ -1087,12 +1087,12 @@ OneDimensionalArray(S:Type): Exports == Implementation where
    oneDimensionalArray: List S -> %
     ++ oneDimensionalArray(l) creates an array from a list of elements l
     ++
-    ++E oneDimensionalArray [i**2 for i in 1..10]
+    ++X oneDimensionalArray [i**2 for i in 1..10]
   
    oneDimensionalArray: (NonNegativeInteger, S) -> %
     ++ oneDimensionalArray(n,s) creates an array from n copies of element s
     ++
-    ++E oneDimensionalArray(10,0.0)
+    ++X oneDimensionalArray(10,0.0)
 
   Implementation == IndexedOneDimensionalArray(S, ARRAYMININDEX) add
     oneDimensionalArray(u) ==
@@ -1125,9 +1125,9 @@ OneDimensionalArrayFunctions2(A, B): Exports == Implementation where
     ++ \spad{scan(f,a,r)} returns
     ++ \spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
     ++
-    ++E T1:=OneDimensionalArrayFunctions2(Integer,Integer)
-    ++E adder(a:Integer,b:Integer):Integer == a+b
-    ++E scan(adder,[i for i in 1..10],0)$T1
+    ++X T1:=OneDimensionalArrayFunctions2(Integer,Integer)
+    ++X adder(a:Integer,b:Integer):Integer == a+b
+    ++X scan(adder,[i for i in 1..10],0)$T1
 
    reduce : ((A, B) -> B, VA, B) -> B
     ++ reduce(f,a,r) applies function f to each
@@ -1137,17 +1137,17 @@ OneDimensionalArrayFunctions2(A, B): Exports == Implementation where
     ++ does \spad{3+(2+(1+0))}. Note: third argument r
     ++ may be regarded as the identity element for the function f.
     ++
-    ++E T1:=OneDimensionalArrayFunctions2(Integer,Integer)
-    ++E adder(a:Integer,b:Integer):Integer == a+b
-    ++E reduce(adder,[i for i in 1..10],0)$T1
+    ++X T1:=OneDimensionalArrayFunctions2(Integer,Integer)
+    ++X adder(a:Integer,b:Integer):Integer == a+b
+    ++X reduce(adder,[i for i in 1..10],0)$T1
 
    map : (A -> B, VA) -> VB
     ++ map(f,a) applies function f to each member of one-dimensional array
     ++ \spad{a} resulting in a new one-dimensional array over a
     ++ possibly different underlying domain.
     ++
-    ++E T1:=OneDimensionalArrayFunctions2(Integer,Integer)
-    ++E map(x+->x+2,[i for i in 1..10])$T1
+    ++X T1:=OneDimensionalArrayFunctions2(Integer,Integer)
+    ++X map(x+->x+2,[i for i in 1..10])$T1
 
   Implementation ==> add
     map(f, v)       == map(f, v)$O2
diff --git a/src/algebra/array2.spad.pamphlet b/src/algebra/array2.spad.pamphlet
index e6a8b7a..a6f9cd7 100644
--- a/src/algebra/array2.spad.pamphlet
+++ b/src/algebra/array2.spad.pamphlet
@@ -46,51 +46,51 @@ TwoDimensionalArrayCategory(R,Row,Col): Category == Definition where
    new: (NonNegativeInteger,NonNegativeInteger,R) -> %
     ++ new(m,n,r) is an m-by-n array all of whose entries are r
     ++
-    ++E arr : ARRAY2 INT := new(5,4,0)
+    ++X arr : ARRAY2 INT := new(5,4,0)
     
    fill_!: (%,R) -> %
     ++ fill!(m,r) fills m with r's
     ++
-    ++E arr : ARRAY2 INT := new(5,4,0)
-    ++E fill!(arr,10)
+    ++X arr : ARRAY2 INT := new(5,4,0)
+    ++X fill!(arr,10)
 
 --% Size inquiries
 
    minRowIndex : % -> Integer
     ++ minRowIndex(m) returns the index of the 'first' row of the array m
     ++
-    ++E arr : ARRAY2 INT := new(5,4,10)
-    ++E minRowIndex(arr)
+    ++X arr : ARRAY2 INT := new(5,4,10)
+    ++X minRowIndex(arr)
 
    maxRowIndex : % -> Integer
     ++ maxRowIndex(m) returns the index of the 'last' row of the array m
     ++
-    ++E arr : ARRAY2 INT := new(5,4,10)
-    ++E maxRowIndex(arr)
+    ++X arr : ARRAY2 INT := new(5,4,10)
+    ++X maxRowIndex(arr)
 
    minColIndex : % -> Integer
     ++ minColIndex(m) returns the index of the 'first' column of the array m
     ++
-    ++E arr : ARRAY2 INT := new(5,4,10)
-    ++E minColIndex(arr)
+    ++X arr : ARRAY2 INT := new(5,4,10)
+    ++X minColIndex(arr)
 
    maxColIndex : % -> Integer
     ++ maxColIndex(m) returns the index of the 'last' column of the array m
     ++
-    ++E arr : ARRAY2 INT := new(5,4,10)
-    ++E maxColIndex(arr)
+    ++X arr : ARRAY2 INT := new(5,4,10)
+    ++X maxColIndex(arr)
 
    nrows : % -> NonNegativeInteger
     ++ nrows(m) returns the number of rows in the array m
     ++
-    ++E arr : ARRAY2 INT := new(5,4,10)
-    ++E nrows(arr)
+    ++X arr : ARRAY2 INT := new(5,4,10)
+    ++X nrows(arr)
 
    ncols : % -> NonNegativeInteger
     ++ ncols(m) returns the number of columns in the array m
     ++
-    ++E arr : ARRAY2 INT := new(5,4,10)
-    ++E ncols(arr)
+    ++X arr : ARRAY2 INT := new(5,4,10)
+    ++X ncols(arr)
 
 --% Part extractions
 
@@ -99,45 +99,45 @@ TwoDimensionalArrayCategory(R,Row,Col): Category == Definition where
     ++ column of the array m
     ++ error check to determine if indices are in proper ranges
     ++
-    ++E arr : ARRAY2 INT := new(5,4,10)
-    ++E elt(arr,1,1)
+    ++X arr : ARRAY2 INT := new(5,4,10)
+    ++X elt(arr,1,1)
 
    qelt: (%,Integer,Integer) -> R
     ++ qelt(m,i,j) returns the element in the ith row and jth
     ++ column of the array m
     ++ NO error check to determine if indices are in proper ranges
     ++
-    ++E arr : ARRAY2 INT := new(5,4,10)
-    ++E qelt(arr,1,1)
+    ++X arr : ARRAY2 INT := new(5,4,10)
+    ++X qelt(arr,1,1)
 
    elt: (%,Integer,Integer,R) -> R
     ++ elt(m,i,j,r) returns the element in the ith row and jth
     ++ column of the array m, if m has an ith row and a jth column,
     ++ and returns r otherwise
     ++
-    ++E arr : ARRAY2 INT := new(5,4,10)
-    ++E elt(arr,1,1,6)
-    ++E elt(arr,1,10,6)
+    ++X arr : ARRAY2 INT := new(5,4,10)
+    ++X elt(arr,1,1,6)
+    ++X elt(arr,1,10,6)
 
    row: (%,Integer) -> Row
     ++ row(m,i) returns the ith row of m
     ++ error check to determine if index is in proper ranges
     ++
-    ++E arr : ARRAY2 INT := new(5,4,10)
-    ++E row(arr,1)
+    ++X arr : ARRAY2 INT := new(5,4,10)
+    ++X row(arr,1)
 
    column: (%,Integer) -> Col
     ++ column(m,j) returns the jth column of m
     ++ error check to determine if index is in proper ranges
     ++
-    ++E arr : ARRAY2 INT := new(5,4,10)
-    ++E column(arr,1)
+    ++X arr : ARRAY2 INT := new(5,4,10)
+    ++X column(arr,1)
 
    parts: % -> List R
     ++ parts(m) returns a list of the elements of m in row major order
     ++
-    ++E arr : ARRAY2 INT := new(5,4,10)
-    ++E parts(arr)
+    ++X arr : ARRAY2 INT := new(5,4,10)
+    ++X parts(arr)
 
 --% Part assignments
 
@@ -147,34 +147,34 @@ TwoDimensionalArrayCategory(R,Row,Col): Category == Definition where
     ++ column of m to r
     ++ error check to determine if indices are in proper ranges
     ++
-    ++E arr : ARRAY2 INT := new(5,4,0)
-    ++E setelt(arr,1,1,17)
+    ++X arr : ARRAY2 INT := new(5,4,0)
+    ++X setelt(arr,1,1,17)
 
    qsetelt_!: (%,Integer,Integer,R) -> R
     ++ qsetelt!(m,i,j,r) sets the element in the ith row and jth
     ++ column of m to r
     ++ NO error check to determine if indices are in proper ranges
     ++
-    ++E arr : ARRAY2 INT := new(5,4,0)
-    ++E qsetelt!(arr,1,1,17)
+    ++X arr : ARRAY2 INT := new(5,4,0)
+    ++X qsetelt!(arr,1,1,17)
 
    setRow_!: (%,Integer,Row) -> %
     ++ setRow!(m,i,v) sets to ith row of m to v
     ++
-    ++E T1:=TwoDimensionalArray Integer
-    ++E arr:T1:= new(5,4,0)
-    ++E T2:=OneDimensionalArray Integer
-    ++E arow:=construct([1,2,3,4]::List(INT))$T2
-    ++E setRow!(arr,1,arow)$T1
+    ++X T1:=TwoDimensionalArray Integer
+    ++X arr:T1:= new(5,4,0)
+    ++X T2:=OneDimensionalArray Integer
+    ++X arow:=construct([1,2,3,4]::List(INT))$T2
+    ++X setRow!(arr,1,arow)$T1
 
    setColumn_!: (%,Integer,Col) -> %
     ++ setColumn!(m,j,v) sets to jth column of m to v
     ++
-    ++E T1:=TwoDimensionalArray Integer
-    ++E arr:T1:= new(5,4,0)
-    ++E T2:=OneDimensionalArray Integer
-    ++E acol:=construct([1,2,3,4,5]::List(INT))$T2
-    ++E setColumn!(arr,1,acol)$T1
+    ++X T1:=TwoDimensionalArray Integer
+    ++X arr:T1:= new(5,4,0)
+    ++X T2:=OneDimensionalArray Integer
+    ++X acol:=construct([1,2,3,4,5]::List(INT))$T2
+    ++X setColumn!(arr,1,acol)$T1
 
 --% Map and Zip
 
@@ -182,23 +182,23 @@ TwoDimensionalArrayCategory(R,Row,Col): Category == Definition where
     ++ map(f,a) returns \spad{b}, where \spad{b(i,j) = f(a(i,j))} 
     ++ for all \spad{i, j}
     ++
-    ++E arr : ARRAY2 INT := new(5,4,10)
-    ++E map(-,arr)
-    ++E map((x +-> x + x),arr)
+    ++X arr : ARRAY2 INT := new(5,4,10)
+    ++X map(-,arr)
+    ++X map((x +-> x + x),arr)
 
    map_!: (R -> R,%) -> %
     ++ map!(f,a)  assign \spad{a(i,j)} to \spad{f(a(i,j))} for all \spad{i, j}
     ++
-    ++E arr : ARRAY2 INT := new(5,4,10)
-    ++E map!(-,arr)
+    ++X arr : ARRAY2 INT := new(5,4,10)
+    ++X map!(-,arr)
 
    map:((R,R) -> R,%,%) -> %
     ++ map(f,a,b) returns \spad{c}, where \spad{c(i,j) = f(a(i,j),b(i,j))}
     ++ for all \spad{i, j}
     ++
-    ++E adder(a:Integer,b:Integer):Integer == a+b
-    ++E arr : ARRAY2 INT := new(5,4,10)
-    ++E map(adder,arr,arr)
+    ++X adder(a:Integer,b:Integer):Integer == a+b
+    ++X arr : ARRAY2 INT := new(5,4,10)
+    ++X map(adder,arr,arr)
 
    map:((R,R) -> R,%,%,R) -> %
     ++ map(f,a,b,r) returns \spad{c}, where \spad{c(i,j) = f(a(i,j),b(i,j))}
@@ -207,10 +207,10 @@ TwoDimensionalArrayCategory(R,Row,Col): Category == Definition where
     ++ else \spad{c(i,j) = f(a(i,j),r)} when \spad{b(i,j)} does not exist;
     ++ otherwise \spad{c(i,j) = f(r,r)}.
     ++
-    ++E adder(a:Integer,b:Integer):Integer == a+b
-    ++E arr1 : ARRAY2 INT := new(5,4,10)
-    ++E arr2 : ARRAY2 INT := new(3,3,10)
-    ++E map(adder,arr1,arr2,17)
+    ++X adder(a:Integer,b:Integer):Integer == a+b
+    ++X arr1 : ARRAY2 INT := new(5,4,10)
+    ++X arr2 : ARRAY2 INT := new(3,3,10)
+    ++X map(adder,arr1,arr2,17)
 
   add
 
diff --git a/src/algebra/bags.spad.pamphlet b/src/algebra/bags.spad.pamphlet
index 65efc9e..a2fe3f3 100644
--- a/src/algebra/bags.spad.pamphlet
+++ b/src/algebra/bags.spad.pamphlet
@@ -32,7 +32,7 @@ Stack(S:SetCategory): StackAggregate S with
       ++ stack([x,y,...,z]) creates a stack with first (top)
       ++ element x, second element y,...,and last element z.
       ++
-      ++E a:Stack INT:= stack [1,2,3,4,5]
+      ++X a:Stack INT:= stack [1,2,3,4,5]
 
   == add
     Rep := Reference List S
@@ -81,7 +81,7 @@ ArrayStack(S:SetCategory): StackAggregate(S) with
       ++ arrayStack([x,y,...,z]) creates an array stack with first (top)
       ++ element x, second element y,...,and last element z.
       ++
-      ++E c:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++X c:ArrayStack INT:= arrayStack [1,2,3,4,5]
 
   == add
     Rep := IndexedFlexibleArray(S,0)
@@ -134,7 +134,7 @@ Queue(S:SetCategory): QueueAggregate S with
       ++ queue([x,y,...,z]) creates a queue with first (top)
       ++ element x, second element y,...,and last (bottom) element z.
       ++
-      ++E e:Queue INT:= queue [1,2,3,4,5]
+      ++X e:Queue INT:= queue [1,2,3,4,5]
 
   == Stack S add
     Rep := Reference List S
@@ -181,7 +181,7 @@ Dequeue(S:SetCategory): DequeueAggregate S with
        ++ dequeue([x,y,...,z]) creates a dequeue with first (top or front)
        ++ element x, second element y,...,and last (bottom or back) element z.
        ++
-       ++E g:Dequeue INT:= dequeue [1,2,3,4,5]
+       ++X g:Dequeue INT:= dequeue [1,2,3,4,5]
 
   == Queue S add
     Rep := Reference List S
@@ -376,7 +376,7 @@ Heap(S:OrderedSet): Exports == Implementation where
       ++ heap(ls) creates a heap of elements consisting of the 
       ++ elements of ls.
       ++
-      ++E i:Heap INT := heap [1,6,3,7,5,2,4]
+      ++X i:Heap INT := heap [1,6,3,7,5,2,4]
 
   Implementation == IndexedFlexibleArray(S,0) add
     Rep := IndexedFlexibleArray( S,0)
diff --git a/src/algebra/card.spad.pamphlet b/src/algebra/card.spad.pamphlet
index 14c1ae9..7eb9afa 100644
--- a/src/algebra/card.spad.pamphlet
+++ b/src/algebra/card.spad.pamphlet
@@ -381,62 +381,62 @@ CardinalNumber: Join(OrderedSet, AbelianMonoid, Monoid,
             ++ \spad{x - y} returns an element z such that 
             ++ \spad{z+y=x} or "failed" if no such element exists.
             ++
-            ++E c2:=2::CardinalNumber
-            ++E c2-c2
-            ++E A1:=Aleph 1
-            ++E A1-c2
+            ++X c2:=2::CardinalNumber
+            ++X c2-c2
+            ++X A1:=Aleph 1
+            ++X A1-c2
 
         "**": (%, %) -> %
             ++ \spad{x**y} returns \spad{#(X**Y)} where \spad{X**Y} is defined
             ++  as \spad{\{g| g:Y->X\}}.
             ++
-            ++E c2:=2::CardinalNumber
-            ++E c2**c2
-            ++E A1:=Aleph 1
-            ++E A1**c2
-            ++E generalizedContinuumHypothesisAssumed true
-            ++E A1**A1
+            ++X c2:=2::CardinalNumber
+            ++X c2**c2
+            ++X A1:=Aleph 1
+            ++X A1**c2
+            ++X generalizedContinuumHypothesisAssumed true
+            ++X A1**A1
 
         Aleph: NonNegativeInteger -> %
             ++ Aleph(n) provides the named (infinite) cardinal number.
             ++
-            ++E A0:=Aleph 0
+            ++X A0:=Aleph 0
 
         finite?: % -> Boolean
             ++ finite?(\spad{a}) determines whether 
             ++ \spad{a} is a finite cardinal, i.e. an integer.
             ++
-            ++E c2:=2::CardinalNumber
-            ++E finite? c2
-            ++E A0:=Aleph 0
-            ++E finite? A0
+            ++X c2:=2::CardinalNumber
+            ++X finite? c2
+            ++X A0:=Aleph 0
+            ++X finite? A0
 
         countable?: % -> Boolean
             ++ countable?(\spad{a}) determines 
             ++ whether \spad{a} is a countable cardinal,
             ++ i.e. an integer or \spad{Aleph 0}.
             ++
-            ++E c2:=2::CardinalNumber
-            ++E countable? c2
-            ++E A0:=Aleph 0
-            ++E countable? A0
-            ++E A1:=Aleph 1
-            ++E countable? A1
+            ++X c2:=2::CardinalNumber
+            ++X countable? c2
+            ++X A0:=Aleph 0
+            ++X countable? A0
+            ++X A1:=Aleph 1
+            ++X countable? A1
 
         generalizedContinuumHypothesisAssumed?: () -> Boolean
             ++ generalizedContinuumHypothesisAssumed?()
             ++ tests if the hypothesis is currently assumed.
             ++
-            ++E generalizedContinuumHypothesisAssumed?
+            ++X generalizedContinuumHypothesisAssumed?
 
         generalizedContinuumHypothesisAssumed:  Boolean -> Boolean
             ++ generalizedContinuumHypothesisAssumed(bool)
             ++ is used to dictate whether the hypothesis is to be assumed.
             ++
-            ++E generalizedContinuumHypothesisAssumed true
-            ++E a:=Aleph 0
-            ++E c:=2**a
-            ++E f:=2**c
+            ++X generalizedContinuumHypothesisAssumed true
+            ++X a:=Aleph 0
+            ++X c:=2**a
+            ++X f:=2**c
     == add
         NNI ==> NonNegativeInteger
         FINord   ==> -1
diff --git a/src/algebra/carten.spad.pamphlet b/src/algebra/carten.spad.pamphlet
index 8d39805..d1880f4 100644
--- a/src/algebra/carten.spad.pamphlet
+++ b/src/algebra/carten.spad.pamphlet
@@ -1083,94 +1083,94 @@ CartesianTensor(minix, dim, R): Exports == Implementation where
         coerce: DP(dim, R) -> %
             ++ coerce(v) views a vector as a rank 1 tensor.
             ++
-            ++E v:DirectProduct(2,Integer):=directProduct [3,4]
-            ++E tv:CartesianTensor(1,2,Integer):=v
+            ++X v:DirectProduct(2,Integer):=directProduct [3,4]
+            ++X tv:CartesianTensor(1,2,Integer):=v
 
         coerce: SM(dim, R)  -> %
             ++ coerce(m) views a matrix as a rank 2 tensor.
             ++
-            ++E v:SquareMatrix(2,Integer):=[[1,2],[3,4]]
-            ++E tv:CartesianTensor(1,2,Integer):=v
+            ++X v:SquareMatrix(2,Integer):=[[1,2],[3,4]]
+            ++X tv:CartesianTensor(1,2,Integer):=v
 
         coerce: List R -> %
             ++ coerce([r_1,...,r_dim]) allows tensors to be constructed
             ++ using lists.
             ++
-            ++E v:=[2,3]
-            ++E tv:CartesianTensor(1,2,Integer):=v
+            ++X v:=[2,3]
+            ++X tv:CartesianTensor(1,2,Integer):=v
 
         coerce: List % -> %
             ++ coerce([t_1,...,t_dim]) allows tensors to be constructed
             ++ using lists.
             ++
-            ++E v:=[2,3]
-            ++E tv:CartesianTensor(1,2,Integer):=v
-            ++E tm:CartesianTensor(1,2,Integer):=[tv,tv]
+            ++X v:=[2,3]
+            ++X tv:CartesianTensor(1,2,Integer):=v
+            ++X tm:CartesianTensor(1,2,Integer):=[tv,tv]
 
         rank: % -> NNI
             ++ rank(t) returns the tensorial rank of t (that is, the
             ++ number of indices).  This is the same as the graded module
             ++ degree.
             ++
-            ++E CT:=CARTEN(1,2,Integer)
-            ++E t0:CT:=8
-            ++E rank t0
+            ++X CT:=CARTEN(1,2,Integer)
+            ++X t0:CT:=8
+            ++X rank t0
 
         elt: (%) -> R
             ++ elt(t) gives the component of a rank 0 tensor.
             ++
-            ++E tv:CartesianTensor(1,2,Integer):=8
-            ++E elt(tv)
-            ++E tv[]
+            ++X tv:CartesianTensor(1,2,Integer):=8
+            ++X elt(tv)
+            ++X tv[]
 
         elt: (%, I) -> R
             ++ elt(t,i) gives a component of a rank 1 tensor.
             ++
-            ++E v:=[2,3]
-            ++E tv:CartesianTensor(1,2,Integer):=v
-            ++E elt(tv,2)
-            ++E tv[2]
+            ++X v:=[2,3]
+            ++X tv:CartesianTensor(1,2,Integer):=v
+            ++X elt(tv,2)
+            ++X tv[2]
 
         elt: (%, I, I) -> R
             ++ elt(t,i,j) gives a component of a rank 2 tensor.
             ++
-            ++E v:=[2,3]
-            ++E tv:CartesianTensor(1,2,Integer):=v
-            ++E tm:CartesianTensor(1,2,Integer):=[tv,tv]
-            ++E elt(tm,2,2)
-            ++E tm[2,2]
+            ++X v:=[2,3]
+            ++X tv:CartesianTensor(1,2,Integer):=v
+            ++X tm:CartesianTensor(1,2,Integer):=[tv,tv]
+            ++X elt(tm,2,2)
+            ++X tm[2,2]
 
         elt: (%, I, I, I) -> R
             ++ elt(t,i,j,k) gives a component of a rank 3 tensor.
             ++
-            ++E v:=[2,3]
-            ++E tv:CartesianTensor(1,2,Integer):=v
-            ++E tm:CartesianTensor(1,2,Integer):=[tv,tv]
-            ++E tn:CartesianTensor(1,2,Integer):=[tm,tm]
-            ++E elt(tn,2,2,2)
-            ++E tn[2,2,2]
+            ++X v:=[2,3]
+            ++X tv:CartesianTensor(1,2,Integer):=v
+            ++X tm:CartesianTensor(1,2,Integer):=[tv,tv]
+            ++X tn:CartesianTensor(1,2,Integer):=[tm,tm]
+            ++X elt(tn,2,2,2)
+            ++X tn[2,2,2]
 
         elt: (%, I, I, I, I) -> R
             ++ elt(t,i,j,k,l) gives a component of a rank 4 tensor.
             ++
-            ++E v:=[2,3]
-            ++E tv:CartesianTensor(1,2,Integer):=v
-            ++E tm:CartesianTensor(1,2,Integer):=[tv,tv]
-            ++E tn:CartesianTensor(1,2,Integer):=[tm,tm]
-            ++E tp:CartesianTensor(1,2,Integer):=[tn,tn]
-            ++E elt(tp,2,2,2,2)
-            ++E tp[2,2,2,2]
+            ++X v:=[2,3]
+            ++X tv:CartesianTensor(1,2,Integer):=v
+            ++X tm:CartesianTensor(1,2,Integer):=[tv,tv]
+            ++X tn:CartesianTensor(1,2,Integer):=[tm,tm]
+            ++X tp:CartesianTensor(1,2,Integer):=[tn,tn]
+            ++X elt(tp,2,2,2,2)
+            ++X tp[2,2,2,2]
 
         elt: (%, List I) -> R
             ++ elt(t,[i1,...,iN]) gives a component of a rank \spad{N} tensor.
             ++
-            ++E v:=[2,3]
-            ++E tv:CartesianTensor(1,2,Integer):=v
-            ++E tm:CartesianTensor(1,2,Integer):=[tv,tv]
-            ++E tn:CartesianTensor(1,2,Integer):=[tm,tm]
-            ++E tp:CartesianTensor(1,2,Integer):=[tn,tn]
-            ++E tq:CartesianTensor(1,2,Integer):=[tp,tp]
-            ++E elt(tq,[2,2,2,2,2])
+            ++X v:=[2,3]
+            ++X tv:CartesianTensor(1,2,Integer):=v
+            ++X tm:CartesianTensor(1,2,Integer):=[tv,tv]
+            ++X tn:CartesianTensor(1,2,Integer):=[tm,tm]
+            ++X tp:CartesianTensor(1,2,Integer):=[tn,tn]
+            ++X tq:CartesianTensor(1,2,Integer):=[tp,tp]
+            ++X elt(tq,[2,2,2,2,2])
 
         -- This specializes the documentation from GradedAlgebra.
         product: (%,%) -> %
@@ -1179,11 +1179,11 @@ CartesianTensor(minix, dim, R): Exports == Implementation where
             ++ s and t, then \spad{r} is a rank 4 tensor given by
             ++     \spad{r(i,j,k,l) = s(i,j)*t(k,l)}.
             ++
-            ++E m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
-            ++E Tm:CartesianTensor(1,2,Integer):=m
-            ++E n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]]
-            ++E Tn:CartesianTensor(1,2,Integer):=n
-            ++E Tmn:=product(Tm,Tn)
+            ++X m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
+            ++X Tm:CartesianTensor(1,2,Integer):=m
+            ++X n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]]
+            ++X Tn:CartesianTensor(1,2,Integer):=n
+            ++X Tmn:=product(Tm,Tn)
 
         "*": (%, %) -> %
             ++ s*t is the inner product of the tensors s and t which contracts
@@ -1193,11 +1193,11 @@ CartesianTensor(minix, dim, R): Exports == Implementation where
             ++ This is compatible with the use of \spad{M*v} to denote
             ++ the matrix-vector inner product.
             ++
-            ++E m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
-            ++E Tm:CartesianTensor(1,2,Integer):=m
-            ++E v:DirectProduct(2,Integer):=directProduct [3,4]
-            ++E Tv:CartesianTensor(1,2,Integer):=v
-            ++E Tm*Tv
+            ++X m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
+            ++X Tm:CartesianTensor(1,2,Integer):=m
+            ++X v:DirectProduct(2,Integer):=directProduct [3,4]
+            ++X Tv:CartesianTensor(1,2,Integer):=v
+            ++X Tm*Tv
 
         contract:  (%, Integer, %, Integer) -> %
             ++ contract(t,i,s,j) is the inner product of tenors s and t
@@ -1208,11 +1208,11 @@ CartesianTensor(minix, dim, R): Exports == Implementation where
             ++ the rank 4 \spad{(= 3 + 3 - 2)} tensor  given by
             ++     \spad{r(i,j,k,l) = sum(h=1..dim,s(i,h,j)*t(h,k,l))}.
             ++
-            ++E m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
-            ++E Tm:CartesianTensor(1,2,Integer):=m
-            ++E v:DirectProduct(2,Integer):=directProduct [3,4]
-            ++E Tv:CartesianTensor(1,2,Integer):=v
-            ++E Tmv:=contract(Tm,2,Tv,1)
+            ++X m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
+            ++X Tm:CartesianTensor(1,2,Integer):=m
+            ++X v:DirectProduct(2,Integer):=directProduct [3,4]
+            ++X Tv:CartesianTensor(1,2,Integer):=v
+            ++X Tmv:=contract(Tm,2,Tv,1)
 
         contract:  (%, Integer, Integer)    -> %
             ++ contract(t,i,j) is the contraction of tensor t which
@@ -1222,11 +1222,11 @@ CartesianTensor(minix, dim, R): Exports == Implementation where
             ++ \spad{r} is the rank 2 \spad{(= 4 - 2)} tensor given by
             ++     \spad{r(i,j) = sum(h=1..dim,t(h,i,h,j))}.
             ++
-            ++E m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
-            ++E Tm:CartesianTensor(1,2,Integer):=m
-            ++E v:DirectProduct(2,Integer):=directProduct [3,4]
-            ++E Tv:CartesianTensor(1,2,Integer):=v
-            ++E Tmv:=contract(Tm,2,1)
+            ++X m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
+            ++X Tm:CartesianTensor(1,2,Integer):=m
+            ++X v:DirectProduct(2,Integer):=directProduct [3,4]
+            ++X Tv:CartesianTensor(1,2,Integer):=v
+            ++X Tmv:=contract(Tm,2,1)
 
         transpose: % -> %
             ++ transpose(t) exchanges the first and last indices of t.
@@ -1234,9 +1234,9 @@ CartesianTensor(minix, dim, R): Exports == Implementation where
             ++ tensor t, then \spad{r} is the rank 4 tensor given by
             ++     \spad{r(i,j,k,l) = t(l,j,k,i)}.
             ++
-            ++E m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
-            ++E Tm:CartesianTensor(1,2,Integer):=m
-            ++E transpose(Tm)
+            ++X m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
+            ++X Tm:CartesianTensor(1,2,Integer):=m
+            ++X transpose(Tm)
 
         transpose: (%, Integer, Integer) -> %
             ++ transpose(t,i,j) exchanges the \spad{i}-th and \spad{j}-th 
@@ -1245,10 +1245,10 @@ CartesianTensor(minix, dim, R): Exports == Implementation where
             ++ given by
             ++     \spad{r(i,j,k,l) = t(i,k,j,l)}.
             ++
-            ++E m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
-            ++E tm:CartesianTensor(1,2,Integer):=m
-            ++E tn:CartesianTensor(1,2,Integer):=[tm,tm]
-            ++E transpose(tn,1,2)
+            ++X m:SquareMatrix(2,Integer):=matrix [[1,2],[4,5]]
+            ++X tm:CartesianTensor(1,2,Integer):=m
+            ++X tn:CartesianTensor(1,2,Integer):=[tm,tm]
+            ++X transpose(tn,1,2)
 
         reindex: (%, List Integer) -> %
             ++ reindex(t,[i1,...,idim]) permutes the indices of t.
@@ -1257,10 +1257,10 @@ CartesianTensor(minix, dim, R): Exports == Implementation where
             ++ then \spad{r} is the rank for tensor given by
             ++     \spad{r(i,j,k,l) = t(l,i,j,k)}.
             ++ 
-            ++E n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]]
-            ++E tn:CartesianTensor(1,2,Integer):=n
-            ++E p:=product(tn,tn)
-            ++E reindex(p,[4,3,2,1])
+            ++X n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]]
+            ++X tn:CartesianTensor(1,2,Integer):=n
+            ++X p:=product(tn,tn)
+            ++X reindex(p,[4,3,2,1])
  
         kroneckerDelta:  () -> %
             ++ kroneckerDelta() is the rank 2 tensor defined by
@@ -1268,7 +1268,7 @@ CartesianTensor(minix, dim, R): Exports == Implementation where
             ++       \spad{= 1  if i = j}
             ++       \spad{= 0 if  i \^= j}
             ++ 
-            ++E delta:CartesianTensor(1,2,Integer):=kroneckerDelta()
+            ++X delta:CartesianTensor(1,2,Integer):=kroneckerDelta()
 
         leviCivitaSymbol: () -> %
             ++ leviCivitaSymbol() is the rank \spad{dim} tensor defined by
@@ -1276,15 +1276,15 @@ CartesianTensor(minix, dim, R): Exports == Implementation where
             ++ if \spad{i1,...,idim} is an even/is nota /is an odd permutation
             ++ of \spad{minix,...,minix+dim-1}.
             ++ 
-            ++E lcs:CartesianTensor(1,2,Integer):=leviCivitaSymbol()
+            ++X lcs:CartesianTensor(1,2,Integer):=leviCivitaSymbol()
 
         ravel:     % -> List R
             ++ ravel(t) produces a list of components from a tensor such that
             ++   \spad{unravel(ravel(t)) = t}.
             ++ 
-            ++E n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]]
-            ++E tn:CartesianTensor(1,2,Integer):=n
-            ++E ravel tn
+            ++X n:SquareMatrix(2,Integer):=matrix [[2,3],[0,1]]
+            ++X tn:CartesianTensor(1,2,Integer):=n
+            ++X ravel tn
 
         unravel:   List R -> %
             ++ unravel(t) produces a tensor from a list of
diff --git a/src/algebra/curve.spad.pamphlet b/src/algebra/curve.spad.pamphlet
index 6128b6b..d0b44da 100644
--- a/src/algebra/curve.spad.pamphlet
+++ b/src/algebra/curve.spad.pamphlet
@@ -37,42 +37,42 @@ FunctionFieldCategory(F, UP, UPUP): Category == Definition where
       ++ numberOfComponents() returns the number of absolutely irreducible
       ++ components.
       ++
-      ++E P0 := UnivariatePolynomial(x, Integer)
-      ++E P1 := UnivariatePolynomial(y, Fraction P0)
-      ++E R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
-      ++E numberOfComponents()$R
+      ++X P0 := UnivariatePolynomial(x, Integer)
+      ++X P1 := UnivariatePolynomial(y, Fraction P0)
+      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
+      ++X numberOfComponents()$R
     genus                  : () -> NonNegativeInteger
       ++ genus() returns the genus of one absolutely irreducible component
       ++
-      ++E P0 := UnivariatePolynomial(x, Integer)
-      ++E P1 := UnivariatePolynomial(y, Fraction P0)
-      ++E R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
-      ++E genus()$R
+      ++X P0 := UnivariatePolynomial(x, Integer)
+      ++X P1 := UnivariatePolynomial(y, Fraction P0)
+      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
+      ++X genus()$R
     absolutelyIrreducible? : () -> Boolean
       ++ absolutelyIrreducible?() tests if the curve absolutely irreducible?
       ++
-      ++E P0 := UnivariatePolynomial(x, Integer)
-      ++E P1 := UnivariatePolynomial(y, Fraction P0)
-      ++E R2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4)
-      ++E absolutelyIrreducible?()$R2
+      ++X P0 := UnivariatePolynomial(x, Integer)
+      ++X P1 := UnivariatePolynomial(y, Fraction P0)
+      ++X R2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4)
+      ++X absolutelyIrreducible?()$R2
     rationalPoint?         : (F, F) -> Boolean
       ++ rationalPoint?(a, b) tests if \spad{(x=a,y=b)} is on the curve.
       ++
-      ++E P0 := UnivariatePolynomial(x, Integer)
-      ++E P1 := UnivariatePolynomial(y, Fraction P0)
-      ++E R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
-      ++E rationalPoint?(0,0)$R
-      ++E R2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4)
-      ++E rationalPoint?(0,0)$R2
+      ++X P0 := UnivariatePolynomial(x, Integer)
+      ++X P1 := UnivariatePolynomial(y, Fraction P0)
+      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
+      ++X rationalPoint?(0,0)$R
+      ++X R2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4)
+      ++X rationalPoint?(0,0)$R2
     branchPointAtInfinity? : () -> Boolean
       ++ branchPointAtInfinity?() tests if there is a branch point at infinity.
       ++
-      ++E P0 := UnivariatePolynomial(x, Integer)
-      ++E P1 := UnivariatePolynomial(y, Fraction P0)
-      ++E R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
-      ++E branchPointAtInfinity?()$R
-      ++E R2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4)
-      ++E branchPointAtInfinity?()$R
+      ++X P0 := UnivariatePolynomial(x, Integer)
+      ++X P1 := UnivariatePolynomial(y, Fraction P0)
+      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
+      ++X branchPointAtInfinity?()$R
+      ++X R2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4)
+      ++X branchPointAtInfinity?()$R
     branchPoint?           : F -> Boolean
       ++ branchPoint?(a) tests whether \spad{x = a} is a branch point.
     branchPoint?           : UP -> Boolean
@@ -92,17 +92,17 @@ FunctionFieldCategory(F, UP, UPUP): Category == Definition where
     integralBasis          : () -> Vector $
       ++ integralBasis() returns the integral basis for the curve.
       ++
-      ++E P0 := UnivariatePolynomial(x, Integer)
-      ++E P1 := UnivariatePolynomial(y, Fraction P0)
-      ++E R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
-      ++E integralBasis()$R
+      ++X P0 := UnivariatePolynomial(x, Integer)
+      ++X P1 := UnivariatePolynomial(y, Fraction P0)
+      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
+      ++X integralBasis()$R
     integralBasisAtInfinity: () -> Vector $
       ++ integralBasisAtInfinity() returns the local integral basis at infinity
       ++
-      ++E P0 := UnivariatePolynomial(x, Integer)
-      ++E P1 := UnivariatePolynomial(y, Fraction P0)
-      ++E R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
-      ++E integralBasisAtInfinity()$R
+      ++X P0 := UnivariatePolynomial(x, Integer)
+      ++X P1 := UnivariatePolynomial(y, Fraction P0)
+      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
+      ++X integralBasisAtInfinity()$R
     integralAtInfinity?    : $  -> Boolean
       ++ integralAtInfinity?() tests if f is locally integral at infinity.
     integral?              : $  -> Boolean
@@ -121,40 +121,40 @@ FunctionFieldCategory(F, UP, UPUP): Category == Definition where
       ++ where \spad{(w1,...,wn)} is the integral basis of
       ++ \spadfunFrom{integralBasis}{FunctionFieldCategory}.
       ++
-      ++E P0 := UnivariatePolynomial(x, Integer)
-      ++E P1 := UnivariatePolynomial(y, Fraction P0)
-      ++E R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
-      ++E integralMatrix()$R
+      ++X P0 := UnivariatePolynomial(x, Integer)
+      ++X P1 := UnivariatePolynomial(y, Fraction P0)
+      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
+      ++X integralMatrix()$R
     inverseIntegralMatrix  : () -> Matrix RF
       ++ inverseIntegralMatrix() returns M such that
       ++ \spad{M (w1,...,wn) = (1, y, ..., y**(n-1))}
       ++ where \spad{(w1,...,wn)} is the integral basis of
       ++ \spadfunFrom{integralBasis}{FunctionFieldCategory}.
       ++
-      ++E P0 := UnivariatePolynomial(x, Integer)
-      ++E P1 := UnivariatePolynomial(y, Fraction P0)
-      ++E R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
-      ++E inverseIntegralMatrix()$R
+      ++X P0 := UnivariatePolynomial(x, Integer)
+      ++X P1 := UnivariatePolynomial(y, Fraction P0)
+      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
+      ++X inverseIntegralMatrix()$R
     integralMatrixAtInfinity       : () -> Matrix RF
       ++ integralMatrixAtInfinity() returns M such that
       ++ \spad{(v1,...,vn) = M (1, y, ..., y**(n-1))}
       ++ where \spad{(v1,...,vn)} is the local integral basis at infinity
       ++ returned by \spad{infIntBasis()}.
       ++
-      ++E P0 := UnivariatePolynomial(x, Integer)
-      ++E P1 := UnivariatePolynomial(y, Fraction P0)
-      ++E R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
-      ++E integralMatrixAtInfinity()$R
+      ++X P0 := UnivariatePolynomial(x, Integer)
+      ++X P1 := UnivariatePolynomial(y, Fraction P0)
+      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
+      ++X integralMatrixAtInfinity()$R
     inverseIntegralMatrixAtInfinity: () -> Matrix RF
       ++ inverseIntegralMatrixAtInfinity() returns M such
       ++ that \spad{M (v1,...,vn) = (1, y, ..., y**(n-1))}
       ++ where \spad{(v1,...,vn)} is the local integral basis at infinity
       ++ returned by \spad{infIntBasis()}.
       ++
-      ++E P0 := UnivariatePolynomial(x, Integer)
-      ++E P1 := UnivariatePolynomial(y, Fraction P0)
-      ++E R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
-      ++E inverseIntegralMatrixAtInfinity()$R
+      ++X P0 := UnivariatePolynomial(x, Integer)
+      ++X P1 := UnivariatePolynomial(y, Fraction P0)
+      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
+      ++X inverseIntegralMatrixAtInfinity()$R
     yCoordinates           : $ -> Record(num:Vector(UP), den:UP)
       ++ yCoordinates(f) returns \spad{[[A1,...,An], D]} such that
       ++ \spad{f = (A1 + A2 y +...+ An y**(n-1)) / D}.
diff --git a/src/algebra/fr.spad.pamphlet b/src/algebra/fr.spad.pamphlet
index 8c4c8f0..d03f159 100644
--- a/src/algebra/fr.spad.pamphlet
+++ b/src/algebra/fr.spad.pamphlet
@@ -675,38 +675,38 @@ Factored(R: IntegralDomain): Exports == Implementation where
     ++ \spadfun{coerce} which would cause the interpreter to do this 
     ++ automatically.
     ++
-    ++E f:=nilFactor(y-x,3)
-    ++E expand(f)
+    ++X f:=nilFactor(y-x,3)
+    ++X expand(f)
 
    exponent:  % -> Integer
     ++ exponent(u) returns the exponent of the first factor of
     ++ \spadvar{u}, or 0 if the factored form consists solely of a unit.
     ++
-    ++E f:=nilFactor(y-x,3)
-    ++E exponent(f)
+    ++X f:=nilFactor(y-x,3)
+    ++X exponent(f)
 
    makeFR  : (R, List FF) -> %
     ++ makeFR(unit,listOfFactors) creates a factored object (for
     ++ use by factoring code).
     ++
-    ++E f:=nilFactor(x-y,3)
-    ++E g:=factorList f
-    ++E makeFR(z,g)
+    ++X f:=nilFactor(x-y,3)
+    ++X g:=factorList f
+    ++X makeFR(z,g)
 
    factorList : % -> List FF
     ++ factorList(u) returns the list of factors with flags (for
     ++ use by factoring code).
     ++
-    ++E f:=nilFactor(x-y,3)
-    ++E factorList f
+    ++X f:=nilFactor(x-y,3)
+    ++X factorList f
 
    nilFactor: (R, Integer) -> %
     ++ nilFactor(base,exponent) creates a factored object with
     ++ a single factor with no information about the kind of
     ++ base (flag = "nil").
     ++
-    ++E nilFactor(24,2)
-    ++E nilFactor(x-y,3)
+    ++X nilFactor(24,2)
+    ++X nilFactor(x-y,3)
 
    factors: % -> List Record(factor:R, exponent:Integer)
     ++ factors(u) returns a list of the factors in a form suitable
@@ -715,26 +715,26 @@ Factored(R: IntegralDomain): Exports == Implementation where
     ++ object is the product of all the factors and the unit (which
     ++ can be extracted by \axiom{unit(u)}).
     ++
-    ++E f:=x*y^3-3*x^2*y^2+3*x^3*y-x^4
-    ++E factors f
-    ++E g:=makeFR(z,factorList f)
-    ++E factors g
+    ++X f:=x*y^3-3*x^2*y^2+3*x^3*y-x^4
+    ++X factors f
+    ++X g:=makeFR(z,factorList f)
+    ++X factors g
 
    irreducibleFactor: (R, Integer) -> %
     ++ irreducibleFactor(base,exponent) creates a factored object with
     ++ a single factor whose base is asserted to be irreducible
     ++ (flag = "irred").
     ++
-    ++E a:=irreducibleFactor(3,1)
-    ++E nthFlag(a,1)
+    ++X a:=irreducibleFactor(3,1)
+    ++X nthFlag(a,1)
 
    nthExponent: (%, Integer) -> Integer
     ++ nthExponent(u,n) returns the exponent of the nth factor of
     ++ \spadvar{u}.  If \spadvar{n} is not a valid index for a factor
     ++ (for example, less than 1 or too big), 0 is returned.
     ++
-    ++E a:=factor 9720000
-    ++E nthExponent(a,2)
+    ++X a:=factor 9720000
+    ++X nthExponent(a,2)
 
    nthFactor:  (%,Integer) -> R
     ++ nthFactor(u,n) returns the base of the nth factor of
@@ -742,38 +742,38 @@ Factored(R: IntegralDomain): Exports == Implementation where
     ++ (for example, less than 1 or too big), 1 is returned.  If
     ++ \spadvar{u} consists only of a unit, the unit is returned.
     ++
-    ++E a:=factor 9720000
-    ++E nthFactor(a,2)
+    ++X a:=factor 9720000
+    ++X nthFactor(a,2)
 
    nthFlag:    (%,Integer) -> fUnion
     ++ nthFlag(u,n) returns the information flag of the nth factor of
     ++ \spadvar{u}.  If \spadvar{n} is not a valid index for a factor
     ++ (for example, less than 1 or too big), "nil" is returned.
     ++
-    ++E a:=factor 9720000
-    ++E nthFlag(a,2)
+    ++X a:=factor 9720000
+    ++X nthFlag(a,2)
 
    numberOfFactors : %  -> NonNegativeInteger
     ++ numberOfFactors(u) returns the number of factors in \spadvar{u}.
     ++
-    ++E a:=factor 9720000
-    ++E numberOfFactors a
+    ++X a:=factor 9720000
+    ++X numberOfFactors a
 
    primeFactor:   (R,Integer) -> %
     ++ primeFactor(base,exponent) creates a factored object with
     ++ a single factor whose base is asserted to be prime
     ++ (flag = "prime").
     ++
-    ++E a:=primeFactor(3,4)
-    ++E nthFlag(a,1)
+    ++X a:=primeFactor(3,4)
+    ++X nthFlag(a,1)
 
    sqfrFactor:   (R,Integer) -> %
     ++ sqfrFactor(base,exponent) creates a factored object with
     ++ a single factor whose base is asserted to be square-free
     ++ (flag = "sqfr").
     ++
-    ++E a:=sqfrFactor(3,5)
-    ++E nthFlag(a,1)
+    ++X a:=sqfrFactor(3,5)
+    ++X nthFlag(a,1)
 
    flagFactor: (R,Integer, fUnion) -> %
     ++ flagFactor(base,exponent,flag) creates a factored object with
@@ -783,10 +783,10 @@ Factored(R: IntegralDomain): Exports == Implementation where
    unit:    % -> R
     ++ unit(u) extracts the unit part of the factorization.
     ++
-    ++E f:=x*y^3-3*x^2*y^2+3*x^3*y-x^4
-    ++E unit f
-    ++E g:=makeFR(z,factorList f)
-    ++E unit g
+    ++X f:=x*y^3-3*x^2*y^2+3*x^3*y-x^4
+    ++X unit f
+    ++X g:=makeFR(z,factorList f)
+    ++X unit g
 
    unitNormalize: % -> %
     ++ unitNormalize(u) normalizes the unit part of the factorization.
@@ -799,11 +799,11 @@ Factored(R: IntegralDomain): Exports == Implementation where
     ++ the information flags (sets them to "nil") because the effect of
     ++ \userfun{fn} is clearly not known in general.
     ++
-    ++E m(a:Factored Polynomial Integer):Factored Polynomial Integer == a^2
-    ++E f:=x*y^3-3*x^2*y^2+3*x^3*y-x^4
-    ++E map(m,f)
-    ++E g:=makeFR(z,factorList f)
-    ++E map(m,g)
+    ++X m(a:Factored Polynomial Integer):Factored Polynomial Integer == a^2
+    ++X f:=x*y^3-3*x^2*y^2+3*x^3*y-x^4
+    ++X map(m,f)
+    ++X g:=makeFR(z,factorList f)
+    ++X map(m,g)
 
     -- the following operations are conditional on R
 
diff --git a/src/algebra/listgcd.spad.pamphlet b/src/algebra/listgcd.spad.pamphlet
index 8cbcebe..8c74a22 100644
--- a/src/algebra/listgcd.spad.pamphlet
+++ b/src/algebra/listgcd.spad.pamphlet
@@ -35,8 +35,8 @@ HeuGcd (BP):C == T
      gcd          : List BP  -> BP
        ++ gcd([f1,..,fk]) = gcd of the polynomials fi.
        ++
-       ++E gcd([671*671*x^2-1,671*671*x^2+2*671*x+1])
-       ++E gcd([7*x^2+1,(7*x^2+1)^2])
+       ++X gcd([671*671*x^2-1,671*671*x^2+2*671*x+1])
+       ++X gcd([7*x^2+1,(7*x^2+1)^2])
 
      gcdprim      : List BP  -> BP
        ++ gcdprim([f1,..,fk]) = gcd of k PRIMITIVE univariate polynomials
diff --git a/src/algebra/mappkg.spad.pamphlet b/src/algebra/mappkg.spad.pamphlet
index ca1dc5f..030d679 100644
--- a/src/algebra/mappkg.spad.pamphlet
+++ b/src/algebra/mappkg.spad.pamphlet
@@ -1783,28 +1783,28 @@ MappingPackage4(A:SetCategory, B:Ring):
    "+": (A->B, A->B) -> (A->B) 
         ++ \spad(+) does functional addition
         ++
-        ++E f:=(x:INT):INT +-> 3*x
-        ++E g:=(x:INT):INT +-> 2*x+3
-        ++E (f+g)(4)
+        ++X f:=(x:INT):INT +-> 3*x
+        ++X g:=(x:INT):INT +-> 2*x+3
+        ++X (f+g)(4)
    "-": (A->B, A->B) -> (A->B) 
         ++ \spad(+) does functional addition
         ++
-        ++E f:=(x:INT):INT +-> 3*x
-        ++E g:=(x:INT):INT +-> 2*x+3
-        ++E (f-g)(4)
+        ++X f:=(x:INT):INT +-> 3*x
+        ++X g:=(x:INT):INT +-> 2*x+3
+        ++X (f-g)(4)
    "*": (A->B, A->B) -> (A->B) 
         ++ \spad(+) does functional addition
         ++
-        ++E f:=(x:INT):INT +-> 3*x
-        ++E g:=(x:INT):INT +-> 2*x+3
-        ++E (f*g)(4)
+        ++X f:=(x:INT):INT +-> 3*x
+        ++X g:=(x:INT):INT +-> 2*x+3
+        ++X (f*g)(4)
    "/": (A->Expression(Integer), A->Expression(Integer)) -> (A->Expression(Integer))
         ++ \spad(+) does functional addition
         ++
-        ++E p:=(x:EXPR(INT)):EXPR(INT)+->3*x
-        ++E q:=(x:EXPR(INT)):EXPR(INT)+->2*x+3
-        ++E (p/q)(4)
-        ++E (p/q)(x)
+        ++X p:=(x:EXPR(INT)):EXPR(INT)+->3*x
+        ++X q:=(x:EXPR(INT)):EXPR(INT)+->2*x+3
+        ++X (p/q)(4)
+        ++X (p/q)(x)
   == add
     fab ==> (A -> B)
     faei ==> (A -> Expression(Integer))
diff --git a/src/algebra/mkfunc.spad.pamphlet b/src/algebra/mkfunc.spad.pamphlet
index 840aa2e..6a34b58 100644
--- a/src/algebra/mkfunc.spad.pamphlet
+++ b/src/algebra/mkfunc.spad.pamphlet
@@ -34,8 +34,8 @@ InputForm():
       ++ \spad{binary(op, [a1,...,an])} returns the input form
       ++ corresponding to  \spad{a1 op a2 op ... op an}.
       ++
-      ++E a:=[1,2,3]::List(InputForm)
-      ++E binary(_+::InputForm,a)
+      ++X a:=[1,2,3]::List(InputForm)
+      ++X binary(_+::InputForm,a)
 
     function : (%, List Symbol, Symbol) -> %
       ++ \spad{function(code, [x1,...,xn], f)} returns the input form
diff --git a/src/algebra/plot.spad.pamphlet b/src/algebra/plot.spad.pamphlet
index 81c4846..4c9ed69 100644
--- a/src/algebra/plot.spad.pamphlet
+++ b/src/algebra/plot.spad.pamphlet
@@ -146,8 +146,8 @@ Plot(): Exports == Implementation where
       ++ plot(f,a..b) plots the function \spad{f(x)} 
       ++ on the interval \spad{[a,b]}.
       ++ 
-      ++E fp:=(t:DFLOAT):DFLOAT +-> sin(t)
-      ++E plot(fp,-1.0..1.0)$PLOT
+      ++X fp:=(t:DFLOAT):DFLOAT +-> sin(t)
+      ++X plot(fp,-1.0..1.0)$PLOT
 
     plot: (F -> F,R,R) -> %
       ++ plot(f,a..b,c..d) plots the function \spad{f(x)} on the interval
diff --git a/src/algebra/radix.spad.pamphlet b/src/algebra/radix.spad.pamphlet
index 28185f1..06bb6b8 100644
--- a/src/algebra/radix.spad.pamphlet
+++ b/src/algebra/radix.spad.pamphlet
@@ -724,7 +724,7 @@ BinaryExpansion(): Exports == Implementation where
     binary: Fraction Integer -> %
       ++ binary(r) converts a rational number to a binary expansion.
       ++
-      ++E binary(22/7)
+      ++X binary(22/7)
 
   Implementation ==> RadixExpansion(2) add
     binary r == r :: %
diff --git a/src/algebra/stream.spad.pamphlet b/src/algebra/stream.spad.pamphlet
index d69cbfb..e30e3b4 100644
--- a/src/algebra/stream.spad.pamphlet
+++ b/src/algebra/stream.spad.pamphlet
@@ -30,40 +30,40 @@ LazyStreamAggregate(S:Type): Category == StreamAggregate(S) with
     ++ st which do not satisfy the predicate f.
     ++ Note: \spad{remove(f,st) = [x for x in st | not f(x)]}.
     ++
-    ++E m:=[i for i in 1..]
-    ++E f(i:PositiveInteger):Boolean == even? i
-    ++E remove(f,m)
+    ++X m:=[i for i in 1..]
+    ++X f(i:PositiveInteger):Boolean == even? i
+    ++X remove(f,m)
 
   select: (S -> Boolean,%) -> %
     ++ select(f,st) returns a stream consisting of those elements of stream
     ++ st satisfying the predicate f.
     ++ Note: \spad{select(f,st) = [x for x in st | f(x)]}.
     ++
-    ++E m:=[i for i in 0..]
-    ++E select(x+->prime? x,m)
+    ++X m:=[i for i in 0..]
+    ++X select(x+->prime? x,m)
 
   explicitEntries?: % -> Boolean
     ++ explicitEntries?(s) returns true if the stream s has
     ++ explicitly computed entries, and false otherwise.
     ++
-    ++E m:=[i for i in 0..]
-    ++E explicitEntries? m
+    ++X m:=[i for i in 0..]
+    ++X explicitEntries? m
 
   explicitlyEmpty?: % -> Boolean
     ++ explicitlyEmpty?(s) returns true if the stream is an
     ++ (explicitly) empty stream.
     ++ Note: this is a null test which will not cause lazy evaluation.
     ++
-    ++E m:=[i for i in 0..]
-    ++E explicitlyEmpty? m
+    ++X m:=[i for i in 0..]
+    ++X explicitlyEmpty? m
 
   lazy?: % -> Boolean
     ++ lazy?(s) returns true if the first node of the stream s
     ++ is a lazy evaluation mechanism which could produce an
     ++ additional entry to s.
     ++
-    ++E m:=[i for i in 0..]
-    ++E lazy? m
+    ++X m:=[i for i in 0..]
+    ++X lazy? m
 
   lazyEvaluate: % -> %
     ++ lazyEvaluate(s) causes one lazy evaluation of stream s.
@@ -76,24 +76,24 @@ LazyStreamAggregate(S:Type): Category == StreamAggregate(S) with
     ++ Caution: this function should only be called after a \spad{empty?} test
     ++ has been made since there no error check.
     ++
-    ++E m:=[i for i in 0..]
-    ++E frst m
+    ++X m:=[i for i in 0..]
+    ++X frst m
 
   rst: % -> %
     ++ rst(s) returns a pointer to the next node of stream s.
     ++ Caution: this function should only be called after a \spad{empty?} test
     ++ has been made since there no error check.
     ++
-    ++E m:=[i for i in 0..]
-    ++E rst m
+    ++X m:=[i for i in 0..]
+    ++X rst m
 
   numberOfComputedEntries: % -> NonNegativeInteger
     ++ numberOfComputedEntries(st) returns the number of explicitly
     ++ computed entries of stream st which exist immediately prior to the time
     ++ this function is called.
     ++
-    ++E m:=[i for i in 0..]
-    ++E numberOfComputedEntries m
+    ++X m:=[i for i in 0..]
+    ++X numberOfComputedEntries m
 
   extend: (%,Integer) -> %
     ++ extend(st,n) causes entries to be computed, if necessary,
@@ -101,21 +101,21 @@ LazyStreamAggregate(S:Type): Category == StreamAggregate(S) with
     ++ that all entries of 'st' will be computed if 'st' is finite
     ++ with length <= n.
     ++
-    ++E m:=[i for i in 0..]
-    ++E numberOfComputedEntries m
-    ++E extend(m,20)
-    ++E numberOfComputedEntries m
+    ++X m:=[i for i in 0..]
+    ++X numberOfComputedEntries m
+    ++X extend(m,20)
+    ++X numberOfComputedEntries m
 
   complete: % -> %
     ++ complete(st) causes all entries of 'st' to be computed.
     ++ this function should only be called on streams which are
     ++ known to be finite.
     ++
-    ++E m:=[i for i in 1..]
-    ++E n:=filterUntil(i+->i>100,m)
-    ++E numberOfComputedEntries n
-    ++E complete n
-    ++E numberOfComputedEntries n
+    ++X m:=[i for i in 1..]
+    ++X n:=filterUntil(i+->i>100,m)
+    ++X numberOfComputedEntries n
+    ++X complete n
+    ++X numberOfComputedEntries n
 
  add
 
@@ -551,29 +551,29 @@ CyclicStreamTools(S,ST): Exports == Implementation where
       ++ cycleElt(s) returns a pointer to a node in the cycle if the stream 
       ++ s is cyclic and returns "failed" if s is not cyclic
       ++
-      ++E p:=repeating([1,2,3])
-      ++E q:=cons(4,p)
-      ++E cycleElt q
-      ++E r:=[1,2,3]::Stream(Integer)
-      ++E cycleElt r
+      ++X p:=repeating([1,2,3])
+      ++X q:=cons(4,p)
+      ++X cycleElt q
+      ++X r:=[1,2,3]::Stream(Integer)
+      ++X cycleElt r
 
     computeCycleLength: ST -> NonNegativeInteger
       ++ computeCycleLength(s) returns the length of the cycle of a
       ++ cyclic stream t, where s is a pointer to a node in the
       ++ cyclic part of t.
       ++
-      ++E p:=repeating([1,2,3])
-      ++E q:=cons(4,p)
-      ++E computeCycleLength(cycleElt(q))
+      ++X p:=repeating([1,2,3])
+      ++X q:=cons(4,p)
+      ++X computeCycleLength(cycleElt(q))
 
     computeCycleEntry: (ST,ST) -> ST
       ++ computeCycleEntry(x,cycElt), where cycElt is a pointer to a
       ++ node in the cyclic part of the cyclic stream x, returns a
       ++ pointer to the first node in the cycle
       ++
-      ++E p:=repeating([1,2,3])
-      ++E q:=cons(4,p)
-      ++E computeCycleEntry(q,cycleElt(q))
+      ++X p:=repeating([1,2,3])
+      ++X q:=cons(4,p)
+      ++X computeCycleEntry(q,cycleElt(q))
 
   Implementation ==> add
 
@@ -817,31 +817,31 @@ Stream(S): Exports == Implementation where
     coerce: L S -> %
       ++ coerce(l) converts a list l to a stream.
       ++
-      ++E m:=[1,2,3,4,5,6,7,8,9,10,11,12]
-      ++E coerce(m)@Stream(Integer)
-      ++E m::Stream(Integer)
+      ++X m:=[1,2,3,4,5,6,7,8,9,10,11,12]
+      ++X coerce(m)@Stream(Integer)
+      ++X m::Stream(Integer)
 
     repeating: L S -> %
       ++ repeating(l) is a repeating stream whose period is the list l.
       ++
-      ++E m:=repeating([-1,0,1,2,3])
+      ++X m:=repeating([-1,0,1,2,3])
 
     if S has SetCategory then
       repeating?: (L S,%) -> B
         ++ repeating?(l,s) returns true if a stream s is periodic
         ++ with period l, and false otherwise.
         ++
-        ++E m:=[1,2,3]
-        ++E n:=repeating(m)
-        ++E repeating?(m,n)
+        ++X m:=[1,2,3]
+        ++X n:=repeating(m)
+        ++X repeating?(m,n)
 
     findCycle: (NNI,%) -> Record(cycle?: B, prefix: NNI, period: NNI)
       ++ findCycle(n,st) determines if st is periodic within n.
       ++
-      ++E m:=[1,2,3]
-      ++E n:=repeating(m)
-      ++E findCycle(3,n)
-      ++E findCycle(2,n)
+      ++X m:=[1,2,3]
+      ++X n:=repeating(m)
+      ++X findCycle(3,n)
+      ++X findCycle(2,n)
 
     delay: (() -> %) -> %
       ++ delay(f) creates a stream with a lazy evaluation defined by 
@@ -852,26 +852,26 @@ Stream(S): Exports == Implementation where
       ++ and whose \spad{rest} is s.
       ++ Note: \spad{cons(a,s) = concat(a,s)}.
       ++
-      ++E m:=[1,2,3]
-      ++E n:=repeating(m)
-      ++E cons(4,n)
+      ++X m:=[1,2,3]
+      ++X n:=repeating(m)
+      ++X cons(4,n)
 
     if S has SetCategory then
       output: (I, %) -> Void
         ++ output(n,st) computes and displays the first n entries
         ++ of st.
         ++
-        ++E m:=[1,2,3]
-        ++E n:=repeating(m)
-        ++E output(5,n)
+        ++X m:=[1,2,3]
+        ++X n:=repeating(m)
+        ++X output(5,n)
 
       showAllElements: % -> OUT
         ++ showAllElements(s) creates an output form which displays all
         ++ computed elements.
         ++
-        ++E m:=[1,2,3,4,5,6,7,8,9,10,11,12]
-        ++E n:=m::Stream(PositiveInteger)
-        ++E showAllElements n
+        ++X m:=[1,2,3,4,5,6,7,8,9,10,11,12]
+        ++X n:=m::Stream(PositiveInteger)
+        ++X showAllElements n
 
       showAll?: () -> B
         ++ showAll?() returns true if all computed entries of streams
@@ -881,44 +881,44 @@ Stream(S): Exports == Implementation where
       ++ setrest!(x,n,y) sets rest(x,n) to y. The function will expand
       ++ cycles if necessary.
       ++
-      ++E p:=[i for i in 1..]
-      ++E q:=[i for i in 9..]
-      ++E setrest!(p,4,q)
-      ++E p
+      ++X p:=[i for i in 1..]
+      ++X q:=[i for i in 9..]
+      ++X setrest!(p,4,q)
+      ++X p
 
     generate: (() -> S) -> %
       ++ generate(f) creates an infinite stream all of whose elements are
       ++ equal to \spad{f()}.
       ++ Note: \spad{generate(f) = [f(),f(),f(),...]}.
       ++
-      ++E f():Integer == 1
-      ++E generate(f)
+      ++X f():Integer == 1
+      ++X generate(f)
 
     generate: (S -> S,S) -> %
       ++ generate(f,x) creates an infinite stream whose first element is
       ++ x and whose nth element (\spad{n > 1}) is f applied to the previous
       ++ element. Note: \spad{generate(f,x) = [x,f(x),f(f(x)),...]}.
       ++
-      ++E f(x:Integer):Integer == x+10
-      ++E generate(f,10)
+      ++X f(x:Integer):Integer == x+10
+      ++X generate(f,10)
 
     filterWhile: (S -> Boolean,%) -> %
       ++ filterWhile(p,s) returns \spad{[x0,x1,...,x(n-1)]} where
       ++ \spad{s = [x0,x1,x2,..]} and
       ++ n is the smallest index such that \spad{p(xn) = false}.
       ++
-      ++E m:=[i for i in 1..]
-      ++E f(x:PositiveInteger):Boolean ==  x < 5
-      ++E filterWhile(f,m)
+      ++X m:=[i for i in 1..]
+      ++X f(x:PositiveInteger):Boolean ==  x < 5
+      ++X filterWhile(f,m)
 
     filterUntil: (S -> Boolean,%) -> %
       ++ filterUntil(p,s) returns \spad{[x0,x1,...,x(n)]} where
       ++ \spad{s = [x0,x1,x2,..]} and
       ++ n is the smallest index such that \spad{p(xn) = true}.
       ++
-      ++E m:=[i for i in 1..]
-      ++E f(x:PositiveInteger):Boolean ==  x < 5
-      ++E filterUntil(f,m)
+      ++X m:=[i for i in 1..]
+      ++X f(x:PositiveInteger):Boolean ==  x < 5
+      ++X filterUntil(f,m)
 
 --    if S has SetCategory then
 --      map: ((S,S) -> S,%,%,S) -> %
@@ -1446,10 +1446,10 @@ StreamFunctions1(S:Type): Exports == Implementation where
       ++ concat(u) returns the left-to-right concatentation of the 
       ++ streams in u. Note: \spad{concat(u) = reduce(concat,u)}.
       ++
-      ++E m:=[i for i in 10..]
-      ++E n:=[j for j in 1.. | prime? j]
-      ++E p:=[m,n]::Stream(Stream(PositiveInteger))
-      ++E concat(p)
+      ++X m:=[i for i in 10..]
+      ++X n:=[j for j in 1.. | prime? j]
+      ++X p:=[m,n]::Stream(Stream(PositiveInteger))
+      ++X concat(p)
 
   Implementation ==> add
 
@@ -1476,9 +1476,9 @@ StreamFunctions2(A:Type,B:Type): Exports == Implementation where
       ++ to the corresponding elements of s.
       ++ Note: \spad{map(f,[x0,x1,x2,...]) = [f(x0),f(x1),f(x2),..]}.
       ++
-      ++E m:=[i for i in 1..]
-      ++E f(i:PositiveInteger):PositiveInteger==i**2
-      ++E map(f,m)
+      ++X m:=[i for i in 1..]
+      ++X f(i:PositiveInteger):PositiveInteger==i**2
+      ++X map(f,m)
 
     scan: (B,((A,B) -> B),ST A) -> ST B
       ++ scan(b,h,[x0,x1,x2,...]) returns \spad{[y0,y1,y2,...]}, where
@@ -1486,9 +1486,9 @@ StreamFunctions2(A:Type,B:Type): Exports == Implementation where
       ++ \spad{y1 = h(x1,y0)},\spad{...}
       ++ \spad{yn = h(xn,y(n-1))}.
       ++
-      ++E m:=[i for i in 1..]::Stream(Integer)
-      ++E f(i:Integer,j:Integer):Integer==i+j
-      ++E scan(1,f,m)
+      ++X m:=[i for i in 1..]::Stream(Integer)
+      ++X f(i:Integer,j:Integer):Integer==i+j
+      ++X scan(1,f,m)
 
     reduce:  (B,(A,B) -> B,ST A) -> B
       ++ reduce(b,f,u), where u is a finite stream \spad{[x0,x1,...,xn]},
@@ -1497,9 +1497,9 @@ StreamFunctions2(A:Type,B:Type): Exports == Implementation where
       ++ r1 = f(x1,r0),...,
       ++ r(n) = f(xn,r(n-1))}.
       ++
-      ++E m:=[i for i in 1..300]::Stream(Integer)
-      ++E f(i:Integer,j:Integer):Integer==i+j
-      ++E reduce(1,f,m)
+      ++X m:=[i for i in 1..300]::Stream(Integer)
+      ++X f(i:Integer,j:Integer):Integer==i+j
+      ++X reduce(1,f,m)
 
 --  rreduce: (B,(A,B) -> B,ST A) -> B
 --    ++ reduce(b,h,[x0,x1,..,xn]) = h(x1,h(x2(..,h(x(n-1),h(xn,b))..)
@@ -1554,10 +1554,10 @@ StreamFunctions3(A,B,C): Exports == Implementation where
       ++ \spad{map(f,[x0,x1,x2,..],[y0,y1,y2,..]) = [f(x0,y0),f(x1,y1),..]}.
       ++
       ++S
-      ++E m:=[i for i in 1..]::Stream(Integer)
-      ++E n:=[i for i in 1..]::Stream(Integer)
-      ++E f(i:Integer,j:Integer):Integer == i+j
-      ++E map(f,m,n)
+      ++X m:=[i for i in 1..]::Stream(Integer)
+      ++X n:=[i for i in 1..]::Stream(Integer)
+      ++X f(i:Integer,j:Integer):Integer == i+j
+      ++X map(f,m,n)
 
   Implementation ==> add
 
diff --git a/src/algebra/string.spad.pamphlet b/src/algebra/string.spad.pamphlet
index 9cae78b..8ee1e1b 100644
--- a/src/algebra/string.spad.pamphlet
+++ b/src/algebra/string.spad.pamphlet
@@ -232,81 +232,81 @@ Character: OrderedFinite() with
     ++ ord(c) provides an integral code corresponding to the
     ++ character c.  It is always true that \spad{char ord c = c}.
     ++
-    ++E chars := [char "a", char "A", char "X", char "8", char "+"]
-    ++E [ord c for c in chars]
+    ++X chars := [char "a", char "A", char "X", char "8", char "+"]
+    ++X [ord c for c in chars]
   char: Integer  -> %
     ++ char(i) provides a character corresponding to the integer
     ++ code i. It is always true that \spad{ord char i = i}.
     ++
-    ++E [char c for c in [97,65,88,56,43]]
+    ++X [char c for c in [97,65,88,56,43]]
   char: String   -> %
     ++ char(s) provides a character from a string s of length one.
     ++
-    ++E [char c for c in ["a","A","X","8","+"]]
+    ++X [char c for c in ["a","A","X","8","+"]]
   space: () -> %
     ++ space() provides the blank character.
     ++
-    ++E space()
+    ++X space()
   quote: () -> %
     ++ quote() provides the string quote character, \spad{"}.
     ++
-    ++E quote()
+    ++X quote()
   escape: () -> %
     ++ escape() provides the escape character, \spad{_}, which
     ++ is used to allow quotes and other characters {\em within}
     ++ strings.
     ++
-    ++E escape()
+    ++X escape()
   upperCase: % -> %
     ++ upperCase(c) converts a lower case letter to the corresponding
     ++ upper case letter.  If c is not a lower case letter, then
     ++ it is returned unchanged.
     ++
-    ++E chars := [char "a", char "A", char "X", char "8", char "+"]
-    ++E [upperCase c for c in chars]
+    ++X chars := [char "a", char "A", char "X", char "8", char "+"]
+    ++X [upperCase c for c in chars]
   lowerCase: % -> %
     ++ lowerCase(c) converts an upper case letter to the corresponding
     ++ lower case letter.  If c is not an upper case letter, then
     ++ it is returned unchanged.
     ++
-    ++E chars := [char "a", char "A", char "X", char "8", char "+"]
-    ++E [lowerCase c for c in chars]
+    ++X chars := [char "a", char "A", char "X", char "8", char "+"]
+    ++X [lowerCase c for c in chars]
   digit?: % -> Boolean
     ++ digit?(c) tests if c is a digit character,
     ++ i.e. one of 0..9.
     ++
-    ++E chars := [char "a", char "A", char "X", char "8", char "+"]
-    ++E [digit? c for c in chars]
+    ++X chars := [char "a", char "A", char "X", char "8", char "+"]
+    ++X [digit? c for c in chars]
   hexDigit?: % -> Boolean
     ++ hexDigit?(c) tests if c is a hexadecimal numeral,
     ++ i.e. one of 0..9, a..f or A..F.
     ++
-    ++E chars := [char "a", char "A", char "X", char "8", char "+"]
-    ++E [hexDigit? c for c in chars]
+    ++X chars := [char "a", char "A", char "X", char "8", char "+"]
+    ++X [hexDigit? c for c in chars]
   alphabetic?: % -> Boolean
     ++ alphabetic?(c) tests if c is a letter,
     ++ i.e. one of a..z or A..Z.
     ++
-    ++E chars := [char "a", char "A", char "X", char "8", char "+"]
-    ++E [alphabetic? c for c in chars]
+    ++X chars := [char "a", char "A", char "X", char "8", char "+"]
+    ++X [alphabetic? c for c in chars]
   upperCase?: % -> Boolean
     ++ upperCase?(c) tests if c is an upper case letter,
     ++ i.e. one of A..Z.
     ++
-    ++E chars := [char "a", char "A", char "X", char "8", char "+"]
-    ++E [upperCase? c for c in chars]
+    ++X chars := [char "a", char "A", char "X", char "8", char "+"]
+    ++X [upperCase? c for c in chars]
   lowerCase?: % -> Boolean
     ++ lowerCase?(c) tests if c is an lower case letter,
     ++ i.e. one of a..z.
     ++
-    ++E chars := [char "a", char "A", char "X", char "8", char "+"]
-    ++E [lowerCase? c for c in chars]
+    ++X chars := [char "a", char "A", char "X", char "8", char "+"]
+    ++X [lowerCase? c for c in chars]
   alphanumeric?: % -> Boolean
     ++ alphanumeric?(c) tests if c is either a letter or number,
     ++ i.e. one of 0..9, a..z or A..Z.
     ++
-    ++E chars := [char "a", char "A", char "X", char "8", char "+"]
-    ++E [alphanumeric? c for c in chars]
+    ++X chars := [char "a", char "A", char "X", char "8", char "+"]
+    ++X [alphanumeric? c for c in chars]
 
  == add
 
diff --git a/src/algebra/tree.spad.pamphlet b/src/algebra/tree.spad.pamphlet
index 0a208e0..ab2e87d 100644
--- a/src/algebra/tree.spad.pamphlet
+++ b/src/algebra/tree.spad.pamphlet
@@ -32,50 +32,50 @@ Tree(S: SetCategory): T==C where
      tree: (S,List %) -> %
        ++ tree(nd,ls) creates a tree with value nd, and children ls.
        ++
-       ++E t1:=tree [1,2,3,4]
-       ++E tree(5,[t1])
+       ++X t1:=tree [1,2,3,4]
+       ++X tree(5,[t1])
 
      tree: List S -> %
        ++ tree(ls) creates a tree from a list of elements of s. 
        ++
-       ++E tree [1,2,3,4]
+       ++X tree [1,2,3,4]
 
      tree: S -> %
        ++ tree(nd) creates a tree with value nd, and no children
        ++
-       ++E tree 6
+       ++X tree 6
 
      cyclic?: % -> Boolean
        ++ cyclic?(t) tests if t is a cyclic tree.
        ++
-       ++E t1:=tree [1,2,3,4]
-       ++E cyclic? t1
+       ++X t1:=tree [1,2,3,4]
+       ++X cyclic? t1
 
      cyclicCopy: % -> %
        ++ cyclicCopy(l) makes a copy of a (possibly) cyclic tree l.
        ++
-       ++E t1:=tree [1,2,3,4]
-       ++E cyclicCopy t1
+       ++X t1:=tree [1,2,3,4]
+       ++X cyclicCopy t1
 
      cyclicEntries:    % -> List %
        ++ cyclicEntries(t) returns a list of top-level cycles in tree t.
        ++
-       ++E t1:=tree [1,2,3,4]
-       ++E cyclicEntries t1
+       ++X t1:=tree [1,2,3,4]
+       ++X cyclicEntries t1
 
      cyclicEqual?: (%, %) -> Boolean
        ++ cyclicEqual?(t1, t2) tests of two cyclic trees have 
        ++ the same structure.
        ++
-       ++E t1:=tree [1,2,3,4]
-       ++E t2:=tree [1,2,3,4]
-       ++E cyclicEqual?(t1,t2)
+       ++X t1:=tree [1,2,3,4]
+       ++X t2:=tree [1,2,3,4]
+       ++X cyclicEqual?(t1,t2)
 
      cyclicParents: % -> List %
        ++ cyclicParents(t) returns a list of cycles that are parents of t.
        ++
-       ++E t1:=tree [1,2,3,4]
-       ++E cyclicParents t1
+       ++X t1:=tree [1,2,3,4]
+       ++X cyclicParents t1
 
  C== add
     cycleTreeMax ==> 5
@@ -407,15 +407,15 @@ BinaryTree(S: SetCategory): Exports == Implementation where
     ++ binaryTree(v) is an non-empty binary tree
     ++ with value v, and left and right empty.
     ++
-    ++E t1:=binaryTree([1,2,3])
+    ++X t1:=binaryTree([1,2,3])
     
    binaryTree: (%,S,%) -> %    
     ++ binaryTree(l,v,r) creates a binary tree with
     ++ value v with left subtree l and right subtree r.
     ++
-    ++E t1:=binaryTree([1,2,3])
-    ++E t2:=binaryTree([4,5,6])
-    ++E binaryTree(t1,[7,8,9],t2)
+    ++X t1:=binaryTree([1,2,3])
+    ++X t2:=binaryTree([4,5,6])
+    ++X binaryTree(t1,[7,8,9],t2)
     
   Implementation == add
      Rep := List Tree S
@@ -669,26 +669,26 @@ BinarySearchTree(S: OrderedSet): Exports == Implementation where
     binarySearchTree: List S -> %
      ++ binarySearchTree(l) \undocumented
      ++
-     ++E binarySearchTree [1,2,3,4]
+     ++X binarySearchTree [1,2,3,4]
 
     insert_!: (S,%) -> %
      ++ insert!(x,b) inserts element x as leaves into binary search tree b.
      ++
-     ++E t1:=binarySearchTree [1,2,3,4]
-     ++E insert!(5,t1)
+     ++X t1:=binarySearchTree [1,2,3,4]
+     ++X insert!(5,t1)
 
     insertRoot_!: (S,%) -> %
      ++ insertRoot!(x,b) inserts element x as a root of binary search tree b.
      ++
-     ++E t1:=binarySearchTree [1,2,3,4]
-     ++E insertRoot!(5,t1)
+     ++X t1:=binarySearchTree [1,2,3,4]
+     ++X insertRoot!(5,t1)
 
     split:      (S,%) -> Record(less: %, greater: %)
      ++ split(x,b) splits binary tree b into two trees, one with elements 
      ++ greater than x, the other with elements less than x.
      ++
-     ++E t1:=binarySearchTree [1,2,3,4]
-     ++E split(3,t1)
+     ++X t1:=binarySearchTree [1,2,3,4]
+     ++X split(3,t1)
 
   Implementation == BinaryTree(S) add
     Rep := BinaryTree(S)
@@ -730,14 +730,14 @@ BinaryTournament(S: OrderedSet): Exports == Implementation where
       ++ binaryTournament(ls) creates a binary tournament with the
       ++ elements of ls as values at the nodes.
       ++
-      ++E binaryTournament [1,2,3,4]
+      ++X binaryTournament [1,2,3,4]
 
     insert_!: (S,%) -> %
       ++ insert!(x,b) inserts element x as leaves into binary tournament b.
       ++
-      ++E t1:=binaryTournament [1,2,3,4]
-      ++E insert!(5,t1)
-      ++E t1
+      ++X t1:=binaryTournament [1,2,3,4]
+      ++X insert!(5,t1)
+      ++X t1
 
   Implementation == BinaryTree(S) add
     Rep := BinaryTree(S)
@@ -970,14 +970,14 @@ BalancedBinaryTree(S: SetCategory): Exports == Implementation where
       ++ balancedBinaryTree(n, s) creates a balanced binary tree with
       ++ n nodes each with value s.
       ++
-      ++E balancedBinaryTree(4, 0)
+      ++X balancedBinaryTree(4, 0)
 
     setleaves_!: (%, List S) -> %
       ++ setleaves!(t, ls) sets the leaves of t in left-to-right order
       ++ to the elements of ls.
       ++
-      ++E t1:=balancedBinaryTree(4, 0)
-      ++E setleaves!(t1,[1,2,3,4])
+      ++X t1:=balancedBinaryTree(4, 0)
+      ++X setleaves!(t1,[1,2,3,4])
 
     mapUp_!: (%, (S,S) -> S) -> S
       ++ mapUp!(t,f) traverses balanced binary tree t in an "endorder"
@@ -986,12 +986,12 @@ BalancedBinaryTree(S: SetCategory): Exports == Implementation where
       ++ f(l,r) where l and r are the values at the immediate
       ++ left and right nodes.
       ++
-      ++E T1:=BalancedBinaryTree Integer
-      ++E t2:=balancedBinaryTree(4, 0)$T1
-      ++E setleaves!(t2,[1,2,3,4]::List(Integer))
-      ++E adder(a:Integer,b:Integer):Integer == a+b
-      ++E mapUp!(t2,adder)
-      ++E t2
+      ++X T1:=BalancedBinaryTree Integer
+      ++X t2:=balancedBinaryTree(4, 0)$T1
+      ++X setleaves!(t2,[1,2,3,4]::List(Integer))
+      ++X adder(a:Integer,b:Integer):Integer == a+b
+      ++X mapUp!(t2,adder)
+      ++X t2
 
     mapUp_!: (%, %, (S,S,S,S) -> S) -> %
       ++ mapUp!(t,t1,f) traverses balanced binary tree t in an "endorder"
@@ -1002,12 +1002,12 @@ BalancedBinaryTree(S: SetCategory): Exports == Implementation where
       ++ corresponding nodes of a balanced binary tree t1, of identical
       ++ shape at t.
       ++
-      ++E T1:=BalancedBinaryTree Integer
-      ++E t2:=balancedBinaryTree(4, 0)$T1
-      ++E setleaves!(t2,[1,2,3,4]::List(Integer))
-      ++E adder4(i:INT,j:INT,k:INT,l:INT):INT == i+j+k+l
-      ++E mapUp!(t2,t2,adder4)
-      ++E t2
+      ++X T1:=BalancedBinaryTree Integer
+      ++X t2:=balancedBinaryTree(4, 0)$T1
+      ++X setleaves!(t2,[1,2,3,4]::List(Integer))
+      ++X adder4(i:INT,j:INT,k:INT,l:INT):INT == i+j+k+l
+      ++X mapUp!(t2,t2,adder4)
+      ++X t2
 
     mapDown_!: (%,S,(S,S) -> S) -> %
       ++ mapDown!(t,p,f) returns t after traversing t in "preorder"
@@ -1017,12 +1017,12 @@ BalancedBinaryTree(S: SetCategory): Exports == Implementation where
       ++ mapDown!(r,q,f) are evaluated for the left and right subtrees
       ++ l and r of t.
       ++
-      ++E T1:=BalancedBinaryTree Integer
-      ++E t2:=balancedBinaryTree(4, 0)$T1
-      ++E setleaves!(t2,[1,2,3,4]::List(Integer))
-      ++E adder(i:Integer,j:Integer):Integer == i+j
-      ++E mapDown!(t2,4::INT,adder)
-      ++E t2
+      ++X T1:=BalancedBinaryTree Integer
+      ++X t2:=balancedBinaryTree(4, 0)$T1
+      ++X setleaves!(t2,[1,2,3,4]::List(Integer))
+      ++X adder(i:Integer,j:Integer):Integer == i+j
+      ++X mapDown!(t2,4::INT,adder)
+      ++X t2
 
     mapDown_!: (%,S, (S,S,S) -> List S) -> %
       ++ mapDown!(t,p,f) returns t after traversing t in "preorder"
@@ -1034,12 +1034,12 @@ BalancedBinaryTree(S: SetCategory): Exports == Implementation where
       ++ pl and pr. Then \spad{mapDown!(l,pl,f)} and \spad{mapDown!(l,pr,f)}
       ++ are evaluated.
       ++
-      ++E T1:=BalancedBinaryTree Integer
-      ++E t2:=balancedBinaryTree(4, 0)$T1
-      ++E setleaves!(t2,[1,2,3,4]::List(Integer))
-      ++E adder3(i:Integer,j:Integer,k:Integer):List Integer == [i+j,j+k]
-      ++E mapDown!(t2,4::INT,adder3)
-      ++E t2
+      ++X T1:=BalancedBinaryTree Integer
+      ++X t2:=balancedBinaryTree(4, 0)$T1
+      ++X setleaves!(t2,[1,2,3,4]::List(Integer))
+      ++X adder3(i:Integer,j:Integer,k:Integer):List Integer == [i+j,j+k]
+      ++X mapDown!(t2,4::INT,adder3)
+      ++X t2
 
   Implementation == BinaryTree(S) add
     Rep := BinaryTree(S)
@@ -1112,20 +1112,20 @@ PendantTree(S: SetCategory): T == C where
    ptree : S->%
     ++ ptree(s) is a leaf? pendant tree
     ++
-    ++E t1:=ptree([1,2,3])
+    ++X t1:=ptree([1,2,3])
        
    ptree:(%, %)->%
     ++ ptree(x,y) \undocumented
     ++
-    ++E t1:=ptree([1,2,3])
-    ++E ptree(t1,ptree([1,2,3]))
+    ++X t1:=ptree([1,2,3])
+    ++X ptree(t1,ptree([1,2,3]))
 
    coerce:%->Tree S
     ++ coerce(x) \undocumented
     ++
-    ++E t1:=ptree([1,2,3])
-    ++E t2:=ptree(t1,ptree([1,2,3]))
-    ++E t2::Tree List PositiveInteger
+    ++X t1:=ptree([1,2,3])
+    ++X t2:=ptree(t1,ptree([1,2,3]))
+    ++X t2::Tree List PositiveInteger
 
  C == add
      Rep := Tree S
diff --git a/src/interp/format.boot.pamphlet b/src/interp/format.boot.pamphlet
index 7dca247..de87ba6 100644
--- a/src/interp/format.boot.pamphlet
+++ b/src/interp/format.boot.pamphlet
@@ -253,7 +253,7 @@ reportOpSymbol op1 ==
 \subsection{sayExample}
 This function expects 2 arguments, the documentation string and
 the name of the operation. It searches the documentation string for
-\verb|++E| lines. These lines are examples lines for functions. 
+\verb|++X| lines. These lines are examples lines for functions. 
 They look like ordinary \verb|++| comments and fit into the ordinary
 comment blocks. So, for example, in the plot.spad.pamphlet file we
 find the following function signature:
@@ -262,34 +262,34 @@ find the following function signature:
       ++ plot(f,a..b) plots the function \spad{f(x)} 
       ++ on the interval \spad{[a,b]}.
       ++ 
-      ++E fp:=(t:DFLOAT):DFLOAT +-> sin(t)
-      ++E plot(fp,-1.0..1.0)$PLOT
+      ++X fp:=(t:DFLOAT):DFLOAT +-> sin(t)
+      ++X plot(fp,-1.0..1.0)$PLOT
 \end{verbatim}
-This function splits out and prints the lines that begin with \verb|++E|.
+This function splits out and prints the lines that begin with \verb|++X|.
 
 A minor complication of printing the examples is that the lines have
 been processed into internal compiler format. Thus the lines that read:
 \begin{verbatim}
-      ++E fp:=(t:DFLOAT):DFLOAT +-> sin(t)
-      ++E plot(fp,-1.0..1.0)$PLOT
+      ++X fp:=(t:DFLOAT):DFLOAT +-> sin(t)
+      ++X plot(fp,-1.0..1.0)$PLOT
 \end{verbatim}
 are actually stored as one long line containing the example lines
 \begin{verbatim}
 "\\indented{1}{plot(\\spad{f},{}a..\\spad{b}) plots the function
  \\spad{f(x)}} \\indented{1}{on the interval \\spad{[a,{}b]}.}
  \\blankline
- \\spad{E} fp:=(t:DFLOAT):DFLOAT +-> sin(\\spad{t})
- \\spad{E} plot(\\spad{fp},{}\\spad{-1}.0..1.0)\\$PLOT"
+ \\spad{X} fp:=(t:DFLOAT):DFLOAT +-> sin(\\spad{t})
+ \\spad{X} plot(\\spad{fp},{}\\spad{-1}.0..1.0)\\$PLOT"
 \end{verbatim}
 
-This function finds examples and strips off the prefix \verb|\\spad{E}| 
+This function finds examples and strips off the prefix \verb|\\spad{X}| 
 from the stored form and calls cleanupLine to get rid of the other noise.
 <<*>>=
 sayExample(docstring,op) ==
- point := SEARCH('"{E}",docstring)
+ point := SEARCH('"{X}",docstring)
  point => 
   line := SUBSEQ(docstring,point+3)
-  while (mark:=SEARCH('"{E}",line)) repeat
+  while (mark:=SEARCH('"{X}",line)) repeat
    mark > 0 =>
     PRINC cleanupLine (SUBSEQ(line,0,mark-6))
     sayNewLine()



From MAILER-DAEMON Wed Aug 27 15:16:11 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KYQV1-00065S-DG
	for mharc-axiom-developer@gnu.org; Wed, 27 Aug 2008 15:16:11 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KYQUz-00062z-R1
	for axiom-developer@nongnu.org; Wed, 27 Aug 2008 15:16:09 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KYQUy-00060d-Vk
	for axiom-developer@nongnu.org; Wed, 27 Aug 2008 15:16:09 -0400
Received: from [199.232.76.173] (port=52829 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KYQUy-00060M-IO
	for axiom-developer@nongnu.org; Wed, 27 Aug 2008 15:16:08 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:46544
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KYQUy-00062w-3S
	for axiom-developer@nongnu.org; Wed, 27 Aug 2008 15:16:08 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7RJG5r3005782;
	Wed, 27 Aug 2008 14:16:05 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7RJG52H005779;
	Wed, 27 Aug 2008 14:16:05 -0500
Date: Wed, 27 Aug 2008 14:16:05 -0500
Message-Id: <200808271916.m7RJG52H005779@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080824.02.tpd.patch (expose difference between
	^ and **)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 27 Aug 2008 19:16:10 -0000

Although I believe ^ and ** are intended to be the same operation
clearly they are not. This will require some thought:

(1)-> )d op ^

There are 6 exposed functions called ^ :
   [1] Boolean -> Boolean from Boolean
   [2] D -> D from D if D has BTAGG
   [3] (D,Integer) -> D from D if D has DIVRING
   [4] (D,Integer) -> D from D if D has GROUP
   [5] (D,NonNegativeInteger) -> D from D if D has MONOID
   [6] (D,PositiveInteger) -> D from D if D has SGROUP

Examples of ^ from Boolean


Examples of ^ from BitAggregate


Examples of ^ from DivisionRing


Examples of ^ from Group


Examples of ^ from Monoid


Examples of ^ from SemiGroup

(1) -> )d op **

There are 20 exposed functions called ** :
   [1] (CardinalNumber,CardinalNumber) -> CardinalNumber from 
            CardinalNumber
   [2] (DoubleFloat,DoubleFloat) -> DoubleFloat from DoubleFloat
   [3] (D,Integer) -> D from D if D has DIVRING
   [4] (D,D) -> D from D if D has ELEMFUN
   [5] (Float,Float) -> Float from Float
   [6] (D,NonNegativeInteger) -> D from D
            if D has FS D2 and D2 has ORDSET and D2 has SGROUP
   [7] (D,Integer) -> D from D if D has GROUP
   [8] (PolynomialIdeals(D2,D3,D4,D5),NonNegativeInteger) -> 
            PolynomialIdeals(D2,D3,D4,D5)
            from PolynomialIdeals(D2,D3,D4,D5)
            if D2 has FIELD and D3 has OAMONS and D4 has ORDSET and D5 
            has POLYCAT(D2,D3,D4)
   [9] ((D3 -> D3),NonNegativeInteger) -> (D3 -> D3) from 
            MappingPackage1 D3
            if D3 has SETCAT
   [10] (D,Integer) -> D from D
            if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG 
            D2 and D4 has FLAGG D2 and D2 has FIELD
   [11] (D,NonNegativeInteger) -> D from D
            if D has MATCAT(D2,D3,D4) and D2 has RING and D3 has FLAGG 
            D2 and D4 has FLAGG D2
   [12] (ModuleOperator(D2,D3),Integer) -> ModuleOperator(D2,D3)
            from ModuleOperator(D2,D3)
            if D2 has RING and D3 has LMODULE D2
   [13] (BasicOperator,Integer) -> ModuleOperator(D3,D4)
            from ModuleOperator(D3,D4)
            if D3 has RING and D4 has LMODULE D3
   [14] (D,PositiveInteger) -> D from D if D has MONAD
   [15] (D,NonNegativeInteger) -> D from D if D has MONADWU
   [16] (D,NonNegativeInteger) -> D from D if D has MONOID
   [17] (D,Fraction Integer) -> D from D if D has RADCAT
   [18] (D,PositiveInteger) -> D from D if D has SGROUP
   [19] (D,Integer) -> D from D
            if D has SMATCAT(D2,D3,D4,D5) and D3 has RING and D4 has 
            DIRPCAT(D2,D3) and D5 has DIRPCAT(D2,D3) and D3 has FIELD
         
   [20] (D,D1) -> D from D
            if D has UTSCAT D1 and D1 has RING and D1 has FIELD

There are 18 unexposed functions called ** :
   [1] (D1,Fraction Integer) -> D1 from AlgebraicFunction(D3,D1)
            if D3 has RETRACT INT and D3 has Join(OrderedSet,
            IntegralDomain) and D1 has FS D3
   [2] (D1,D1) -> D1 from CombinatorialFunction(D2,D1)
            if D2 has Join(OrderedSet,IntegralDomain) and D1 has FS D2
            
   [3] (D1,Fraction Integer) -> D1
            from ElementaryFunctionsUnivariateLaurentSeries(D3,D4,D1)
            if D3 has FIELD and D3 has ALGEBRA FRAC INT and D4 has 
            UTSCAT D3 and D1 has ULSCCAT(D3,D4)
   [4] (D1,Fraction Integer) -> D1
            from ElementaryFunctionsUnivariatePuiseuxSeries(D3,D4,D1,D5
            )
            if D3 has FIELD and D3 has ALGEBRA FRAC INT and D4 has 
            ULSCAT D3 and D1 has UPXSCCA(D3,D4) and D5 has PTRANFN D4
         
   [5] (D1,Integer) -> FreeGroup D1 from FreeGroup D1 if D1 has SETCAT
            
   [6] (D1,NonNegativeInteger) -> FreeMonoid D1 from FreeMonoid D1
            if D1 has SETCAT
   [7] (Vector D3,Integer) -> Vector D3 from 
            InnerNormalBasisFieldFunctions D3
            if D3 has FFIELDC
   [8] (InputForm,Integer) -> InputForm from InputForm
   [9] (InputForm,NonNegativeInteger) -> InputForm from InputForm
   [10] (Matrix D3,NonNegativeInteger) -> Matrix D3
            from StorageEfficientMatrixOperations D3 if D3 has RING
   [11] (D1,NonNegativeInteger) -> OrderedFreeMonoid D1
            from OrderedFreeMonoid D1 if D1 has ORDSET
   [12] (Operator D2,Integer) -> Operator D2 from Operator D2 if D2 has
            RING
   [13] (BasicOperator,Integer) -> Operator D3 from Operator D3 if D3 
            has RING
   [14] (OutputForm,OutputForm) -> OutputForm from OutputForm
   [15] (Pattern D1,Pattern D1) -> Pattern D1 from Pattern D1 if D1 has
            SETCAT
   [16] (Pattern D2,NonNegativeInteger) -> Pattern D2 from Pattern D2
            if D2 has SETCAT
   [17] (Stream D2,Stream D2) -> Stream D2
            from StreamTranscendentalFunctionsNonCommutative D2
            if D2 has ALGEBRA FRAC INT
   [18] (Stream D2,Stream D2) -> Stream D2
            from StreamTranscendentalFunctions D2 if D2 has ALGEBRA 
            FRAC INT

Examples of ** from AlgebraicFunction


Examples of ** from CardinalNumber

 c2:=2::CardinalNumber
 c2**c2
 A1:=Aleph 1
 A1**c2
 generalizedContinuumHypothesisAssumed true
 A1**A1


Examples of ** from CombinatorialFunction


Examples of ** from DoubleFloat


Examples of ** from DivisionRing


Examples of ** from ElementaryFunctionsUnivariateLaurentSeries


Examples of ** from ElementaryFunctionsUnivariatePuiseuxSeries


Examples of ** from ElementaryFunctionCategory


Examples of ** from FreeGroup


Examples of ** from Float


Examples of ** from FreeMonoid


Examples of ** from FunctionSpace


Examples of ** from Group


Examples of ** from PolynomialIdeals


Examples of ** from InnerNormalBasisFieldFunctions


Examples of ** from InputForm


Examples of ** from MappingPackage1


Examples of ** from MatrixCategory


Examples of ** from StorageEfficientMatrixOperations


Examples of ** from ModuleOperator


Examples of ** from Monad


Examples of ** from MonadWithUnit


Examples of ** from Monoid


Examples of ** from OrderedFreeMonoid


Examples of ** from Operator


Examples of ** from OutputForm


Examples of ** from Pattern


Examples of ** from RadicalCategory


Examples of ** from SemiGroup


Examples of ** from SquareMatrixCategory


Examples of ** from StreamTranscendentalFunctionsNonCommutative


Examples of ** from StreamTranscendentalFunctions


Examples of ** from UnivariateTaylorSeriesCategory


=======================================================================
diff --git a/changelog b/changelog
index e2cd290..d736c79 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,8 @@
+20080824 tpd src/input/Makefile add liu.input to regression
+20080824 lxx src/input/liu.input expose difference between ^ and **
+20080824 tpd src/interp/setq.lisp add Liu Xiaojun to credits
+20080824 tpd readme add Liu Xiaojun to credits
+20080824 lxx "Liu Xiaojun" <tigertooth4@gmail.com>
 20080824 tpd src/interp/format.boot use ++X
 20080824 tpd src/algebra/tree.spad use ++X
 20080824 tpd src/algebra/string.spad use ++X
diff --git a/readme b/readme
index 7735016..be93ed8 100644
--- a/readme
+++ b/readme
@@ -216,8 +216,8 @@ at the axiom command prompt will prettyprint the list.
 "Kai Kaminski           Grant Keady            Tony Kennedy"
 "Paul Kosinski          Klaus Kusche           Bernhard Kutzler"
 "Larry Lambe            Franz Lehner           Frederic Lehobey"
-"Michel Levaud          Howard Levy            Rudiger Loos"
-"Michael Lucks          Richard Luczak"
+"Michel Levaud          Howard Levy            Liu Xiaojun"
+"Rudiger Loos           Michael Lucks          Richard Luczak"
 "Camm Maguire           Francois Maltey        Alasdair McAndrew"
 "Bob McElrath           Michael McGettrick     Ian Meikle"
 "David Mentre           Victor S. Miller       Gerard Milmeister"
diff --git a/src/input/Makefile.pamphlet b/src/input/Makefile.pamphlet
index 3f80d67..8bc5aa4 100644
--- a/src/input/Makefile.pamphlet
+++ b/src/input/Makefile.pamphlet
@@ -324,8 +324,8 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     kamke4.regress    kamke5.regress   kamke6.regress   kamke7.regress \
     kernel.regress    knot2.regress    kovacic.regress  kuipers.regress \
     laplace.regress   leg.regress      limit.regress    linalg.regress \
-    lindep.regress \
-    list.regress      lode.regress     lodesys.regress  lodo1.regress \
+    lindep.regress    list.regress     liu.regress   \
+    lode.regress      lodesys.regress  lodo1.regress \
     lodo2.regress     lodo3.regress    lodof.regress    lodo.regress \
     log.regress \
     lpoly.regress     lupfact.regress  lword.regress    macbug.regress \
@@ -595,7 +595,8 @@ FILES= ${OUT}/algaggr.input  ${OUT}/algbrbf.input    ${OUT}/algfacob.input \
        ${OUT}/lextripk.input ${OUT}/lib.input        ${OUT}/limit.input \
        ${OUT}/linalg.input \
        ${OUT}/lindep.input   ${OUT}/liss1.input      ${OUT}/liss2.input \
-       ${OUT}/list.input     ${OUT}/lode.input       ${OUT}/lodesys.input \
+       ${OUT}/list.input     ${OUT}/liu.input \
+       ${OUT}/lode.input     ${OUT}/lodesys.input \
        ${OUT}/lodo1.input    ${OUT}/lodo2.input      ${OUT}/lodof.input \
        ${OUT}/lodo.input     ${OUT}/lodo3.input      ${OUT}/log.input \
        ${OUT}/lpoly.input    ${OUT}/lump.input \
@@ -896,7 +897,8 @@ DOCFILES= \
   ${DOC}/lib.input.dvi         ${DOC}/limit.input.dvi      \
   ${DOC}/linalg.input.dvi      ${DOC}/lindep.input.dvi     \
   ${DOC}/liss1.input.dvi       ${DOC}/liss2.input.dvi      \
-  ${DOC}/list.input.dvi        ${DOC}/lode.input.dvi       \
+  ${DOC}/list.input.dvi        ${DOC}/liu.input.dvi        \
+  ${DOC}/lode.input.dvi       \
   ${DOC}/lodesys.input.dvi     ${DOC}/lodo1.input.dvi      \
   ${DOC}/lodo2.input.dvi       ${DOC}/lodo3.input.dvi      \
   ${DOC}/lodof.input.dvi       ${DOC}/lodo.input.dvi       \
diff --git a/src/input/liu.input.pamphlet b/src/input/liu.input.pamphlet
new file mode 100644
index 0000000..65aa30d
--- /dev/null
+++ b/src/input/liu.input.pamphlet
@@ -0,0 +1,94 @@
+\documentclass{article}
+\usepackage{axiom}
+\begin{document}
+\title{\$SPAD/src/input liu.input}
+\author{Xiaojun Liu}
+\maketitle
+\begin{abstract}
+This makes it clear that the exponential operation semantics is different
+for the use of ``\verb|^|'' and ``\verb|**|'' in some cases.
+\end{abstract}
+\eject
+\tableofcontents
+\eject
+Does exponential operation ``\verb|^|'' and ``\verb|**|'' of a differential
+operator, say L, means repeating multiplications of L in Axiom ? If
+so, it seems the following code produced an unexpected result:
+@
+<<*>>=
+)spool liu.output
+)set message test on
+)set message auto off
+)set message type off
+)clear all
+ 
+--S 1 of 9
+Dx: LODO(EXPR INT, f+->D(f,x)) := D()
+--R
+--R   (1)  D
+--E 1
+
+--S 2 of 9
+u := operator 'u
+--R
+--R   (2)  u
+--E 2
+
+--S 3 of 9
+L := Dx + u(x)
+--R
+--R   (3)  D + u(x)
+--E 3
+
+--S 4 of 9
+L**2 = L*L
+--R
+--R         2                2   2             ,          2
+--R   (4)  D  + 2u(x)D + u(x) = D  + 2u(x)D + u (x) + u(x)
+--R
+--E 4
+
+)clear all
+
+--S 5 of 9
+f: INT->INT:=x+->x+1
+--R
+--R   (1)  theMap(Closure)
+--E 5
+
+--S 6 of 9
+K := OREUP ( x, INT, 1, f);
+--R
+--E 6
+
+--S 7 of 9
+x:K
+--E 7
+
+--S 8 of 9
+L:=x+1
+--R
+--R   (4)  x + 1
+--E 8
+
+--S 9 of 9
+L^2=L*L
+--R
+--R         2            2
+--R   (5)  x  + 2x + 1= x  + 4x + 3
+--E 9
+
+)spool 
+)lisp (bye)
+ 
+@
+Clearly, the r.h.s. is correct too. I checked the .spad file, it seems the
+exponential operation of LODO (or its parent OREUP) is missed (or I guess it
+is directly inherited as usual polynomial operation). However I am not
+clever enough to modify the code. Please check this, thanks.
+
+\eject
+\begin{thebibliography}{99}
+\bibitem{1} nothing
+\end{thebibliography}
+\end{document}
diff --git a/src/interp/setq.lisp.pamphlet b/src/interp/setq.lisp.pamphlet
index e9b34ec..37b7fba 100644
--- a/src/interp/setq.lisp.pamphlet
+++ b/src/interp/setq.lisp.pamphlet
@@ -627,8 +627,8 @@
 "Kai Kaminski           Grant Keady            Tony Kennedy"
 "Paul Kosinski          Klaus Kusche           Bernhard Kutzler"
 "Larry Lambe            Franz Lehner           Frederic Lehobey"
-"Michel Levaud          Howard Levy            Rudiger Loos"
-"Michael Lucks          Richard Luczak"
+"Michel Levaud          Howard Levy            Liu Xiaojun"
+"Rudiger Loos           Michael Lucks          Richard Luczak"
 "Camm Maguire           Francois Maltey        Alasdair McAndrew"
 "Bob McElrath           Michael McGettrick     Ian Meikle"
 "David Mentre           Victor S. Miller       Gerard Milmeister"



From MAILER-DAEMON Thu Aug 28 01:14:07 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KYZpf-0005vx-2u
	for mharc-axiom-developer@gnu.org; Thu, 28 Aug 2008 01:14:07 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KYZpd-0005uM-33
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 01:14:05 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KYZpa-0005sc-D7
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 01:14:03 -0400
Received: from [199.232.76.173] (port=49464 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KYZpa-0005sT-6R
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 01:14:02 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:35833
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KYZpa-0007ez-54
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 01:14:02 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7S5Dwr3017031;
	Thu, 28 Aug 2008 00:13:58 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7S5DwfH017028;
	Thu, 28 Aug 2008 00:13:58 -0500
Date: Thu, 28 Aug 2008 00:13:58 -0500
Message-Id: <200808280513.m7S5DwfH017028@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080827.01.wsp.patch (replace \over with \frac
	(Page)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Thu, 28 Aug 2008 05:14:05 -0000

)set message tex on

before change 1/2 formats as:
$$ 1 \over 2 $$

after change 1/2 formats as:

$$\frac{1}{2}$$



========================================================================
diff --git a/changelog b/changelog
index d736c79..5dfa61a 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,4 @@
+20080827 wsp src/algebra/tex.spad change \over to \frac
 20080824 tpd src/input/Makefile add liu.input to regression
 20080824 lxx src/input/liu.input expose difference between ^ and **
 20080824 tpd src/interp/setq.lisp add Liu Xiaojun to credits
diff --git a/src/algebra/tex.spad.pamphlet b/src/algebra/tex.spad.pamphlet
index 7577e3f..3babcb2 100644
--- a/src/algebra/tex.spad.pamphlet
+++ b/src/algebra/tex.spad.pamphlet
@@ -534,7 +534,12 @@ TexFormat(): public == private where
         op
       opPrec := binaryPrecs.p
       s : S := formatTex(first args, opPrec)
-      s := concat [s,op,formatTex(first rest args, opPrec)]
+      if op = " \over " then
+        s := concat [" \frac{",s,"}{",formatTex(first rest args, opPrec),"}"]
+      else if op = " \sp " then
+        s := concat [s,"^",formatTex(first rest args, opPrec)]
+      else
+        s := concat [s,op,formatTex(first rest args, opPrec)]
       group
         op = " \over " => s
         opPrec < prec => parenthesize s



From MAILER-DAEMON Thu Aug 28 09:28:42 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KYhYI-0001xm-8Z
	for mharc-axiom-developer@gnu.org; Thu, 28 Aug 2008 09:28:42 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KYhYG-0001wr-5a
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 09:28:40 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KYhYE-0001wG-E7
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 09:28:39 -0400
Received: from [199.232.76.173] (port=38670 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KYhYE-0001w5-3g
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 09:28:38 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:34618
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KYhYD-0007FG-Lt
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 09:28:37 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7SDSar3010494;
	Thu, 28 Aug 2008 08:28:36 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7SDSZ91010491;
	Thu, 28 Aug 2008 08:28:35 -0500
Date: Thu, 28 Aug 2008 08:28:35 -0500
Message-Id: <200808281328.m7SDSZ91010491@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080828.01.mxr.patch (add cost to bottomUp
	output (Rubey))
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Thu, 28 Aug 2008 13:28:40 -0000

Function selection for overloaded functions is driven by the cost
estimate of the function. This is useful information for someone
skilled at reading the output of )set mes bot on

=======================================================================
diff --git a/changelog b/changelog
index 5dfa61a..41f4ab7 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,4 @@
+20080828 mxr src/interp/i-funsel.boot add cost to bottomUp output
 20080827 wsp src/algebra/tex.spad change \over to \frac
 20080824 tpd src/input/Makefile add liu.input to regression
 20080824 lxx src/input/liu.input expose difference between ^ and **
diff --git a/src/interp/i-funsel.boot.pamphlet b/src/interp/i-funsel.boot.pamphlet
index 8b8b0fd..e06d684 100644
--- a/src/interp/i-funsel.boot.pamphlet
+++ b/src/interp/i-funsel.boot.pamphlet
@@ -88,8 +88,7 @@ sayFunctionSelection(op,args,target,dc,func) ==
     '"      Arguments:",:bright fsig]
   if target then sayMSG concat ['"      Target type:",
     :bright prefix2String target]
-  if dc	 then sayMSG concat ['"      From:     ",
-    :bright prefix2String dc]
+  if dc then sayMSG concat ['"      From:     ", :bright prefix2String dc]
   stopTimingProcess 'debug
 
 sayFunctionSelectionResult(op,args,mmS) ==
@@ -638,6 +637,9 @@ mmCost(name, sig,cond,tar,args1,args2) ==
   res = $PositiveInteger => cost - 2
   res = $NonNegativeInteger => cost - 1
   res = $DoubleFloat => cost + 1
+  if $reportBottomUpFlag then
+    sayMSG ['"cost=",prefix2String cost,'" for ", name,'": ",_
+            :formatSignature CDR sig]
   cost
 
 mmCost0(name, sig,cond,tar,args1,args2) ==



From MAILER-DAEMON Thu Aug 28 10:24:01 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KYiPp-0005lD-BU
	for mharc-axiom-developer@gnu.org; Thu, 28 Aug 2008 10:24:01 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KYiPn-0005l5-Ig
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 10:23:59 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KYiPm-0005kV-Ax
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 10:23:59 -0400
Received: from [199.232.76.173] (port=42698 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KYiPm-0005kS-66
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 10:23:58 -0400
Received: from grace.univie.ac.at ([131.130.3.115]:42694)
	by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <martin.rubey@univie.ac.at>) id 1KYiPm-0004VN-0l
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 10:23:58 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=univie.ac.at; s=rev1; h=Sender:To:Cc:Subject:References:From:
	Date:In-Reply-To:Message-ID:MIME-Version:Content-Type; bh=v+Lk3k
	/3sr1WCRPti4i5UBU7SPuNNlrNhvo7UEEWR9Q=; b=qDo8hBp54zzYJtFOybSu+k
	1sMr1n3FtmvDW9/U4HHNZPOjsBMSGU+8y/dpFmO4jZrgLD/pjxd3SPafcGRTa3dV
	88ssGbCY58JahlB5MKi+z6Kp1QBvywslOgpINYQzB9klNNkwan2VvcG8/nFlAhxL
	0++swJ4HetiCRXeN1RLVM=
Received: from joan.univie.ac.at ([131.130.3.110] helo=joan.univie.ac.at)
	by grace.univie.ac.at with esmtp (Exim 4.69)
	(envelope-from <martin.rubey@univie.ac.at>)
	id 1KYiPg-0002w9-J5; Thu, 28 Aug 2008 16:23:52 +0200
Received: from aquin.mat.univie.ac.at ([131.130.16.163]
	helo=aquin.mat.univie.ac.at)
	by joan.univie.ac.at with esmtp (Exim 4.69)
	(envelope-from <martin.rubey@univie.ac.at>)
	id 1KYiPg-0001Cn-Ga; Thu, 28 Aug 2008 16:23:52 +0200
Sender: rubey@aquin.mat.univie.ac.at
To: daly@axiom-developer.org
Subject: Re: [Axiom-developer] 20080828.01.mxr.patch (add cost to bottomUp
	output (Rubey))
References: <200808281328.m7SDSZ91010491@axiom-developer.org>
From: Martin Rubey <martin.rubey@univie.ac.at>
Date: 28 Aug 2008 16:23:54 +0200
In-Reply-To: <200808281328.m7SDSZ91010491@axiom-developer.org>
Message-ID: <9qiqtlz091.fsf@aquin.mat.univie.ac.at>
Lines: 12
User-Agent: Gnus/5.09 (Gnus v5.9.0) Emacs/21.4
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-detected-kernel: by monty-python.gnu.org: Linux 2.6, seldom 2.4 (older, 4)
Cc: axiom-developer@nongnu.org
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Thu, 28 Aug 2008 14:23:59 -0000

daly@axiom-developer.org writes:

> Function selection for overloaded functions is driven by the cost
> estimate of the function. This is useful information for someone
> skilled at reading the output of )set mes bot on

this is due to Bill Page, although I doubt it was intended for general
audience...

Martin

> +20080828 mxr src/interp/i-funsel.boot add cost to bottomUp output




From MAILER-DAEMON Thu Aug 28 10:44:35 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KYijj-0008Qo-Ns
	for mharc-axiom-developer@gnu.org; Thu, 28 Aug 2008 10:44:35 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KYijh-0008Pr-MU
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 10:44:33 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KYijf-0008Of-Kg
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 10:44:33 -0400
Received: from [199.232.76.173] (port=57064 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KYijf-0008OT-95
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 10:44:31 -0400
Received: from mx-7.zoominternet.net ([24.154.1.26]:50961
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KYijf-0003sy-2I
	for axiom-developer@nongnu.org; Thu, 28 Aug 2008 10:44:31 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=xoIDnGCgXlMA:10 a=6pBmxGeMSocA:10
	a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=37mPLz1kAAAA:8 a=tlLL5PGAKkebYmLv5A8A:9
	a=lKvGfpOgEPTN5gxJYoD6fakc90gA:4 a=WcGY3-TIXCwA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.45] ([24.154.1.45:37751] helo=pop-2.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id BA/E7-04218-4B9B6B84; Thu, 28 Aug 2008 10:44:04 -0400
Received: (qmail 3524 invoked from network); 28 Aug 2008 14:44:09 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-2.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 28 Aug 2008 14:44:09 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id m7SGAeV09732;
	Thu, 28 Aug 2008 12:10:40 -0400
Date: Thu, 28 Aug 2008 12:10:40 -0400
Message-Id: <200808281610.m7SGAeV09732@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: martin.rubey@univie.ac.at
In-reply-to: <9qiqtlz091.fsf@aquin.mat.univie.ac.at> (message from Martin
	Rubey on 28 Aug 2008 16:23:54 +0200)
Subject: Re: [Axiom-developer] 20080828.01.mxr.patch (add cost to bottomUp
	output (Rubey))
References: <200808281328.m7SDSZ91010491@axiom-developer.org>
	<9qiqtlz091.fsf@aquin.mat.univie.ac.at>
X-detected-kernel: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Thu, 28 Aug 2008 14:44:34 -0000

>> Function selection for overloaded functions is driven by the cost
>> estimate of the function. This is useful information for someone
>> skilled at reading the output of )set mes bot on
>
>this is due to Bill Page, although I doubt it was intended for general
>audience...
>
>Martin
>
>> +20080828 mxr src/interp/i-funsel.boot add cost to bottomUp output

Sorry, it looked like the code was from you somehow. 
I've fix it on the website.
<http://axiom-developer.org/axiom-website/patches.html>

The output is now only produced when the )set mes bot on
command has been used. Someone using that command is presumed
to have a clue since it is a "development" command. It is
useful debugging information.

Tim




From MAILER-DAEMON Sat Aug 30 01:11:48 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KZIkW-0002Sa-35
	for mharc-axiom-developer@gnu.org; Sat, 30 Aug 2008 01:11:48 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KZIkT-0002QU-AC
	for axiom-developer@nongnu.org; Sat, 30 Aug 2008 01:11:45 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KZIkS-0002PB-HA
	for axiom-developer@nongnu.org; Sat, 30 Aug 2008 01:11:44 -0400
Received: from [199.232.76.173] (port=46720 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KZIkR-0002Os-7Z
	for axiom-developer@nongnu.org; Sat, 30 Aug 2008 01:11:43 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:37646
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KZIkQ-00046K-M5
	for axiom-developer@nongnu.org; Sat, 30 Aug 2008 01:11:43 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7U5Bcr3020657;
	Sat, 30 Aug 2008 00:11:38 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7U5Bco6020654;
	Sat, 30 Aug 2008 00:11:38 -0500
Date: Sat, 30 Aug 2008 00:11:38 -0500
Message-Id: <200808300511.m7U5Bco6020654@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080829.01.tpd.patch (graphviz dotfile
	decoration)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 30 Aug 2008 05:11:45 -0000

I've started a process to create a graph of the algebra hierarchy.
The results of this are cached with each domain as a <<dot>> chunk
which will later be automatically extracted to construct a graph.
The aggcat.spad file is complete.

The graph currently shows both a graph of the abbreviations and
a graph of the domain signatures. These two graphs are different
in some places because the signatures add additional constraints.
These additional constraints are added to the domain signature graph.

========================================================================
diff --git a/changelog b/changelog
index 41f4ab7..187f1c4 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,4 @@
+20080829 tpd src/algebra/aggcat.spad graphviz dotfile decoration
 20080828 mxr src/interp/i-funsel.boot add cost to bottomUp output
 20080827 wsp src/algebra/tex.spad change \over to \frac
 20080824 tpd src/input/Makefile add liu.input to regression
diff --git a/src/algebra/aggcat.spad.pamphlet b/src/algebra/aggcat.spad.pamphlet
index ee39ddd..7212a34 100644
--- a/src/algebra/aggcat.spad.pamphlet
+++ b/src/algebra/aggcat.spad.pamphlet
@@ -1,4 +1,3 @@
-
 \documentclass{article}
 \usepackage{axiom}
 \begin{document}
@@ -11,8 +10,11 @@
 \tableofcontents
 \eject
 \section{category AGG Aggregate}
+<<dot>>=
+"AGG" -> "TYPE"
+"Aggregate()" -> "Type()"
+@
 <<category AGG Aggregate>>=
-
 )abbrev category AGG Aggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
 ++ Date Created: August 87 through August 88
@@ -66,6 +68,10 @@ Aggregate: Category == Type with
 
 @
 \section{category HOAGG HomogeneousAggregate}
+<<dot>>=
+"HOAGG" -> "AGG"
+"HomogeneousAggregate(a:Type)" -> "Aggregate()"
+@
 <<category HOAGG HomogeneousAggregate>>=
 )abbrev category HOAGG HomogeneousAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -272,6 +278,11 @@ Note that this code is not included in the generated catdef.spad file.
 (MAKEPROP (QUOTE |HomogeneousAggregate&|) (QUOTE |infovec|) (LIST (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) (|List| 37) (0 . |eval|) (|Mapping| 7 7) (6 . |map|) (12 . |eval|) (|List| 7) (18 . |parts|) (|NonNegativeInteger|) (23 . |#|) (|Boolean|) (|Mapping| 17 7) (28 . |any?|) (34 . |every?|) (40 . |count|) (46 . |members|) (51 . |=|) (57 . |count|) (63 . |count|) (69 . |any?|) (75 . |member?|) (81 . |#|) (86 . |size?|) (92 . |=|) (|OutputForm|) (98 . |coerce|) (|List| |$|) (103 . |commaSeparate|) (108 . |bracket|) (113 . |coerce|) (|Equation| 7))) (QUOTE #(|members| 118 |member?| 123 |every?| 129 |eval| 135 |count| 141 |coerce| 153 |any?| 158 |=| 164 |#| 170)) (QUOTE NIL) (CONS (|makeByteWordVec2| 1 (QUOTE NIL)) (CONS (QUOTE #()) (CONS (QUOTE #()) (|makeByteWordVec2| 36 (QUOTE (2 7 0 0 8 9 2 6 0 10 0 11 2 0 0 0 8 12 1 6 13 0 14 1 0 15 0 16 2 0 17 18 0 19 2 0 17 18 0 20 2 0 15 18 0 21 1 0 13 0 22 2 7 17 0 0 23 2 6 15 18 0 24 2 0 15 7 0 25 2 6 17 18 0 26!
 2 0 17 7 0 27 1 6 15 0 28 2 6 17 0 15 29 2 0 17 0 0 30 1 7 31 0 32 1 31 0 33 34 1 31 0 0 35 1 0 31 0 36 1 0 13 0 22 2 0 17 7 0 27 2 0 17 18 0 20 2 0 0 0 8 12 2 0 15 7 0 25 2 0 15 18 0 21 1 0 31 0 36 2 0 17 18 0 19 2 0 17 0 0 30 1 0 15 0 16)))))) (QUOTE |lookupComplete|))) 
 @
 \section{category CLAGG Collection}
+<<dot>>=
+"CLAGG" -> "HOAGG"
+"Collection(a:Type)" -> "HomogeneousAggregate(a:Type)"
+"Collection(a:SetCategory)" -> "Collection(a:Type)"
+@
 <<category CLAGG Collection>>=
 )abbrev category CLAGG Collection
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -420,6 +431,11 @@ Note that this code is not included in the generated catdef.spad file.
 (MAKEPROP (QUOTE |Collection&|) (QUOTE |infovec|) (LIST (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) (|List| 7) (0 . |parts|) (|NonNegativeInteger|) (5 . |#|) (|Mapping| 14 7) (10 . |count|) (|Boolean|) (16 . |any?|) (22 . |every?|) (|Union| 7 (QUOTE "failed")) (28 . |find|) (34 . |find|) (|Mapping| 7 7 7) (40 . |reduce|) (46 . |reduce|) (52 . |reduce|) (59 . |reduce|) (66 . |remove|) (72 . |construct|) (77 . |remove|) (83 . |select|) (89 . |select|) (95 . |=|) (101 . |remove|) (107 . |remove|) (113 . |reduce|) (121 . |reduce|) (129 . |removeDuplicates|) (134 . |removeDuplicates|))) (QUOTE #(|select| 139 |removeDuplicates| 145 |remove| 150 |reduce| 162 |find| 183 |every?| 189 |count| 195 |any?| 201 |#| 207)) (QUOTE NIL) (CONS (|makeByteWordVec2| 1 (QUOTE NIL)) (CONS (QUOTE #()) (CONS (QUOTE #()) (|makeByteWordVec2| 36 (QUOTE (1 6 8 0 9 1 0 10 0 11 2 0 10 12 0 13 2 0 14 12 0 15 2 0 14 12 0 16 2 8 17 12 0 18 2 0 17 12 0 19 2 8 7 20 0 21 2 0 7 20 0 22 3 8 7 2!
0 0 7 23 3 0 7 20 0 7 24 2 8 0 12 0 25 1 6 0 8 26 2 0 0 12 0 27 2 8 0 12 0 28 2 0 0 12 0 29 2 7 14 0 0 30 2 6 0 12 0 31 2 0 0 7 0 32 4 8 7 20 0 7 7 33 4 0 7 20 0 7 7 34 1 8 0 0 35 1 0 0 0 36 2 0 0 12 0 29 1 0 0 0 36 2 0 0 7 0 32 2 0 0 12 0 27 4 0 7 20 0 7 7 34 3 0 7 20 0 7 24 2 0 7 20 0 22 2 0 17 12 0 19 2 0 14 12 0 16 2 0 10 12 0 13 2 0 14 12 0 15 1 0 10 0 11)))))) (QUOTE |lookupComplete|))) 
 @
 \section{category BGAGG BagAggregate}
+<<dot>>=
+"BGAGG" -> "HOAGG"
+"BagAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"
+"BagAggregate(a:SetCategory)" -> "BagAggregate(a:Type)"
+@
 <<category BGAGG BagAggregate>>=
 )abbrev category BGAGG BagAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -455,6 +471,11 @@ BagAggregate(S:Type): Category == HomogeneousAggregate S with
 
 @
 \section{category SKAGG StackAggregate}
+<<dot>>=
+"SKAGG" -> "BGAGG"
+"StackAggregate(a:Type)" -> "BagAggregate(a:Type)"
+"StackAggregate(a:SetCategory)" -> "StackAggregate(a:Type)"
+@
 <<category SKAGG StackAggregate>>=
 )abbrev category SKAGG StackAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -488,6 +509,11 @@ StackAggregate(S:Type): Category == BagAggregate S with
 
 @
 \section{category QUAGG QueueAggregate}
+<<dot>>=
+"QUAGG" -> "BGAGG"
+"QueueAggregate(a:Type)" -> "BagAggregate(a:Type)"
+"QueueAggregate(a:SetCategory)" -> "QueueAggregate(a:Type)"
+@
 <<category QUAGG QueueAggregate>>=
 )abbrev category QUAGG QueueAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -527,6 +553,13 @@ QueueAggregate(S:Type): Category == BagAggregate S with
 
 @
 \section{category DQAGG DequeueAggregate}
+<<dot>>=
+"DQAGG" -> "SKAGG"
+"DequeueAggregate(a:Type)" -> "StackAggregate(a:Type)"
+"DQAGG" -> "QUAGG"
+"DequeueAggregate(a:Type)" -> "QueueAggregate(a:Type)"
+"DequeueAggregate(a:SetCategory)" -> "DequeueAggregate(a:Type)"
+@
 <<category DQAGG DequeueAggregate>>=
 )abbrev category DQAGG DequeueAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -578,6 +611,13 @@ DequeueAggregate(S:Type):
 
 @
 \section{category PRQAGG PriorityQueueAggregate}
+<<dot>>=
+"PRQAGG" -> "BGAGG"
+"PriorityQueueAggregate(a:Type)" -> "BagAggregate(a:Type)"
+"PriorityQueueAggregate(a:SetCategory)" -> "PriorityQueueAggregate(a:Type)"
+"PriorityQueueAggregate(a:OrderedSet)" ->
+    "PriorityQueueAggregate(a:SetCategory)"
+@
 <<category PRQAGG PriorityQueueAggregate>>=
 )abbrev category PRQAGG PriorityQueueAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -605,6 +645,12 @@ PriorityQueueAggregate(S:OrderedSet): Category == BagAggregate S with
 
 @
 \section{category DIOPS DictionaryOperations}
+<<dot>>=
+"DIOPS" -> "BGAGG"
+"DictionaryOperations(a:SetCategory)" -> "BagAggregate(a:SetCategory)"
+"DIOPS" -> "CLAGG"
+"DictionaryOperations(a:SetCategory)" -> "Collection(a:SetCategory)"
+@
 <<category DIOPS DictionaryOperations>>=
 )abbrev category DIOPS DictionaryOperations
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -655,6 +701,12 @@ DictionaryOperations(S:SetCategory): Category ==
 
 @
 \section{category DIAGG Dictionary}
+<<dot>>=
+"DIAGG" -> "DIOPS"
+"Dictionary(a:SetCategory)" -> "DictionaryOperations(a:SetCategory)"
+"Dictionary(Record(a:SetCategory,b:SetCategory)" ->
+    "Dictionary(a:SetCategory)"
+@
 <<category DIAGG Dictionary>>=
 )abbrev category DIAGG Dictionary
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -700,6 +752,10 @@ Dictionary(S:SetCategory): Category ==
 
 @
 \section{category MDAGG MultiDictionary}
+<<dot>>=
+"MDAGG" -> "DIOPS"
+"MultiDictionary(a:SetCategory)" -> "DictionaryOperations(a:SetCategory)"
+@
 <<category MDAGG MultiDictionary>>=
 )abbrev category MDAGG MultiDictionary
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -732,6 +788,12 @@ MultiDictionary(S:SetCategory): Category == DictionaryOperations S with
 
 @
 \section{category SETAGG SetAggregate}
+<<dot>>=
+"SETAGG" -> "SETCAT"
+"SetAggregate(a:SetCategory)" -> "SetCategory()"
+"SETAGG" -> "CLAGG"
+"SetAggregate(a:SetCategory)" -> "Collection(a:SetCategory)"
+@
 <<category SETAGG SetAggregate>>=
 )abbrev category SETAGG SetAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -857,6 +919,12 @@ Note that this code is not included in the generated catdef.spad file.
 (MAKEPROP (QUOTE |SetAggregate&|) (QUOTE |infovec|) (LIST (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) (0 . |difference|) (6 . |union|) |SETAGG-;symmetricDifference;3A;1| (|List| 7) (12 . |brace|) |SETAGG-;union;ASA;2| |SETAGG-;union;S2A;3| |SETAGG-;difference;ASA;4|)) (QUOTE #(|union| 17 |symmetricDifference| 29 |difference| 35)) (QUOTE NIL) (CONS (|makeByteWordVec2| 1 (QUOTE NIL)) (CONS (QUOTE #()) (CONS (QUOTE #()) (|makeByteWordVec2| 15 (QUOTE (2 6 0 0 0 8 2 6 0 0 0 9 1 6 0 11 12 2 0 0 7 0 14 2 0 0 0 7 13 2 0 0 0 0 10 2 0 0 0 7 15)))))) (QUOTE |lookupComplete|))) 
 @
 \section{category FSAGG FiniteSetAggregate}
+<<dot>>=
+"FSAGG" -> "DIAGG"
+"FiniteSetAggregate(a:SetCategory)" -> "Dictionary(a:SetCategory)"
+"FSAGG" -> "SETAGG"
+"FiniteSetAggregate(a:SetCategory)" -> "SetAggregate(a:SetCategory)"
+@
 <<category FSAGG FiniteSetAggregate>>=
 )abbrev category FSAGG FiniteSetAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -949,6 +1017,12 @@ FiniteSetAggregate(S:SetCategory): Category ==
 
 @
 \section{category MSETAGG MultisetAggregate}
+<<dot>>=
+"MSETAGG" -> "MDAGG"
+"MultisetAggregate(a:SetCategory)" -> "MultiDictionary(a:SetCategory)"
+"MSETAGG" -> "SETAGG"
+"MultisetAggregate(a:SetCategory)" -> "SetAggregate(a:SetCategory)"
+@
 <<category MSETAGG MultisetAggregate>>=
 )abbrev category MSETAGG MultisetAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -968,6 +1042,14 @@ MultisetAggregate(S:SetCategory):
 
 @
 \section{category OMSAGG OrderedMultisetAggregate}
+<<dot>>=
+"OMSAGG" -> "MSETAGG"
+"OrderedMultisetAggregate(a:SetCategory)" -> 
+    "MultisetAggregate(a:SetCategory)"
+"OMSAGG" -> "PRQAGG"
+"OrderedMultisetAggregate(a:SetCategory)" -> 
+    "PriorityQueueAggregate(a:SetCategory)"
+@
 <<category OMSAGG OrderedMultisetAggregate>>=
 )abbrev category OMSAGG OrderedMultisetAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -994,6 +1076,11 @@ OrderedMultisetAggregate(S:OrderedSet): Category ==
 
 @
 \section{category KDAGG KeyedDictionary}
+<<dot>>=
+"KDAGG" -> "DIAGG"
+"KeyedDictionary(a:SetCategory,b:SetCategory)" -> 
+    "Dictionary(Record(a:SetCategory,b:SetCategory)"
+@
 <<category KDAGG KeyedDictionary>>=
 )abbrev category KDAGG KeyedDictionary
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -1035,6 +1122,10 @@ KeyedDictionary(Key:SetCategory, Entry:SetCategory): Category ==
 
 @
 \section{category ELTAB Eltable}
+<<dot>>=
+"ELTAB" -> "CATEGORY"
+"Eltable(a:SetCategory,b:Type)" -> "Category"
+@
 <<category ELTAB Eltable>>=
 )abbrev category ELTAB Eltable
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Manuel Bronstein
@@ -1058,6 +1149,10 @@ Eltable(S:SetCategory, Index:Type): Category == with
 
 @
 \section{category ELTAGG EltableAggregate}
+<<dot>>=
+"ELTAGG" -> "ELTAB"
+"EltableAggregate(a:SetCategory,b:Type)"-> "Eltable(a:SetCategory,b:Type)"
+@
 <<category ELTAGG EltableAggregate>>=
 )abbrev category ELTAGG EltableAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -1109,6 +1204,18 @@ EltableAggregate(Dom:SetCategory, Im:Type): Category ==
 
 @
 \section{category IXAGG IndexedAggregate}
+<<dot>>=
+"IXAGG" -> "HOAGG"
+"IndexedAggregate(a:SetCategory,b:Type)" -> 
+    "HomogeneousAggregate(a:Type)"
+"IXAGG" -> "ELTAGG"
+"IndexedAggregate(a:SetCategory,b:Type)" -> 
+    "EltableAggregate(a:SetCategory,b:Type)"
+"IndexedAggregate(a:SetCategory,b:SetCategory)" ->
+    "IndexedAggregate(a:SetCategory,b:Type)"
+"IndexedAggregate(b:Integer,a:Type)" ->
+    "IndexedAggregate(a:SetCategory,b:Type)"
+@
 <<category IXAGG IndexedAggregate>>=
 )abbrev category IXAGG IndexedAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -1198,6 +1305,14 @@ IndexedAggregate(Index: SetCategory, Entry: Type): Category ==
 
 @
 \section{category TBAGG TableAggregate}
+<<dot>>=
+"TBAGG" -> "KDAGG"
+"TableAggregate(a:SetCategory,b:SetCategory)" -> 
+    "KeyedDictionary(a:SetCategory,b:SetCategory)"
+"TBAGG" -> "IXAGG"
+"TableAggregate(a:SetCategory,b:SetCategory)" -> 
+    "IndexedAggregate(a:SetCategory,b:SetCategory)"
+@
 <<category TBAGG TableAggregate>>=
 )abbrev category TBAGG TableAggregate
 ++ Author: Michael Monagan, Stephen Watt; revised by Manuel Bronstein and Richard Jenks
@@ -1220,9 +1335,9 @@ TableAggregate(Key:SetCategory, Entry:SetCategory): Category ==
    table: () -> %
      ++ table()$T creates an empty table of type T.
      ++
-     ++X Data:=Record(age:Integer,gender:String)
-     ++X a1:AssociationList(String,Data):=table()
-     ++X a1."tim":=[55,"male"]$Data
+     ++E Data:=Record(age:Integer,gender:String)
+     ++E a1:AssociationList(String,Data):=table()
+     ++E a1."tim":=[55,"male"]$Data
 
    table: List Record(key:Key,entry:Entry) -> %
      ++ table([x,y,...,z]) creates a table consisting of entries
@@ -1326,6 +1441,10 @@ TableAggregate(Key:SetCategory, Entry:SetCategory): Category ==
 
 @
 \section{category RCAGG RecursiveAggregate}
+<<dot>>=
+"RCAGG" -> "HOAGG"
+"RecursiveAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"
+@
 <<category RCAGG RecursiveAggregate>>=
 )abbrev category RCAGG RecursiveAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -1435,6 +1554,10 @@ Note that this code is not included in the generated catdef.spad file.
 (MAKEPROP (QUOTE |RecursiveAggregate&|) (QUOTE |infovec|) (LIST (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) (0 . |value|) (QUOTE "value") |RCAGG-;elt;AvalueS;1| (5 . |setvalue!|) (11 . |setelt|) (|List| |$|) (18 . |children|) (|Boolean|) (|List| 6) (23 . |member?|) (29 . |child?|))) (QUOTE #(|setelt| 35 |elt| 42 |child?| 48)) (QUOTE NIL) (CONS (|makeByteWordVec2| 1 (QUOTE NIL)) (CONS (QUOTE #()) (CONS (QUOTE #()) (|makeByteWordVec2| 18 (QUOTE (1 6 7 0 8 2 6 7 0 7 11 3 0 7 0 9 7 12 1 6 13 0 14 2 16 15 6 0 17 2 0 15 0 0 18 3 0 7 0 9 7 12 2 0 7 0 9 10 2 0 15 0 0 18)))))) (QUOTE |lookupComplete|))) 
 @
 \section{category BRAGG BinaryRecursiveAggregate}
+<<dot>>=
+"BRAGG" -> "RCAGG"
+"BinaryRecursiveAggregate(a:Type)" -> "RecursiveAggregate(a:Type)"
+@
 <<category BRAGG BinaryRecursiveAggregate>>=
 )abbrev category BRAGG BinaryRecursiveAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -1550,6 +1673,10 @@ BinaryRecursiveAggregate(S:Type):Category == RecursiveAggregate S with
 
 @
 \section{category DLAGG DoublyLinkedAggregate}
+<<dot>>=
+"DLAGG" -> "RCAGG"
+"DoublyLinkedAggregate(a:Type)" -> "RecursiveAggregate(a:Type)"
+@
 <<category DLAGG DoublyLinkedAggregate>>=
 )abbrev category DLAGG DoublyLinkedAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -1596,6 +1723,10 @@ DoublyLinkedAggregate(S:Type): Category == RecursiveAggregate S with
 
 @
 \section{category URAGG UnaryRecursiveAggregate}
+<<dot>>=
+"URAGG" -> "RCAGG"
+"UnaryRecursiveAggregate(a:Type)" -> "RecursiveAggregate(a:Type)"
+@
 <<category URAGG UnaryRecursiveAggregate>>=
 )abbrev category URAGG UnaryRecursiveAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -1619,196 +1750,90 @@ DoublyLinkedAggregate(S:Type): Category == RecursiveAggregate S with
 ++ Since these aggregates are recursive aggregates, they may be cyclic.
 UnaryRecursiveAggregate(S:Type): Category == RecursiveAggregate S with
    concat: (%,%) -> %
-     ++ concat(u,v) returns an aggregate w consisting of the elements of u
-     ++ followed by the elements of v.
-     ++ Note: \axiom{v = rest(w,#a)}.
-     ++
-     ++X m:=[1,2,3]      
-     ++X concat(5,m)
-
+      ++ concat(u,v) returns an aggregate w consisting of the elements of u
+      ++ followed by the elements of v.
+      ++ Note: \axiom{v = rest(w,#a)}.
    concat: (S,%) -> %
-     ++ concat(x,u) returns aggregate consisting of x followed by
-     ++ the elements of u.
-     ++ Note: if \axiom{v = concat(x,u)} then \axiom{x = first v}
-     ++ and \axiom{u = rest v}.
-     ++
-     ++X m:=[1,2,3]      
-     ++X concat(m,m)
-
+      ++ concat(x,u) returns aggregate consisting of x followed by
+      ++ the elements of u.
+      ++ Note: if \axiom{v = concat(x,u)} then \axiom{x = first v}
+      ++ and \axiom{u = rest v}.
    first: % -> S
-     ++ first(u) returns the first element of u
-     ++ (equivalently, the value at the current node).
-     ++
-     ++X m:=[1,2,3]      
-     ++X first(m)
-
+      ++ first(u) returns the first element of u
+      ++ (equivalently, the value at the current node).
    elt: (%,"first") -> S
-     ++ elt(u,"first") (also written: \axiom{u . first}) is 
-     ++equivalent to first u.
-
+      ++ elt(u,"first") (also written: \axiom{u . first}) is equivalent to first u.
    first: (%,NonNegativeInteger) -> %
-     ++ first(u,n) returns a copy of the first n 
-     ++ (\axiom{n >= 0}) elements of u.
-     ++
-     ++X m:=[1,2,3]      
-     ++X first(m,2)
-
+      ++ first(u,n) returns a copy of the first n (\axiom{n >= 0}) elements of u.
    rest: % -> %
-     ++ rest(u) returns an aggregate consisting of all but the first
-     ++ element of u
-     ++ (equivalently, the next node of u).
-     ++
-     ++X m:=[1,2,3]      
-     ++X rest m
-
+      ++ rest(u) returns an aggregate consisting of all but the first
+      ++ element of u
+      ++ (equivalently, the next node of u).
    elt: (%,"rest") -> %
-     ++ elt(%,"rest") (also written: \axiom{u.rest}) is
-     ++ equivalent to \axiom{rest u}.
-
+      ++ elt(%,"rest") (also written: \axiom{u.rest}) is
+      ++ equivalent to \axiom{rest u}.
    rest: (%,NonNegativeInteger) -> %
-     ++ rest(u,n) returns the \axiom{n}th (n >= 0) node of u.
-     ++ Note: \axiom{rest(u,0) = u}.
-     ++
-     ++X m:=[1,2,3]      
-     ++X rest(m,2)
-
+      ++ rest(u,n) returns the \axiom{n}th (n >= 0) node of u.
+      ++ Note: \axiom{rest(u,0) = u}.
    last: % -> S
-     ++ last(u) resturn the last element of u.
-     ++ Note: for lists, \axiom{last(u) = u . (maxIndex u) = u . (# u - 1)}.
-     ++
-     ++X m:=[1,2,3]      
-     ++X last m
-
+      ++ last(u) resturn the last element of u.
+      ++ Note: for lists, \axiom{last(u) = u . (maxIndex u) = u . (# u - 1)}.
    elt: (%,"last") -> S
-     ++ elt(u,"last") (also written: \axiom{u . last}) is equivalent to last u.
-
+      ++ elt(u,"last") (also written: \axiom{u . last}) is equivalent to last u.
    last: (%,NonNegativeInteger) -> %
-     ++ last(u,n) returns a copy of the last n (\axiom{n >= 0}) nodes of u.
-     ++ Note: \axiom{last(u,n)} is a list of n elements.
-     ++
-     ++X m:=[1,2,3]      
-     ++X last(m,2)
-
+      ++ last(u,n) returns a copy of the last n (\axiom{n >= 0}) nodes of u.
+      ++ Note: \axiom{last(u,n)} is a list of n elements.
    tail: % -> %
-     ++ tail(u) returns the last node of u.
-     ++ Note: if u is \axiom{shallowlyMutable},
-     ++ \axiom{setrest(tail(u),v) = concat(u,v)}.
-     ++
-     ++X m:=[1,2,3]      
-     ++X last(m,2)
-
+      ++ tail(u) returns the last node of u.
+      ++ Note: if u is \axiom{shallowlyMutable},
+      ++ \axiom{setrest(tail(u),v) = concat(u,v)}.
    second: % -> S
-     ++ second(u) returns the second element of u.
-     ++ Note: \axiom{second(u) = first(rest(u))}.
-     ++
-     ++X m:=[1,2,3]      
-     ++X second m
-
+      ++ second(u) returns the second element of u.
+      ++ Note: \axiom{second(u) = first(rest(u))}.
    third: % -> S
-     ++ third(u) returns the third element of u.
-     ++ Note: \axiom{third(u) = first(rest(rest(u)))}.
-     ++
-     ++X m:=[1,2,3]      
-     ++X third m
-
+      ++ third(u) returns the third element of u.
+      ++ Note: \axiom{third(u) = first(rest(rest(u)))}.
    cycleEntry: % -> %
-     ++ cycleEntry(u) returns the head of a top-level cycle contained in
-     ++ aggregate u, or \axiom{empty()} if none exists.
-     ++
-     ++X m:=[1,2,3]      
-     ++X concat!(m,tail(m))
-     ++X cycleEntry m
-
+      ++ cycleEntry(u) returns the head of a top-level cycle contained in
+      ++ aggregate u, or \axiom{empty()} if none exists.
    cycleLength: % -> NonNegativeInteger
-     ++ cycleLength(u) returns the length of a top-level cycle
-     ++ contained  in aggregate u, or 0 is u has no such cycle.
-     ++
-     ++X m:=[1,2,3]      
-     ++X concat!(m,tail(m))
-     ++X cycleLength m
-
+      ++ cycleLength(u) returns the length of a top-level cycle
+      ++ contained  in aggregate u, or 0 is u has no such cycle.
    cycleTail: % -> %
-     ++ cycleTail(u) returns the last node in the cycle, or
-     ++ empty if none exists.
-     ++
-     ++X m:=[1,2,3]      
-     ++X concat!(m,tail(m))
-     ++X cycleTail m
-
+      ++ cycleTail(u) returns the last node in the cycle, or
+      ++ empty if none exists.
    if % has shallowlyMutable then
       concat_!: (%,%) -> %
 	++ concat!(u,v) destructively concatenates v to the end of u.
 	++ Note: \axiom{concat!(u,v) = setlast_!(u,v)}.
-        ++
-        ++X m:=[1,2,3]
-        ++X n:=[4,5,6]
-        ++X concat!(m,n)
-
       concat_!: (%,S) -> %
 	++ concat!(u,x) destructively adds element x to the end of u.
 	++ Note: \axiom{concat!(a,x) = setlast!(a,[x])}.
-        ++
-        ++X m:=[1,2,3]      
-        ++X concat!(m,5)
-
       cycleSplit_!: % -> %
 	++ cycleSplit!(u) splits the aggregate by dropping off the cycle.
 	++ The value returned is the cycle entry, or nil if none exists.
-	++ If \axiom{w = concat(u,v)} is the cyclic list where v is
+	++ For example, if \axiom{w = concat(u,v)} is the cyclic list where v is
 	++ the head of the cycle, \axiom{cycleSplit!(w)} will drop v off w thus
 	++ destructively changing w to u, and returning v.
-        ++
-        ++X m:=[1,2,3]
-        ++X concat!(m,m)
-        ++X n:=[4,5,6]
-        ++X p:=concat(n,m)
-        ++X q:=cycleSplit! p
-        ++X p
-        ++X q
-
       setfirst_!: (%,S) -> S
 	++ setfirst!(u,x) destructively changes the first element of a to x.
-        ++ 
-        ++X m:=[1,2,3]
-        ++X setfirst!(m,4)
-        ++X m
-
       setelt: (%,"first",S) -> S
 	++ setelt(u,"first",x) (also written: \axiom{u.first := x}) is
 	++ equivalent to \axiom{setfirst!(u,x)}.
-
       setrest_!: (%,%) -> %
 	++ setrest!(u,v) destructively changes the rest of u to v.
-        ++
-        ++X m:=[1,2,3]
-        ++X setrest!(m,[4,5,6])
-        ++X m
-
       setelt: (%,"rest",%) -> %
-	++ setelt(u,"rest",v) (also written: \axiom{u.rest := v}) 
-	++ is equivalent to \axiom{setrest!(u,v)}.
-
+	++ setelt(u,"rest",v) (also written: \axiom{u.rest := v}) is equivalent to
+	++ \axiom{setrest!(u,v)}.
       setlast_!: (%,S) -> S
 	++ setlast!(u,x) destructively changes the last element of u to x.
-        ++
-        ++X m:=[1,2,3]
-        ++X setlast!(m,4)
-        ++X m
-
       setelt: (%,"last",S) -> S
 	++ setelt(u,"last",x) (also written: \axiom{u.last := b})
 	++ is equivalent to \axiom{setlast!(u,v)}.
-
       split_!: (%,Integer) -> %
-	++ split!(u,n) splits u into two aggregates: \axiom{v = rest(u,n)}
-	++ and \axiom{w = first(u,n)}, returning \axiom{v}.
-	++ Note: afterwards \axiom{rest(u,n)} returns \axiom{empty()}.
-        ++
-        ++X m:=[1,2,3,4]
-        ++X n:=split!(m,2)
-        ++X m
-        ++X n
-
+	 ++ split!(u,n) splits u into two aggregates: \axiom{v = rest(u,n)}
+	 ++ and \axiom{w = first(u,n)}, returning \axiom{v}.
+	 ++ Note: afterwards \axiom{rest(u,n)} returns \axiom{empty()}.
  add
   cycleMax ==> 1000
 
@@ -2068,6 +2093,12 @@ Note that this code is not included in the generated catdef.spad file.
 (MAKEPROP (QUOTE |UnaryRecursiveAggregate&|) (QUOTE |infovec|) (LIST (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) (0 . |first|) (QUOTE "first") |URAGG-;elt;AfirstS;1| (5 . |last|) (QUOTE "last") |URAGG-;elt;AlastS;2| (10 . |rest|) (QUOTE "rest") |URAGG-;elt;ArestA;3| |URAGG-;second;AS;4| |URAGG-;third;AS;5| (|Boolean|) (15 . |empty?|) |URAGG-;cyclic?;AB;6| (20 . |tail|) |URAGG-;last;AS;7| (|List| |$|) |URAGG-;nodes;AL;8| |URAGG-;children;AL;9| |URAGG-;leaf?;AB;10| |URAGG-;value;AS;11| (|NonNegativeInteger|) |URAGG-;less?;ANniB;12| |URAGG-;more?;ANniB;13| |URAGG-;size?;ANniB;14| (25 . |cyclic?|) |URAGG-;#;ANni;15| |URAGG-;tail;2A;16| (30 . |eq?|) (36 . |cycleEntry|) |URAGG-;cycleTail;2A;18| |URAGG-;cycleEntry;2A;19| |URAGG-;cycleLength;ANni;20| |URAGG-;rest;ANniA;21| (41 . |#|) (46 . |rest|) (52 . |copy|) (57 . |last|) (63 . |=|) (69 . |=|) (75 . |=|) (81 . |node?|) (87 . |setfirst!|) (93 . |setelt|) (100 . |setlast!|) (106 . |setelt|) (113 . |setrest!|) (1!
19 . |setelt|) (126 . |concat!|) (132 . |concat|) (138 . |setlast!|) (144 . |setchildren!|) (150 . |setvalue!|) (156 . |empty|) (|Integer|) (160 . |split!|) (166 . |cycleSplit!|) (QUOTE "value"))) (QUOTE #(|value| 171 |third| 176 |tail| 181 |split!| 186 |size?| 192 |setvalue!| 198 |setlast!| 204 |setelt| 210 |setchildren!| 231 |second| 237 |rest| 242 |nodes| 248 |node?| 253 |more?| 259 |less?| 265 |leaf?| 271 |last| 276 |elt| 287 |cyclic?| 305 |cycleTail| 310 |cycleSplit!| 315 |cycleLength| 320 |cycleEntry| 325 |concat| 330 |children| 336 |=| 341 |#| 347)) (QUOTE NIL) (CONS (|makeByteWordVec2| 1 (QUOTE NIL)) (CONS (QUOTE #()) (CONS (QUOTE #()) (|makeByteWordVec2| 64 (QUOTE (1 6 7 0 8 1 6 7 0 11 1 6 0 0 14 1 6 19 0 20 1 6 0 0 22 1 6 19 0 33 2 6 19 0 0 36 1 6 0 0 37 1 6 29 0 42 2 6 0 0 29 43 1 6 0 0 44 2 0 0 0 29 45 2 7 19 0 0 46 2 0 19 0 0 47 2 6 19 0 0 48 2 0 19 0 0 49 2 6 7 0 7 50 3 0 7 0 9 7 51 2 6 7 0 7 52 3 0 7 0 12 7 53 2 6 0 0 0 54 3 0 0 0 15 0 55 2 6 0 0 0 56 2 0 0 0 !
0 57 2 0 7 0 7 58 2 0 0 0 24 59 2 0 7 0 7 60 0 6 0 61 2 0 0 0!
 62 63 1 0 0 0 64 1 0 7 0 28 1 0 7 0 18 1 0 0 0 35 2 0 0 0 62 63 2 0 19 0 29 32 2 0 7 0 7 60 2 0 7 0 7 58 3 0 7 0 12 7 53 3 0 0 0 15 0 55 3 0 7 0 9 7 51 2 0 0 0 24 59 1 0 7 0 17 2 0 0 0 29 41 1 0 24 0 25 2 0 19 0 0 49 2 0 19 0 29 31 2 0 19 0 29 30 1 0 19 0 27 2 0 0 0 29 45 1 0 7 0 23 2 0 7 0 12 13 2 0 0 0 15 16 2 0 7 0 9 10 1 0 19 0 21 1 0 0 0 38 1 0 0 0 64 1 0 29 0 40 1 0 0 0 39 2 0 0 0 0 57 1 0 24 0 26 2 0 19 0 0 47 1 0 29 0 34)))))) (QUOTE |lookupComplete|))) 
 @
 \section{category STAGG StreamAggregate}
+<<dot>>=
+"STAGG" -> "RCAGG"
+"StreamAggregate(a:Type)" -> "RecursiveAggregate(a:Type)"
+"STAGG" -> "LNAGG"
+"StreamAggregate(a:Type)" -> "LinearAggregate(a:Type)"
+@
 <<category STAGG StreamAggregate>>=
 )abbrev category STAGG StreamAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -2223,6 +2254,12 @@ Note that this code is not included in the generated catdef.spad file.
 (MAKEPROP (QUOTE |StreamAggregate&|) (QUOTE |infovec|) (LIST (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) (|Boolean|) (0 . |cyclic?|) |STAGG-;explicitlyFinite?;AB;1| |STAGG-;possiblyInfinite?;AB;2| (5 . |rest|) (|List| 7) (10 . |construct|) (|NonNegativeInteger|) |STAGG-;first;ANniA;3| (15 . |empty?|) (20 . |first|) (|Integer|) (25 . |minIndex|) (30 . |rest|) |STAGG-;elt;AIS;5| (|UniversalSegment| 19) (36 . |lo|) (41 . |hasHi|) (46 . |copy|) (51 . |hi|) (56 . |empty|) (60 . |first|) |STAGG-;elt;AUsA;6| (66 . |concat!|) (72 . |concat|) (|List| |$|) (78 . |concat|) (83 . |concat|) (88 . |setfirst!|) (|Mapping| 7 7) (94 . |map!|) (100 . |fill!|) (106 . |setelt|) (113 . |maxIndex|) (118 . |eq?|) (124 . |setelt|) (131 . |tail|) (136 . |setrest!|) (142 . |concat!|) (QUOTE "rest") (QUOTE "last") (QUOTE "first") (QUOTE "value"))) (QUOTE #(|setelt| 148 |possiblyInfinite?| 162 |map!| 167 |first| 173 |fill!| 179 |explicitlyFinite?| 185 |elt| 190 |concat!| 202 |concat!
| 208)) (QUOTE NIL) (CONS (|makeByteWordVec2| 1 (QUOTE NIL)) (CONS (QUOTE #()) (CONS (QUOTE #()) (|makeByteWordVec2| 46 (QUOTE (1 6 8 0 9 1 6 0 0 12 1 6 0 13 14 1 6 8 0 17 1 6 7 0 18 1 6 19 0 20 2 6 0 0 15 21 1 23 19 0 24 1 23 8 0 25 1 6 0 0 26 1 23 19 0 27 0 6 0 28 2 6 0 0 15 29 2 6 0 0 0 31 2 0 0 0 0 32 1 6 0 33 34 1 0 0 33 35 2 6 7 0 7 36 2 0 0 37 0 38 2 0 0 0 7 39 3 0 7 0 19 7 40 1 6 19 0 41 2 6 8 0 0 42 3 0 7 0 23 7 43 1 6 0 0 44 2 6 0 0 0 45 2 0 0 0 0 46 3 0 7 0 19 7 40 3 0 7 0 23 7 43 1 0 8 0 11 2 0 0 37 0 38 2 0 0 0 15 16 2 0 0 0 7 39 1 0 8 0 10 2 0 7 0 19 22 2 0 0 0 23 30 2 0 0 0 0 46 1 0 0 33 35 2 0 0 0 0 32)))))) (QUOTE |lookupComplete|))) 
 @
 \section{category LNAGG LinearAggregate}
+<<dot>>=
+"LNAGG" -> "IXAGG"
+"LinearAggregate(a:Type)" -> "IndexedAggregate(b:Integer,a:Type)"
+"LNAGG" -> "CLAGG"
+"LinearAggregate(a:Type)" -> "Collection(a:Type)"
+@
 <<category LNAGG LinearAggregate>>=
 )abbrev category LNAGG LinearAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -2358,6 +2395,10 @@ Note that this code is not included in the generated catdef.spad file.
 (MAKEPROP (QUOTE |LinearAggregate&|) (QUOTE |infovec|) (LIST (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) (|Integer|) (0 . |minIndex|) (5 . |maxIndex|) (|List| 8) |LNAGG-;indices;AL;1| (|Boolean|) |LNAGG-;index?;IAB;2| (|NonNegativeInteger|) (10 . |new|) (16 . |concat|) |LNAGG-;concat;ASA;3| |LNAGG-;concat;S2A;4| (22 . |insert|) |LNAGG-;insert;SAIA;5| (29 . |#|) (34 . |maxIndex|) (|List| |$|))) (QUOTE #(|maxIndex| 39 |insert| 44 |indices| 51 |index?| 56 |concat| 62)) (QUOTE NIL) (CONS (|makeByteWordVec2| 1 (QUOTE NIL)) (CONS (QUOTE #()) (CONS (QUOTE #()) (|makeByteWordVec2| 23 (QUOTE (1 6 8 0 9 1 6 8 0 10 2 6 0 15 7 16 2 6 0 0 0 17 3 6 0 0 0 8 20 1 6 15 0 22 1 0 8 0 23 1 0 8 0 23 3 0 0 7 0 8 21 1 0 11 0 12 2 0 13 8 0 14 2 0 0 0 7 18 2 0 0 7 0 19)))))) (QUOTE |lookupComplete|))) 
 @
 \section{category FLAGG FiniteLinearAggregate}
+<<dot>>=
+"FLAGG" -> "LNAGG"
+"FiniteLinearAggregate(a:Type)" -> "LinearAggregate(a:Type)"
+@
 <<category FLAGG FiniteLinearAggregate>>=
 )abbrev category FLAGG FiniteLinearAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -2441,6 +2482,15 @@ FiniteLinearAggregate(S:Type): Category == LinearAggregate S with
 
 @
 \section{category A1AGG OneDimensionalArrayAggregate}
+<<dot>>=
+"A1AGG" -> "FLAGG"
+"OneDimensionalArrayAggregate(a:Type)" -> 
+    "FiniteLinearAggregate(a:Type)"
+"OneDimensionalArrayAggregate(Character)" ->
+    "OneDimensionalArrayAggregate(a:Type)"
+"OneDimensionalArrayAggregate(Boolean)" ->    
+    "OneDimensionalArrayAggregate(a:Type)"
+@
 <<category A1AGG OneDimensionalArrayAggregate>>=
 )abbrev category A1AGG OneDimensionalArrayAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -2689,6 +2739,10 @@ OneDimensionalArrayAggregate(S:Type): Category ==
 
 @
 \section{category ELAGG ExtensibleLinearAggregate}
+<<dot>>=
+"ELAGG" -> "LNAGG"
+"ExtensibleLinearAggregate(a:Type)" -> "LinearAggregate(a:Type)"
+@
 <<category ELAGG ExtensibleLinearAggregate>>=
 )abbrev category ELAGG ExtensibleLinearAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -2717,10 +2771,10 @@ ExtensibleLinearAggregate(S:Type):Category == LinearAggregate S with
    delete_!: (%,Integer) -> %
      ++ delete!(u,i) destructively deletes the \axiom{i}th element of u.
      ++
-     ++X Data:=Record(age:Integer,gender:String)
-     ++X a1:AssociationList(String,Data):=table()
-     ++X a1."tim":=[55,"male"]$Data
-     ++X delete!(a1,1)
+     ++E Data:=Record(age:Integer,gender:String)
+     ++E a1:AssociationList(String,Data):=table()
+     ++E a1."tim":=[55,"male"]$Data
+     ++E delete!(a1,1)
 
    delete_!: (%,UniversalSegment(Integer)) -> %
      ++ delete!(u,i..j) destructively deletes elements u.i through u.j.
@@ -2763,6 +2817,12 @@ ExtensibleLinearAggregate(S:Type):Category == LinearAggregate S with
 
 @
 \section{category LSAGG ListAggregate}
+<<dot>>=
+"LSAGG" -> "FLAGG"
+"ListAggregate(a:Type)" -> "FiniteLinearAggregate(a:Type)"
+"LSAGG" -> "ELAGG"
+"ListAggregate(a:Type)" -> "ExtensibleLinearAggregate(a:Type)"
+@
 <<category LSAGG ListAggregate>>=
 )abbrev category LSAGG ListAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -3073,6 +3133,14 @@ Note that this code is not included in the generated catdef.spad file.
 (MAKEPROP (QUOTE |ListAggregate&|) (QUOTE |infovec|) (LIST (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) (|NonNegativeInteger|) (0 . |#|) (|Mapping| 15 7 7) |LSAGG-;sort!;M2A;1| (5 . |empty|) (9 . |concat|) |LSAGG-;list;SA;2| (|Boolean|) (15 . |empty?|) (20 . |rest|) (25 . |first|) (|Mapping| 7 7 7) (30 . |reduce|) |LSAGG-;reduce;MAS;3| (37 . |copy|) (42 . |merge!|) |LSAGG-;merge;M3A;4| (49 . |setrest!|) (|Mapping| 15 7) |LSAGG-;select!;M2A;5| (55 . |eq?|) |LSAGG-;merge!;M3A;6| (|Integer|) (61 . |minIndex|) (66 . |rest|) |LSAGG-;insert!;SAIA;7| (72 . |concat!|) |LSAGG-;insert!;2AIA;8| |LSAGG-;remove!;M2A;9| |LSAGG-;delete!;AIA;10| (|UniversalSegment| 30) (78 . |lo|) (83 . |hasHi|) (88 . |hi|) (93 . |maxIndex|) |LSAGG-;delete!;AUsA;11| (|Union| 7 (QUOTE "failed")) |LSAGG-;find;MAU;12| |LSAGG-;position;MAI;13| (98 . |reverse!|) (103 . |split!|) |LSAGG-;sorted?;MAB;15| |LSAGG-;reduce;MA2S;16| (109 . |=|) (115 . |reduce|) |LSAGG-;new;NniSA;18| |LSAGG-;map;M3A;1!
9| |LSAGG-;reverse!;2A;20| (123 . |cyclic?|) |LSAGG-;copy;2A;21| (128 . |setfirst!|) |LSAGG-;copyInto!;2AIA;22| (134 . |position|) (141 . |remove!|) (147 . |removeDuplicates!|) (152 . |<|) (158 . |<|) (|Mapping| 7 7))) (QUOTE #(|sorted?| 164 |sort!| 170 |select!| 176 |reverse!| 182 |removeDuplicates!| 187 |remove!| 192 |reduce| 198 |position| 219 |new| 232 |merge!| 238 |merge| 245 |map| 252 |list| 259 |insert!| 264 |find| 278 |delete!| 284 |copyInto!| 296 |copy| 303 |<| 308)) (QUOTE NIL) (CONS (|makeByteWordVec2| 1 (QUOTE NIL)) (CONS (QUOTE #()) (CONS (QUOTE #()) (|makeByteWordVec2| 64 (QUOTE (1 6 8 0 9 0 6 0 12 2 6 0 7 0 13 1 6 15 0 16 1 6 0 0 17 1 6 7 0 18 3 6 7 19 0 7 20 1 6 0 0 22 3 6 0 10 0 0 23 2 6 0 0 0 25 2 6 15 0 0 28 1 6 30 0 31 2 6 0 0 8 32 2 6 0 0 0 34 1 38 30 0 39 1 38 15 0 40 1 38 30 0 41 1 6 30 0 42 1 6 0 0 47 2 6 0 0 30 48 2 7 15 0 0 51 4 0 7 19 0 7 7 52 1 6 15 0 56 2 6 7 0 7 58 3 0 30 7 0 30 60 2 6 0 26 0 61 1 0 0 0 62 2 7 15 0 0 63 2 0 15 0 0 64 2 0 15 10 0!
 49 2 0 0 10 0 11 2 0 0 26 0 27 1 0 0 0 55 1 0 0 0 62 2 0 0 2!
6 0 36 3 0 7 19 0 7 50 4 0 7 19 0 7 7 52 2 0 7 19 0 21 2 0 30 26 0 46 3 0 30 7 0 30 60 2 0 0 8 7 53 3 0 0 10 0 0 29 3 0 0 10 0 0 24 3 0 0 19 0 0 54 1 0 0 7 14 3 0 0 7 0 30 33 3 0 0 0 0 30 35 2 0 44 26 0 45 2 0 0 0 38 43 2 0 0 0 30 37 3 0 0 0 0 30 59 1 0 0 0 57 2 0 15 0 0 64)))))) (QUOTE |lookupComplete|))) 
 @
 \section{category ALAGG AssociationListAggregate}
+<<dot>>=
+"ALAGG" -> "TBAGG"
+"AssociationListAggregate(a:SetCategory,b:SetCategory)" ->
+    "TableAggregate(a:SetCategory,b:SetCategory)"
+"ALAGG" -> "LSAGG"
+"AssociationListAggregate(a:SetCategory,b:SetCategory)" ->
+    "ListAggregate(Record(a:SetCategory,b:SetCategory))"
+@
 <<category ALAGG AssociationListAggregate>>=
 )abbrev category ALAGG AssociationListAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
@@ -3117,6 +3185,10 @@ Note that this code is not included in the generated catdef.spad file.
 (DEFUN |AssociationListAggregate;| (|t#1| |t#2|) (PROG (#1=#:G88401) (RETURN (PROG1 (LETT #1# (|sublisV| (PAIR (QUOTE (|t#1| |t#2|)) (LIST (|devaluate| |t#1|) (|devaluate| |t#2|))) (|sublisV| (PAIR (QUOTE (#2=#:G88400)) (LIST (QUOTE (|Record| (|:| |key| |t#1|) (|:| |entry| |t#2|))))) (COND (|AssociationListAggregate;CAT|) ((QUOTE T) (LETT |AssociationListAggregate;CAT| (|Join| (|TableAggregate| (QUOTE |t#1|) (QUOTE |t#2|)) (|ListAggregate| (QUOTE #2#)) (|mkCategory| (QUOTE |domain|) (QUOTE (((|assoc| ((|Union| (|Record| (|:| |key| |t#1|) (|:| |entry| |t#2|)) "failed") |t#1| |$|)) T))) NIL (QUOTE NIL) NIL)) . #3=(|AssociationListAggregate|)))))) . #3#) (SETELT #1# 0 (LIST (QUOTE |AssociationListAggregate|) (|devaluate| |t#1|) (|devaluate| |t#2|))))))) 
 @
 \section{category SRAGG StringAggregate}
+<<dot>>=
+"SRAGG" -> "A1AGG"
+"StringAggregate()" -> "OneDimensionalArrayAggregate(Character)"
+@
 <<category SRAGG StringAggregate>>=
 )abbrev category SRAGG StringAggregate
 ++ Author: Stephen Watt and Michael Monagan. revised by Manuel Bronstein and Richard Jenks
@@ -3219,6 +3291,14 @@ StringAggregate: Category == OneDimensionalArrayAggregate Character with
 
 @
 \section{category BTAGG BitAggregate}
+<<dot>>=
+"BTAGG" -> "ORDSET"
+"BitAggregate()" -> "OrderedSet()"
+"BTAGG" -> "LOGIC"
+"BitAggregate()" -> "Logic()"
+"BTAGG" -> "A1AGG"
+"BitAggregate()" -> "OneDimensionalArrayAggregate(Boolean)"
+@
 <<category BTAGG BitAggregate>>=
 )abbrev category BTAGG BitAggregate
 ++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks



From MAILER-DAEMON Sun Aug 31 00:34:16 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KZedk-00013G-1g
	for mharc-axiom-developer@gnu.org; Sun, 31 Aug 2008 00:34:16 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KZedi-000136-3d
	for axiom-developer@nongnu.org; Sun, 31 Aug 2008 00:34:14 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KZedd-00012m-4s
	for axiom-developer@nongnu.org; Sun, 31 Aug 2008 00:34:12 -0400
Received: from [199.232.76.173] (port=58814 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KZedc-00012c-S1
	for axiom-developer@nongnu.org; Sun, 31 Aug 2008 00:34:08 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:56331
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KZedb-0006k8-5m
	for axiom-developer@nongnu.org; Sun, 31 Aug 2008 00:34:08 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m7V4Xxr3016217;
	Sat, 30 Aug 2008 23:33:59 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m7V4Xxth016214;
	Sat, 30 Aug 2008 23:33:59 -0500
Date: Sat, 30 Aug 2008 23:33:59 -0500
Message-Id: <200808310433.m7V4Xxth016214@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by monty-python.gnu.org: Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20080830.01.tpd.patch (graphviz dotfile
	decoration)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 31 Aug 2008 04:34:14 -0000

dot file decoration is now available for:
trigcat si sf pscat pattern patmatch1 omcat misc integer equation1
coerce catdef boolean bags algcat aggcat2 acplot

======================================================================
diff --git a/changelog b/changelog
index 187f1c4..2a699f6 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,20 @@
+20080830 tpd src/algebra/trigcat.spad graphviz dotfile decoration
+20080830 tpd src/algebra/si.spad graphviz dotfile decoration
+20080830 tpd src/algebra/sf.spad graphviz dotfile decoration
+20080830 tpd src/algebra/pscat.spad graphviz dotfile decoration
+20080830 tpd src/algebra/pattern.spad graphviz dotfile decoration
+20080830 tpd src/algebra/patmatch1.spad graphviz dotfile decoration
+20080830 tpd src/algebra/omcat.spad graphviz dotfile decoration
+20080830 tpd src/algebra/misc.spad graphviz dotfile decoration
+20080830 tpd src/algebra/integer.spad graphviz dotfile decoration
+20080830 tpd src/algebra/equation1.spad graphviz dotfile decoration
+20080830 tpd src/algebra/coerce.spad graphviz dotfile decoration
+20080830 tpd src/algebra/catdef.spad graphviz dotfile decoration
+20080830 tpd src/algebra/boolean.spad graphviz dotfile decoration
+20080830 tpd src/algebra/bags.spad graphviz dotfile decoration
+20080830 tpd src/algebra/algcat.spad graphviz dotfile decoration
+20080830 tpd src/algebra/aggcat2.spad graphviz dotfile decoration
+20080830 tpd src/algebra/acplot.spad graphviz dotfile decoration
 20080829 tpd src/algebra/aggcat.spad graphviz dotfile decoration
 20080828 mxr src/interp/i-funsel.boot add cost to bottomUp output
 20080827 wsp src/algebra/tex.spad change \over to \frac
diff --git a/src/algebra/acplot.spad.pamphlet b/src/algebra/acplot.spad.pamphlet
index a39e3b6..b76e71b 100644
--- a/src/algebra/acplot.spad.pamphlet
+++ b/src/algebra/acplot.spad.pamphlet
@@ -164,6 +164,10 @@ o $AXIOM/doc/src/algebra/acplot.spad.dvi
 
 @
 \subsection{realsolv code}
+<<dot>>=
+"REALSOLV" -> "PACKAGE"
+"RealSolvePackage()" -> "Package"
+@
 <<package REALSOLV RealSolvePackage>>=
 )abbrev package REALSOLV RealSolvePackage
 
@@ -247,6 +251,10 @@ o )show PlaneAlgebraicCurvePlot
 o $AXIOM/doc/src/algebra/acplot.spad.dvi 
 
 @
+<<dot>>=
+"ACPLOT" -> "PPCURVE"
+"PlaneAlgebraicCurvePlot()" -> "PlottablePlaneCurveCategory()"
+@
 <<domain ACPLOT PlaneAlgebraicCurvePlot>>=
 --% PlaneAlgebraicCurvePlot
 ++ Plot a NON-SINGULAR plane algebraic curve p(x,y) = 0.
diff --git a/src/algebra/aggcat2.spad.pamphlet b/src/algebra/aggcat2.spad.pamphlet
index 6a4c57b..be3a656 100644
--- a/src/algebra/aggcat2.spad.pamphlet
+++ b/src/algebra/aggcat2.spad.pamphlet
@@ -10,6 +10,10 @@
 \tableofcontents
 \eject
 \section{package FLAGG2 FiniteLinearAggregateFunctions2}
+<<dot>>=
+"FLAGG2" -> "PACKAGE"
+"FiniteLinearAggregateFunctions2()" -> "Package"
+@
 <<package FLAGG2 FiniteLinearAggregateFunctions2>>=
 )abbrev package FLAGG2 FiniteLinearAggregateFunctions2
 --% FiniteLinearAggregateFunctions2
@@ -126,6 +130,10 @@ FiniteLinearAggregateFunctions2(S, A, R, B):
 
 @
 \section{package FSAGG2 FiniteSetAggregateFunctions2}
+<<dot>>=
+"FSAGG2" -> "PACKAGE"
+"FiniteSetAggregateFunctions2()" -> "Package"
+@
 <<package FSAGG2 FiniteSetAggregateFunctions2>>=
 )abbrev package FSAGG2 FiniteSetAggregateFunctions2
 
diff --git a/src/algebra/algcat.spad.pamphlet b/src/algebra/algcat.spad.pamphlet
index 5c02831..0462ae2 100644
--- a/src/algebra/algcat.spad.pamphlet
+++ b/src/algebra/algcat.spad.pamphlet
@@ -10,6 +10,11 @@
 \tableofcontents
 \eject
 \section{category FINRALG FiniteRankAlgebra}
+<<dot>>=
+"FINRALG" -> "ALGEBRA"
+"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
+    "Algebra(a:CommutativeRing)"
+@
 <<category FINRALG FiniteRankAlgebra>>=
 )abbrev category FINRALG FiniteRankAlgebra
 ++ Author: Barry Trager
@@ -88,6 +93,11 @@ FiniteRankAlgebra(R:CommutativeRing, UP:UnivariatePolynomialCategory R):
 
 @
 \section{category FRAMALG FramedAlgebra}
+<<dot>>=
+"FRAMALG" -> "FINRALG"
+"FramedAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
+   "FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"
+@
 <<category FRAMALG FramedAlgebra>>=
 )abbrev category FRAMALG FramedAlgebra
 ++ Author: Barry Trager
@@ -179,6 +189,23 @@ FramedAlgebra(R:CommutativeRing, UP:UnivariatePolynomialCategory R):
 
 @
 \section{category MONOGEN MonogenicAlgebra}
+<<dot>>=
+"MONOGEN" -> "FRAMALG"
+"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
+    "FramedAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"
+"MONOGEN" -> "COMRING"
+"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
+    "CommutativeRing()"
+"MONOGEN" -> "KONVERT"
+"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
+    "ConvertibleTo(UnivariatePolynomialCategory(CommutativeRing))"
+"MONOGEN" -> "FRETRCT"
+"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
+    "FullyRetractableTo(a:CommutativeRing)"
+"MONOGEN" -> "FLINEXP"
+"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
+    "FullyLinearlyExplicitRingOver(a:CommutativeRing)"
+@
 <<category MONOGEN MonogenicAlgebra>>=
 )abbrev category MONOGEN MonogenicAlgebra
 ++ Author: Barry Trager
@@ -257,6 +284,11 @@ MonogenicAlgebra(R:CommutativeRing, UP:UnivariatePolynomialCategory R):
 
 @
 \section{package CPIMA CharacteristicPolynomialInMonogenicalAlgebra}
+<<dot>>=
+"CPIMA" -> "PACKAGE"
+"CharacteristicPolynomialInMonogenicalAlgebra(a:COMRING,b:UPOLYC(a),c:MONOGEN(a,b))"
+    -> "Package"
+@
 <<package CPIMA CharacteristicPolynomialInMonogenicalAlgebra>>=
 )abbrev package CPIMA CharacteristicPolynomialInMonogenicalAlgebra
 ++ Author: Claude Quitte
@@ -294,6 +326,11 @@ CharacteristicPolynomialInMonogenicalAlgebra(R : CommutativeRing,
 
 @
 \section{package NORMMA NormInMonogenicAlgebra}
+<<dot>>=
+"NORMMA" -> "PACKAGE"
+"NormInMonogenicAlgebra(a:GcdDomain,b:UPOLYC(a),c:MONOGEN(a,b),d:UPOLYC(c))"
+    -> "Package"
+@
 <<package NORMMA NormInMonogenicAlgebra>>=
 )abbrev package NORMMA NormInMonogenicAlgebra
 ++ Author: Manuel Bronstein
diff --git a/src/algebra/bags.spad.pamphlet b/src/algebra/bags.spad.pamphlet
index a2fe3f3..f5cc60d 100644
--- a/src/algebra/bags.spad.pamphlet
+++ b/src/algebra/bags.spad.pamphlet
@@ -10,6 +10,10 @@
 \tableofcontents
 \eject
 \section{domain STACK Stack}
+<<dot>>=
+"STACK" -> "SKAGG"
+"Stack(a:SetCategory)" -> "StackAggregate(a:SetCategory)"
+@
 <<domain STACK Stack>>=
 )abbrev domain STACK Stack
 ++ Author: Michael Monagan and Stephen Watt
@@ -32,7 +36,7 @@ Stack(S:SetCategory): StackAggregate S with
       ++ stack([x,y,...,z]) creates a stack with first (top)
       ++ element x, second element y,...,and last element z.
       ++
-      ++X a:Stack INT:= stack [1,2,3,4,5]
+      ++E a:Stack INT:= stack [1,2,3,4,5]
 
   == add
     Rep := Reference List S
@@ -59,6 +63,10 @@ Stack(S:SetCategory): StackAggregate S with
 
 @
 \section{domain ASTACK ArrayStack}
+<<dot>>=
+"ASTACK" -> "STACK"
+"ArrayStack(a:SetCategory)" -> "Stack(a:SetCategory)"
+@
 <<domain ASTACK ArrayStack>>=
 )abbrev domain ASTACK ArrayStack
 ++ Author: Michael Monagan and Stephen Watt
@@ -81,7 +89,7 @@ ArrayStack(S:SetCategory): StackAggregate(S) with
       ++ arrayStack([x,y,...,z]) creates an array stack with first (top)
       ++ element x, second element y,...,and last element z.
       ++
-      ++X c:ArrayStack INT:= arrayStack [1,2,3,4,5]
+      ++E c:ArrayStack INT:= arrayStack [1,2,3,4,5]
 
   == add
     Rep := IndexedFlexibleArray(S,0)
@@ -112,6 +120,10 @@ ArrayStack(S:SetCategory): StackAggregate(S) with
 
 @
 \section{domain QUEUE Queue}
+<<dot>>=
+"QUEUE" -> "QUAGG"
+"Queue(a:SetCategory)" -> "QueueAggregate(a:SetCategory)"
+@
 <<domain QUEUE Queue>>=
 )abbrev domain QUEUE Queue
 ++ Author: Michael Monagan and Stephen Watt
@@ -134,7 +146,7 @@ Queue(S:SetCategory): QueueAggregate S with
       ++ queue([x,y,...,z]) creates a queue with first (top)
       ++ element x, second element y,...,and last (bottom) element z.
       ++
-      ++X e:Queue INT:= queue [1,2,3,4,5]
+      ++E e:Queue INT:= queue [1,2,3,4,5]
 
   == Stack S add
     Rep := Reference List S
@@ -159,6 +171,10 @@ Queue(S:SetCategory): QueueAggregate S with
 
 @
 \section{domain DEQUEUE Dequeue}
+<<dot>>=
+"DEQUEUE" -> "DQAGG"
+"Dequeue(a:SetCategory)" -> "DequeueAggregate(a:SetCategory)"
+@
 <<domain DEQUEUE Dequeue>>=
 )abbrev domain DEQUEUE Dequeue
 ++ Author: Michael Monagan and Stephen Watt
@@ -181,7 +197,7 @@ Dequeue(S:SetCategory): DequeueAggregate S with
        ++ dequeue([x,y,...,z]) creates a dequeue with first (top or front)
        ++ element x, second element y,...,and last (bottom or back) element z.
        ++
-       ++X g:Dequeue INT:= dequeue [1,2,3,4,5]
+       ++E g:Dequeue INT:= dequeue [1,2,3,4,5]
 
   == Queue S add
     Rep := Reference List S
@@ -352,6 +368,10 @@ o )show Heap
 o $AXIOM/doc/src/algebra/bags.spad.dvi
 
 @
+<<dot>>=
+"HEAP" -> "PRQAGG"
+"Heap(a:OrderedSet)" -> "PriorityQueueAggregate(a:OrderedSet)"
+@
 <<domain HEAP Heap>>=
 )abbrev domain HEAP Heap
 ++ Author: Michael Monagan and Stephen Watt
@@ -376,7 +396,7 @@ Heap(S:OrderedSet): Exports == Implementation where
       ++ heap(ls) creates a heap of elements consisting of the 
       ++ elements of ls.
       ++
-      ++X i:Heap INT := heap [1,6,3,7,5,2,4]
+      ++E i:Heap INT := heap [1,6,3,7,5,2,4]
 
   Implementation == IndexedFlexibleArray(S,0) add
     Rep := IndexedFlexibleArray( S,0)
diff --git a/src/algebra/boolean.spad.pamphlet b/src/algebra/boolean.spad.pamphlet
index 84632fa..41e9347 100644
--- a/src/algebra/boolean.spad.pamphlet
+++ b/src/algebra/boolean.spad.pamphlet
@@ -10,6 +10,10 @@
 \tableofcontents
 \eject
 \section{domain REF Reference}
+<<dot>>=
+"REF" -> "TYPE"
+"Reference(a:Type)" -> "Type()"
+@
 <<domain REF Reference>>=
 )abbrev domain REF Reference
 ++ Author: Stephen M. Watt
@@ -95,6 +99,10 @@ Note that this code is not included in the generated catdef.spad file.
 (MAKEPROP (QUOTE |Reference|) (QUOTE |infovec|) (LIST (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (QUOTE |Rep|) (|Boolean|) |REF;=;2$B;1| |REF;ref;S$;2| |REF;elt;$S;3| |REF;setelt;$2S;4| |REF;deref;$S;5| |REF;setref;$2S;6| (|String|) (|OutputForm|) (0 . |message|) (5 . |coerce|) (|List| |$|) (10 . |prefix|) (16 . |coerce|) (|SingleInteger|))) (QUOTE #(|~=| 21 |setref| 27 |setelt| 33 |ref| 39 |latex| 44 |hash| 49 |elt| 54 |deref| 59 |coerce| 64 |=| 69)) (QUOTE NIL) (CONS (|makeByteWordVec2| 1 (QUOTE (1 0 1 1))) (CONS (QUOTE #(|SetCategory&| NIL |BasicType&| NIL)) (CONS (QUOTE #((|SetCategory|) (|Type|) (|BasicType|) (|CoercibleTo| 16))) (|makeByteWordVec2| 22 (QUOTE (1 16 0 15 17 1 6 16 0 18 2 16 0 0 19 20 1 0 16 0 21 2 1 8 0 0 1 2 0 6 0 6 14 2 0 6 0 6 12 1 0 0 6 10 1 1 15 0 1 1 1 22 0 1 1 0 6 0 11 1 0 6 0 13 1 1 16 0 21 2 0 8 0 0 9)))))) (QUOTE |lookupComplete|))) 
 @
 \section{category LOGIC Logic}
+<<dot>>=
+"LOGIC" -> "BASTYPE"
+"Logic()" -> "BasicType()"
+@
 <<category LOGIC Logic>>=
 )abbrev category LOGIC Logic
 ++ Author: 
@@ -106,8 +114,6 @@ Note that this code is not included in the generated catdef.spad file.
 ++ Description:  
 ++ `Logic' provides the basic operations for lattices,
 ++ e.g., boolean algebra.
-
-
 Logic: Category == BasicType with
        _~:        % -> %
 	++ ~(x) returns the logical complement of x.
@@ -120,6 +126,16 @@ Logic: Category == BasicType with
 
 @
 \section{domain BOOLEAN Boolean}
+<<dot>>=
+"BOOLEAN" -> "ORDSET"
+"Boolean()" -> "OrderedSet()"
+"BOOLEAN" -> "FINITE"
+"Boolean()" -> "Finite()"
+"BOOLEAN" -> "LOGIC"
+"Boolean()" -> "Logic()"
+"BOOLEAN" -> "KONVERT"
+"Boolean()" -> "ConvertibleTo(InputForm)"
+@
 <<domain BOOLEAN Boolean>>=
 )abbrev domain BOOLEAN Boolean
 ++ Author: Stephen M. Watt
@@ -458,6 +474,10 @@ This is eventually forcibly replaced by a recompiled version.
 
 @
 \section{domain IBITS IndexedBits}
+<<dot>>=
+"IBITS" -> "BTAGG"
+"IndexedBits(a:Integer)" -> "BitAggregate()"
+@
 <<domain IBITS IndexedBits>>=
 )abbrev domain IBITS IndexedBits
 ++ Author: Stephen Watt and Michael Monagan
@@ -520,6 +540,10 @@ IndexedBits(mn:Integer): BitAggregate() with
 
 @
 \section{domain BITS Bits}
+<<dot>>=
+"BITS" -> "BTAGG"
+"Bits()" -> "BitAggregate()"
+@
 <<domain BITS Bits>>=
 )abbrev domain BITS Bits
 ++ Author: Stephen M. Watt
diff --git a/src/algebra/catdef.spad.pamphlet b/src/algebra/catdef.spad.pamphlet
index 38c9a1c..b16f4b2 100644
--- a/src/algebra/catdef.spad.pamphlet
+++ b/src/algebra/catdef.spad.pamphlet
@@ -10,6 +10,10 @@
 \tableofcontents
 \eject
 \section{category ABELGRP AbelianGroup}
+<<dot>>=
+"ABELGRP" -> "CABMON"
+"AbelianGroup()" -> "CancellationAbelianMonoid()"
+@
 <<category ABELGRP AbelianGroup>>=
 )abbrev category ABELGRP AbelianGroup
 ++ Author:
@@ -178,6 +182,10 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{category ABELMON AbelianMonoid}
+<<dot>>=
+"ABELMON" -> "ABELSG"
+"AbelianMonoid()" -> "AbelianSemiGroup()"
+@
 <<category ABELMON AbelianMonoid>>=
 )abbrev category ABELMON AbelianMonoid
 ++ Author:
@@ -367,6 +375,10 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{category ABELSG AbelianSemiGroup}
+<<dot>>=
+"ABELSG" -> "SETCAT"
+"AbelianSemiGroup()" -> "SetCategory()"
+@
 <<category ABELSG AbelianSemiGroup>>=
 )abbrev category ABELSG AbelianSemiGroup
 ++ Author:
@@ -521,6 +533,13 @@ Note that this code is not included in the generated catdef.spad file.
     (QUOTE |lookupComplete|))) 
 @
 \section{category ALGEBRA Algebra}
+<<dot>>=
+"ALGEBRA" -> "RING"
+"Algebra(a:CommutativeRing)" -> "Ring()"
+"ALGEBRA" -> "MODULE"
+"Algebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"
+"Algebra(Fraction(Integer))" -> "Algebra(a:CommutativeRing)"
+@
 <<category ALGEBRA Algebra>>=
 )abbrev category ALGEBRA Algebra
 ++ Author:
@@ -551,6 +570,10 @@ Algebra(R:CommutativeRing): Category ==
 
 @
 \section{category BASTYPE BasicType}
+<<dot>>=
+"BASTYPE" -> "CATEGORY"
+"BasicType()" -> "Category"
+@
 <<category BASTYPE BasicType>>=
 )abbrev category BASTYPE BasicType
 --% BasicType
@@ -574,6 +597,14 @@ BasicType(): Category == with
 
 @
 \section{category BMODULE BiModule}
+<<dot>>=
+"BMODULE" -> "LMODULE"
+"BiModule(a:Ring,b:Ring)" -> "LeftModule(a:Ring)"
+"BiModule(a:CommutativeRing,b:CommutativeRing)" -> "BiModule(a:Ring,b:Ring)"
+"BiModule(a:Ring,b:OrderedAbelianMonoid)" -> "BiModule(a:Ring,b:Ring)"
+"BMODULE" -> "RMODULE"
+"BiModule(a:Ring,b:Ring)" -> "RightModule(a:Ring)"
+@
 <<category BMODULE BiModule>>=
 )abbrev category BMODULE BiModule
 ++ Author:
@@ -598,6 +629,10 @@ BiModule(R:Ring,S:Ring):Category ==
 
 @
 \section{category CABMON CancellationAbelianMonoid}
+<<dot>>=
+"CABMON" -> "ABELMON"
+"CancellationAbelianMonoid()" -> "AbelianMonoid()"
+@
 <<category CABMON CancellationAbelianMonoid>>=
 )abbrev category CABMON CancellationAbelianMonoid
 ++ Author:
@@ -681,6 +716,10 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{category CHARNZ CharacteristicNonZero}
+<<dot>>=
+"CHARNZ" -> "RING"
+"CharacteristicNonZero()" -> "Ring()"
+@
 <<category CHARNZ CharacteristicNonZero>>=
 )abbrev category CHARNZ CharacteristicNonZero
 ++ Author:
@@ -701,6 +740,10 @@ CharacteristicNonZero():Category == Ring with
 
 @
 \section{category CHARZ CharacteristicZero}
+<<dot>>=
+"CHARZ" -> "RING"
+"CharacteristicZero()" -> "Ring()"
+@
 <<category CHARZ CharacteristicZero>>=
 )abbrev category CHARZ CharacteristicZero
 ++ Author:
@@ -718,6 +761,12 @@ CharacteristicZero():Category == Ring
 
 @
 \section{category COMRING CommutativeRing}
+<<dot>>=
+"COMRING" -> "RING"
+"CommutativeRing()" -> "Ring()"
+"COMRING" -> "BMODULE"
+"CommutativeRing()" -> "BiModule(a:Ring,b:Ring)"
+@
 <<category COMRING CommutativeRing>>=
 )abbrev category COMRING CommutativeRing
 ++ Author:
@@ -780,6 +829,10 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{category DIFRING DifferentialRing}
+<<dot>>=
+"DIFRING" -> "RING"
+"DifferentialRing()" -> "Ring()"
+@
 <<category DIFRING DifferentialRing>>=
 )abbrev category DIFRING DifferentialRing
 ++ Author:
@@ -945,6 +998,10 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{category DIFEXT DifferentialExtension}
+<<dot>>=
+"DIFEXT" -> "RING"
+"DifferentialExtension(a:Ring)" -> "Ring()"
+@
 <<category DIFEXT DifferentialExtension>>=
 )abbrev category DIFEXT DifferentialExtension
 ++ Author:
@@ -994,6 +1051,12 @@ DifferentialExtension(R:Ring): Category == Ring with
 
 @
 \section{category DIVRING DivisionRing}
+<<dot>>=
+"DIVRING" -> "ENTIRER"
+"DivisionRing()" -> "EntireRing()"
+"DIVRING" -> "ALGEBRA"
+"DivisionRing()" -> "Algebra(Fraction(Integer))"
+@
 <<category DIVRING DivisionRing>>=
 )abbrev category DIVRING DivisionRing
 ++ Author:
@@ -1183,6 +1246,12 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{category ENTIRER EntireRing}
+<<dot>>=
+"ENTIRER" -> "RING"
+"EntireRing()" -> "Ring()"
+"ENTIRER" -> "BMODULE"
+"EntireRing()" -> "BiModule(a:Ring,b:Ring)"
+@
 <<category ENTIRER EntireRing>>=
 )abbrev category ENTIRER EntireRing
 ++ Author:
@@ -1249,6 +1318,10 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{category EUCDOM EuclideanDomain}
+<<dot>>=
+"EUCDOM" -> "PID"
+"EuclideanDomain()" -> "PrincipalIdealDomain()"
+@
 <<category EUCDOM EuclideanDomain>>=
 )abbrev category EUCDOM EuclideanDomain
 ++ Author:
@@ -2066,6 +2139,14 @@ recompiling.
 <<EUCDOM-;MAKEPROP>>
 @
 \section{category FIELD Field}
+<<dot>>=
+"FIELD" -> "EUCDOM"
+"Field()" -> "EuclideanDomain()"
+"FIELD" -> "UFD"
+"Field()" -> "UniqueFactorizationDomain()"
+"FIELD" -> "DIVRING"
+"Field()" -> "DivisionRing()"
+@
 <<category FIELD Field>>=
 )abbrev category FIELD Field
 ++ Author:
@@ -2116,6 +2197,10 @@ Field(): Category == Join(EuclideanDomain,UniqueFactorizationDomain,
 
 @
 \section{category FINITE Finite}
+<<dot>>=
+"FINITE" -> "SETCAT"
+"Finite()" -> "SetCategory()"
+@
 <<category FINITE Finite>>=
 )abbrev category FINITE Finite
 ++ Author:
@@ -2153,6 +2238,12 @@ Finite(): Category == SetCategory with
 
 @
 \section{category FLINEXP FullyLinearlyExplicitRingOver}
+<<dot>>=
+"FLINEXP" -> "LINEXP"
+"FullyLinearlyExplicitRingOver(a:Ring)" -> "LinearlyExplicitRingOver(a:Ring)"
+"FullyLinearlyExplicitRingOver(a:CommutativeRing)" ->
+    "FullyLinearlyExplicitRingOver(a:Ring)"
+@
 <<category FLINEXP FullyLinearlyExplicitRingOver>>=
 )abbrev category FLINEXP FullyLinearlyExplicitRingOver
 ++ Author:
@@ -2185,6 +2276,10 @@ FullyLinearlyExplicitRingOver(R:Ring):Category ==
 
 @
 \section{category GCDDOM GcdDomain}
+<<dot>>=
+"GCDDOM" -> "INTDOM"
+"GcdDomain()" -> "IntegralDomain()"
+@
 <<category GCDDOM GcdDomain>>=
 )abbrev category GCDDOM GcdDomain
 ++ Author:
@@ -2575,6 +2670,10 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{category GROUP Group}
+<<dot>>=
+"GROUP" -> "MONOID"
+"Group()" -> "Monoid()"
+@
 <<category GROUP Group>>=
 )abbrev category GROUP Group
 ++ Author:
@@ -2620,6 +2719,14 @@ Group(): Category == Monoid with
 
 @
 \section{category INTDOM IntegralDomain}
+<<dot>>=
+"INTDOM" -> "COMRING"
+"IntegralDomain()" -> "CommutativeRing()"
+"INTDOM" -> "ALGEBRA"
+"IntegralDomain()" -> "Algebra(a:CommutativeRing)"
+"INTDOM" -> "ENTIRER"
+"IntegralDomain()" -> "EntireRing()"
+@
 <<category INTDOM IntegralDomain>>=
 )abbrev category INTDOM IntegralDomain
 ++ Author:
@@ -2844,6 +2951,11 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{category LMODULE LeftModule}
+<<dot>>=
+"LMODULE" -> "ABELGRP"
+"LeftModule(a:Rng)" -> "AbelianGroup()"
+"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"
+@
 <<category LMODULE LeftModule>>=
 )abbrev category LMODULE LeftModule
 ++ Author:
@@ -2871,6 +2983,11 @@ LeftModule(R:Rng):Category == AbelianGroup with
 
 @
 \section{category LINEXP LinearlyExplicitRingOver}
+<<dot>>=
+"LINEXP" -> "RING"
+"LinearlyExplicitRingOver(a:Ring)" -> "Ring()"
+"LinearlyExplicitRingOver(Integer)" -> "LinearlyExplicitRingOver(a:Ring)"
+@
 <<category LINEXP LinearlyExplicitRingOver>>=
 )abbrev category LINEXP LinearlyExplicitRingOver
 ++ Author:
@@ -2894,6 +3011,11 @@ LinearlyExplicitRingOver(R:Ring): Category == Ring with
 
 @
 \section{category MODULE Module}
+<<dot>>=
+"MODULE" -> "BMODULE"
+"Module(a:CommutativeRing)" -> "BiModule(a:CommutativeRing,b:CommutativeRing)"
+"Module(Field)" -> "Module(a:CommutativeRing)"
+@
 <<category MODULE Module>>=
 )abbrev category MODULE Module
 ++ Author:
@@ -2919,6 +3041,10 @@ Module(R:CommutativeRing): Category == BiModule(R,R)
 
 @
 \section{category MONOID Monoid}
+<<dot>>=
+"MONOID" -> "SGROUP"
+"Monoid()" -> "SemiGroup()"
+@
 <<category MONOID Monoid>>=
 )abbrev category MONOID Monoid
 ++ Author:
@@ -3095,6 +3221,12 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{category OAGROUP OrderedAbelianGroup}
+<<dot>>=
+"OAGROUP" -> "OCAMON"
+"OrderedAbelianGroup()" -> "OrderedCancellationAbelianMonoid()"
+"OAGROUP" -> "ABELGRP"
+"OrderedAbelianGroup()" -> "AbelianGroup()"
+@
 <<category OAGROUP OrderedAbelianGroup>>=
 )abbrev category OAGROUP OrderedAbelianGroup
 ++ Author:
@@ -3115,6 +3247,12 @@ OrderedAbelianGroup(): Category ==
 
 @
 \section{category OAMON OrderedAbelianMonoid}
+<<dot>>=
+"OAMON" -> "OASGP"
+"OrderedAbelianMonoid()" -> "OrderedAbelianSemiGroup()"
+"OAMON" -> "ABELMON"
+"OrderedAbelianMonoid()" -> "AbelianMonoid()"
+@
 <<category OAMON OrderedAbelianMonoid>>=
 )abbrev category OAMON OrderedAbelianMonoid
 ++ Author:
@@ -3135,6 +3273,10 @@ OrderedAbelianMonoid(): Category ==
 
 @
 \section{category OAMONS OrderedAbelianMonoidSup}
+<<dot>>=
+"OAMONS" -> "OCAMON"
+"OrderedAbelianMonoidSup()" -> "OrderedCancellationAbelianMonoid()"
+@
 <<category OAMONS OrderedAbelianMonoidSup>>=
 )abbrev category OAMONS OrderedAbelianMonoidSup
 ++ Author:
@@ -3165,6 +3307,12 @@ OrderedAbelianMonoidSup(): Category == OrderedCancellationAbelianMonoid with
 
 @
 \section{category OASGP OrderedAbelianSemiGroup}
+<<dot>>=
+"OASGP" -> "ORDSET"
+"OrderedAbelianSemiGroup()" -> "OrderedSet()"
+"OASGP" -> "ABELMON"
+"OrderedAbelianSemiGroup()" -> "AbelianMonoid()"
+@
 <<category OASGP OrderedAbelianSemiGroup>>=
 )abbrev category OASGP OrderedAbelianSemiGroup
 ++ Author:
@@ -3185,6 +3333,12 @@ OrderedAbelianSemiGroup(): Category == Join(OrderedSet, AbelianMonoid)
 
 @
 \section{category OCAMON OrderedCancellationAbelianMonoid}
+<<dot>>=
+"OCAMON" -> "OAMON"
+"OrderedCancellationAbelianMonoid()" -> "OrderedAbelianMonoid()"
+"OCAMON" -> "CABMON"
+"OrderedCancellationAbelianMonoid()" -> "CancellationAbelianMonoid()"
+@
 <<category OCAMON OrderedCancellationAbelianMonoid>>=
 )abbrev category OCAMON OrderedCancellationAbelianMonoid
 ++ Author:
@@ -3205,6 +3359,12 @@ OrderedCancellationAbelianMonoid(): Category ==
 
 @
 \section{category ORDFIN OrderedFinite}
+<<dot>>=
+"ORDFIN" -> "ORDSET"
+"OrderedFinite()" -> "OrderedSet()"
+"ORDFIN" -> "FINITE"
+"OrderedFinite()" -> "Finite()"
+@
 <<category ORDFIN OrderedFinite>>=
 )abbrev category ORDFIN OrderedFinite
 ++ Author:
@@ -3223,6 +3383,12 @@ OrderedFinite(): Category == Join(OrderedSet, Finite)
 
 @
 \section{category OINTDOM OrderedIntegralDomain}
+<<dot>>=
+"OINTDOM" -> "INTDOM"
+"OrderedIntegralDomain()" -> "IntegralDomain()"
+"OINTDOM" -> "ORDRING"
+"OrderedIntegralDomain()" -> "OrderedRing()"
+@
 <<category OINTDOM OrderedIntegralDomain>>=
 )abbrev category OINTDOM OrderedIntegralDomain
 ++ Author: JH Davenport (after L Gonzalez-Vega)
@@ -3275,6 +3441,12 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{category ORDMON OrderedMonoid}
+<<dot>>=
+"ORDMON" -> "ORDSET"
+"OrderedMonoid()" -> "OrderedSet()"
+"ORDMON" -> "MONOID"
+"OrderedMonoid()" -> "Monoid()"
+@
 <<category ORDMON OrderedMonoid>>=
 )abbrev category ORDMON OrderedMonoid
 ++ Author:
@@ -3298,6 +3470,14 @@ OrderedMonoid(): Category == Join(OrderedSet, Monoid)
 
 @
 \section{category ORDRING OrderedRing}
+<<dot>>=
+"ORDRING" -> "OAGROUP"
+"OrderedRing()" -> "OrderedAbelianGroup()"
+"ORDRING" -> "RING"
+"OrderedRing()" -> "Ring()"
+"ORDRING" -> "MONOID"
+"OrderedRing()" -> "Monoid()"
+@
 <<category ORDRING OrderedRing>>=
 )abbrev category ORDRING OrderedRing
 ++ Author:
@@ -3474,6 +3654,10 @@ Note that this code is not included in the generated catdef.spad file.
    (QUOTE |lookupComplete|))) 
 @
 \section{category ORDSET OrderedSet}
+<<dot>>=
+"ORDSET" -> "SETCAT"
+"OrderedSet()" -> "SetCategory()"
+@
 <<category ORDSET OrderedSet>>=
 )abbrev category ORDSET OrderedSet
 ++ Author:
@@ -3522,6 +3706,12 @@ OrderedSet(): Category == SetCategory with
 
 @
 \section{category PDRING PartialDifferentialRing}
+<<dot>>=
+"PDRING" -> "RING"
+"PartialDifferentialRing(a:SetCategory)" -> "Ring()"
+"PartialDifferentialRing(a:OrderedSet)" ->
+    "PartialDifferentialRing(a:SetCategory)"
+@
 <<category PDRING PartialDifferentialRing>>=
 )abbrev category PDRING PartialDifferentialRing
 ++ Author:
@@ -3586,6 +3776,10 @@ PartialDifferentialRing(S:SetCategory): Category == Ring with
 
 @
 \section{category PFECAT PolynomialFactorizationExplicit}
+<<dot>>=
+"PFECAT" -> "UFD"
+"PolynomialFactorizationExplicit()" -> "UniqueFactorizationDomain()"
+@
 <<category PFECAT PolynomialFactorizationExplicit>>=
 )abbrev category PFECAT PolynomialFactorizationExplicit
 ++ Author: James Davenport
@@ -3671,6 +3865,10 @@ PolynomialFactorizationExplicit(): Category == Definition where
 
 @
 \section{category PID PrincipalIdealDomain}
+<<dot>>=
+"PID" -> "GCDDOM"
+"PrincipalIdealDomain()" -> "GcdDomain()"
+@
 <<category PID PrincipalIdealDomain>>=
 )abbrev category PID PrincipalIdealDomain
 ++ Author:
@@ -3704,6 +3902,11 @@ PrincipalIdealDomain(): Category == GcdDomain with
 
 @
 \section{category RMODULE RightModule}
+<<dot>>=
+"RMODULE" -> "ABELGRP"
+"RightModule(a:Rng)" -> "AbelianGroup()"
+"RightModule(a:Ring)" -> "RightModule(a:Rng)"
+@
 <<category RMODULE RightModule>>=
 )abbrev category RMODULE RightModule
 ++ Author:
@@ -3731,6 +3934,14 @@ RightModule(R:Rng):Category == AbelianGroup with
 
 @
 \section{category RING Ring}
+<<dot>>=
+"RING" -> "RNG"
+"Ring()" -> "Rng()"
+"RING" -> "MONOID"
+"Ring()" -> "Monoid()"
+"RING" -> "LMODULE"
+"Ring()" -> "LeftModule(a:Ring)"
+@
 <<category RING Ring>>=
 )abbrev category RING Ring
 ++ Author:
@@ -3865,6 +4076,12 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{category RNG Rng}
+<<dot>>=
+"RNG" -> "ABELGRP"
+"Rng()" -> "AbelianGroup()"
+"RNG" -> "SGROUP"
+"Rng()" -> "SemiGroup()"
+@
 <<category RNG Rng>>=
 )abbrev category RNG Rng
 ++ Author:
@@ -3930,6 +4147,10 @@ operator ``*''. A Semigroup $G(S,*)$ is:
 \item a binary multiplicative operator ``*''
 \item associative. $\forall a,b,c \in S, a*(b*c) = (a*b)*c$
 \end{itemize}
+<<dot>>=
+"SGROUP" -> "SETCAT"
+"SemiGroup()" -> "SetCategory()"
+@
 <<category SGROUP SemiGroup>>=
 )abbrev category SGROUP SemiGroup
 ++ Author:
@@ -3964,6 +4185,12 @@ SemiGroup(): Category == SetCategory with
 
 @
 \section{category SETCAT SetCategory}
+<<dot>>=
+"SETCAT" -> "BASTYPE"
+"SetCategory()" -> "BasicType()"
+"SETCAT" -> "KOERCE"
+"SetCategory()" -> "CoercibleTo(OutputForm)"
+@
 <<category SETCAT SetCategory>>=
 )abbrev category SETCAT SetCategory
 ++ Author:
@@ -4119,6 +4346,10 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{category STEP StepThrough}
+<<dot>>=
+"STEP" -> "SETCAT"
+"StepThrough()" -> "SetCategory()"
+@
 <<category STEP StepThrough>>=
 )abbrev category STEP StepThrough
 ++ Author:
@@ -4151,6 +4382,10 @@ StepThrough(): Category == SetCategory with
 
 @
 \section{category UFD UniqueFactorizationDomain}
+<<dot>>=
+"UFD" -> "GCDDOM"
+"UniqueFactorizationDomain()" -> "GcdDomain()"
+@
 <<category UFD UniqueFactorizationDomain>>=
 )abbrev category UFD UniqueFactorizationDomain
 ++ Author:
@@ -4366,6 +4601,10 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{category VSPACE VectorSpace}
+<<dot>>=
+"VSPACE" -> "MODULE"
+"VectorSpace(a:Field)" -> "Module(Field)"
+@
 <<category VSPACE VectorSpace>>=
 )abbrev category VSPACE VectorSpace
 ++ Author:
diff --git a/src/algebra/coerce.spad.pamphlet b/src/algebra/coerce.spad.pamphlet
index 3ad352b..9c0935c 100644
--- a/src/algebra/coerce.spad.pamphlet
+++ b/src/algebra/coerce.spad.pamphlet
@@ -10,6 +10,10 @@
 \tableofcontents
 \eject
 \section{category TYPE Type}
+<<dot>>=
+"TYPE" -> "CATEGORY"
+"Type()" -> "Category"
+@
 <<category TYPE Type>>=
 )abbrev category TYPE Type
 ++ The new fundamental Type (keeping Object for 1.5 as well)
@@ -21,6 +25,12 @@ Type(): Category == with nil
 
 @
 \section{category KOERCE CoercibleTo}
+<<dot>>=
+"KOERCE" -> "CATEGORY"
+"CoercibleTo(a:Type)" -> "Category"
+"CoercibleTo(OutputForm)" ->
+    "CoercibleTo(a:Type)"
+@
 <<category KOERCE CoercibleTo>>=
 )abbrev category KOERCE CoercibleTo
 ++ Category for coerce
@@ -36,6 +46,26 @@ CoercibleTo(S:Type): Category == with
 
 @
 \section{category KONVERT ConvertibleTo}
+<<dot>>=
+"KONVERT" -> "CATEGORY"
+"ConvertibleTo(a:Type)" -> "Category"
+"ConvertibleTo(DoubleFloat)" -> "ConvertibleTo(a:Type)"
+"ConvertibleTo(Float)" -> "ConvertibleTo(a:Type)"
+"ConvertibleTo(InputForm)" -> "ConvertibleTo(a:Type)"
+"ConvertibleTo(Integer)" -> "ConvertibleTo(a:Type)"
+"ConvertibleTo(Pattern(Integer))" -> "ConvertibleTo(a:Type)"
+"ConvertibleTo(Pattern(Float))" -> "ConvertibleTo(a:Type)"
+"ConvertibleTo(Complex(Float))" ->  "ConvertibleTo(a:Type)"
+"ConvertibleTo(Complex(DoubleFloat))" ->  "ConvertibleTo(a:Type)"
+"ConvertibleTo(String)" ->  "ConvertibleTo(a:Type)"
+"ConvertibleTo(Symbol)" ->  "ConvertibleTo(a:Type)"
+"ConvertibleTo(SExpression)" ->  "ConvertibleTo(a:Type)"
+"ConvertibleTo(Pattern(Base))" ->  "ConvertibleTo(a:Type)"
+"ConvertibleTo(List(Integer))" ->  "ConvertibleTo(a:Type)"
+"ConvertibleTo(List(Character))" ->  "ConvertibleTo(a:Type)"
+"ConvertibleTo(UnivariatePolynomialCategory(CommutativeRing))" ->
+    "ConvertibleTo(a:Type)"
+@
 <<category KONVERT ConvertibleTo>>=
 )abbrev category KONVERT ConvertibleTo
 ++ Category for convert
@@ -52,6 +82,16 @@ ConvertibleTo(S:Type): Category == with
 
 @
 \section{category RETRACT RetractableTo}
+<<dot>>=
+"RETRACT" -> "CATEGORY"
+"RetractableTo(a:Type)" -> "Category"
+"RetractableTo(SetCategory)" -> "RetractableTo(a:Type)"
+"RetractableTo(Symbol)" -> "RetractableTo(a:Type)"
+"RetractableTo(Integer)" -> "RetractableTo(a:Type)"
+"RetractableTo(NonNegativeInteger)" -> "RetractableTo(a:Type)"
+"RetractableTo(Fraction(Integer))" -> "RetractableTo(a:Type)"
+"RetractableTo(Float)" -> "RetractableTo(a:Type)"
+@
 <<category RETRACT RetractableTo>>=
 )abbrev category RETRACT RetractableTo
 ++ Category for retract
diff --git a/src/algebra/equation1.spad.pamphlet b/src/algebra/equation1.spad.pamphlet
index a147e68..116e585 100644
--- a/src/algebra/equation1.spad.pamphlet
+++ b/src/algebra/equation1.spad.pamphlet
@@ -10,6 +10,14 @@
 \tableofcontents
 \eject
 \section{category IEVALAB InnerEvalable}
+<<dot>>=
+"IEVALAB" -> "CATEGORY"
+"InnerEvalable(a:SetCategory,b:Type)" -> "Category"
+"InnerEvalable(a:SetCategory,b:SetCategory)" ->
+    "InnerEvalable(a:SetCategory,b:Type)"
+"InnerEvalable(a:Ring,MultivariateTaylorSeriesCategory(a:Ring,b:OrderedSet))"
+     -> "InnerEvalable(a:SetCategory,b:Type)"
+@
 <<category IEVALAB InnerEvalable>>=
 )abbrev category IEVALAB InnerEvalable
 -- FOR THE BENEFIT OF LIBAX0 GENERATION
@@ -40,6 +48,12 @@ InnerEvalable(A:SetCategory, B:Type): Category == with
 
 @
 \section{category EVALAB Evalable}
+<<dot>>=
+"EVALAB" -> "IEVALAB"
+"Evalable(a:SetCategory)" -> "InnerEvalable(a:SetCategory,b:SetCategory)"
+"Evalable(MultivariateTaylorSeriesCategory(a:Ring,b:OrderedSet))" ->
+    "Evalable(a:SetCategory)"
+@
 <<category EVALAB Evalable>>=
 )abbrev category EVALAB Evalable
 ++ Author:
diff --git a/src/algebra/integer.spad.pamphlet b/src/algebra/integer.spad.pamphlet
index c415a4e..5f5a068 100644
--- a/src/algebra/integer.spad.pamphlet
+++ b/src/algebra/integer.spad.pamphlet
@@ -10,6 +10,10 @@
 \tableofcontents
 \eject
 \section{package INTSLPE IntegerSolveLinearPolynomialEquation}
+<<dot>>=
+"INTSLPE" -> "PACKAGE"
+"IntegerSolveLinearPolynomialEquation()" -> "Package"
+@
 <<package INTSLPE IntegerSolveLinearPolynomialEquation>>=
 )abbrev package INTSLPE IntegerSolveLinearPolynomialEquation
 ++ Author: Davenport
@@ -722,6 +726,14 @@ o )show Integer
 o $AXIOM/doc/src/algebra/integer.spad.dvi
 
 @
+<<dot>>=
+"INT" -> "INS"
+"Integer()" -> "IntegerNumberSystem()"
+"INT" -> "KONVERT"
+"Integer()" -> "ConvertibleTo(String)"
+"INT" -> "OM"
+"Integer()" -> "OpenMath()"
+@
 <<domain INT Integer>>=
 )abbrev domain INT Integer
 ++ Author:
@@ -1111,6 +1123,12 @@ Note that this code is not included in the generated catdef.spad file.
 (MAKEPROP (QUOTE |Integer|) (QUOTE NILADIC) T) 
 @
 \section{domain NNI NonNegativeInteger}
+<<dot>>=
+"NNI" -> "OAMONS"
+"NonNegativeInteger()" -> "OrderedAbelianMonoidSup()"
+"NNI" -> "MONOID"
+"NonNegativeInteger()" -> "Monoid()"
+@
 <<domain NNI NonNegativeInteger>>=
 )abbrev domain NNI NonNegativeInteger
 ++ Author:
@@ -1313,6 +1331,12 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{domain PI PositiveInteger}
+<<dot>>=
+"PI" -> "OASGP"
+"PositiveInteger()" -> "OrderedAbelianSemiGroup()"
+"PI" -> "MONOID"
+"PositiveInteger()" -> "Monoid()"
+@
 <<domain PI PositiveInteger>>=
 )abbrev domain PI PositiveInteger
 ++ Author:
@@ -1719,6 +1743,10 @@ o )show RomanNumeral
 o $AXIOM/doc/src/algebra/integer.spad.dvi
 
 @
+<<dot>>=
+"ROMAN" -> "INS"
+"RomanNumeral()" -> "IntegerNumberSystem()"
+@
 <<domain ROMAN RomanNumeral>>=
 )abbrev domain ROMAN RomanNumeral
 ++ Author:
diff --git a/src/algebra/misc.spad.pamphlet b/src/algebra/misc.spad.pamphlet
index 86caa39..837e326 100644
--- a/src/algebra/misc.spad.pamphlet
+++ b/src/algebra/misc.spad.pamphlet
@@ -10,6 +10,10 @@
 \tableofcontents
 \eject
 \section{domain SAOS SingletonAsOrderedSet}
+<<dot>>=
+"SAOS" -> "ORDSET"
+"SingletonAsOrderedSet()" -> "OrderedSet()"
+@
 <<domain SAOS SingletonAsOrderedSet>>=
 )abbrev domain SAOS SingletonAsOrderedSet
 ++ This trivial domain lets us build Univariate Polynomials
diff --git a/src/algebra/omcat.spad.pamphlet b/src/algebra/omcat.spad.pamphlet
index 824bf1b..ca6b74f 100644
--- a/src/algebra/omcat.spad.pamphlet
+++ b/src/algebra/omcat.spad.pamphlet
@@ -10,6 +10,10 @@
 \tableofcontents
 \eject
 \section{category OM OpenMath}
+<<dot>>=
+"OM" -> "CATEGORY"
+"OpenMath()" -> "Category"
+@
 <<category OM OpenMath>>=
 )abbrev category OM OpenMath
 ++ Author: Mike Dewar & Vilya Harvey
diff --git a/src/algebra/patmatch1.spad.pamphlet b/src/algebra/patmatch1.spad.pamphlet
index 381bbf3..1225137 100644
--- a/src/algebra/patmatch1.spad.pamphlet
+++ b/src/algebra/patmatch1.spad.pamphlet
@@ -10,6 +10,10 @@
 \tableofcontents
 \eject
 \section{domain PATRES PatternMatchResult}
+<<dot>>=
+"PATRES" -> "SETCAT"
+"PatternMatchResult(a:SetCategory, b:SetCategory)" -> "SetCategory()"
+@
 <<domain PATRES PatternMatchResult>>=
 )abbrev domain PATRES PatternMatchResult
 ++ Result returned by the pattern matcher
@@ -113,6 +117,11 @@ PatternMatchResult(R:SetCategory, S:SetCategory): SetCategory with
 
 @
 \section{package PATRES2 PatternMatchResultFunctions2}
+<<dot>>=
+"PATRES2" -> "PACKAGE"
+"PatternMatchResultFunctions2(a:SetCategory,b:SetCategory,c:SetCategory)" -> 
+    "Package"
+@
 <<package PATRES2 PatternMatchResultFunctions2>>=
 )abbrev package PATRES2 PatternMatchResultFunctions2
 ++ Lifts maps to pattern matching results
@@ -138,6 +147,11 @@ PatternMatchResultFunctions2(R, A, B): Exports == Implementation where
 
 @
 \section{domain PATLRES PatternMatchListResult}
+<<dot>>=
+"PATLRES" -> "SETCAT"
+"PatternMatchListResult(a:SETCAT,b:SETCAT,c:LSAGG(SETCAT))"
+  -> "SetCategory()"
+@
 <<domain PATLRES PatternMatchListResult>>=
 )abbrev domain PATLRES PatternMatchListResult
 ++ Result returned by the pattern matcher when using lists
@@ -186,6 +200,12 @@ PatternMatchListResult(R:SetCategory, S:SetCategory, L:ListAggregate S):
 
 @
 \section{category PATMAB PatternMatchable}
+<<dot>>=
+"PATMAB" -> "SETCAT"
+"PatternMatchable(a:SetCategory)" -> "SetCategory()"
+"PatternMatchable(Integer)" -> "PatternMatchable(a:SetCategory)"
+"PatternMatchable(Float)" -> "PatternMatchable(a:SetCategory)"
+@
 <<category PATMAB PatternMatchable>>=
 )abbrev category PATMAB PatternMatchable
 ++ Category of sets that can be pattern-matched on
@@ -207,6 +227,10 @@ PatternMatchable(S:SetCategory): Category == SetCategory with
 
 @
 \section{category FPATMAB FullyPatternMatchable}
+<<dot>>=
+"FPATMAB" -> "TYPE"
+"FullyPatternMatchable(a:Type)" -> "Type()"
+@
 <<category FPATMAB FullyPatternMatchable>>=
 )abbrev category FPATMAB FullyPatternMatchable
 ++ Category of sets that can be pattern-matched on
@@ -224,6 +248,10 @@ FullyPatternMatchable(R:Type): Category == Type with
 
 @
 \section{package PMSYM PatternMatchSymbol}
+<<dot>>=
+"PMSYM" -> "PACKAGE"
+"PatternMatchSymbol(a:SetCategory)" -> "Package"
+@
 <<package PMSYM PatternMatchSymbol>>=
 )abbrev package PMSYM PatternMatchSymbol
 ++ Pattern matching on symbols
@@ -252,6 +280,10 @@ PatternMatchSymbol(S:SetCategory): with
 
 @
 \section{package PMKERNEL PatternMatchKernel}
+<<dot>>=
+"PMKERNEL" -> "PACKAGE"
+"PatternMatchKernel(a:SetCategory, b:Join(...))" -> "Package"
+@
 <<package PMKERNEL PatternMatchKernel>>=
 )abbrev package PMKERNEL PatternMatchKernel
 ++ Pattern matching on kernels
@@ -349,6 +381,11 @@ PatternMatchKernel(S, E): Exports == Implementation where
 
 @
 \section{package PMDOWN PatternMatchPushDown}
+<<dot>>=
+"PMDOWN" -> "PACKAGE"
+"PatternMatchPushDown(a:SETCAT, b:PATMAB(SETCAT), c:Join(...))"
+    -> "Package"
+@
 <<package PMDOWN PatternMatchPushDown>>=
 )abbrev package PMDOWN PatternMatchPushDown
 ++ Pattern matching in towers
@@ -449,6 +486,10 @@ PatternMatchPushDown(S, A, B): Exports == Implementation where
 
 @
 \section{package PMTOOLS PatternMatchTools}
+<<dot>>=
+"PMTOOLS" -> "PACKAGE"
+"PatternMatchTools(a:SetCategory,b:Join(...),c:Join(...))" -> "Package"
+@
 <<package PMTOOLS PatternMatchTools>>=
 )abbrev package PMTOOLS PatternMatchTools
 ++ Tools for the pattern matcher
@@ -613,6 +654,11 @@ PatternMatchTools(S, R, P): Exports == Implementation where
 
 @
 \section{package PMLSAGG PatternMatchListAggregate}
+<<dot>>=
+"PMLSAGG" -> "PACKAGE"
+"PatternMatchListAggregate(a:SETCAT,b:PATMAB(SETCAT),c:LSAGG(PATMAB(SETCAT)))"
+    -> "Package"
+@
 <<package PMLSAGG PatternMatchListAggregate>>=
 )abbrev package PMLSAGG PatternMatchListAggregate
 ++ Pattern matching for list aggregates
diff --git a/src/algebra/pattern.spad.pamphlet b/src/algebra/pattern.spad.pamphlet
index e22e920..4d3d0a2 100644
--- a/src/algebra/pattern.spad.pamphlet
+++ b/src/algebra/pattern.spad.pamphlet
@@ -10,6 +10,12 @@
 \tableofcontents
 \eject
 \section{domain PATTERN Pattern}
+<<dot>>=
+"RETRACT" -> "CATEGORY"
+"RetractableTo(a:Type)" -> "Category"
+"RetractableTo(SetCategory)" -> "RetractableTo(a:Type)"
+"RetractableTo(Symbol)" -> "RetractableTo(a:Type)"
+@
 <<domain PATTERN Pattern>>=
 )abbrev domain PATTERN Pattern
 ++ Patterns for use by the pattern matcher
@@ -386,6 +392,10 @@ Pattern(R:SetCategory): Exports == Implementation where
 
 @
 \section{package PATTERN1 PatternFunctions1}
+<<dot>>=
+"PATTERN1" -> "PACKAGE" 
+"PatternFunctions1(a:SetCategory,b:Type)" -> "Package"
+@
 <<package PATTERN1 PatternFunctions1>>=
 )abbrev package PATTERN1 PatternFunctions1
 ++ Utilities for handling patterns
@@ -450,6 +460,10 @@ PatternFunctions1(R:SetCategory, D:Type): with
 
 @
 \section{package PATTERN2 PatternFunctions2}
+<<dot>>=
+"PATTERN2" -> "PACKAGE"
+"PatternFunctions2(a:SetCategory,b:SetCategory)" -> "Package"
+@
 <<package PATTERN2 PatternFunctions2>>=
 )abbrev package PATTERN2 PatternFunctions2
 ++ Lifting of maps to patterns
@@ -489,6 +503,10 @@ PatternFunctions2(R:SetCategory, S:SetCategory): with
 
 @
 \section{category PATAB Patternable}
+<<dot>>=
+"PATAB" -> "CATEGORY" 
+"Patternable(a:Type)" -> "Category"
+@
 <<category PATAB Patternable>>=
 )abbrev category PATAB Patternable
 ++ Category of sets that can be converted to useful patterns
diff --git a/src/algebra/pscat.spad.pamphlet b/src/algebra/pscat.spad.pamphlet
index 115c4ac..f91de29 100644
--- a/src/algebra/pscat.spad.pamphlet
+++ b/src/algebra/pscat.spad.pamphlet
@@ -10,6 +10,15 @@
 \tableofcontents
 \eject
 \section{category PSCAT PowerSeriesCategory}
+<<dot>>=
+"PSCAT" -> "AMR"
+"PowerSeriesCategory(a:Ring,b:OrderedAbelianMonoid,c:OrderedSet)" ->
+    "AbelianMonoidRing(a:Ring,b:OrderedAbelianMonoid)"
+"PowerSeriesCategory(a:Ring,b:OrderedAbelianMonoid,c:SingletonAsOrderedSet)"
+  -> "PowerSeriesCategory(a:Ring,b:OrderedAbelianMonoid,c:OrderedSet)"
+"PowerSeriesCategory(a:Ring,IndexedExponents(b:OrderedSet),c:OrderedSet))"
+  -> "PowerSeriesCategory(a:Ring,b:OrderedAbelianMonoid,c:OrderedSet)"
+@
 <<category PSCAT PowerSeriesCategory>>=
 )abbrev category PSCAT PowerSeriesCategory
 ++ Author: Clifton J. Williamson
@@ -71,6 +80,17 @@ PowerSeriesCategory(Coef,Expon,Var): Category == Definition where
 
 @
 \section{category UPSCAT UnivariatePowerSeriesCategory}
+<<dot>>=
+"UPSCAT" -> "PSCAT"
+"UnivariatePowerSeriesCategory(a:Ring,b:OrderedAbelianMonoid)" ->
+ "PowerSeriesCategory(a:Ring,b:OrderedAbelianMonoid,c:SingletonAsOrderedSet)"
+"UnivariatePowerSeriesCategory(a:Ring,NonNegativeInteger)" -> 
+    "UnivariatePowerSeriesCategory(a:Ring,b:OrderedAbelianMonoid)"
+"UnivariatePowerSeriesCategory(a:Ring,Integer)" -> 
+    "UnivariatePowerSeriesCategory(a:Ring,b:OrderedAbelianMonoid)"
+"UnivariatePowerSeriesCategory(a:Ring,Fraction(Integer))" ->
+    "UnivariatePowerSeriesCategory(a:Ring,b:OrderedAbelianMonoid)"
+@
 <<category UPSCAT UnivariatePowerSeriesCategory>>=
 )abbrev category UPSCAT UnivariatePowerSeriesCategory
 ++ Author: Clifton J. Williamson
@@ -168,6 +188,11 @@ UnivariatePowerSeriesCategory(Coef,Expon): Category == Definition where
 
 @
 \section{category UTSCAT UnivariateTaylorSeriesCategory}
+<<dot>>=
+"UTSCAT" -> "UPSCAT"
+"UnivariateTaylorSeriesCategory(a:Ring)" ->
+    "UnivariatePowerSeriesCategory(a:Ring,NonNegativeInteger)"
+@
 <<category UTSCAT UnivariateTaylorSeriesCategory>>=
 )abbrev category UTSCAT UnivariateTaylorSeriesCategory
 ++ Author: Clifton J. Williamson
@@ -404,6 +429,11 @@ UnivariateTaylorSeriesCategory(Coef): Category == Definition where
 
 @
 \section{category ULSCAT UnivariateLaurentSeriesCategory}
+<<dot>>=
+"ULSCAT" -> "UPSCAT"
+"UnivariateLaurentSeriesCategory(a:Ring)" ->
+    "UnivariatePowerSeriesCategory(a:Ring,Integer)"
+@
 <<category ULSCAT UnivariateLaurentSeriesCategory>>=
 )abbrev category ULSCAT UnivariateLaurentSeriesCategory
 ++ Author: Clifton J. Williamson
@@ -496,6 +526,11 @@ Note that this code is not included in the generated catdef.spad file.
 (DEFUN |UnivariateLaurentSeriesCategory;| (|t#1|) (PROG (#1=#:G83277) (RETURN (PROG1 (LETT #1# (|sublisV| (PAIR (QUOTE (|t#1|)) (LIST (|devaluate| |t#1|))) (|sublisV| (PAIR (QUOTE (#2=#:G83276)) (LIST (QUOTE (|Integer|)))) (COND (|UnivariateLaurentSeriesCategory;CAT|) ((QUOTE T) (LETT |UnivariateLaurentSeriesCategory;CAT| (|Join| (|UnivariatePowerSeriesCategory| (QUOTE |t#1|) (QUOTE #2#)) (|mkCategory| (QUOTE |domain|) (QUOTE (((|series| (|$| (|Stream| (|Record| (|:| |k| (|Integer|)) (|:| |c| |t#1|))))) T) ((|multiplyCoefficients| (|$| (|Mapping| |t#1| (|Integer|)) |$|)) T) ((|rationalFunction| ((|Fraction| (|Polynomial| |t#1|)) |$| (|Integer|))) (|has| |t#1| (|IntegralDomain|))) ((|rationalFunction| ((|Fraction| (|Polynomial| |t#1|)) |$| (|Integer|) (|Integer|))) (|has| |t#1| (|IntegralDomain|))) ((|integrate| (|$| |$|)) (|has| |t#1| (|Algebra| (|Fraction| (|Integer|))))) ((|integrate| (|$| |$| (|Symbol|))) (AND (|has| |t#1| (SIGNATURE |variables| ((|List| (|Symbol|)) |t#1!
|))) (|has| |t#1| (SIGNATURE |integrate| (|t#1| |t#1| (|Symbol|)))) (|has| |t#1| (|Algebra| (|Fraction| (|Integer|)))))) ((|integrate| (|$| |$| (|Symbol|))) (AND (|has| |t#1| (|AlgebraicallyClosedFunctionSpace| (|Integer|))) (|has| |t#1| (|PrimitiveFunctionCategory|)) (|has| |t#1| (|TranscendentalFunctionCategory|)) (|has| |t#1| (|Algebra| (|Fraction| (|Integer|)))))))) (QUOTE (((|RadicalCategory|) (|has| |t#1| (|Algebra| (|Fraction| (|Integer|))))) ((|TranscendentalFunctionCategory|) (|has| |t#1| (|Algebra| (|Fraction| (|Integer|))))) ((|Field|) (|has| |t#1| (|Field|))))) (QUOTE ((|Symbol|) (|Fraction| (|Polynomial| |t#1|)) (|Integer|) (|Stream| (|Record| (|:| |k| (|Integer|)) (|:| |c| |t#1|))))) NIL)) . #3=(|UnivariateLaurentSeriesCategory|)))))) . #3#) (SETELT #1# 0 (LIST (QUOTE |UnivariateLaurentSeriesCategory|) (|devaluate| |t#1|))))))) 
 @
 \section{category UPXSCAT UnivariatePuiseuxSeriesCategory}
+<<dot>>=
+"UPXSCAT" -> "UPSCAT"
+"UnivariatePuiseuxSeriesCategory(a:Ring)" ->
+    "UnivariatePowerSeriesCategory(a:Ring,Fraction(Integer))"
+@
 <<category UPXSCAT UnivariatePuiseuxSeriesCategory>>=
 )abbrev category UPXSCAT UnivariatePuiseuxSeriesCategory
 ++ Author: Clifton J. Williamson
@@ -558,6 +593,20 @@ UnivariatePuiseuxSeriesCategory(Coef): Category == Definition where
 
 @
 \section{category MTSCAT MultivariateTaylorSeriesCategory}
+<<dot>>=
+"MTSCAT" -> "PDRING"
+"MultivariateTaylorSeriesCategory(a:Ring,b:OrderedSet)" ->
+    "PartialDifferentialRing(a:OrderedSet)"
+"MTSCAT" -> "PSCAT"
+"MultivariateTaylorSeriesCategory(a:Ring,b:OrderedSet)" ->
+   "PowerSeriesCategory(a:Ring,IndexedExponents(b:OrderedSet),c:OrderedSet))"
+"MTSCAT" -> "IEVALAB"
+"MultivariateTaylorSeriesCategory(a:Ring,b:OrderedSet)" ->
+ "InnerEvalable(a:Ring,MultivariateTaylorSeriesCategory(a:Ring,b:OrderedSet))"
+"MTSCAT" -> "EVALAB"
+"MultivariateTaylorSeriesCategory(a:Ring,b:OrderedSet)" ->
+ "Evalable(MultivariateTaylorSeriesCategory(a:Ring,b:OrderedSet))"
+@
 <<category MTSCAT MultivariateTaylorSeriesCategory>>=
 )abbrev category MTSCAT MultivariateTaylorSeriesCategory
 ++ Author: Clifton J. Williamson
diff --git a/src/algebra/sf.spad.pamphlet b/src/algebra/sf.spad.pamphlet
index 1517c92..c35c3b4 100644
--- a/src/algebra/sf.spad.pamphlet
+++ b/src/algebra/sf.spad.pamphlet
@@ -10,6 +10,11 @@
 \tableofcontents
 \eject
 \section{category REAL RealConstant}
+<<dot>>=
+"REAL" -> "KONVERT"
+"RealConstant()" -> "ConvertibleTo(DoubleFloat)"
+"RealConstant()" -> "ConvertibleTo(Float)"
+@
 <<category REAL RealConstant>>=
 )abbrev category REAL RealConstant
 ++ Author:
@@ -28,6 +33,10 @@ RealConstant(): Category ==
 
 @
 \section{category RADCAT RadicalCategory}
+<<dot>>=
+"RADCAT" -> "CATEGORY"
+"RadicalCategory()" -> "Category"
+@
 <<category RADCAT RadicalCategory>>=
 )abbrev category RADCAT RadicalCategory
 ++ Author:
@@ -50,6 +59,25 @@ RadicalCategory(): Category == with
 
 @
 \section{category RNS RealNumberSystem}
+<<dot>>=
+"RNS" -> "FIELD"
+"RealNumberSystem()" -> "Field()"
+"RNS" -> "ORDRING"
+"RealNumberSystem()" -> "OrderedRing()"
+"RNS" -> "REAL"
+"RealNumberSystem()" -> "RealConstant()"
+"RNS" -> "RETRACT"
+"RealNumberSystem()" -> "RetractableTo(Integer)"
+"RealNumberSystem()" -> "RetractableTo(Fraction(Integer))"
+"RNS" -> "RADCAT"
+"RealNumberSystem()" -> "RadicalCategory()"
+"RNS" -> "KONVERT"
+"RealNumberSystem()" -> "ConvertibleTo(Pattern(Float))"
+"RNS" -> "PATMAB"
+"RealNumberSystem()" -> "PatternMatchable(Float)"
+"RNS" -> "CHARZ"
+"RealNumberSystem()" -> "CharacteristicZero()"
+@
 <<category RNS RealNumberSystem>>=
 )abbrev category RNS RealNumberSystem
 ++ Author: Michael Monagan and Stephen M. Watt
@@ -395,6 +423,10 @@ Note that this code is not included in the generated catdef.spad file.
 
 @
 \section{category FPS FloatingPointSystem}
+<<dot>>=
+"FPS" -> "RNS"
+"FloatingPointSystem()" -> "RealNumberSystem()"
+@
 <<category FPS FloatingPointSystem>>=
 )abbrev category FPS FloatingPointSystem
 ++ Author:
@@ -411,9 +443,11 @@ Note that this code is not included in the generated catdef.spad file.
 ++ exactly representable by floating point numbers.
 ++ A floating point system is characterized by the following:
 ++
-++   1: \spadfunFrom{base}{FloatingPointSystem} of the \spadfunFrom{exponent}{FloatingPointSystem}.
-++          (actual implemenations are usually binary or decimal)
-++   2: \spadfunFrom{precision}{FloatingPointSystem} of the \spadfunFrom{mantissa}{FloatingPointSystem} (arbitrary or fixed)
+++   1: \spadfunFrom{base}{FloatingPointSystem} of the 
+++      \spadfunFrom{exponent}{FloatingPointSystem}.
+++      (actual implemenations are usually binary or decimal)
+++   2: \spadfunFrom{precision}{FloatingPointSystem} of the 
+++       \spadfunFrom{mantissa}{FloatingPointSystem} (arbitrary or fixed)
 ++   3: rounding error for operations
 --++   4:  when, and what happens if exponent overflow/underflow occurs
 ++
@@ -433,9 +467,13 @@ FloatingPointSystem(): Category == RealNumberSystem() with
       ++ order x is the order of magnitude of x.
       ++ Note: \spad{base ** order x <= |x| < base ** (1 + order x)}.
    base: () -> PositiveInteger
-      ++ base() returns the base of the \spadfunFrom{exponent}{FloatingPointSystem}.
+      ++ base() returns the base of the 
+      ++\spadfunFrom{exponent}{FloatingPointSystem}.
+
    exponent: % -> Integer
-      ++ exponent(x) returns the \spadfunFrom{exponent}{FloatingPointSystem} part of x.
+      ++ exponent(x) returns the 
+      ++ \spadfunFrom{exponent}{FloatingPointSystem} part of x.
+
    mantissa: % -> Integer
       ++ mantissa(x) returns the mantissa part of x.
   -- round?: () -> B
@@ -450,17 +488,25 @@ FloatingPointSystem(): Category == RealNumberSystem() with
 
    if % has arbitraryPrecision then
       bits: PositiveInteger -> PositiveInteger
-        ++ bits(n) set the \spadfunFrom{precision}{FloatingPointSystem} to n bits.
+        ++ bits(n) set the \spadfunFrom{precision}{FloatingPointSystem} 
+        ++ to n bits.
+
       digits: PositiveInteger -> PositiveInteger
-        ++ digits(d) set the \spadfunFrom{precision}{FloatingPointSystem} to d digits.
+        ++ digits(d) set the \spadfunFrom{precision}{FloatingPointSystem} 
+        ++ to d digits.
+
       precision: PositiveInteger -> PositiveInteger
         ++ precision(n) set the precision in the base to n decimal digits.
+
       increasePrecision: Integer -> PositiveInteger
         ++ increasePrecision(n) increases the current
         ++ \spadfunFrom{precision}{FloatingPointSystem} by n decimal digits.
+
       decreasePrecision: Integer -> PositiveInteger
         ++ decreasePrecision(n) decreases the current
-        ++ \spadfunFrom{precision}{FloatingPointSystem} precision by n decimal digits.
+        ++ \spadfunFrom{precision}{FloatingPointSystem} precision 
+        ++ by n decimal digits.
+
    if not (% has arbitraryExponent) then
     --  overflow: (()->Exit) -> Void
     --    ++ overflow() returns the Exponent overflow of float
@@ -947,6 +993,20 @@ o )show DoubleFloat
 o $AXIOM/doc/src/algebra/sf.spad.dvi
 
 @
+<<dot>>=
+"DFLOAT" -> "FPS"
+"DoubleFloat()" -> "FloatingPointSystem()"
+"DFLOAT" -> "DIFRING"
+"DoubleFloat()" -> "DifferentialRing()"
+"DFLOAT" -> "OM"
+"DoubleFloat()" -> "OpenMath()"
+"DFLOAT" -> "TRANFUN"
+"DoubleFloat()" -> "TranscendentalFunctionCategory()"
+"DFLOAT" -> "SPFCAT"
+"DoubleFloat()" -> "SpecialFunctionCategory()"
+"DFLOAT" -> "KONVERT"
+"DoubleFloat()" -> "ConvertibleTo(InputForm)"
+@
 <<domain DFLOAT DoubleFloat>>=
 )abbrev domain DFLOAT DoubleFloat
 ++ Author: Michael Monagan
@@ -982,7 +1042,8 @@ o $AXIOM/doc/src/algebra/sf.spad.dvi
 ++ and \spadfunFrom{cos}{DoubleFloat}
 ++ will lose all precision for large arguments.
 ++
-++ The \spadtype{Float} domain provides an alternative to the \spad{DoubleFloat} domain.
+++ The \spadtype{Float} domain provides an alternative to the 
+++ \spad{DoubleFloat} domain.
 ++ It provides an arbitrary precision model of floating point arithmetic.
 ++ This means that accuracy problems like those above are eliminated
 ++ by increasing the working precision where necessary.  \spadtype{Float}
diff --git a/src/algebra/si.spad.pamphlet b/src/algebra/si.spad.pamphlet
index 04d6d1f..3610e05 100644
--- a/src/algebra/si.spad.pamphlet
+++ b/src/algebra/si.spad.pamphlet
@@ -10,6 +10,34 @@
 \tableofcontents
 \eject
 \section{category INS IntegerNumberSystem}
+<<dot>>=
+"INS" -> "UFD"
+"IntegerNumberSystem()" -> "UniqueFactorizationDomain()"
+"INS" -> "EUCDOM"
+"IntegerNumberSystem()" -> "EuclideanDomain()"
+"INS" -> "OINTDOM"
+"IntegerNumberSystem()" -> "OrderedIntegralDomain()"
+"INS" -> "DIFRING"
+"IntegerNumberSystem()" -> "DifferentialRing()"
+"INS" -> "KONVERT"
+"IntegerNumberSystem()" -> "ConvertibleTo(Integer)"
+"IntegerNumberSystem()" -> "ConvertibleTo(InputForm)"
+"IntegerNumberSystem()" -> "ConvertibleTo(Pattern(Integer))"
+"INS" -> "RETRACT"
+"IntegerNumberSystem()" -> "RetractableTo(Integer)"
+"INS" -> "LINEXP"
+"IntegerNumberSystem()" -> "LinearlyExplicitRingOver(Integer)"
+"INS" -> "PATMAB"
+"IntegerNumberSystem()" -> "PatternMatchable(Integer)"
+"INS" -> "CFCAT"
+"IntegerNumberSystem()" -> "CombinatorialFunctionCategory()"
+"INS" -> "REAL"
+"IntegerNumberSystem()" -> "RealConstant()"
+"INS" -> "CHARZ"
+"IntegerNumberSystem()" -> "CharacteristicZero()"
+"INS" -> "STEP"
+"IntegerNumberSystem()" -> "StepThrough()"
+@
 <<category INS IntegerNumberSystem>>=
 )abbrev category INS IntegerNumberSystem
 ++ Author: Stephen M. Watt
@@ -837,6 +865,14 @@ o )show SingleInteger
 o $AXIOM/doc/src/algebra/si.spad.dvi
 
 @
+<<dot>>=
+"SINT" -> "INS"
+"SingleInteger()" -> "IntegerNumberSystem()"
+"SINT" -> "LOGIC"
+"SingleInteger()" -> "Logic()"
+"SINT" -> "OM"
+"SingleInteger()" -> "OpenMath()"
+@
 <<domain SINT SingleInteger>>=
 )abbrev domain SINT SingleInteger
 
@@ -869,11 +905,14 @@ o $AXIOM/doc/src/algebra/si.spad.dvi
 
 SingleInteger(): Join(IntegerNumberSystem,Logic,OpenMath) with
    canonical
-      ++ \spad{canonical} means that mathematical equality is implied by data structure equality.
+      ++ \spad{canonical} means that mathematical equality is 
+      ++ implied by data structure equality.
    canonicalsClosed
-      ++ \spad{canonicalClosed} means two positives multiply to give positive.
+      ++ \spad{canonicalClosed} means two positives multiply to 
+      ++ give positive.
    noetherian
-      ++ \spad{noetherian} all ideals are finitely generated (in fact principal).
+      ++ \spad{noetherian} all ideals are finitely generated 
+      ++ (in fact principal).
 
    max      : () -> %
       ++ max() returns the largest single integer.
diff --git a/src/algebra/trigcat.spad.pamphlet b/src/algebra/trigcat.spad.pamphlet
index e3d7bb3..4e5529a 100644
--- a/src/algebra/trigcat.spad.pamphlet
+++ b/src/algebra/trigcat.spad.pamphlet
@@ -10,6 +10,10 @@
 \tableofcontents
 \eject
 \section{category ELEMFUN ElementaryFunctionCategory}
+<<dot>>=
+"ELEMFUN" -> "CATEGORY"
+"ElementaryFunctionCategory()" -> "Category"
+@
 <<category ELEMFUN ElementaryFunctionCategory>>=
 )abbrev category ELEMFUN ElementaryFunctionCategory
 ++ Category for the elementary functions
@@ -27,6 +31,10 @@ ElementaryFunctionCategory(): Category == with
 
 @
 \section{category AHYP ArcHyperbolicFunctionCategory}
+<<dot>>=
+"AHYP" -> "CATEGORY"
+"ArcHyperbolicFunctionCategory()" -> "Category"
+@
 <<category AHYP ArcHyperbolicFunctionCategory>>=
 )abbrev category AHYP ArcHyperbolicFunctionCategory
 ++ Category for the inverse hyperbolic trigonometric functions
@@ -47,6 +55,10 @@ ArcHyperbolicFunctionCategory(): Category == with
 \section{category ATRIG ArcTrigonometricFunctionCategory}
 The [[asec]] and [[acsc]] functions were modified to include an
 intermediate test to check that the argument has a reciprocal values.
+<<dot>>=
+"ATRIG" -> "CATEGORY"
+"ArcTrigonometricFunctionCategory()" -> "Category"
+@
 <<category ATRIG ArcTrigonometricFunctionCategory>>=
 )abbrev category ATRIG ArcTrigonometricFunctionCategory
 ++ Category for the inverse trigonometric functions
@@ -74,6 +86,10 @@ ArcTrigonometricFunctionCategory(): Category == with
 \section{category HYPCAT HyperbolicFunctionCategory}
 The [[csch]] and [[sech]] functions were modified to include an
 intermediate test to check that the argument has a reciprocal values.
+<<dot>>=
+"HYPCAT" -> "CATEGORY"
+"HyperbolicFunctionCategory()" -> "Category"
+@
 <<category HYPCAT HyperbolicFunctionCategory>>=
 )abbrev category HYPCAT HyperbolicFunctionCategory
 ++ Category for the hyperbolic trigonometric functions
@@ -111,6 +127,23 @@ HyperbolicFunctionCategory(): Category == with
 The [[acsch]], [[asech]], and [[acoth]] functions were modified to
 include an intermediate test to check that the argument has a
 reciprocal values.
+<<dot>>=
+"TRANFUN" -> "TRIGCAT"
+"TranscendentalFunctionCategory()" ->
+    "TrigonometricFunctionCategory()"
+"TRANFUN" -> "ATRIG"
+"TranscendentalFunctionCategory()" ->
+    "ArcTrigonometricFunctionCategory()"
+"TRANFUN" -> "HYPCAT"
+"TranscendentalFunctionCategory()" ->
+    "HyperbolicFunctionCategory()"
+"TRANFUN" -> "AHYP"
+"TranscendentalFunctionCategory()" ->
+    "ArcHyperbolicFunctionCategory()"
+"TRANFUN" -> "ELEMFUN"
+"TranscendentalFunctionCategory()" ->
+    "ElementaryFunctionCategory()"
+@
 <<category TRANFUN TranscendentalFunctionCategory>>=
 )abbrev category TRANFUN TranscendentalFunctionCategory
 ++ Category for the transcendental elementary functions
@@ -147,6 +180,10 @@ TranscendentalFunctionCategory(): Category ==
 \section{category TRIGCAT TrigonometricFunctionCategory}
 The [[csc]] and [[sec]] functions were modified to include an
 intermediate test to check that the argument has a reciprocal values.
+<<dot>>=
+"TRIGCAT" -> "CATEGORY"
+"TrigonometricFunctionCategory()" -> "Category"
+@
 <<category TRIGCAT TrigonometricFunctionCategory>>=
 )abbrev category TRIGCAT TrigonometricFunctionCategory
 ++ Category for the trigonometric functions
@@ -174,6 +211,10 @@ TrigonometricFunctionCategory(): Category == with
 
 @
 \section{category PRIMCAT PrimitiveFunctionCategory}
+<<dot>>=
+"PRIMCAT" -> "CATEGORY"
+"PrimitiveFunctionCategory()" -> "Category"
+@
 <<category PRIMCAT PrimitiveFunctionCategory>>=
 )abbrev category PRIMCAT PrimitiveFunctionCategory
 ++ Category for the integral functions
@@ -190,6 +231,12 @@ PrimitiveFunctionCategory(): Category == with
 
 @
 \section{category LFCAT LiouvillianFunctionCategory}
+<<dot>>=
+"LFCAT" -> "PRIMCAT"
+"LiouvillianFunctionCategory()" -> "PrimitiveFunctionCategory()"
+"LFCAT" -> "TRANFUN"
+"LiouvillianFunctionCategory()" -> "TranscendentalFunctionCategory()"
+@
 <<category LFCAT LiouvillianFunctionCategory>>=
 )abbrev category LFCAT LiouvillianFunctionCategory
 ++ Category for the transcendental Liouvillian functions
@@ -220,6 +267,10 @@ LiouvillianFunctionCategory(): Category ==
 
 @
 \section{category CFCAT CombinatorialFunctionCategory}
+<<dot>>=
+"CFCAT" -> "CATEGORY" 
+"CombinatorialFunctionCategory()" -> "Category"
+@
 <<category CFCAT CombinatorialFunctionCategory>>=
 )abbrev category CFCAT CombinatorialFunctionCategory
 ++ Category for the usual combinatorial functions
@@ -243,6 +294,10 @@ CombinatorialFunctionCategory(): Category == with
 
 @
 \section{category SPFCAT SpecialFunctionCategory}
+<<dot>>=
+"SPFCAT" -> "CATEGORY"
+"SpecialFunctionCategory()" -> "Category"
+@
 <<category SPFCAT SpecialFunctionCategory>>=
 )abbrev category SPFCAT SpecialFunctionCategory
 ++ Category for the other special functions




