From MAILER-DAEMON Fri Oct 03 04:06:25 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Klfg9-00047p-6n
	for mharc-axiom-developer@gnu.org; Fri, 03 Oct 2008 04:06:25 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Klfg6-00047T-D1
	for axiom-developer@nongnu.org; Fri, 03 Oct 2008 04:06:22 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Klfg3-000471-MB
	for axiom-developer@nongnu.org; Fri, 03 Oct 2008 04:06:21 -0400
Received: from [199.232.76.173] (port=42463 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Klfg3-00046y-I8
	for axiom-developer@nongnu.org; Fri, 03 Oct 2008 04:06:19 -0400
Received: from mx20.gnu.org ([199.232.41.8]:49262)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <daly@axiom-developer.org>)
	id 1Klfg2-0007bd-FI
	for axiom-developer@nongnu.org; Fri, 03 Oct 2008 04:06:19 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]
	helo=axiom-developer.org) by mx20.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Klfg0-0008OK-Lv
	for axiom-developer@nongnu.org; Fri, 03 Oct 2008 04:06:17 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m9383Or3009024;
	Fri, 3 Oct 2008 03:03:24 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m9383OZr009020;
	Fri, 3 Oct 2008 03:03:24 -0500
Date: Fri, 3 Oct 2008 03:03:24 -0500
Message-Id: <200810030803.m9383OZr009020@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by mx20.gnu.org: Linux 2.6? (barebone, rare!)
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6,
	seldom 2.4 (older, 4)
Cc: 
Subject: [Axiom-developer] 20081001.01.tpd.patch (bookvol10.2 add more
	categories)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Fri, 03 Oct 2008 08:06:22 -0000

add FiniteAlgebraicExtensionField, FiniteFieldCategory
======================================================================
diff --git a/books/bookvol10.2.pamphlet b/books/bookvol10.2.pamphlet
index 940e136..f0cea1d 100644
--- a/books/bookvol10.2.pamphlet
+++ b/books/bookvol10.2.pamphlet
@@ -1339,6 +1339,7 @@ digraph pic {
 
 {\bf See:}\\
 \pageto{ExtensionField}{XF}
+\pageto{FiniteAlgebraicExtensionField}{FAXF}
 \pageto{FullyRetractableTo}{FRETRCT}
 \pageto{GradedAlgebra}{GRALG}
 \pagefrom{Category}{CATEGORY}
@@ -2626,6 +2627,7 @@ digraph pic {
 \pagepic{ps/v102finite.ps}{FINITE}{1.00}
 
 {\bf See:}\\
+\pageto{FiniteFieldCategory}{FFIELDC}
 \pageto{OrderedFinite}{ORDFIN}
 \pagefrom{SetCategory}{SETCAT}
 
@@ -3689,6 +3691,7 @@ digraph pic {
 \pagepic{ps/v102stepthrough.ps}{STEP}{1.00}
 
 {\bf See:}\\
+\pageto{FiniteFieldCategory}{FFIELDC}
 \pagefrom{SetCategory}{SETCAT}
 
 {\bf Exports:}\\
@@ -16328,6 +16331,7 @@ digraph pic {
 \pagepic{ps/v102differentialring.ps}{DIFRING}{0.90}
 
 {\bf See:}\\
+\pageto{FiniteFieldCategory}{FFIELDC}
 \pagefrom{Ring}{RING}
 
 {\bf Exports:}\\
@@ -19066,16 +19070,16 @@ FiniteRankNonAssociativeAlgebra(R:CommutativeRing):
       b := someBasis()
       n := rank()
       recip(2 * 1$R) case "failed" =>                             
-       messagePrint("this is not a noncommutative Jordan algebra,")$OutputForm
-       messagePrint(" as 2 is not invertible in the ground ring")$OutputForm
+       messagePrint("this is not a noncommutative Jordan algebra,_
+ as 2 is not invertible in the ground ring")$OutputForm
        false
       not flexible?()$% =>
-       messagePrint("this is not a noncommutative Jordan algebra,")$OutputForm
-       messagePrint(" as it is not flexible")$OutputForm
+       messagePrint("this is not a noncommutative Jordan algebra,_
+ as it is not flexible")$OutputForm
        false
       not jordanAdmissible?()$% =>
-       messagePrint("this is not a noncommutative Jordan algebra,")$OutputForm
-       messagePrint(" as it is not Jordan admissible")$OutputForm
+       messagePrint("this is not a noncommutative Jordan algebra,_
+ as it is not Jordan admissible")$OutputForm
        false
       messagePrint("this is a noncommutative Jordan algebra")$OutputForm
       true
@@ -21599,6 +21603,7 @@ digraph pic {
 \pagepic{ps/v102fieldofprimecharacteristic.ps}{FPC}{1.00}
 
 {\bf See:}\\
+\pageto{FiniteFieldCategory}{FFIELDC}
 \pagefrom{CharacteristicNonZero}{CHARNZ}
 \pagefrom{Field}{FIELD}
 
@@ -21721,6 +21726,7 @@ These exports come from \refto{Field}():
  ?**? : (%,NonNegativeInteger) -> %
  ?^? : (%,PositiveInteger) -> %
  ?^? : (%,NonNegativeInteger) -> %
+ ?^? : (%,Integer) -> %
  ?/? : (%,%) -> %                     
  ?quo? : (%,%) -> %                   
  ?rem? : (%,%) -> %                   
@@ -21905,9 +21911,9 @@ These exports come from \refto{Algebra}(R:CommutativeRing):
 
 These exports come from \refto{Field}():
 \begin{verbatim}
+ coerce : R -> %
  ?*? : (R,%) -> %                     
  ?*? : (%,R) -> %
- coerce : R -> %
 \end{verbatim}
 
 These exports come from \refto{CharacteristicNonZero}():
@@ -22209,6 +22215,7 @@ digraph pic {
 \pagepic{ps/v102extensionfield.ps}{XF}{0.75}
 
 {\bf See:}\\
+\pageto{FiniteAlgebraicExtensionField}{FAXF}
 \pagefrom{Field}{FIELD}
 \pagefrom{RetractableTo}{RETRACT}
 \pagefrom{VectorSpace}{VSPACE}
@@ -22505,6 +22512,482 @@ digraph pic {
 
 @
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\pagehead{FiniteFieldCategory}{FFIELDC}
+\pagepic{ps/v102finitefieldcategory.ps}{FFIELDC}{1.00}
+
+{\bf See:}\\
+\pagefrom{DifferentialRing}{DIFRING}
+\pagefrom{FieldOfPrimeCharacteristic}{FPC}
+\pagefrom{Finite}{FINITE}
+\pagefrom{StepThrough}{STEP}
+
+{\bf Exports:}\\
+\begin{tabular}{lllll}
+\cross{FFIELDC}{0} &
+\cross{FFIELDC}{1} &
+\cross{FFIELDC}{associates?} &
+\cross{FFIELDC}{characteristic} &
+\cross{FFIELDC}{charthRoot} \\
+\cross{FFIELDC}{coerce} &
+\cross{FFIELDC}{conditionP} &
+\cross{FFIELDC}{createPrimitiveElement} &
+\cross{FFIELDC}{D} &
+\cross{FFIELDC}{differentiate} \\
+\cross{FFIELDC}{discreteLog} &
+\cross{FFIELDC}{divide} &
+\cross{FFIELDC}{euclideanSize} &
+\cross{FFIELDC}{expressIdealMember} &
+\cross{FFIELDC}{exquo} \\
+\cross{FFIELDC}{extendedEuclidean} &
+\cross{FFIELDC}{factor} &
+\cross{FFIELDC}{factorsOfCyclicGroupSize} &
+\cross{FFIELDC}{gcd} &
+\cross{FFIELDC}{gcdPolynomial} \\
+\cross{FFIELDC}{hash} &
+\cross{FFIELDC}{index} &
+\cross{FFIELDC}{init} &
+\cross{FFIELDC}{inv} &
+\cross{FFIELDC}{latex} \\
+\cross{FFIELDC}{lcm} &
+\cross{FFIELDC}{lookup} &
+\cross{FFIELDC}{multiEuclidean} &
+\cross{FFIELDC}{nextItem} &
+\cross{FFIELDC}{one?} \\
+\cross{FFIELDC}{order} &
+\cross{FFIELDC}{prime?} &
+\cross{FFIELDC}{primeFrobenius} &
+\cross{FFIELDC}{primitive?} &
+\cross{FFIELDC}{primitiveElement} \\
+\cross{FFIELDC}{principalIdeal} &
+\cross{FFIELDC}{random} &
+\cross{FFIELDC}{recip} &
+\cross{FFIELDC}{representationType} &
+\cross{FFIELDC}{sample} \\
+\cross{FFIELDC}{size} &
+\cross{FFIELDC}{sizeLess?} &
+\cross{FFIELDC}{squareFree} &
+\cross{FFIELDC}{squareFreePart} &
+\cross{FFIELDC}{subtractIfCan} \\
+\cross{FFIELDC}{tableForDiscreteLogarithm} &
+\cross{FFIELDC}{unit?} &
+\cross{FFIELDC}{unitCanonical} &
+\cross{FFIELDC}{unitNormal} &
+\cross{FFIELDC}{zero?} \\
+\cross{FFIELDC}{?*?} &
+\cross{FFIELDC}{?**?} &
+\cross{FFIELDC}{?+?} &
+\cross{FFIELDC}{?-?} &
+\cross{FFIELDC}{-?} \\
+\cross{FFIELDC}{?/?} &
+\cross{FFIELDC}{?=?} &
+\cross{FFIELDC}{?\^{}?} &
+\cross{FFIELDC}{?quo?} &
+\cross{FFIELDC}{?rem?} \\
+\cross{FFIELDC}{?\~{}=?} &&&&
+\end{tabular}
+
+These are directly exported but not implemented:
+\begin{verbatim}
+ factorsOfCyclicGroupSize : () ->
+    List Record(factor: Integer,exponent: Integer)
+ tableForDiscreteLogarithm : Integer ->
+    Table(PositiveInteger,NonNegativeInteger)
+ primitiveElement : () -> %           
+ representationType : () -> Union("prime",polynomial,normal,cyclic)
+\end{verbatim}
+
+These are implemented by this category:
+\begin{verbatim}
+ charthRoot : % -> %
+ charthRoot : % -> Union(%,"failed")
+ conditionP : Matrix % -> Union(Vector %,"failed")
+ createPrimitiveElement : () -> %     
+ differentiate : % -> %
+ discreteLog : % -> NonNegativeInteger
+ discreteLog : (%,%) -> Union(NonNegativeInteger,"failed")
+ gcdPolynomial : (SparseUnivariatePolynomial %,
+                  SparseUnivariatePolynomial %) ->
+                      SparseUnivariatePolynomial %
+ init : () -> %
+ nextItem : % -> Union(%,"failed")
+ order : % -> OnePointCompletion PositiveInteger
+ order : % -> PositiveInteger         
+ primitive? : % -> Boolean
+\end{verbatim}
+
+These exports come from \refto{FieldOfPrimeCharacteristic}():
+\begin{verbatim}
+ 0 : () -> %
+ 1 : () -> %                          
+ associates? : (%,%) -> Boolean       
+ characteristic : () -> NonNegativeInteger
+ coerce : % -> %
+ coerce : Integer -> %                
+ coerce : % -> OutputForm
+ coerce : Fraction Integer -> %       
+ divide : (%,%) -> Record(quotient: %,remainder: %)
+ euclideanSize : % -> NonNegativeInteger
+ expressIdealMember : (List %,%) -> Union(List %,"failed")
+ extendedEuclidean : (%,%,%) -> Union(Record(coef1: %,coef2: %),"failed")
+ extendedEuclidean : (%,%) -> Record(coef1: %,coef2: %,generator: %)
+ exquo : (%,%) -> Union(%,"failed")
+ factor : % -> Factored %             
+ gcd : List % -> %
+ gcd : (%,%) -> %                     
+ hash : % -> SingleInteger
+ inv : % -> %                         
+ latex : % -> String
+ lcm : List % -> %                    
+ lcm : (%,%) -> %
+ multiEuclidean : (List %,%) -> Union(List %,"failed")
+ one? : % -> Boolean
+ prime? : % -> Boolean
+ primeFrobenius : % -> %              
+ primeFrobenius : (%,NonNegativeInteger) -> %
+ principalIdeal : List % -> Record(coef: List %,generator: %)
+ recip : % -> Union(%,"failed")
+ sample : () -> %
+ sizeLess? : (%,%) -> Boolean
+ squareFree : % -> Factored %         
+ squareFreePart : % -> %
+ subtractIfCan : (%,%) -> Union(%,"failed")
+ unit? : % -> Boolean                 
+ unitCanonical : % -> %
+ unitNormal : % -> Record(unit: %,canonical: %,associate: %)
+ zero? : % -> Boolean                 
+ ?+? : (%,%) -> %
+ ?=? : (%,%) -> Boolean
+ ?~=? : (%,%) -> Boolean
+ ?*? : (Fraction Integer,%) -> %      
+ ?*? : (%,Fraction Integer) -> %
+ ?*? : (%,%) -> %                     
+ ?*? : (Integer,%) -> %
+ ?*? : (PositiveInteger,%) -> %       
+ ?*? : (NonNegativeInteger,%) -> %
+ ?-? : (%,%) -> %                     
+ -? : % -> %
+ ?**? : (%,Integer) -> %
+ ?**? : (%,PositiveInteger) -> %      
+ ?**? : (%,NonNegativeInteger) -> %
+ ?^? : (%,PositiveInteger) -> %
+ ?^? : (%,NonNegativeInteger) -> %
+ ?^? : (%,Integer) -> %               
+ ?/? : (%,%) -> %                     
+ ?quo? : (%,%) -> %
+ ?rem? : (%,%) -> %                   
+\end{verbatim}
+
+These exports come from \refto{Finite}():
+\begin{verbatim}
+ index : PositiveInteger -> %         
+ lookup : % -> PositiveInteger        
+ random : () -> %                     
+ size : () -> NonNegativeInteger      
+\end{verbatim}
+
+These exports come from \refto{StepThrough}():
+\begin{verbatim}
+\end{verbatim}
+
+These exports come from \refto{DifferentialRing}():
+\begin{verbatim}
+ D : % -> %                           
+ D : (%,NonNegativeInteger) -> %
+ differentiate : (%,NonNegativeInteger) -> %
+\end{verbatim}
+
+<<category FFIELDC FiniteFieldCategory>>=
+)abbrev category FFIELDC FiniteFieldCategory
+++ Author: J. Grabmeier, A. Scheerhorn
+++ Date Created: 11 March 1991
+++ Date Last Updated: 31 March 1991
+++ Basic Operations: _+, _*, extensionDegree, order, primitiveElement
+++ Related Constructors:
+++ Also See:
+++ AMS Classifications:
+++ Keywords: field, extension field, algebraic extension, finite field
+++  Galois field
+++ References:
+++  D.Lipson, Elements of Algebra and Algebraic Computing, The
+++  Benjamin/Cummings Publishing Company, Inc.-Menlo Park, California, 1981.
+++  J. Grabmeier, A. Scheerhorn: Finite Fields in AXIOM.
+++  AXIOM Technical Report Series, ATR/5 NP2522.
+++ Description:
+++  FiniteFieldCategory is the category of finite fields
+
+FiniteFieldCategory() : Category ==_
+  Join(FieldOfPrimeCharacteristic,Finite,StepThrough,DifferentialRing) with
+--                 ,PolynomialFactorizationExplicit) with
+    charthRoot: $ -> $
+      ++ charthRoot(a) takes the characteristic'th root of {\em a}.
+      ++ Note: such a root is alway defined in finite fields.
+    conditionP: Matrix $ -> Union(Vector $,"failed")
+      ++ conditionP(mat), given a matrix representing a homogeneous system
+      ++ of equations, returns a vector whose characteristic'th powers
+      ++ is a non-trivial solution, or "failed" if no such vector exists.
+    -- the reason for implementing the following function is that we
+    -- can implement the functions order, getGenerator and primitive? on
+    -- category level without computing the, may be time intensive,
+    -- factorization of size()-1 at every function call again.
+    factorsOfCyclicGroupSize:_
+      () -> List Record(factor:Integer,exponent:Integer)
+      ++ factorsOfCyclicGroupSize() returns the factorization of size()-1
+    -- the reason for implementing the function tableForDiscreteLogarithm
+    -- is that we can implement the functions discreteLog and
+    -- shanksDiscLogAlgorithm on category level
+    -- computing the necessary exponentiation tables in the respective
+    -- domains once and for all
+    -- absoluteDegree : $ -> PositiveInteger
+    --  ++ degree of minimal polynomial, if algebraic with respect
+    --  ++ to the prime subfield
+    tableForDiscreteLogarithm: Integer -> _
+             Table(PositiveInteger,NonNegativeInteger)
+      ++ tableForDiscreteLogarithm(a,n) returns a table of the discrete
+      ++ logarithms of \spad{a**0} up to \spad{a**(n-1)} which, called with
+      ++ key \spad{lookup(a**i)} returns i for i in \spad{0..n-1}.
+      ++ Error: if not called for prime divisors of order of
+      ++        multiplicative group.
+    createPrimitiveElement: () -> $
+      ++ createPrimitiveElement() computes a generator of the (cyclic)
+      ++ multiplicative group of the field.
+      -- RDJ: Are these next lines to be included?
+      -- we run through the field and test, algorithms which construct
+      -- elements of larger order were found to be too slow
+    primitiveElement: () -> $
+      ++ primitiveElement() returns a primitive element stored in a global
+      ++ variable in the domain.
+      ++ At first call, the primitive element is computed
+      ++ by calling \spadfun{createPrimitiveElement}.
+    primitive?: $ -> Boolean
+      ++ primitive?(b) tests whether the element b is a generator of the
+      ++ (cyclic) multiplicative group of the field, i.e. is a primitive
+      ++ element.
+      ++ Implementation Note: see ch.IX.1.3, th.2 in D. Lipson.
+    discreteLog: $ -> NonNegativeInteger
+      ++ discreteLog(a) computes the discrete logarithm of \spad{a}
+      ++ with respect to \spad{primitiveElement()} of the field.
+    order: $ -> PositiveInteger
+      ++ order(b) computes the order of an element b in the multiplicative
+      ++ group of the field.
+      ++ Error: if b equals 0.
+    representationType: () -> Union("prime","polynomial","normal","cyclic")
+      ++ representationType() returns the type of the representation, one of:
+      ++ \spad{prime}, \spad{polynomial}, \spad{normal}, or \spad{cyclic}.
+  add
+    I   ==> Integer
+    PI  ==> PositiveInteger
+    NNI ==> NonNegativeInteger
+    SUP ==> SparseUnivariatePolynomial
+    DLP ==> DiscreteLogarithmPackage
+
+    -- exported functions
+
+    differentiate x          == 0
+
+    init() == 0
+
+    nextItem(a) ==
+      zero?(a:=index(lookup(a)+1)) => "failed"
+      a
+
+    order(e):OnePointCompletion(PositiveInteger) ==
+      (order(e)@PI)::OnePointCompletion(PositiveInteger)
+
+    conditionP(mat:Matrix $) ==
+      l:=nullSpace mat
+      empty? l or every?(zero?, first l) => "failed"
+      map(charthRoot,first l)
+
+    charthRoot(x:$):$ == x**(size() quo characteristic())
+
+    charthRoot(x:%):Union($,"failed") ==
+        (charthRoot(x)@$)::Union($,"failed")
+
+    createPrimitiveElement() ==
+      sm1  : PositiveInteger := (size()$$-1) pretend PositiveInteger
+      start : Integer :=
+        -- in the polynomial case, index from 1 to characteristic-1
+        -- gives prime field elements
+        representationType = "polynomial" => characteristic()::Integer
+        1
+      found : Boolean := false
+      for i in start..  while not found repeat
+        e : $ := index(i::PositiveInteger)
+        found := (order(e) = sm1)
+      e
+
+    primitive? a ==
+      -- add special implementation for prime field case
+      zero?(a) => false
+      explist := factorsOfCyclicGroupSize()
+      q:=(size()-1)@Integer
+      equalone : Boolean := false
+      for exp in explist while not equalone repeat
+--        equalone := one?(a**(q quo exp.factor))
+        equalone := ((a**(q quo exp.factor)) = 1)
+      not equalone
+
+    order e ==
+      e = 0 => error "order(0) is not defined "
+      ord:Integer:= size()-1 -- order e divides ord
+      a:Integer:= 0
+      lof:=factorsOfCyclicGroupSize()
+      for rec in lof repeat -- run through prime divisors
+        a := ord quo (primeDivisor := rec.factor)
+--        goon := one?(e**a)
+        goon := ((e**a) = 1)
+        -- run through exponents of the prime divisors
+        for j in 0..(rec.exponent)-2 while goon repeat
+          -- as long as we get (e**ord = 1) we
+          -- continue dividing by primeDivisor
+          ord := a
+          a := ord quo primeDivisor
+--          goon := one?(e**a)
+          goon := ((e**a) = 1)
+        if goon then ord := a
+        -- as we do a top down search we have found the
+        -- correct exponent of primeDivisor in order e
+        -- and continue with next prime divisor
+      ord pretend PositiveInteger
+
+    discreteLog(b) ==
+      zero?(b) => error "discreteLog: logarithm of zero"
+      faclist:=factorsOfCyclicGroupSize()
+      a:=b
+      gen:=primitiveElement()
+      -- in GF(2) its necessary to have discreteLog(1) = 1
+      b = gen => 1
+      disclog:Integer:=0
+      mult:Integer:=1
+      groupord := (size() - 1)@Integer
+      exp:Integer:=groupord
+      for f in faclist repeat
+        fac:=f.factor
+        for t in 0..f.exponent-1 repeat
+          exp:=exp quo fac
+          -- shanks discrete logarithm algorithm
+          exptable:=tableForDiscreteLogarithm(fac)
+          n:=#exptable
+          c:=a**exp
+          end:=(fac - 1) quo n
+          found:=false
+          disc1:Integer:=0
+          for i in 0..end while not found repeat
+            rho:= search(lookup(c),exptable)_
+                  $Table(PositiveInteger,NNI)
+            rho case NNI =>
+              found := true
+              disc1:=((n * i + rho)@Integer) * mult
+            c:=c* gen**((groupord quo fac) * (-n))
+          not found => error "discreteLog: ?? discrete logarithm"
+          -- end of shanks discrete logarithm algorithm
+          mult := mult * fac
+          disclog:=disclog+disc1
+          a:=a * (gen ** (-disc1))
+      disclog pretend NonNegativeInteger
+
+    discreteLog(logbase,b) ==
+      zero?(b) =>
+        messagePrint("discreteLog: logarithm of zero")$OutputForm
+        "failed"
+      zero?(logbase) =>
+        messagePrint("discreteLog: logarithm to base zero")$OutputForm
+        "failed"
+      b = logbase => 1
+      not zero?((groupord:=order(logbase)@PI) rem order(b)@PI) =>
+         messagePrint("discreteLog: second argument not in cyclic group_
+ generated by first argument")$OutputForm
+         "failed"
+      faclist:=factors factor groupord
+      a:=b
+      disclog:Integer:=0
+      mult:Integer:=1
+      exp:Integer:= groupord
+      for f in faclist repeat
+        fac:=f.factor
+        primroot:= logbase ** (groupord quo fac)
+        for t in 0..f.exponent-1 repeat
+          exp:=exp quo fac
+          rhoHelp:= shanksDiscLogAlgorithm(primroot,_
+                a**exp,fac pretend NonNegativeInteger)$DLP($)
+          rhoHelp case "failed" => return "failed"
+          rho := (rhoHelp :: NNI) * mult
+          disclog := disclog + rho
+          mult := mult * fac
+          a:=a * (logbase ** (-rho))
+      disclog pretend NonNegativeInteger
+
+    FP ==> SparseUnivariatePolynomial($)
+    FRP ==> Factored FP
+    f,g:FP
+
+    squareFreePolynomial(f:FP):FRP ==
+          squareFree(f)$UnivariatePolynomialSquareFree($,FP)
+
+    factorPolynomial(f:FP):FRP == factor(f)$DistinctDegreeFactorize($,FP)
+
+    factorSquareFreePolynomial(f:FP):FRP ==
+        f = 0 => 0
+        flist := distdfact(f,true)$DistinctDegreeFactorize($,FP)
+        (flist.cont :: FP) *
+            (*/[primeFactor(u.irr,u.pow) for u in flist.factors])
+
+    gcdPolynomial(f:FP,g:FP):FP ==
+         gcd(f,g)$EuclideanDomain_&(FP)
+
+@
+<<FFIELDC.dotabb>>=
+"FFIELDC"
+ [color=lightblue,href="bookvol10.2.pdf#nameddest=FFIELDC"];
+"FFIELDC" -> "FPC"
+"FFIELDC" -> "FINITE"
+"FFIELDC" -> "STEP"
+"FFIELDC" -> "DIFRING"
+
+@
+<<FFIELDC.dotfull>>=
+"FiniteFieldCategory()"
+ [color=lightblue,href="bookvol10.2.pdf#nameddest=FFIELDC"];
+"FiniteFieldCategory()" -> "FieldOfPrimeCharacteristic()"
+"FiniteFieldCategory()" -> "Finite()"
+"FiniteFieldCategory()" -> "StepThrough()"
+"FiniteFieldCategory()" -> "DifferentialRing()"
+
+@
+<<FFIELDC.dotpic>>=
+digraph pic {
+ fontsize=10;
+ bgcolor="#FFFF66";
+ node [shape=box, color=white, style=filled];
+
+"FiniteFieldCategory()" [color=lightblue];
+"FiniteFieldCategory()" -> "FieldOfPrimeCharacteristic()"
+"FiniteFieldCategory()" -> "Finite()"
+"FiniteFieldCategory()" -> "StepThrough()"
+"FiniteFieldCategory()" -> "DifferentialRing()"
+
+"FieldOfPrimeCharacteristic()" [color=lightblue];
+"FieldOfPrimeCharacteristic()" -> "CHARNZ..."
+"FieldOfPrimeCharacteristic()" -> "FIELD..."
+
+"Finite()" [color=lightblue];
+"Finite()" -> "SETCAT..."
+
+"StepThrough()" [color=lightblue];
+"StepThrough()" -> "SETCAT..."
+
+"DifferentialRing()" [color=lightblue];
+"DifferentialRing()" -> "RING..."
+
+"RING..." [color=lightblue];
+"FIELD..." [color=lightblue];
+"CHARNZ..." [color=lightblue];
+"SETCAT..." [color=lightblue];
+
+}
+
+@
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \pagehead{FunctionFieldCategory}{FFCAT}
 \pagepic{ps/v102functionfieldcategory.ps}{FFCAT}{0.70}
 
@@ -23720,6 +24203,629 @@ digraph pic {
 }
 
 @
+\chapter{Category Layer 19}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\pagehead{FiniteAlgebraicExtensionField}{FAXF}
+\pagepic{ps/v102finitealgebraicextensionfield.ps}{FAXF}{0.75}
+
+{\bf See:}\\
+\pagefrom{ExtensionField}{XF}
+\pagefrom{RetractableTo}{RETRACT}
+
+{\bf Exports:}\\
+\begin{tabular}{lllll}
+\cross{FAXF}{0} &
+\cross{FAXF}{1} &
+\cross{FAXF}{algebraic?} \\
+\cross{FAXF}{associates?} &
+\cross{FAXF}{basis} &
+\cross{FAXF}{characteristic} \\
+\cross{FAXF}{charthRoot} &
+\cross{FAXF}{coerce} &
+\cross{FAXF}{conditionP} \\
+\cross{FAXF}{coordinates} &
+\cross{FAXF}{createNormalElement} &
+\cross{FAXF}{createPrimitiveElement} \\
+\cross{FAXF}{D} &
+\cross{FAXF}{definingPolynomial} &
+\cross{FAXF}{degree} \\
+\cross{FAXF}{differentiate} &
+\cross{FAXF}{dimension} &
+\cross{FAXF}{discreteLog} \\
+\cross{FAXF}{divide} &
+\cross{FAXF}{euclideanSize} &
+\cross{FAXF}{expressIdealMember} \\
+\cross{FAXF}{exquo} &
+\cross{FAXF}{extendedEuclidean} &
+\cross{FAXF}{extensionDegree} \\
+\cross{FAXF}{factor} &
+\cross{FAXF}{factorsOfCyclicGroupSize} &
+\cross{FAXF}{Frobenius} \\
+\cross{FAXF}{gcd} &
+\cross{FAXF}{gcdPolynomial} &
+\cross{FAXF}{generator} \\
+\cross{FAXF}{hash} &
+\cross{FAXF}{index} &
+\cross{FAXF}{inGroundField?} \\
+\cross{FAXF}{init} &
+\cross{FAXF}{inv} &
+\cross{FAXF}{latex} \\
+\cross{FAXF}{lcm} &
+\cross{FAXF}{linearAssociatedExp} &
+\cross{FAXF}{linearAssociatedLog} \\
+\cross{FAXF}{linearAssociatedOrder} &
+\cross{FAXF}{lookup} &
+\cross{FAXF}{minimalPolynomial} \\
+\cross{FAXF}{multiEuclidean} &
+\cross{FAXF}{nextItem} &
+\cross{FAXF}{norm} \\
+\cross{FAXF}{normal?} &
+\cross{FAXF}{normalElement} &
+\cross{FAXF}{one?} \\
+\cross{FAXF}{order} &
+\cross{FAXF}{prime?} &
+\cross{FAXF}{primeFrobenius} \\
+\cross{FAXF}{primitive?} &
+\cross{FAXF}{primitiveElement} &
+\cross{FAXF}{principalIdeal} \\
+\cross{FAXF}{random} &
+\cross{FAXF}{recip} &
+\cross{FAXF}{representationType} \\
+\cross{FAXF}{represents} &
+\cross{FAXF}{retract} &
+\cross{FAXF}{retractIfCan} \\
+\cross{FAXF}{sample} &
+\cross{FAXF}{size} &
+\cross{FAXF}{sizeLess?} \\
+\cross{FAXF}{squareFree} &
+\cross{FAXF}{squareFreePart} &
+\cross{FAXF}{subtractIfCan} \\
+\cross{FAXF}{tableForDiscreteLogarithm} &
+\cross{FAXF}{trace} &
+\cross{FAXF}{transcendenceDegree} \\
+\cross{FAXF}{transcendent?} &
+\cross{FAXF}{unit?} &
+\cross{FAXF}{unitCanonical} \\
+\cross{FAXF}{unitNormal} &
+\cross{FAXF}{zero?} &
+\cross{FAXF}{?*?} \\
+\cross{FAXF}{?**?} &
+\cross{FAXF}{?+?} &
+\cross{FAXF}{?-?} \\
+\cross{FAXF}{-?} &
+\cross{FAXF}{?/?} &
+\cross{FAXF}{?/?} \\
+\cross{FAXF}{?=?} &
+\cross{FAXF}{?\^{}?} &
+\cross{FAXF}{?quo?} \\
+\cross{FAXF}{?rem?} &
+\cross{FAXF}{?\~{}=?} &
+\end{tabular}
+
+These are directly exported but not implemented:
+\begin{verbatim}
+ basis : () -> Vector %               
+ basis : PositiveInteger -> Vector %
+ coordinates : % -> Vector F          
+ definingPolynomial : () -> SparseUnivariatePolynomial F
+ generator : () -> % if F has FINITE
+ minimalPolynomial : (%,PositiveInteger) ->
+    SparseUnivariatePolynomial % 
+      if F has FINITE
+ normalElement : () -> % if F has FINITE
+\end{verbatim}
+
+These are implemented by this category:
+\begin{verbatim}
+ algebraic? : % -> Boolean            
+ charthRoot : % -> Union(%,"failed") 
+     if F has CHARNZ or F has FINITE
+ coordinates : Vector % -> Matrix F
+ createNormalElement : () -> % if F has FINITE
+ degree : % -> PositiveInteger
+ dimension : () -> CardinalNumber     
+ extensionDegree : () -> PositiveInteger
+ linearAssociatedExp : (%,SparseUnivariatePolynomial F) -> % 
+     if F has FINITE
+ linearAssociatedLog : (%,%) ->
+    Union(SparseUnivariatePolynomial F,"failed") 
+      if F has FINITE
+ linearAssociatedLog : % -> SparseUnivariatePolynomial F 
+     if F has FINITE
+ linearAssociatedOrder : % -> SparseUnivariatePolynomial F 
+     if F has FINITE
+ minimalPolynomial : % -> SparseUnivariatePolynomial F
+ norm : % -> F                        
+ norm : (%,PositiveInteger) -> % if F has FINITE
+ normal? : % -> Boolean if F has FINITE
+ represents : Vector F -> %           
+ size : () -> NonNegativeInteger if F has FINITE
+ trace : % -> F                       
+ trace : (%,PositiveInteger) -> % if F has FINITE
+ transcendenceDegree : () -> NonNegativeInteger
+ transcendent? : % -> Boolean
+\end{verbatim}
+
+These exports come from \refto{ExtensionField}(F:Field):
+\begin{verbatim}
+ 0 : () -> %
+ 1 : () -> %                          
+ associates? : (%,%) -> Boolean
+ characteristic : () -> NonNegativeInteger
+ coerce : F -> %
+ coerce : % -> %
+ coerce : Integer -> %                
+ coerce : % -> OutputForm
+ coerce : Fraction Integer -> %       
+ discreteLog : (%,%) ->
+    Union(NonNegativeInteger,"failed")
+      if F has CHARNZ or F has FINITE
+ divide : (%,%) -> Record(quotient: %,remainder: %)
+ euclideanSize : % -> NonNegativeInteger
+ expressIdealMember : (List %,%) -> Union(List %,"failed")
+ exquo : (%,%) -> Union(%,"failed")
+ extendedEuclidean : (%,%,%) ->
+    Union(Record(coef1: %,coef2: %),"failed")
+ extendedEuclidean : (%,%) ->
+    Record(coef1: %,coef2: %,generator: %)
+ factor : % -> Factored %
+ Frobenius : (%,NonNegativeInteger) -> % if F has FINITE
+ Frobenius : % -> % if F has FINITE
+ gcd : List % -> %                    
+ gcd : (%,%) -> %
+ gcdPolynomial : (SparseUnivariatePolynomial %,
+                  SparseUnivariatePolynomial %) ->
+                     SparseUnivariatePolynomial %
+ hash : % -> SingleInteger            
+ inGroundField? : % -> Boolean
+ inv : % -> %                         
+ latex : % -> String
+ lcm : List % -> %                    
+ lcm : (%,%) -> %
+ multiEuclidean : (List %,%) -> Union(List %,"failed")
+ one? : % -> Boolean
+ order : % -> OnePointCompletion PositiveInteger
+      if F has CHARNZ or F has FINITE
+ prime? : % -> Boolean                
+ primeFrobenius : % -> % 
+     if F has CHARNZ or F has FINITE
+ primeFrobenius : (%,NonNegativeInteger) -> % 
+     if F has CHARNZ or F has FINITE
+ principalIdeal : List % -> Record(coef: List %,generator: %)
+ recip : % -> Union(%,"failed")       
+ retract : % -> F
+ retractIfCan : % -> Union(F,"failed")
+ sample : () -> %                     
+ squareFree : % -> Factored %         
+ squareFreePart : % -> %
+ sizeLess? : (%,%) -> Boolean
+ subtractIfCan : (%,%) -> Union(%,"failed")
+ unit? : % -> Boolean                 
+ unitCanonical : % -> %
+ unitNormal : % -> Record(unit: %,canonical: %,associate: %)
+ zero? : % -> Boolean                 
+ ?/? : (%,%) -> %
+ ?+? : (%,%) -> %
+ ?=? : (%,%) -> Boolean               
+ ?~=? : (%,%) -> Boolean
+ ?*? : (%,%) -> %                     
+ ?*? : (Integer,%) -> %
+ ?*? : (PositiveInteger,%) -> %       
+ ?*? : (NonNegativeInteger,%) -> %
+ ?*? : (Fraction Integer,%) -> %      
+ ?*? : (%,Fraction Integer) -> %
+ ?*? : (F,%) -> %                     
+ ?*? : (%,F) -> %
+ ?-? : (%,%) -> %                     
+ -? : % -> %
+ ?**? : (%,NonNegativeInteger) -> %
+ ?**? : (%,PositiveInteger) -> %      
+ ?**? : (%,Integer) -> %
+ ?^? : (%,Integer) -> %               
+ ?^? : (%,PositiveInteger) -> %
+ ?^? : (%,NonNegativeInteger) -> %
+ ?quo? : (%,%) -> %
+ ?rem? : (%,%) -> %
+ ?/? : (%,F) -> %                     
+\end{verbatim}
+
+These exports come from \refto{RetractableTo}(F:Field):
+\begin{verbatim}
+\end{verbatim}
+
+These exports come from \refto{FiniteFieldCategory}():
+\begin{verbatim}
+ charthRoot : % -> % if F has FINITE
+ conditionP : Matrix % -> Union(Vector %,"failed") 
+     if F has FINITE
+ createPrimitiveElement : () -> % if F has FINITE
+ D : % -> % if F has FINITE
+ D : (%,NonNegativeInteger) -> % if F has FINITE
+ differentiate : % -> % if F has FINITE
+ differentiate : (%,NonNegativeInteger) -> % 
+     if F has FINITE
+ discreteLog : % -> NonNegativeInteger if F has FINITE
+ factorsOfCyclicGroupSize : () ->
+    List Record(factor: Integer,exponent: Integer) 
+      if F has FINITE
+ index : PositiveInteger -> % if F has FINITE
+ init : () -> % if F has FINITE
+ lookup : % -> PositiveInteger if F has FINITE
+ nextItem : % -> Union(%,"failed") if F has FINITE
+ order : % -> PositiveInteger if F has FINITE
+ primitive? : % -> Boolean if F has FINITE
+ primitiveElement : () -> % if F has FINITE
+ random : () -> % if F has FINITE
+ representationType : () ->
+    Union("prime",polynomial,normal,cyclic) 
+      if F has FINITE
+ tableForDiscreteLogarithm : Integer ->
+    Table(PositiveInteger,NonNegativeInteger) 
+      if F has FINITE
+\end{verbatim}
+
+
+<<category FAXF FiniteAlgebraicExtensionField>>=
+)abbrev category FAXF FiniteAlgebraicExtensionField
+++ Author: J. Grabmeier, A. Scheerhorn
+++ Date Created: 11 March 1991
+++ Date Last Updated: 31 March 1991
+++ Basic Operations: _+, _*, extensionDegree,
+++ Related Constructors:
+++ Also See:
+++ AMS Classifications:
+++ Keywords: field, extension field, algebraic extension, finite extension
+++ References:
+++  R.Lidl, H.Niederreiter: Finite Field, Encycoldia of Mathematics and
+++  Its Applications, Vol. 20, Cambridge Univ. Press, 1983, 
+++  ISBN 0 521 30240 4 J. Grabmeier, A. Scheerhorn: Finite Fields in AXIOM.
+++  AXIOM Technical Report Series, ATR/5 NP2522.
+++ Description:
+++  FiniteAlgebraicExtensionField {\em F} is the category of fields
+++  which are finite algebraic extensions of the field {\em F}.
+++  If {\em F} is finite then any finite algebraic extension of {\em F} 
+++  is finite, too. Let {\em K} be a finite algebraic extension of the 
+++  finite field {\em F}. The exponentiation of elements of {\em K} 
+++  defines a Z-module structure on the multiplicative group of {\em K}. 
+++  The additive group of {\em K} becomes a module over the ring of 
+++  polynomials over {\em F} via the operation 
+++  \spadfun{linearAssociatedExp}(a:K,f:SparseUnivariatePolynomial F)
+++  which is linear over {\em F}, i.e. for elements {\em a} from {\em K},
+++  {\em c,d} from {\em F} and {\em f,g} univariate polynomials over {\em F}
+++  we have \spadfun{linearAssociatedExp}(a,cf+dg) equals {\em c} times
+++  \spadfun{linearAssociatedExp}(a,f) plus {\em d} times
+++  \spadfun{linearAssociatedExp}(a,g).
+++  Therefore \spadfun{linearAssociatedExp} is defined completely by
+++  its action on  monomials from {\em F[X]}:
+++  \spadfun{linearAssociatedExp}(a,monomial(1,k)\$SUP(F)) is defined to be
+++  \spadfun{Frobenius}(a,k) which is {\em a**(q**k)} where {\em q=size()\$F}.
+++  The operations order and discreteLog associated with the multiplicative
+++  exponentiation have additive analogues associated to the operation
+++  \spadfun{linearAssociatedExp}. These are the functions
+++  \spadfun{linearAssociatedOrder} and \spadfun{linearAssociatedLog},
+++  respectively.
+
+FiniteAlgebraicExtensionField(F : Field) : Category == _
+  Join(ExtensionField F, RetractableTo F) with
+  -- should be unified with algebras
+  -- Join(ExtensionField F, FramedAlgebra F, RetractableTo F) with
+    basis : () -> Vector $
+      ++ basis() returns a fixed basis of \$ as \spad{F}-vectorspace.
+    basis : PositiveInteger -> Vector $
+      ++ basis(n) returns a fixed basis of a subfield of \$ as
+      ++ \spad{F}-vectorspace.
+    coordinates : $ -> Vector F
+      ++ coordinates(a) returns the coordinates of \spad{a} with respect
+      ++ to the fixed \spad{F}-vectorspace basis.
+    coordinates : Vector $ -> Matrix F
+      ++ coordinates([v1,...,vm]) returns the coordinates of the
+      ++ vi's with to the fixed basis.  The coordinates of vi are
+      ++ contained in the ith row of the matrix returned by this
+      ++ function.
+    represents:  Vector F -> $
+      ++ represents([a1,..,an]) returns \spad{a1*v1 + ... + an*vn}, where
+      ++ v1,...,vn are the elements of the fixed basis.
+    minimalPolynomial: $ -> SparseUnivariatePolynomial F
+      ++ minimalPolynomial(a) returns the minimal polynomial of an
+      ++ element \spad{a} over the ground field F.
+    definingPolynomial: () -> SparseUnivariatePolynomial F
+      ++ definingPolynomial() returns the polynomial used to define
+      ++ the field extension.
+    extensionDegree : () ->  PositiveInteger
+      ++ extensionDegree() returns the degree of field extension.
+    degree : $ -> PositiveInteger
+      ++ degree(a) returns the degree of the minimal polynomial of an
+      ++ element \spad{a} over the ground field F.
+    norm: $  -> F
+      ++ norm(a) computes the norm of \spad{a} with respect to the
+      ++ field considered as an algebra with 1 over the ground field F.
+    trace: $ -> F
+      ++ trace(a) computes the trace of \spad{a} with respect to
+      ++ the field considered as an algebra with 1 over the ground field F.
+    if F has Finite then
+      FiniteFieldCategory
+      minimalPolynomial: ($,PositiveInteger) -> SparseUnivariatePolynomial $
+        ++ minimalPolynomial(x,n) computes the minimal polynomial of x over
+        ++ the field of extension degree n over the ground field F.
+      norm: ($,PositiveInteger)  -> $
+        ++ norm(a,d) computes the norm of \spad{a} with respect to the field
+        ++ of extension degree d over the ground field of size.
+        ++ Error: if d does not divide the extension degree of \spad{a}.
+        ++ Note: norm(a,d) = reduce(*,[a**(q**(d*i)) for i in 0..n/d])
+      trace: ($,PositiveInteger)   -> $
+        ++ trace(a,d) computes the trace of \spad{a} with respect to the
+        ++ field of extension degree d over the ground field of size q.
+        ++ Error: if d does not divide the extension degree of \spad{a}.
+        ++ Note: \spad{trace(a,d)=reduce(+,[a**(q**(d*i)) for i in 0..n/d])}.
+      createNormalElement: () -> $
+        ++ createNormalElement() computes a normal element over the ground
+        ++ field F, that is,
+        ++ \spad{a**(q**i), 0 <= i < extensionDegree()} is an F-basis,
+        ++ where \spad{q = size()\$F}.
+        ++ Reference: Such an element exists Lidl/Niederreiter: Theorem 2.35.
+      normalElement: () -> $
+        ++ normalElement() returns a element, normal over the ground field F,
+        ++ i.e. \spad{a**(q**i), 0 <= i < extensionDegree()} is an F-basis,
+        ++ where \spad{q = size()\$F}.
+        ++ At the first call, the element is computed by
+        ++ \spadfunFrom{createNormalElement}{FiniteAlgebraicExtensionField}
+        ++ then cached in a global variable.
+        ++ On subsequent calls, the element is retrieved by referencing the
+        ++ global variable.
+      normal?: $ -> Boolean
+        ++ normal?(a) tests whether the element \spad{a} is normal over the
+        ++ ground field F, i.e.
+        ++ \spad{a**(q**i), 0 <= i <= extensionDegree()-1} is an F-basis,
+        ++ where \spad{q = size()\$F}.
+        ++ Implementation according to Lidl/Niederreiter: Theorem 2.39.
+      generator: () -> $
+        ++ generator() returns a root of the defining polynomial.
+        ++ This element generates the field as an algebra over the ground
+        ++ field.
+      linearAssociatedExp:($,SparseUnivariatePolynomial F) -> $
+        ++ linearAssociatedExp(a,f) is linear over {\em F}, i.e.
+        ++ for elements {\em a} from {\em \$}, {\em c,d} form {\em F} and
+        ++ {\em f,g} univariate polynomials over {\em F} we have
+        ++ \spadfun{linearAssociatedExp}(a,cf+dg) equals {\em c} times
+        ++ \spadfun{linearAssociatedExp}(a,f) plus {\em d} times
+        ++ \spadfun{linearAssociatedExp}(a,g). Therefore
+        ++ \spadfun{linearAssociatedExp} is defined completely by its 
+        ++ action on monomials from {\em F[X]}:
+        ++ \spadfun{linearAssociatedExp}(a,monomial(1,k)\$SUP(F)) is 
+        ++ defined to be \spadfun{Frobenius}(a,k) which is {\em a**(q**k)},
+        ++ where {\em q=size()\$F}.
+      linearAssociatedOrder: $ -> SparseUnivariatePolynomial F
+        ++ linearAssociatedOrder(a) retruns the monic polynomial {\em g} of
+        ++ least degree, such that \spadfun{linearAssociatedExp}(a,g) is 0.
+      linearAssociatedLog: $ -> SparseUnivariatePolynomial F
+        ++ linearAssociatedLog(a) returns a polynomial {\em g}, such that
+        ++ \spadfun{linearAssociatedExp}(normalElement(),g) equals {\em a}.
+      linearAssociatedLog: ($,$) -> _
+        Union(SparseUnivariatePolynomial F,"failed")
+        ++ linearAssociatedLog(b,a) returns a polynomial {\em g}, such 
+        ++ that the \spadfun{linearAssociatedExp}(b,g) equals {\em a}.
+        ++ If there is no such polynomial {\em g}, then
+        ++ \spadfun{linearAssociatedLog} fails.
+  add
+    I   ==> Integer
+    PI  ==> PositiveInteger
+    NNI ==> NonNegativeInteger
+    SUP ==> SparseUnivariatePolynomial
+    DLP ==> DiscreteLogarithmPackage
+
+    represents(v) ==
+      a:$:=0
+      b:=basis()
+      for i in 1..extensionDegree()@PI repeat
+        a:=a+(v.i)*(b.i)
+      a
+
+    transcendenceDegree() == 0$NNI
+
+    dimension() == (#basis()) ::NonNegativeInteger::CardinalNumber
+
+    coordinates(v:Vector $) ==
+      m := new(#v, extensionDegree(), 0)$Matrix(F)
+      for i in minIndex v .. maxIndex v for j in minRowIndex m .. repeat
+        setRow_!(m, j, coordinates qelt(v, i))
+      m
+
+    algebraic? a == true
+
+    transcendent? a == false
+
+-- This definition is a duplicate and has been removed
+--    extensionDegree():OnePointCompletion(PositiveInteger) ==
+--      (#basis()) :: PositiveInteger::OnePointCompletion(PositiveInteger)
+
+    extensionDegree() == (#basis()) :: PositiveInteger
+
+-- These definitions are duplicates and have been removed
+--    degree(a):OnePointCompletion(PositiveInteger) ==
+--      degree(a)@PI::OnePointCompletion(PositiveInteger)
+
+    -- degree a == degree(minimalPolynomial a)$SUP(F) :: PI
+
+    trace a ==
+      b := basis()
+      abs : F := 0
+      for i in 1..#b repeat
+        abs := abs + coordinates(a*b.i).i
+      abs
+
+    norm a ==
+      b := basis()
+      m := new(#b,#b, 0)$Matrix(F)
+      for i in 1..#b repeat
+        setRow_!(m,i, coordinates(a*b.i))
+      determinant(m)
+
+    if F has Finite then
+      linearAssociatedExp(x,f) ==
+        erg:$:=0
+        y:=x
+        for i in 0..degree(f) repeat
+          erg:=erg + coefficient(f,i) * y
+          y:=Frobenius(y)
+        erg
+
+      linearAssociatedLog(b,x) ==
+        x=0 => 0
+        l:List List F:=[entries coordinates b]
+        a:$:=b
+        extdeg:NNI:=extensionDegree()@PI
+        for i in 2..extdeg repeat
+          a:=Frobenius(a)
+          l:=concat(l,entries coordinates a)$(List List F)
+        l:=concat(l,entries coordinates x)$(List List F)
+        m1:=rowEchelon transpose matrix(l)$(Matrix F)
+        v:=zero(extdeg)$(Vector F)
+        rown:I:=1
+        for i in 1..extdeg repeat
+          if qelt(m1,rown,i) = 1$F then
+            v.i:=qelt(m1,rown,extdeg+1)
+            rown:=rown+1
+        p:=+/[monomial(v.(i+1),i::NNI) for i in 0..(#v-1)]
+        p=0 =>
+         messagePrint("linearAssociatedLog: second argument not in_
+                       group generated by first argument")$OutputForm
+         "failed"
+        p
+
+      linearAssociatedLog(x) == linearAssociatedLog(normalElement(),x) ::
+                              SparseUnivariatePolynomial(F)
+
+      linearAssociatedOrder(x) ==
+        x=0 => 0
+        l:List List F:=[entries coordinates x]
+        a:$:=x
+        for i in 1..extensionDegree()@PI repeat
+          a:=Frobenius(a)
+          l:=concat(l,entries coordinates a)$(List List F)
+        v:=first nullSpace transpose matrix(l)$(Matrix F)
+        +/[monomial(v.(i+1),i::NNI) for i in 0..(#v-1)]
+
+      charthRoot(x):Union($,"failed") ==
+        (charthRoot(x)@$)::Union($,"failed")
+      -- norm(e) == norm(e,1) pretend F
+      -- trace(e) == trace(e,1) pretend F
+
+      minimalPolynomial(a,n) ==
+        extensionDegree()@PI rem n ^= 0 =>
+          error "minimalPolynomial: 2. argument must divide extension degree"
+        f:SUP $:=monomial(1,1)$(SUP $) - monomial(a,0)$(SUP $)
+        u:$:=Frobenius(a,n)
+        while not(u = a) repeat
+          f:=f * (monomial(1,1)$(SUP $) - monomial(u,0)$(SUP $))
+          u:=Frobenius(u,n)
+        f
+
+      norm(e,s) ==
+        qr := divide(extensionDegree(), s)
+        zero?(qr.remainder) =>
+          pow := (size()-1) quo (size()$F ** s - 1)
+          e ** (pow::NonNegativeInteger)
+        error "norm: second argument must divide degree of extension"
+
+      trace(e,s) ==
+        qr:=divide(extensionDegree(),s)
+        q:=size()$F
+        zero?(qr.remainder) =>
+          a:$:=0
+          for i in 0..qr.quotient-1 repeat
+            a:=a + e**(q**(s*i))
+          a
+        error "trace: second argument must divide degree of extension"
+
+      size() == size()$F ** extensionDegree()
+
+      createNormalElement() ==
+        characteristic() = size() => 1
+        res : $
+        for i in 1.. repeat
+          res := index(i :: PI)
+          not inGroundField? res =>
+            normal? res => return res
+        -- theorem: there exists a normal element, this theorem is
+        -- unknown to the compiler
+        res
+
+      normal?(x:$) ==
+        p:SUP $:=(monomial(1,extensionDegree()) - monomial(1,0))@(SUP $)
+        f:SUP $:= +/[monomial(Frobenius(x,i),i)$(SUP $) _
+                   for i in 0..extensionDegree()-1]
+        gcd(p,f) = 1 => true
+        false
+
+      degree a ==
+        y:$:=Frobenius a
+        deg:PI:=1
+        while y^=a repeat
+          y := Frobenius(y)
+          deg:=deg+1
+        deg
+
+@
+<<FAXF.dotabb>>=
+"FAXF"
+ [color=lightblue,href="bookvol10.2.pdf#nameddest=FAXF"];
+"FAXF" -> "XF"
+"FAXF" -> "RETRACT"
+
+@
+<<FAXF.dotfull>>=
+"FiniteAlgebraicExtensionField(a:Field)"
+ [color=lightblue,href="bookvol10.2.pdf#nameddest=FAXF"];
+"FiniteAlgebraicExtensionField(a:Field)" -> "ExtensionField(a:Field)"
+"FiniteAlgebraicExtensionField(a:Field)" -> "RetractableTo(a:Field)"
+
+@
+<<FAXF.dotpic>>=
+digraph pic {
+ fontsize=10;
+ bgcolor="#FFFF66";
+ node [shape=box, color=white, style=filled];
+
+"FiniteAlgebraicExtensionField(a:Field)"
+ [color=lightblue,href="bookvol10.2.pdf#nameddest=FAXF"];
+"FiniteAlgebraicExtensionField(a:Field)" -> "ExtensionField(a:Field)"
+"FiniteAlgebraicExtensionField(a:Field)" -> "RetractableTo(Field)"
+
+"ExtensionField(a:Field)" [color=lightblue];
+"ExtensionField(a:Field)" -> "Field()"
+"ExtensionField(a:Field)" -> "RetractableTo(Field)"
+"ExtensionField(a:Field)" -> "VectorSpace(a:Field)"
+
+"Field()" [color=lightblue];
+"Field()" -> "EuclideanDomain()"
+"Field()" -> "UniqueFactorizationDomain()"
+"Field()" -> "DIVRING..."
+
+"EuclideanDomain()" [color=lightblue];
+"EuclideanDomain()" -> "PrincipalIdealDomain()"
+
+"UniqueFactorizationDomain()" [color=lightblue];
+"UniqueFactorizationDomain()" -> "GCDDOM..."
+
+"PrincipalIdealDomain()" [color=lightblue];
+"PrincipalIdealDomain()" -> "GCDDOM..."
+
+"RetractableTo(Field)" [color=seagreen];
+"RetractableTo(Field)" -> "RetractableTo(a:Type)"
+
+"RetractableTo(a:Type)" [color=lightblue];
+"RetractableTo(a:Type)" -> "Category"
+
+"VectorSpace(a:Field)" [color=lightblue];
+"VectorSpace(a:Field)" -> "MODULE..."
+
+"MODULE..." [color=lightblue];
+"DIVRING..." [color=lightblue];
+"GCDDOM..." [color=lightblue];
+"Category" [color=lightblue];
+}
+
+@
 \chapter{The bootstrap code}
 \section{ABELGRP.lsp BOOTSTRAP} 
 {\bf ABELGRP} depends on a chain of
@@ -25558,6 +26664,639 @@ Note that this code is not included in the generated catdef.spad file.
 (MAKEPROP (QUOTE |EntireRing|) (QUOTE NILADIC) T) 
 
 @
+\section{FFIELDC.lsp BOOTSTRAP}
+{\bf FFIELDC} 
+depends on a chain of files. We need to break this cycle to build
+the algebra. So we keep a cached copy of the translated {\bf FFIELDC}
+category which we can write into the {\bf MID} directory. We compile 
+the lisp code and copy the {\bf FFIELDC.o} file to the {\bf OUT} directory.
+This is eventually forcibly replaced by a recompiled version. 
+
+Note that this code is not included in the generated catdef.spad file.
+
+<<FFIELDC.lsp BOOTSTRAP>>=
+
+(|/VERSIONCHECK| 2) 
+
+(SETQ |FiniteFieldCategory;AL| (QUOTE NIL)) 
+
+(DEFUN |FiniteFieldCategory| NIL
+ (LET (#:G83129)
+  (COND 
+   (|FiniteFieldCategory;AL|)
+   (T (SETQ |FiniteFieldCategory;AL| (|FiniteFieldCategory;|)))))) 
+
+(DEFUN |FiniteFieldCategory;| NIL
+ (PROG (#1=#:G83127)
+  (RETURN
+   (PROG1
+    (LETT #1#
+     (|Join|
+      (|FieldOfPrimeCharacteristic|)
+      (|Finite|)
+      (|StepThrough|)
+      (|DifferentialRing|)
+      (|mkCategory|
+       (QUOTE |domain|)
+       (QUOTE (
+        ((|charthRoot| (|$| |$|)) T)
+        ((|conditionP| ((|Union| (|Vector| |$|) "failed") (|Matrix| |$|))) T)
+        ((|factorsOfCyclicGroupSize|
+         ((|List| (|Record| 
+                   (|:| |factor| (|Integer|))
+                   (|:| |exponent| (|Integer|))))))
+          T)
+        ((|tableForDiscreteLogarithm|
+          ((|Table| (|PositiveInteger|) (|NonNegativeInteger|))
+           (|Integer|))) T)
+        ((|createPrimitiveElement| (|$|)) T)
+        ((|primitiveElement| (|$|)) T)
+        ((|primitive?| ((|Boolean|) |$|)) T)
+        ((|discreteLog| ((|NonNegativeInteger|) |$|)) T)
+        ((|order| ((|PositiveInteger|) |$|)) T)
+        ((|representationType|
+          ((|Union| "prime" "polynomial" "normal" "cyclic"))) T)))
+       NIL
+       (QUOTE (
+        (|PositiveInteger|)
+        (|NonNegativeInteger|)
+        (|Boolean|)
+        (|Table| (|PositiveInteger|) (|NonNegativeInteger|))
+        (|Integer|)
+        (|List|
+         (|Record| (|:| |factor| (|Integer|)) (|:| |exponent| (|Integer|))))
+        (|Matrix| |$|)))
+       NIL))
+     |FiniteFieldCategory|)
+    (SETELT #1# 0 (QUOTE (|FiniteFieldCategory|))))))) 
+
+(MAKEPROP (QUOTE |FiniteFieldCategory|) (QUOTE NILADIC) T) 
+
+@
+\section{FFIELDC-.lsp BOOTSTRAP}
+{\bf FFIELDC-} depends on {\bf FFIELDC}. We need to break this cycle
+to build the algebra. So we keep a cached copy of the translated {\bf
+FFIELDC-} category which we can write into the {\bf MID} directory. We
+compile the lisp code and copy the {\bf FFIELDC-.o} file to the {\bf
+OUT} directory.  This is eventually forcibly replaced by a recompiled
+version.
+
+Note that this code is not included in the generated catdef.spad file.
+
+<<FFIELDC-.lsp BOOTSTRAP>>=
+
+(|/VERSIONCHECK| 2) 
+
+(DEFUN |FFIELDC-;differentiate;2S;1| (|x| |$|) (|spadConstant| |$| 7)) 
+
+(DEFUN |FFIELDC-;init;S;2| (|$|) (|spadConstant| |$| 7)) 
+
+(DEFUN |FFIELDC-;nextItem;SU;3| (|a| |$|)
+ (COND
+  ((SPADCALL 
+    (LETT |a|
+     (SPADCALL (|+| (SPADCALL |a| (QREFELT |$| 11)) 1) (QREFELT |$| 12))
+     |FFIELDC-;nextItem;SU;3|)
+    (QREFELT |$| 14))
+     (CONS 1 "failed"))
+  ((QUOTE T) (CONS 0 |a|)))) 
+
+(DEFUN |FFIELDC-;order;SOpc;4| (|e| |$|)
+ (SPADCALL (SPADCALL |e| (QREFELT |$| 17)) (QREFELT |$| 20))) 
+
+(DEFUN |FFIELDC-;conditionP;MU;5| (|mat| |$|)
+ (PROG (|l|)
+  (RETURN
+   (SEQ
+    (LETT |l| (SPADCALL |mat| (QREFELT |$| 24)) |FFIELDC-;conditionP;MU;5|)
+    (COND
+     ((OR
+       (NULL |l|)
+       (SPADCALL (ELT |$| 14) (|SPADfirst| |l|) (QREFELT |$| 27)))
+         (EXIT (CONS 1 "failed"))))
+    (EXIT
+     (CONS 0
+      (SPADCALL (ELT |$| 28) (|SPADfirst| |l|) (QREFELT |$| 30)))))))) 
+
+(DEFUN |FFIELDC-;charthRoot;2S;6| (|x| |$|)
+ (SPADCALL |x|
+  (QUOTIENT2 (SPADCALL (QREFELT |$| 35)) (SPADCALL (QREFELT |$| 36)))
+  (QREFELT |$| 37))) 
+
+(DEFUN |FFIELDC-;charthRoot;SU;7| (|x| |$|)
+ (CONS 0 (SPADCALL |x| (QREFELT |$| 28)))) 
+
+(DEFUN |FFIELDC-;createPrimitiveElement;S;8| (|$|)
+ (PROG (|sm1| |start| |i| #1=#:G83175 |e| |found|)
+  (RETURN
+   (SEQ
+    (LETT |sm1|
+     (|-| (SPADCALL (QREFELT |$| 35)) 1)
+     |FFIELDC-;createPrimitiveElement;S;8|)
+    (LETT |start|
+     (COND
+      ((SPADCALL
+        (SPADCALL (QREFELT |$| 42))
+        (CONS 1 "polynomial")
+        (QREFELT |$| 43))
+       (SPADCALL (QREFELT |$| 36)))
+      ((QUOTE T) 1))
+     |FFIELDC-;createPrimitiveElement;S;8|)
+    (LETT |found| (QUOTE NIL) |FFIELDC-;createPrimitiveElement;S;8|)
+    (SEQ
+     (LETT |i| |start| |FFIELDC-;createPrimitiveElement;S;8|)
+     G190
+     (COND
+      ((NULL (COND (|found| (QUOTE NIL)) ((QUOTE T) (QUOTE T))))
+        (GO G191)))
+     (SEQ
+      (LETT |e|
+       (SPADCALL
+        (PROG1
+         (LETT #1# |i| |FFIELDC-;createPrimitiveElement;S;8|)
+         (|check-subtype| (|>| #1# 0) (QUOTE (|PositiveInteger|)) #1#))
+        (QREFELT |$| 12))
+       |FFIELDC-;createPrimitiveElement;S;8|)
+      (EXIT
+       (LETT |found|
+        (EQL (SPADCALL |e| (QREFELT |$| 17)) |sm1|)
+        |FFIELDC-;createPrimitiveElement;S;8|)))
+     (LETT |i| (|+| |i| 1) |FFIELDC-;createPrimitiveElement;S;8|)
+     (GO G190)
+     G191
+     (EXIT NIL))
+    (EXIT |e|))))) 
+
+(DEFUN |FFIELDC-;primitive?;SB;9| (|a| |$|)
+ (PROG (|explist| |q| |exp| #1=#:G83187 |equalone|)
+  (RETURN
+   (SEQ
+    (COND
+     ((SPADCALL |a| (QREFELT |$| 14)) (QUOTE NIL))
+     ((QUOTE T)
+      (SEQ
+       (LETT |explist|
+        (SPADCALL (QREFELT |$| 47)) |FFIELDC-;primitive?;SB;9|)
+       (LETT |q|
+        (|-| (SPADCALL (QREFELT |$| 35)) 1) |FFIELDC-;primitive?;SB;9|)
+       (LETT |equalone| (QUOTE NIL) |FFIELDC-;primitive?;SB;9|)
+       (SEQ
+        (LETT |exp| NIL |FFIELDC-;primitive?;SB;9|)
+        (LETT #1# |explist| |FFIELDC-;primitive?;SB;9|)
+        G190
+        (COND
+         ((OR
+           (ATOM #1#)
+           (PROGN (LETT |exp| (CAR #1#) |FFIELDC-;primitive?;SB;9|) NIL)
+           (NULL (COND (|equalone| (QUOTE NIL)) ((QUOTE T) (QUOTE T)))))
+          (GO G191)))
+        (SEQ
+         (EXIT
+          (LETT |equalone|
+           (SPADCALL
+            (SPADCALL |a| (QUOTIENT2 |q| (QCAR |exp|)) (QREFELT |$| 48))
+            (QREFELT |$| 49))
+           |FFIELDC-;primitive?;SB;9|)))
+        (LETT #1# (CDR #1#) |FFIELDC-;primitive?;SB;9|)
+        (GO G190)
+        G191
+        (EXIT NIL))
+       (EXIT (COND (|equalone| (QUOTE NIL)) ((QUOTE T) (QUOTE T))))))))))) 
+
+(DEFUN |FFIELDC-;order;SPi;10| (|e| |$|)
+ (PROG (|lof| |rec| #1=#:G83195 |primeDivisor| 
+        |j| #2=#:G83196 |a| |goon| |ord|)
+  (RETURN
+   (SEQ 
+    (COND
+     ((SPADCALL |e| (|spadConstant| |$| 7) (QREFELT |$| 51))
+       (|error| "order(0) is not defined "))
+     ((QUOTE T)
+      (SEQ 
+       (LETT |ord|
+        (|-| (SPADCALL (QREFELT |$| 35)) 1) |FFIELDC-;order;SPi;10|)
+       (LETT |a| 0 |FFIELDC-;order;SPi;10|)
+       (LETT |lof| (SPADCALL (QREFELT |$| 47)) |FFIELDC-;order;SPi;10|)
+       (SEQ
+        (LETT |rec| NIL |FFIELDC-;order;SPi;10|)
+        (LETT #1# |lof| |FFIELDC-;order;SPi;10|)
+        G190
+        (COND
+         ((OR
+           (ATOM #1#)
+           (PROGN (LETT |rec| (CAR #1#) |FFIELDC-;order;SPi;10|) NIL))
+          (GO G191)))
+        (SEQ
+         (LETT |a|
+          (QUOTIENT2 |ord|
+           (LETT |primeDivisor| (QCAR |rec|) |FFIELDC-;order;SPi;10|))
+          |FFIELDC-;order;SPi;10|)
+         (LETT |goon|
+          (SPADCALL (SPADCALL |e| |a| (QREFELT |$| 48)) (QREFELT |$| 49))
+          |FFIELDC-;order;SPi;10|)
+         (SEQ
+          (LETT |j| 0 |FFIELDC-;order;SPi;10|)
+          (LETT #2# (|-| (QCDR |rec|) 2) |FFIELDC-;order;SPi;10|)
+          G190
+          (COND ((OR (QSGREATERP |j| #2#) (NULL |goon|)) (GO G191)))
+          (SEQ
+           (LETT |ord| |a| |FFIELDC-;order;SPi;10|)
+           (LETT |a|
+            (QUOTIENT2 |ord| |primeDivisor|)
+            |FFIELDC-;order;SPi;10|)
+           (EXIT
+            (LETT |goon|
+             (SPADCALL (SPADCALL |e| |a| (QREFELT |$| 48)) (QREFELT |$| 49))
+             |FFIELDC-;order;SPi;10|)))
+          (LETT |j| (QSADD1 |j|) |FFIELDC-;order;SPi;10|)
+          (GO G190)
+          G191
+          (EXIT NIL))
+         (EXIT (COND (|goon| (LETT |ord| |a| |FFIELDC-;order;SPi;10|)))))
+        (LETT #1# (CDR #1#) |FFIELDC-;order;SPi;10|)
+        (GO G190)
+        G191
+        (EXIT NIL))
+       (EXIT |ord|)))))))) 
+
+(DEFUN |FFIELDC-;discreteLog;SNni;11| (|b| |$|)
+ (PROG (|faclist| |gen| |groupord| |f| #1=#:G83216 |fac| |t| #2=#:G83217 
+        |exp| |exptable| |n| |end| |i| |rho| |found| |disc1| |c| |mult| 
+        |disclog| |a|)
+  (RETURN
+   (SEQ
+    (COND
+     ((SPADCALL |b| (QREFELT |$| 14))
+       (|error| "discreteLog: logarithm of zero"))
+     ((QUOTE T)
+      (SEQ
+       (LETT |faclist|
+        (SPADCALL (QREFELT |$| 47))
+        |FFIELDC-;discreteLog;SNni;11|)
+       (LETT |a| |b| |FFIELDC-;discreteLog;SNni;11|)
+       (LETT |gen|
+        (SPADCALL (QREFELT |$| 53))
+        |FFIELDC-;discreteLog;SNni;11|)
+       (EXIT
+        (COND
+         ((SPADCALL |b| |gen| (QREFELT |$| 51)) 1)
+         ((QUOTE T)
+          (SEQ
+           (LETT |disclog| 0 |FFIELDC-;discreteLog;SNni;11|)
+           (LETT |mult| 1 |FFIELDC-;discreteLog;SNni;11|)
+           (LETT |groupord|
+            (|-| (SPADCALL (QREFELT |$| 35)) 1)
+            |FFIELDC-;discreteLog;SNni;11|)
+           (LETT |exp| |groupord| |FFIELDC-;discreteLog;SNni;11|)
+           (SEQ
+            (LETT |f| NIL |FFIELDC-;discreteLog;SNni;11|)
+            (LETT #1# |faclist| |FFIELDC-;discreteLog;SNni;11|)
+            G190
+            (COND 
+             ((OR 
+               (ATOM #1#)
+               (PROGN
+                (LETT |f| (CAR #1#) |FFIELDC-;discreteLog;SNni;11|)
+                NIL))
+             (GO G191)))
+            (SEQ
+             (LETT |fac| (QCAR |f|) |FFIELDC-;discreteLog;SNni;11|)
+             (EXIT
+              (SEQ
+               (LETT |t| 0 |FFIELDC-;discreteLog;SNni;11|)
+               (LETT #2# (|-| (QCDR |f|) 1) |FFIELDC-;discreteLog;SNni;11|)
+               G190
+               (COND ((QSGREATERP |t| #2#) (GO G191)))
+               (SEQ
+                (LETT |exp|
+                 (QUOTIENT2 |exp| |fac|)
+                 |FFIELDC-;discreteLog;SNni;11|)
+                (LETT |exptable|
+                 (SPADCALL |fac| (QREFELT |$| 55))
+                 |FFIELDC-;discreteLog;SNni;11|)
+                (LETT |n|
+                 (SPADCALL |exptable| (QREFELT |$| 56))
+                 |FFIELDC-;discreteLog;SNni;11|)
+                (LETT |c|
+                 (SPADCALL |a| |exp| (QREFELT |$| 48))
+                 |FFIELDC-;discreteLog;SNni;11|)
+                (LETT |end|
+                 (QUOTIENT2 (|-| |fac| 1) |n|)
+                 |FFIELDC-;discreteLog;SNni;11|)
+                (LETT |found| (QUOTE NIL) |FFIELDC-;discreteLog;SNni;11|)
+                (LETT |disc1| 0 |FFIELDC-;discreteLog;SNni;11|)
+                (SEQ
+                 (LETT |i| 0 |FFIELDC-;discreteLog;SNni;11|)
+                 G190
+                 (COND 
+                  ((OR
+                    (QSGREATERP |i| |end|)
+                    (NULL
+                     (COND (|found| (QUOTE NIL)) ((QUOTE T) (QUOTE T)))))
+                   (GO G191)))
+                 (SEQ
+                  (LETT |rho|
+                   (SPADCALL
+                    (SPADCALL |c| (QREFELT |$| 11))
+                    |exptable|
+                    (QREFELT |$| 58))
+                   |FFIELDC-;discreteLog;SNni;11|)
+                  (EXIT
+                   (COND
+                    ((QEQCAR |rho| 0)
+                     (SEQ
+                      (LETT |found| (QUOTE T) |FFIELDC-;discreteLog;SNni;11|)
+                      (EXIT
+                       (LETT |disc1|
+                        (|*| (|+| (|*| |n| |i|) (QCDR |rho|)) |mult|)
+                        |FFIELDC-;discreteLog;SNni;11|))))
+                    ((QUOTE T)
+                     (LETT |c|
+                      (SPADCALL |c|
+                       (SPADCALL |gen|
+                        (|*| (QUOTIENT2 |groupord| |fac|) (|-| |n|))
+                        (QREFELT |$| 48))
+                       (QREFELT |$| 59))
+                      |FFIELDC-;discreteLog;SNni;11|)))))
+                 (LETT |i| (QSADD1 |i|) |FFIELDC-;discreteLog;SNni;11|)
+                 (GO G190)
+                 G191
+                 (EXIT NIL))
+                (EXIT
+                 (COND
+                  (|found|
+                   (SEQ
+                    (LETT |mult|
+                     (|*| |mult| |fac|)
+                     |FFIELDC-;discreteLog;SNni;11|)
+                    (LETT |disclog|
+                     (|+| |disclog| |disc1|)
+                     |FFIELDC-;discreteLog;SNni;11|)
+                    (EXIT
+                     (LETT |a|
+                      (SPADCALL |a|
+                       (SPADCALL |gen| (|-| |disc1|) (QREFELT |$| 48))
+                       (QREFELT |$| 59))
+                      |FFIELDC-;discreteLog;SNni;11|))))
+                  ((QUOTE T)
+                    (|error| "discreteLog: ?? discrete logarithm")))))
+               (LETT |t|
+                (QSADD1 |t|)
+                |FFIELDC-;discreteLog;SNni;11|)
+               (GO G190)
+               G191
+               (EXIT NIL))))
+            (LETT #1#
+             (CDR #1#)
+             |FFIELDC-;discreteLog;SNni;11|)
+            (GO G190)
+            G191 
+            (EXIT NIL))
+           (EXIT |disclog|)))))))))))) 
+
+(DEFUN |FFIELDC-;discreteLog;2SU;12| (|logbase| |b| |$|)
+ (PROG (|groupord| |faclist| |f| #1=#:G83235 |fac| |primroot| 
+        |t| #2=#:G83236 |exp| |rhoHelp| #3=#:G83234 |rho| |disclog| 
+        |mult| |a|)
+  (RETURN
+   (SEQ
+    (EXIT
+     (COND
+      ((SPADCALL |b| (QREFELT |$| 14))
+       (SEQ
+        (SPADCALL "discreteLog: logarithm of zero" (QREFELT |$| 64))
+        (EXIT (CONS 1 "failed"))))
+      ((SPADCALL |logbase| (QREFELT |$| 14))
+       (SEQ 
+        (SPADCALL "discreteLog: logarithm to base zero" (QREFELT |$| 64))
+        (EXIT (CONS 1 "failed"))))
+      ((SPADCALL |b| |logbase| (QREFELT |$| 51)) (CONS 0 1))
+      ((QUOTE T)
+       (COND
+        ((NULL
+          (ZEROP
+           (REMAINDER2
+            (LETT |groupord|
+             (SPADCALL |logbase| (QREFELT |$| 17))
+             |FFIELDC-;discreteLog;2SU;12|)
+            (SPADCALL |b| (QREFELT |$| 17)))))
+         (SEQ
+          (SPADCALL 
+"discreteLog: second argument not in cyclic group generated by first argument" 
+           (QREFELT |$| 64))
+          (EXIT (CONS 1 "failed"))))
+        ((QUOTE T)
+         (SEQ
+          (LETT |faclist|
+           (SPADCALL (SPADCALL |groupord| (QREFELT |$| 66)) (QREFELT |$| 68))
+           |FFIELDC-;discreteLog;2SU;12|)
+          (LETT |a| |b| |FFIELDC-;discreteLog;2SU;12|)
+          (LETT |disclog| 0 |FFIELDC-;discreteLog;2SU;12|)
+          (LETT |mult| 1 |FFIELDC-;discreteLog;2SU;12|)
+          (LETT |exp| |groupord| |FFIELDC-;discreteLog;2SU;12|)
+          (SEQ
+           (LETT |f| NIL |FFIELDC-;discreteLog;2SU;12|)
+           (LETT #1# |faclist| |FFIELDC-;discreteLog;2SU;12|)
+           G190
+           (COND
+            ((OR
+              (ATOM #1#)
+              (PROGN (LETT |f| (CAR #1#) |FFIELDC-;discreteLog;2SU;12|) NIL))
+             (GO G191)))
+           (SEQ
+            (LETT |fac| (QCAR |f|) |FFIELDC-;discreteLog;2SU;12|)
+            (LETT |primroot|
+             (SPADCALL |logbase|
+              (QUOTIENT2 |groupord| |fac|)
+              (QREFELT |$| 48))
+             |FFIELDC-;discreteLog;2SU;12|)
+            (EXIT
+             (SEQ
+              (LETT |t| 0 |FFIELDC-;discreteLog;2SU;12|)
+              (LETT #2# (|-| (QCDR |f|) 1) |FFIELDC-;discreteLog;2SU;12|)
+              G190
+              (COND ((QSGREATERP |t| #2#) (GO G191)))
+              (SEQ
+               (LETT |exp|
+                (QUOTIENT2 |exp| |fac|)
+                |FFIELDC-;discreteLog;2SU;12|)
+               (LETT |rhoHelp|
+                (SPADCALL |primroot|
+                 (SPADCALL |a| |exp| (QREFELT |$| 48))
+                 |fac|
+                 (QREFELT |$| 70))
+                 |FFIELDC-;discreteLog;2SU;12|)
+               (EXIT
+                (COND
+                 ((QEQCAR |rhoHelp| 1)
+                  (PROGN
+                   (LETT #3# (CONS 1 "failed") |FFIELDC-;discreteLog;2SU;12|)
+                   (GO #3#)))
+                 ((QUOTE T)
+                  (SEQ
+                   (LETT |rho|
+                    (|*| (QCDR |rhoHelp|) |mult|)
+                    |FFIELDC-;discreteLog;2SU;12|)
+                   (LETT |disclog|
+                    (|+| |disclog| |rho|)
+                    |FFIELDC-;discreteLog;2SU;12|)
+                   (LETT |mult|
+                    (|*| |mult| |fac|)
+                    |FFIELDC-;discreteLog;2SU;12|)
+                   (EXIT
+                    (LETT |a|
+                     (SPADCALL |a|
+                      (SPADCALL |logbase| (|-| |rho|) (QREFELT |$| 48))
+                      (QREFELT |$| 59))
+                     |FFIELDC-;discreteLog;2SU;12|)))))))
+              (LETT |t| (QSADD1 |t|) |FFIELDC-;discreteLog;2SU;12|)
+              (GO G190)
+              G191
+              (EXIT NIL))))
+           (LETT #1# (CDR #1#) |FFIELDC-;discreteLog;2SU;12|)
+           (GO G190)
+           G191
+           (EXIT NIL))
+          (EXIT (CONS 0 |disclog|))))))))
+    #3#
+    (EXIT #3#))))) 
+
+(DEFUN |FFIELDC-;squareFreePolynomial| (|f| |$|)
+ (SPADCALL |f| (QREFELT |$| 75))) 
+
+(DEFUN |FFIELDC-;factorPolynomial| (|f| |$|)
+ (SPADCALL |f| (QREFELT |$| 77))) 
+
+(DEFUN |FFIELDC-;factorSquareFreePolynomial| (|f| |$|)
+ (PROG (|flist| |u| #1=#:G83248 #2=#:G83245 #3=#:G83243 #4=#:G83244)
+  (RETURN
+   (SEQ
+    (COND
+     ((SPADCALL |f| (|spadConstant| |$| 78) (QREFELT |$| 79))
+       (|spadConstant| |$| 80))
+     ((QUOTE T)
+      (SEQ
+       (LETT |flist|
+        (SPADCALL |f| (QUOTE T) (QREFELT |$| 83))
+        |FFIELDC-;factorSquareFreePolynomial|)
+       (EXIT
+        (SPADCALL
+         (SPADCALL (QCAR |flist|) (QREFELT |$| 84))
+         (PROGN
+          (LETT #4# NIL |FFIELDC-;factorSquareFreePolynomial|)
+          (SEQ
+           (LETT |u| NIL |FFIELDC-;factorSquareFreePolynomial|)
+           (LETT #1# (QCDR |flist|) |FFIELDC-;factorSquareFreePolynomial|)
+           G190
+           (COND
+            ((OR
+              (ATOM #1#)
+              (PROGN 
+               (LETT |u| (CAR #1#) |FFIELDC-;factorSquareFreePolynomial|)
+               NIL))
+             (GO G191)))
+           (SEQ
+            (EXIT
+             (PROGN
+              (LETT #2#
+               (SPADCALL (QCAR |u|) (QCDR |u|) (QREFELT |$| 85))
+               |FFIELDC-;factorSquareFreePolynomial|)
+              (COND
+               (#4#
+                (LETT #3# 
+                 (SPADCALL #3# #2# (QREFELT |$| 86))
+                 |FFIELDC-;factorSquareFreePolynomial|))
+               ((QUOTE T)
+                (PROGN
+                 (LETT #3# #2# |FFIELDC-;factorSquareFreePolynomial|)
+                 (LETT #4#
+                  (QUOTE T)
+                  |FFIELDC-;factorSquareFreePolynomial|)))))))
+           (LETT #1# (CDR #1#) |FFIELDC-;factorSquareFreePolynomial|)
+           (GO G190)
+           G191
+          (EXIT NIL))
+          (COND (#4# #3#) ((QUOTE T) (|spadConstant| |$| 87))))
+         (QREFELT |$| 88)))))))))) 
+
+(DEFUN |FFIELDC-;gcdPolynomial;3Sup;16| (|f| |g| |$|)
+ (SPADCALL |f| |g| (QREFELT |$| 90))) 
+
+(DEFUN |FiniteFieldCategory&| (|#1|)
+ (PROG (|DV$1| |dv$| |$| |pv$|)
+  (RETURN
+   (PROGN
+    (LETT |DV$1| (|devaluate| |#1|) . #1=(|FiniteFieldCategory&|))
+    (LETT |dv$| (LIST (QUOTE |FiniteFieldCategory&|) |DV$1|) . #1#)
+    (LETT |$| (GETREFV 93) . #1#)
+    (QSETREFV |$| 0 |dv$|)
+    (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
+    (|stuffDomainSlots| |$|)
+    (QSETREFV |$| 6 |#1|) |$|)))) 
+
+(MAKEPROP
+ (QUOTE |FiniteFieldCategory&|)
+ (QUOTE |infovec|)
+ (LIST 
+  (QUOTE
+  #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (0 . |Zero|) 
+    |FFIELDC-;differentiate;2S;1| |FFIELDC-;init;S;2| (|PositiveInteger|) 
+    (4 . |lookup|) (9 . |index|) (|Boolean|) (14 . |zero?|)
+    (|Union| |$| (QUOTE "failed")) |FFIELDC-;nextItem;SU;3| (19 . |order|)
+    (|Integer|) (|OnePointCompletion| 10) (24 . |coerce|)
+    |FFIELDC-;order;SOpc;4| (|List| 26) (|Matrix| 6) (29 . |nullSpace|)
+    (|Mapping| 13 6) (|Vector| 6) (34 . |every?|) (40 . |charthRoot|)
+    (|Mapping| 6 6) (45 . |map|) (|Union| (|Vector| |$|) (QUOTE "failed"))
+    (|Matrix| |$|) |FFIELDC-;conditionP;MU;5| (|NonNegativeInteger|)
+    (51 . |size|) (55 . |characteristic|) (59 . |**|)
+    |FFIELDC-;charthRoot;2S;6| |FFIELDC-;charthRoot;SU;7| (65 . |One|)
+    (|Union| (QUOTE "prime") (QUOTE "polynomial") (QUOTE "normal")
+    (QUOTE "cyclic")) (69 . |representationType|) (73 . |=|)
+    |FFIELDC-;createPrimitiveElement;S;8| (|Record| (|:| |factor| 18)
+    (|:| |exponent| 18)) (|List| 45) (79 . |factorsOfCyclicGroupSize|)
+    (83 . |**|) (89 . |one?|) |FFIELDC-;primitive?;SB;9| (94 . |=|)
+    |FFIELDC-;order;SPi;10| (100 . |primitiveElement|) (|Table| 10 34)
+    (104 . |tableForDiscreteLogarithm|) (109 . |#|) 
+    (|Union| 34 (QUOTE "failed")) (114 . |search|) (120 . |*|)
+    |FFIELDC-;discreteLog;SNni;11| (|Void|) (|String|) (|OutputForm|)
+    (126 . |messagePrint|) (|Factored| |$|) (131 . |factor|)
+    (|Factored| 18) (136 . |factors|) (|DiscreteLogarithmPackage| 6)
+    (141 . |shanksDiscLogAlgorithm|) |FFIELDC-;discreteLog;2SU;12|
+    (|Factored| 73) (|SparseUnivariatePolynomial| 6)
+    (|UnivariatePolynomialSquareFree| 6 73) (148 . |squareFree|)
+    (|DistinctDegreeFactorize| 6 73) (153 . |factor|) (158 . |Zero|)
+    (162 . |=|) (168 . |Zero|) (|Record| (|:| |irr| 73) (|:| |pow| 18))
+    (|Record| (|:| |cont| 6) (|:| |factors| (|List| 81)))
+    (172 . |distdfact|) (178 . |coerce|) (183 . |primeFactor|)
+    (189 . |*|) (195 . |One|) (199 . |*|) (|EuclideanDomain&| 73)
+    (205 . |gcd|) (|SparseUnivariatePolynomial| |$|) 
+    |FFIELDC-;gcdPolynomial;3Sup;16|))
+   (QUOTE
+    #(|primitive?| 211 |order| 216 |nextItem| 226 |init| 231 
+      |gcdPolynomial| 235 |discreteLog| 241 |differentiate| 252 
+      |createPrimitiveElement| 257 |conditionP| 261 |charthRoot| 266))
+  (QUOTE NIL)
+  (CONS 
+   (|makeByteWordVec2| 1 (QUOTE NIL))
+   (CONS 
+    (QUOTE #())
+    (CONS
+     (QUOTE #())
+     (|makeByteWordVec2| 92
+      (QUOTE
+       (0 6 0 7 1 6 10 0 11 1 6 0 10 12 1 6 13 0 14 1 6 10 0 17 1 19 
+        0 18 20 1 23 22 0 24 2 26 13 25 0 27 1 6 0 0 28 2 26 0 29 0 30 
+        0 6 34 35 0 6 34 36 2 6 0 0 34 37 0 6 0 40 0 6 41 42 2 41 13 
+        0 0 43 0 6 46 47 2 6 0 0 18 48 1 6 13 0 49 2 6 13 0 0 51 0 6 0
+        53 1 6 54 18 55 1 54 34 0 56 2 54 57 10 0 58 2 6 0 0 0 59 1
+        63 61 62 64 1 18 65 0 66 1 67 46 0 68 3 69 57 6 6 34 70 1 74
+        72 73 75 1 76 72 73 77 0 73 0 78 2 73 13 0 0 79 0 72 0 80 2
+        76 82 73 13 83 1 73 0 6 84 2 72 0 73 18 85 2 72 0 0 0 86 0 72
+        0 87 2 72 0 73 0 88 2 89 0 0 0 90 1 0 13 0 50 1 0 10 0 52 1 0
+        19 0 21 1 0 15 0 16 0 0 0 9 2 0 91 91 91 92 1 0 34 0 60 2 0 57
+        0 0 71 1 0 0 0 8 0 0 0 44 1 0 31 32 33 1 0 0 0 38 1 0 15 0 39))))))
+  (QUOTE |lookupComplete|))) 
+@
 \section{GCDDOM.lsp BOOTSTRAP}
 {\bf GCDDOM} needs
 {\bf COMRING} which needs
@@ -29684,11 +31423,13 @@ Note that this code is not included in the generated catdef.spad file.
 <<category ENTIRER EntireRing>>
 <<category EUCDOM EuclideanDomain>>
 <<category EVALAB Evalable>>
+<<category FAXF FiniteAlgebraicExtensionField>>
 <<category FIELD Field>>
 <<category FINAALG FiniteRankNonAssociativeAlgebra>>
 <<category FINITE Finite>>
 <<category FINRALG FiniteRankAlgebra>>
 <<category FFCAT FunctionFieldCategory>>
+<<category FFIELDC FiniteFieldCategory>>
 <<category FLAGG FiniteLinearAggregate>>
 <<category FLINEXP FullyLinearlyExplicitRingOver>>
 <<category FPC FieldOfPrimeCharacteristic>>
@@ -29805,11 +31546,13 @@ digraph dotabb {
 <<ENTIRER.dotabb>>
 <<EUCDOM.dotabb>>
 <<EVALAB.dotabb>>
+<<FAXF.dotabb>>
 <<FIELD.dotabb>>
 <<FINAALG.dotabb>>
 <<FINITE.dotabb>>
 <<FINRALG.dotabb>>
 <<FFCAT.dotabb>>
+<<FFIELDC.dotabb>>
 <<FLAGG.dotabb>>
 <<FLINEXP.dotabb>>
 <<FPC.dotabb>>
@@ -29928,11 +31671,13 @@ digraph dotfull {
 <<ENTIRER.dotfull>>
 <<EUCDOM.dotfull>>
 <<EVALAB.dotfull>>
+<<FAXF.dotfull>>
 <<FIELD.dotfull>>
 <<FINAALG.dotfull>>
 <<FINITE.dotfull>>
 <<FINRALG.dotfull>>
 <<FFCAT.dotfull>>
+<<FFIELDC.dotfull>>
 <<FLAGG.dotfull>>
 <<FLINEXP.dotfull>>
 <<FPC.dotfull>>
diff --git a/books/ps/v102finitealgebraicextensionfield.ps b/books/ps/v102finitealgebraicextensionfield.ps
new file mode 100644
index 0000000..eb86f1a
--- /dev/null
+++ b/books/ps/v102finitealgebraicextensionfield.ps
@@ -0,0 +1,842 @@
+%!PS-Adobe-2.0
+%%Creator: dot version 2.8 (Thu Sep 14 20:34:11 UTC 2006)
+%%For: (root) root
+%%Title: pic
+%%Pages: (atend)
+%%BoundingBox: 36 36 576 440
+%%EndComments
+save
+%%BeginProlog
+/DotDict 200 dict def
+DotDict begin
+
+/setupLatin1 {
+mark
+/EncodingVector 256 array def
+ EncodingVector 0
+
+ISOLatin1Encoding 0 255 getinterval putinterval
+EncodingVector 45 /hyphen put
+
+% Set up ISO Latin 1 character encoding
+/starnetISO {
+        dup dup findfont dup length dict begin
+        { 1 index /FID ne { def }{ pop pop } ifelse
+        } forall
+        /Encoding EncodingVector def
+        currentdict end definefont
+} def
+/Times-Roman starnetISO def
+/Times-Italic starnetISO def
+/Times-Bold starnetISO def
+/Times-BoldItalic starnetISO def
+/Helvetica starnetISO def
+/Helvetica-Oblique starnetISO def
+/Helvetica-Bold starnetISO def
+/Helvetica-BoldOblique starnetISO def
+/Courier starnetISO def
+/Courier-Oblique starnetISO def
+/Courier-Bold starnetISO def
+/Courier-BoldOblique starnetISO def
+cleartomark
+} bind def
+
+%%BeginResource: procset graphviz 0 0
+/coord-font-family /Times-Roman def
+/default-font-family /Times-Roman def
+/coordfont coord-font-family findfont 8 scalefont def
+
+/InvScaleFactor 1.0 def
+/set_scale {
+	dup 1 exch div /InvScaleFactor exch def
+	dup scale
+} bind def
+
+% styles
+/solid { [] 0 setdash } bind def
+/dashed { [9 InvScaleFactor mul dup ] 0 setdash } bind def
+/dotted { [1 InvScaleFactor mul 6 InvScaleFactor mul] 0 setdash } bind def
+/invis {/fill {newpath} def /stroke {newpath} def /show {pop newpath} def} bind def
+/bold { 2 setlinewidth } bind def
+/filled { } bind def
+/unfilled { } bind def
+/rounded { } bind def
+/diagonals { } bind def
+
+% hooks for setting color 
+/nodecolor { sethsbcolor } bind def
+/edgecolor { sethsbcolor } bind def
+/graphcolor { sethsbcolor } bind def
+/nopcolor {pop pop pop} bind def
+
+/beginpage {	% i j npages
+	/npages exch def
+	/j exch def
+	/i exch def
+	/str 10 string def
+	npages 1 gt {
+		gsave
+			coordfont setfont
+			0 0 moveto
+			(\() show i str cvs show (,) show j str cvs show (\)) show
+		grestore
+	} if
+} bind def
+
+/set_font {
+	findfont exch
+	scalefont setfont
+} def
+
+% draw aligned label in bounding box aligned to current point
+/alignedtext {			% width adj text
+	/text exch def
+	/adj exch def
+	/width exch def
+	gsave
+		width 0 gt {
+			text stringwidth pop adj mul 0 rmoveto
+		} if
+		[] 0 setdash
+		text show
+	grestore
+} def
+
+/boxprim {				% xcorner ycorner xsize ysize
+		4 2 roll
+		moveto
+		2 copy
+		exch 0 rlineto
+		0 exch rlineto
+		pop neg 0 rlineto
+		closepath
+} bind def
+
+/ellipse_path {
+	/ry exch def
+	/rx exch def
+	/y exch def
+	/x exch def
+	matrix currentmatrix
+	newpath
+	x y translate
+	rx ry scale
+	0 0 1 0 360 arc
+	setmatrix
+} bind def
+
+/endpage { showpage } bind def
+/showpage { } def
+
+/layercolorseq
+	[	% layer color sequence - darkest to lightest
+		[0 0 0]
+		[.2 .8 .8]
+		[.4 .8 .8]
+		[.6 .8 .8]
+		[.8 .8 .8]
+	]
+def
+
+/layerlen layercolorseq length def
+
+/setlayer {/maxlayer exch def /curlayer exch def
+	layercolorseq curlayer 1 sub layerlen mod get
+	aload pop sethsbcolor
+	/nodecolor {nopcolor} def
+	/edgecolor {nopcolor} def
+	/graphcolor {nopcolor} def
+} bind def
+
+/onlayer { curlayer ne {invis} if } def
+
+/onlayers {
+	/myupper exch def
+	/mylower exch def
+	curlayer mylower lt
+	curlayer myupper gt
+	or
+	{invis} if
+} def
+
+/curlayer 0 def
+
+%%EndResource
+%%EndProlog
+%%BeginSetup
+14 default-font-family set_font
+1 setmiterlimit
+% /arrowlength 10 def
+% /arrowwidth 5 def
+
+% make sure pdfmark is harmless for PS-interpreters other than Distiller
+/pdfmark where {pop} {userdict /pdfmark /cleartomark load put} ifelse
+% make '<<' and '>>' safe on PS Level 1 devices
+/languagelevel where {pop languagelevel}{1} ifelse
+2 lt {
+    userdict (<<) cvn ([) cvn load put
+    userdict (>>) cvn ([) cvn load put
+} if
+
+%%EndSetup
+%%Page: 1 1
+%%PageBoundingBox: 36 36 576 440
+%%PageOrientation: Portrait
+gsave
+36 36 540 404 boxprim clip newpath
+36 36 translate
+0 0 1 beginpage
+1.0000 set_scale
+4 4 translate 0 rotate
+0.167 0.600 1.000 graphcolor
+0.167 0.600 1.000 graphcolor
+newpath -6 -6 moveto
+-6 402 lineto
+538 402 lineto
+538 -6 lineto
+closepath
+fill
+0.167 0.600 1.000 graphcolor
+newpath -6 -6 moveto
+-6 402 lineto
+538 402 lineto
+538 -6 lineto
+closepath
+stroke
+0.000 0.000 0.000 graphcolor
+14.00 /Times-Roman set_font
+% FiniteAlgebraicExtensionField(a:Field)
+[ /Rect [ 139 360 375 396 ]
+  /Border [ 0 0 0 ]
+  /Action << /Subtype /URI /URI (bookvol10.2.pdf#nameddest=FAXF) >>
+  /Subtype /Link
+/ANN pdfmark
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 375 396 moveto
+139 396 lineto
+139 360 lineto
+375 360 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 375 396 moveto
+139 396 lineto
+139 360 lineto
+375 360 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+147 373 moveto
+(FiniteAlgebraicExtensionField\(a:Field\))
+[7.44 3.84 6.96 3.84 3.84 6.24 10.08 3.84 6.72 6.24 6.96 4.8 6.24 3.84 6.24 8.64 6.96 3.84 6.24 6.96 5.52 3.84 6.96 6.96 7.44 3.84 6.24 3.84 6.96 4.56 6.24 3.84 7.44 3.84 6.24 3.84 6.96 4.56]
+xshow
+end grestore
+end grestore
+% ExtensionField(a:Field)
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 383 324 moveto
+235 324 lineto
+235 288 lineto
+383 288 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 383 324 moveto
+235 324 lineto
+235 288 lineto
+383 288 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+243 301 moveto
+(ExtensionField\(a:Field\))
+[8.64 6.96 3.84 6.24 6.96 5.52 3.84 6.96 6.96 7.44 3.84 6.24 3.84 6.96 4.56 6.24 3.84 7.44 3.84 6.24 3.84 6.96 4.56]
+xshow
+end grestore
+end grestore
+% FiniteAlgebraicExtensionField(a:Field)->ExtensionField(a:Field)
+newpath 270 360 moveto
+276 352 283 341 290 332 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 293 334 moveto
+296 324 lineto
+287 330 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 293 334 moveto
+296 324 lineto
+287 330 lineto
+closepath
+stroke
+end grestore
+% RetractableTo(Field)
+gsave 10 dict begin
+filled
+0.404 0.667 0.545 nodecolor
+0.404 0.667 0.545 nodecolor
+newpath 267 252 moveto
+135 252 lineto
+135 216 lineto
+267 216 lineto
+closepath
+fill
+0.404 0.667 0.545 nodecolor
+newpath 267 252 moveto
+135 252 lineto
+135 216 lineto
+267 216 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+143 229 moveto
+(RetractableTo\(Field\))
+[9.12 6 3.84 4.8 6.24 6.24 4.08 6.24 6.96 3.84 6.24 7.44 6.96 4.56 7.44 3.84 6.24 3.84 6.96 4.56]
+xshow
+end grestore
+end grestore
+% FiniteAlgebraicExtensionField(a:Field)->RetractableTo(Field)
+newpath 245 360 moveto
+239 350 231 336 226 324 curveto
+218 304 211 280 207 262 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 210 261 moveto
+205 252 lineto
+204 262 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 210 261 moveto
+205 252 lineto
+204 262 lineto
+closepath
+stroke
+end grestore
+% ExtensionField(a:Field)->RetractableTo(Field)
+newpath 282 288 moveto
+268 279 251 268 237 258 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 238 255 moveto
+228 252 lineto
+234 260 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 238 255 moveto
+228 252 lineto
+234 260 lineto
+closepath
+stroke
+end grestore
+% Field()
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 339 252 moveto
+285 252 lineto
+285 216 lineto
+339 216 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 339 252 moveto
+285 252 lineto
+285 216 lineto
+339 216 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+293 229 moveto
+(Field\(\))
+[7.44 3.84 6.24 3.84 6.96 4.56 4.56]
+xshow
+end grestore
+end grestore
+% ExtensionField(a:Field)->Field()
+newpath 310 288 moveto
+311 280 311 271 311 262 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 315 262 moveto
+311 252 lineto
+308 262 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 315 262 moveto
+311 252 lineto
+308 262 lineto
+closepath
+stroke
+end grestore
+% VectorSpace(a:Field)
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 523 252 moveto
+389 252 lineto
+389 216 lineto
+523 216 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 523 252 moveto
+389 252 lineto
+389 216 lineto
+523 216 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+396 229 moveto
+(VectorSpace\(a:Field\))
+[8.88 6.24 6.24 3.84 6.96 4.8 7.68 6.96 6.24 6.24 6.24 4.56 6.24 3.84 7.44 3.84 6.24 3.84 6.96 4.56]
+xshow
+end grestore
+end grestore
+% ExtensionField(a:Field)->VectorSpace(a:Field)
+newpath 346 288 moveto
+366 278 390 267 411 256 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 412 259 moveto
+420 252 lineto
+409 253 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 412 259 moveto
+420 252 lineto
+409 253 lineto
+closepath
+stroke
+end grestore
+% RetractableTo(a:Type)
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 140 180 moveto
+0 180 lineto
+0 144 lineto
+140 144 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 140 180 moveto
+0 180 lineto
+0 144 lineto
+140 144 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+7 157 moveto
+(RetractableTo\(a:Type\))
+[9.12 6 3.84 4.8 6.24 6.24 4.08 6.24 6.96 3.84 6.24 7.44 6.96 4.56 6.24 3.84 7.2 6.96 6.96 6.24 4.56]
+xshow
+end grestore
+end grestore
+% RetractableTo(Field)->RetractableTo(a:Type)
+newpath 168 216 moveto
+151 207 130 195 112 185 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 113 182 moveto
+103 180 lineto
+110 188 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 113 182 moveto
+103 180 lineto
+110 188 lineto
+closepath
+stroke
+end grestore
+% EuclideanDomain()
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 284 180 moveto
+158 180 lineto
+158 144 lineto
+284 144 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 284 180 moveto
+158 180 lineto
+158 144 lineto
+284 144 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+165 157 moveto
+(EuclideanDomain\(\))
+[8.64 6.96 6.24 3.84 3.84 6.96 6.24 6.24 6.96 10.08 6.96 10.8 6.24 3.84 6.96 4.56 4.56]
+xshow
+end grestore
+end grestore
+% Field()->EuclideanDomain()
+newpath 289 216 moveto
+278 207 264 196 252 186 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 254 183 moveto
+244 180 lineto
+250 189 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 254 183 moveto
+244 180 lineto
+250 189 lineto
+closepath
+stroke
+end grestore
+% UniqueFactorizationDomain()
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 486 108 moveto
+302 108 lineto
+302 72 lineto
+486 72 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 486 108 moveto
+302 108 lineto
+302 72 lineto
+486 72 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+309 85 moveto
+(UniqueFactorizationDomain\(\))
+[9.6 6.96 3.84 6.72 6.96 6.24 7.2 6.24 6.24 3.84 6.96 5.04 3.84 6.24 6.24 3.84 3.84 6.96 6.96 10.08 6.96 10.8 6.24 3.84 6.96 4.56 4.56]
+xshow
+end grestore
+end grestore
+% Field()->UniqueFactorizationDomain()
+newpath 313 216 moveto
+314 197 318 166 331 144 curveto
+338 133 348 123 357 114 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 359 117 moveto
+365 108 lineto
+355 111 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 359 117 moveto
+365 108 lineto
+355 111 lineto
+closepath
+stroke
+end grestore
+% DIVRING...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 426 180 moveto
+340 180 lineto
+340 144 lineto
+426 144 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 426 180 moveto
+340 180 lineto
+340 144 lineto
+426 144 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+347 157 moveto
+(DIVRING...)
+[10.08 4.56 10.08 9.36 4.56 9.84 10.08 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% Field()->DIVRING...
+newpath 330 216 moveto
+339 207 349 197 358 188 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 361 190 moveto
+365 180 lineto
+356 185 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 361 190 moveto
+365 180 lineto
+356 185 lineto
+closepath
+stroke
+end grestore
+% MODULE...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 532 180 moveto
+444 180 lineto
+444 144 lineto
+532 144 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 532 180 moveto
+444 180 lineto
+444 144 lineto
+532 144 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+452 157 moveto
+(MODULE...)
+[12.48 10.08 10.08 10.08 8.64 8.64 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% VectorSpace(a:Field)->MODULE...
+newpath 464 216 moveto
+468 208 472 198 476 189 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 479 191 moveto
+480 180 lineto
+473 188 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 479 191 moveto
+480 180 lineto
+473 188 lineto
+closepath
+stroke
+end grestore
+% PrincipalIdealDomain()
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 284 108 moveto
+134 108 lineto
+134 72 lineto
+284 72 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 284 108 moveto
+134 108 lineto
+134 72 lineto
+284 72 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+142 85 moveto
+(PrincipalIdealDomain\(\))
+[7.68 5.04 3.84 6.96 6.24 3.84 6.96 6.24 3.84 4.56 6.96 6.24 6.24 3.84 10.08 6.96 10.8 6.24 3.84 6.96 4.56 4.56]
+xshow
+end grestore
+end grestore
+% EuclideanDomain()->PrincipalIdealDomain()
+newpath 218 144 moveto
+217 136 215 127 214 118 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 217 117 moveto
+212 108 lineto
+211 118 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 217 117 moveto
+212 108 lineto
+211 118 lineto
+closepath
+stroke
+end grestore
+% GCDDOM...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 346 36 moveto
+256 36 lineto
+256 0 lineto
+346 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 346 36 moveto
+256 36 lineto
+256 0 lineto
+346 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+264 13 moveto
+(GCDDOM...)
+[10.08 9.36 10.08 10.08 10.08 12.48 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% UniqueFactorizationDomain()->GCDDOM...
+newpath 371 72 moveto
+360 63 345 52 332 42 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 334 39 moveto
+324 36 lineto
+330 45 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 334 39 moveto
+324 36 lineto
+330 45 lineto
+closepath
+stroke
+end grestore
+% PrincipalIdealDomain()->GCDDOM...
+newpath 232 72 moveto
+243 63 258 52 270 42 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 272 45 moveto
+278 36 lineto
+268 39 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 272 45 moveto
+278 36 lineto
+268 39 lineto
+closepath
+stroke
+end grestore
+% Category
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 104 108 moveto
+36 108 lineto
+36 72 lineto
+104 72 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 104 108 moveto
+36 108 lineto
+36 72 lineto
+104 72 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+44 85 moveto
+(Category)
+[9.36 6.24 3.84 6.24 6.96 6.96 5.04 6.96]
+xshow
+end grestore
+end grestore
+% RetractableTo(a:Type)->Category
+newpath 70 144 moveto
+70 136 70 127 70 118 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 74 118 moveto
+70 108 lineto
+67 118 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 74 118 moveto
+70 108 lineto
+67 118 lineto
+closepath
+stroke
+end grestore
+endpage
+showpage
+grestore
+%%PageTrailer
+%%EndPage: 1
+%%Trailer
+%%Pages: 1
+end
+restore
+%%EOF
diff --git a/books/ps/v102finitefieldcategory.ps b/books/ps/v102finitefieldcategory.ps
new file mode 100644
index 0000000..c96d9dd
--- /dev/null
+++ b/books/ps/v102finitefieldcategory.ps
@@ -0,0 +1,631 @@
+%!PS-Adobe-2.0
+%%Creator: dot version 2.8 (Thu Sep 14 20:34:11 UTC 2006)
+%%For: (root) root
+%%Title: pic
+%%Pages: (atend)
+%%BoundingBox: 36 36 552 224
+%%EndComments
+save
+%%BeginProlog
+/DotDict 200 dict def
+DotDict begin
+
+/setupLatin1 {
+mark
+/EncodingVector 256 array def
+ EncodingVector 0
+
+ISOLatin1Encoding 0 255 getinterval putinterval
+EncodingVector 45 /hyphen put
+
+% Set up ISO Latin 1 character encoding
+/starnetISO {
+        dup dup findfont dup length dict begin
+        { 1 index /FID ne { def }{ pop pop } ifelse
+        } forall
+        /Encoding EncodingVector def
+        currentdict end definefont
+} def
+/Times-Roman starnetISO def
+/Times-Italic starnetISO def
+/Times-Bold starnetISO def
+/Times-BoldItalic starnetISO def
+/Helvetica starnetISO def
+/Helvetica-Oblique starnetISO def
+/Helvetica-Bold starnetISO def
+/Helvetica-BoldOblique starnetISO def
+/Courier starnetISO def
+/Courier-Oblique starnetISO def
+/Courier-Bold starnetISO def
+/Courier-BoldOblique starnetISO def
+cleartomark
+} bind def
+
+%%BeginResource: procset graphviz 0 0
+/coord-font-family /Times-Roman def
+/default-font-family /Times-Roman def
+/coordfont coord-font-family findfont 8 scalefont def
+
+/InvScaleFactor 1.0 def
+/set_scale {
+	dup 1 exch div /InvScaleFactor exch def
+	dup scale
+} bind def
+
+% styles
+/solid { [] 0 setdash } bind def
+/dashed { [9 InvScaleFactor mul dup ] 0 setdash } bind def
+/dotted { [1 InvScaleFactor mul 6 InvScaleFactor mul] 0 setdash } bind def
+/invis {/fill {newpath} def /stroke {newpath} def /show {pop newpath} def} bind def
+/bold { 2 setlinewidth } bind def
+/filled { } bind def
+/unfilled { } bind def
+/rounded { } bind def
+/diagonals { } bind def
+
+% hooks for setting color 
+/nodecolor { sethsbcolor } bind def
+/edgecolor { sethsbcolor } bind def
+/graphcolor { sethsbcolor } bind def
+/nopcolor {pop pop pop} bind def
+
+/beginpage {	% i j npages
+	/npages exch def
+	/j exch def
+	/i exch def
+	/str 10 string def
+	npages 1 gt {
+		gsave
+			coordfont setfont
+			0 0 moveto
+			(\() show i str cvs show (,) show j str cvs show (\)) show
+		grestore
+	} if
+} bind def
+
+/set_font {
+	findfont exch
+	scalefont setfont
+} def
+
+% draw aligned label in bounding box aligned to current point
+/alignedtext {			% width adj text
+	/text exch def
+	/adj exch def
+	/width exch def
+	gsave
+		width 0 gt {
+			text stringwidth pop adj mul 0 rmoveto
+		} if
+		[] 0 setdash
+		text show
+	grestore
+} def
+
+/boxprim {				% xcorner ycorner xsize ysize
+		4 2 roll
+		moveto
+		2 copy
+		exch 0 rlineto
+		0 exch rlineto
+		pop neg 0 rlineto
+		closepath
+} bind def
+
+/ellipse_path {
+	/ry exch def
+	/rx exch def
+	/y exch def
+	/x exch def
+	matrix currentmatrix
+	newpath
+	x y translate
+	rx ry scale
+	0 0 1 0 360 arc
+	setmatrix
+} bind def
+
+/endpage { showpage } bind def
+/showpage { } def
+
+/layercolorseq
+	[	% layer color sequence - darkest to lightest
+		[0 0 0]
+		[.2 .8 .8]
+		[.4 .8 .8]
+		[.6 .8 .8]
+		[.8 .8 .8]
+	]
+def
+
+/layerlen layercolorseq length def
+
+/setlayer {/maxlayer exch def /curlayer exch def
+	layercolorseq curlayer 1 sub layerlen mod get
+	aload pop sethsbcolor
+	/nodecolor {nopcolor} def
+	/edgecolor {nopcolor} def
+	/graphcolor {nopcolor} def
+} bind def
+
+/onlayer { curlayer ne {invis} if } def
+
+/onlayers {
+	/myupper exch def
+	/mylower exch def
+	curlayer mylower lt
+	curlayer myupper gt
+	or
+	{invis} if
+} def
+
+/curlayer 0 def
+
+%%EndResource
+%%EndProlog
+%%BeginSetup
+14 default-font-family set_font
+1 setmiterlimit
+% /arrowlength 10 def
+% /arrowwidth 5 def
+
+% make sure pdfmark is harmless for PS-interpreters other than Distiller
+/pdfmark where {pop} {userdict /pdfmark /cleartomark load put} ifelse
+% make '<<' and '>>' safe on PS Level 1 devices
+/languagelevel where {pop languagelevel}{1} ifelse
+2 lt {
+    userdict (<<) cvn ([) cvn load put
+    userdict (>>) cvn ([) cvn load put
+} if
+
+%%EndSetup
+%%Page: 1 1
+%%PageBoundingBox: 36 36 552 224
+%%PageOrientation: Portrait
+gsave
+36 36 516 188 boxprim clip newpath
+36 36 translate
+0 0 1 beginpage
+1.0000 set_scale
+4 4 translate 0 rotate
+0.167 0.600 1.000 graphcolor
+0.167 0.600 1.000 graphcolor
+newpath -6 -6 moveto
+-6 186 lineto
+514 186 lineto
+514 -6 lineto
+closepath
+fill
+0.167 0.600 1.000 graphcolor
+newpath -6 -6 moveto
+-6 186 lineto
+514 186 lineto
+514 -6 lineto
+closepath
+stroke
+0.000 0.000 0.000 graphcolor
+14.00 /Times-Roman set_font
+% FiniteFieldCategory()
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 344 180 moveto
+206 180 lineto
+206 144 lineto
+344 144 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 344 180 moveto
+206 180 lineto
+206 144 lineto
+344 144 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+214 157 moveto
+(FiniteFieldCategory\(\))
+[7.44 3.84 6.96 3.84 3.84 6.24 7.44 3.84 6.24 3.84 6.96 9.36 6.24 3.84 6.24 6.96 6.96 5.04 6.96 4.56 4.56]
+xshow
+end grestore
+end grestore
+% FieldOfPrimeCharacteristic()
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 180 108 moveto
+0 108 lineto
+0 72 lineto
+180 72 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 180 108 moveto
+0 108 lineto
+0 72 lineto
+180 72 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+8 85 moveto
+(FieldOfPrimeCharacteristic\(\))
+[7.44 3.84 6.24 3.84 6.96 10.08 4.56 7.68 5.04 3.84 10.8 6.24 9.36 6.96 6.24 4.8 6.24 6.24 3.84 6.24 5.04 3.84 5.28 3.84 3.84 6.24 4.56 4.56]
+xshow
+end grestore
+end grestore
+% FiniteFieldCategory()->FieldOfPrimeCharacteristic()
+newpath 228 144 moveto
+203 134 172 122 145 112 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 147 109 moveto
+136 108 lineto
+144 115 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 147 109 moveto
+136 108 lineto
+144 115 lineto
+closepath
+stroke
+end grestore
+% Finite()
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 256 108 moveto
+198 108 lineto
+198 72 lineto
+256 72 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 256 108 moveto
+198 108 lineto
+198 72 lineto
+256 72 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+206 85 moveto
+(Finite\(\))
+[7.44 3.84 6.96 3.84 3.84 6.24 4.56 4.56]
+xshow
+end grestore
+end grestore
+% FiniteFieldCategory()->Finite()
+newpath 263 144 moveto
+258 136 251 126 245 116 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 248 114 moveto
+239 108 lineto
+242 118 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 248 114 moveto
+239 108 lineto
+242 118 lineto
+closepath
+stroke
+end grestore
+% StepThrough()
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 372 108 moveto
+274 108 lineto
+274 72 lineto
+372 72 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 372 108 moveto
+274 108 lineto
+274 72 lineto
+372 72 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+282 85 moveto
+(StepThrough\(\))
+[7.44 3.84 6.24 6.96 8.64 6.96 4.8 6.96 6.96 6.96 6.96 4.56 4.56]
+xshow
+end grestore
+end grestore
+% FiniteFieldCategory()->StepThrough()
+newpath 287 144 moveto
+292 136 299 126 305 116 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 308 118 moveto
+311 108 lineto
+302 114 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 308 118 moveto
+311 108 lineto
+302 114 lineto
+closepath
+stroke
+end grestore
+% DifferentialRing()
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 508 108 moveto
+390 108 lineto
+390 72 lineto
+508 72 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 508 108 moveto
+390 108 lineto
+390 72 lineto
+508 72 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+398 85 moveto
+(DifferentialRing\(\))
+[10.08 3.84 4.56 4.08 6.24 4.8 6.24 6.96 3.84 3.84 6.24 3.84 9.36 3.84 6.96 6.96 4.56 4.56]
+xshow
+end grestore
+end grestore
+% FiniteFieldCategory()->DifferentialRing()
+newpath 319 144 moveto
+342 134 371 122 397 112 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 398 115 moveto
+406 108 lineto
+395 109 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 398 115 moveto
+406 108 lineto
+395 109 lineto
+closepath
+stroke
+end grestore
+% CHARNZ...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 97 36 moveto
+13 36 lineto
+13 0 lineto
+97 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 97 36 moveto
+13 36 lineto
+13 0 lineto
+97 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+20 13 moveto
+(CHARNZ...)
+[9.36 10.08 10.08 9.36 10.08 8.64 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% FieldOfPrimeCharacteristic()->CHARNZ...
+newpath 81 72 moveto
+77 64 73 54 68 45 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 71 44 moveto
+64 36 lineto
+65 47 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 71 44 moveto
+64 36 lineto
+65 47 lineto
+closepath
+stroke
+end grestore
+% FIELD...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 181 36 moveto
+115 36 lineto
+115 0 lineto
+181 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 181 36 moveto
+115 36 lineto
+115 0 lineto
+181 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+122 13 moveto
+(FIELD...)
+[7.68 4.56 8.64 8.64 10.08 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% FieldOfPrimeCharacteristic()->FIELD...
+newpath 105 72 moveto
+112 63 120 53 128 44 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 131 46 moveto
+134 36 lineto
+125 42 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 131 46 moveto
+134 36 lineto
+125 42 lineto
+closepath
+stroke
+end grestore
+% SETCAT...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 302 36 moveto
+224 36 lineto
+224 0 lineto
+302 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 302 36 moveto
+224 36 lineto
+224 0 lineto
+302 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+232 13 moveto
+(SETCAT...)
+[7.68 8.64 8.64 9.12 9.36 7.44 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% Finite()->SETCAT...
+newpath 236 72 moveto
+240 64 245 54 250 45 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 253 47 moveto
+254 36 lineto
+247 44 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 253 47 moveto
+254 36 lineto
+247 44 lineto
+closepath
+stroke
+end grestore
+% StepThrough()->SETCAT...
+newpath 308 72 moveto
+301 63 292 53 285 44 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 287 41 moveto
+278 36 lineto
+282 46 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 287 41 moveto
+278 36 lineto
+282 46 lineto
+closepath
+stroke
+end grestore
+% RING...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 479 36 moveto
+419 36 lineto
+419 0 lineto
+479 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 479 36 moveto
+419 36 lineto
+419 0 lineto
+479 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+426 13 moveto
+(RING...)
+[9.36 4.56 9.84 10.08 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% DifferentialRing()->RING...
+newpath 449 72 moveto
+449 64 449 55 449 46 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 453 46 moveto
+449 36 lineto
+446 46 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 453 46 moveto
+449 36 lineto
+446 46 lineto
+closepath
+stroke
+end grestore
+endpage
+showpage
+grestore
+%%PageTrailer
+%%EndPage: 1
+%%Trailer
+%%Pages: 1
+end
+restore
+%%EOF
diff --git a/books/ps/v102setcategory.ps b/books/ps/v102setcategory.ps
index ba73fd5..2e4a72e 100644
--- a/books/ps/v102setcategory.ps
+++ b/books/ps/v102setcategory.ps
@@ -206,11 +206,6 @@ stroke
 0.000 0.000 0.000 graphcolor
 14.00 /Times-Roman set_font
 % SetCategory()
-[ /Rect [ 58 216 152 252 ]
-  /Border [ 0 0 0 ]
-  /Action << /Subtype /URI /URI (books/bookvol10.2.pamphlet) >>
-  /Subtype /Link
-/ANN pdfmark
 gsave 10 dict begin
 filled
 0.537 0.247 0.902 nodecolor
@@ -237,11 +232,6 @@ xshow
 end grestore
 end grestore
 % BasicType()
-[ /Rect [ 0 72 84 108 ]
-  /Border [ 0 0 0 ]
-  /Action << /Subtype /URI /URI (books/bookvol10.2.pamphlet) >>
-  /Subtype /Link
-/ANN pdfmark
 gsave 10 dict begin
 filled
 0.537 0.247 0.902 nodecolor
@@ -289,11 +279,6 @@ closepath
 stroke
 end grestore
 % CoercibleTo(OutputForm)
-[ /Rect [ 82 144 246 180 ]
-  /Border [ 0 0 0 ]
-  /Action << /Subtype /URI /URI (books/bookvol10.2.pamphlet) >>
-  /Subtype /Link
-/ANN pdfmark
 gsave 10 dict begin
 filled
 0.404 0.667 0.545 nodecolor
@@ -340,11 +325,6 @@ closepath
 stroke
 end grestore
 % Category
-[ /Rect [ 71 0 139 36 ]
-  /Border [ 0 0 0 ]
-  /Action << /Subtype /URI /URI (books/bookvol10.pamphlet) >>
-  /Subtype /Link
-/ANN pdfmark
 gsave 10 dict begin
 filled
 0.537 0.247 0.902 nodecolor
@@ -391,11 +371,6 @@ closepath
 stroke
 end grestore
 % CoercibleTo(a:Type)
-[ /Rect [ 102 72 234 108 ]
-  /Border [ 0 0 0 ]
-  /Action << /Subtype /URI /URI (books/bookvol10.2.pamphlet) >>
-  /Subtype /Link
-/ANN pdfmark
 gsave 10 dict begin
 filled
 0.537 0.247 0.902 nodecolor



From MAILER-DAEMON Sat Oct 04 04:07:43 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Km2Aw-0006uB-T6
	for mharc-axiom-developer@gnu.org; Sat, 04 Oct 2008 04:07:42 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Km2Au-0006ta-S8
	for axiom-developer@nongnu.org; Sat, 04 Oct 2008 04:07:40 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Km2Ak-0006qU-5w
	for axiom-developer@nongnu.org; Sat, 04 Oct 2008 04:07:40 -0400
Received: from [199.232.76.173] (port=38474 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Km2Ak-0006qR-2Y
	for axiom-developer@nongnu.org; Sat, 04 Oct 2008 04:07:30 -0400
Received: from mx20.gnu.org ([199.232.41.8]:39041)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <daly@axiom-developer.org>)
	id 1Km2Aj-000397-Uf
	for axiom-developer@nongnu.org; Sat, 04 Oct 2008 04:07:30 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]
	helo=axiom-developer.org) by mx20.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Km2AE-0002yl-2x
	for axiom-developer@nongnu.org; Sat, 04 Oct 2008 04:06:58 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m946hcr3004867;
	Sat, 4 Oct 2008 01:43:38 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m946hc9S004864;
	Sat, 4 Oct 2008 01:43:38 -0500
Date: Sat, 4 Oct 2008 01:43:38 -0500
Message-Id: <200810040643.m946hc9S004864@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by mx20.gnu.org: Linux 2.6? (barebone, rare!)
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6,
	seldom 2.4 (older, 4)
Cc: 
Subject: [Axiom-developer] 20081002.01.tpd.patch (bookvol10.2 add more
	categories)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 04 Oct 2008 08:07:41 -0000

Added the following categories to bookvol10.2:

  AbelianMonoidRing
  FileCategory
  FileNameCategory
  FiniteAbelianMonoidRing 
  FullyPatternMatchable
  OpenMath 
  Patternable
  PatternMatchable
  StringCategory 

=======================================================================
patch too big to post. See
<http://axiom-developer@nongnu.org/axiom-website/patches.html#latest>



From MAILER-DAEMON Sat Oct 04 14:10:28 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KmBaG-0005SA-Lw
	for mharc-axiom-developer@gnu.org; Sat, 04 Oct 2008 14:10:28 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KmBaF-0005Rv-Ek
	for axiom-developer@nongnu.org; Sat, 04 Oct 2008 14:10:27 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KmBaB-0005Qs-8d
	for axiom-developer@nongnu.org; Sat, 04 Oct 2008 14:10:27 -0400
Received: from [199.232.76.173] (port=52423 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KmBaA-0005Qn-SD
	for axiom-developer@nongnu.org; Sat, 04 Oct 2008 14:10:22 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:38572
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KmBa9-0006qK-6Z
	for axiom-developer@nongnu.org; Sat, 04 Oct 2008 14:10:22 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m94IA5r3020852;
	Sat, 4 Oct 2008 13:10:05 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m94IA345020836;
	Sat, 4 Oct 2008 13:10:03 -0500
Date: Sat, 4 Oct 2008 13:10:03 -0500
Message-Id: <200810041810.m94IA345020836@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20081003.01.tpd.patch (bookvol10.2 add POLYCAT)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 04 Oct 2008 18:10:27 -0000

Add PolynomialCategory to bookvol10.2
=====================================================================
diff --git a/books/bookvol10.2.pamphlet b/books/bookvol10.2.pamphlet
index 35305df..5685fd5 100644
--- a/books/bookvol10.2.pamphlet
+++ b/books/bookvol10.2.pamphlet
@@ -853,6 +853,7 @@ digraph pic {
 {\bf See:}\\
 \pageto{Collection}{CLAGG}
 \pageto{MonogenicAlgebra}{MONOGEN}
+\pageto{PolynomialCategory}{POLYCAT}
 \pagefrom{Category}{CATEGORY}
 
 {\bf Exports:}\\
@@ -1191,6 +1192,7 @@ digraph pic {
 
 {\bf See:}\\
 \pageto{Evalable}{EVALAB}
+\pageto{PolynomialCategory}{POLYCAT}
 \pagefrom{Category}{CATEGORY}
 
 {\bf Exports:}\\
@@ -1253,6 +1255,16 @@ InnerEvalable(A:SetCategory, B:Type): Category == with
 "InnerEvalable(a:SetCategory,b:SetCategory)" ->
     "InnerEvalable(a:SetCategory,b:Type)"
 
+"InnerEvalable(a:OrderedSet,b:Ring)"
+ [color=seagreen,href="bookvol10.2.pdf#nameddest=IEVALAB"];
+"InnerEvalable(a:OrderedSet,b:Ring)" ->
+    "InnerEvalable(a:SetCategory,b:Type)"
+
+"InnerEvalable(a:OrderedSet,b:PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+ [color=seagreen,href="bookvol10.2.pdf#nameddest=IEVALAB"];
+"InnerEvalable(a:OrderedSet,b:PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)" ->
+    "InnerEvalable(a:SetCategory,b:Type)"
+
 "InnerEvalable(a:Ring,MultivariateTaylorSeriesCategory(a:Ring,b:OrderedSet))"
  [color=seagreen,href="bookvol10.2.pdf#nameddest=IEVALAB"];
 "InnerEvalable(a:Ring,MultivariateTaylorSeriesCategory(a:Ring,b:OrderedSet))"
@@ -1485,6 +1497,7 @@ digraph pic {
 \pageto{FiniteAlgebraicExtensionField}{FAXF}
 \pageto{FullyRetractableTo}{FRETRCT}
 \pageto{GradedAlgebra}{GRALG}
+\pageto{PolynomialCategory}{POLYCAT}
 \pagefrom{Category}{CATEGORY}
 
 {\bf Exports:}\\
@@ -1545,6 +1558,10 @@ RetractableTo(S: Type): Category == with
  [color=seagreen,href="bookvol10.2.pdf#nameddest=RETRACT"];
 "RetractableTo(SetCategory)" -> "RetractableTo(a:Type)"
 
+"RetractableTo(OrderedSet)"
+ [color=seagreen,href="bookvol10.2.pdf#nameddest=RETRACT"];
+"RetractableTo(OrderedSet)" -> "RetractableTo(a:Type)"
+
 "RetractableTo(Symbol)"
  [color=seagreen,href="bookvol10.2.pdf#nameddest=RETRACT"];
 "RetractableTo(Symbol)" -> "RetractableTo(a:Type)"
@@ -2059,10 +2076,12 @@ digraph pic {
 \pagepic{ps/v102evalable.ps}{EVALAB}{1.00}
 
 {\bf See:}\\
+\pageto{PolynomialCategory}{POLYCAT}
 \pagefrom{InnerEvalable}{IEVALAB}
 
 {\bf Exports:}\\
-\begin{tabular}{lllll}
+\begin{tabular}{l}
+\cross{EVALAB}{eval}
 \end{tabular}
 
 These are directly exported but not implemented:
@@ -2127,6 +2146,11 @@ Evalable(R:SetCategory): Category == InnerEvalable(R,R) with
  [color=seagreen,href="bookvol10.2.pdf#nameddest=EVALAB"];
 "Evalable(ExpressionSpace)" -> "Evalable(a:SetCategory)"
 
+"Evalable(PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet))"
+ [color=seagreen,href="bookvol10.2.pdf#nameddest=EVALAB"];
+"Evalable(PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet))"
+  -> "Evalable(a:SetCategory)"
+
 @
 <<EVALAB.dotpic>>=
 digraph pic {
@@ -3961,6 +3985,7 @@ digraph pic {
 \pageto{OrderedAbelianSemiGroup}{OASGP}
 \pageto{OrderedFinite}{ORDFIN}
 \pageto{OrderedMonoid}{ORDMON}
+\pageto{PolynomialCategory}{POLYCAT}
 \pagefrom{SetCategory}{SETCAT}
 
 {\bf Exports:}\\
@@ -4087,6 +4112,7 @@ digraph pic {
 \pagepic{ps/v102patternmatchable.ps}{PATMAB}{1.00}
 
 {\bf See:}\\
+\pageto{PolynomialCategory}{POLYCAT}
 \pagefrom{SetCategory}{SETCAT}
 
 {\bf Exports:}\\
@@ -4149,7 +4175,13 @@ PatternMatchable(S:SetCategory): Category == SetCategory with
 "PatternMatchable(a:SetCategory)"
  [color=lightblue,href="bookvol10.2.pdf#nameddest=PATMAB"];
 "PatternMatchable(a:SetCategory)" -> "SetCategory()"
+
+"PatternMatchable(Integer)"
+ [color=seagreen,href="bookvol10.2.pdf#nameddest=PATMAB"];
 "PatternMatchable(Integer)" -> "PatternMatchable(a:SetCategory)"
+
+"PatternMatchable(Float)"
+ [color=seagreen,href="bookvol10.2.pdf#nameddest=PATMAB"];
 "PatternMatchable(Float)" -> "PatternMatchable(a:SetCategory)"
 
 @
@@ -17406,6 +17438,7 @@ digraph pic {
 {\bf See:}\\
 \pageto{IntegralDomain}{INTDOM}
 \pageto{MonogenicAlgebra}{MONOGEN}
+\pageto{PolynomialCategory}{POLYCAT}
 \pagefrom{BiModule}{BMODULE}
 \pagefrom{Ring}{RING}
 
@@ -17432,14 +17465,13 @@ digraph pic {
 \cross{COMRING}{?=?} &
 \end{tabular}
 
-{\bf Attributes:}
+{\bf Attributes exported:}
 \begin{itemize}
 \item {\bf \cross{COMRING}{commutative("*")}}
 is true if it has an operation $"*": (D,D) -> D$
 which is commutative.
 \end{itemize}
 
-
 These exports come from \refto{Ring}():
 \begin{verbatim}
  0 : () -> %
@@ -18244,6 +18276,7 @@ digraph pic {
 
 {\bf See:}\\
 \pageto{DifferentialExtension}{DIFEXT}
+\pageto{PolynomialCategory}{POLYCAT}
 \pagefrom{Ring}{RING}
 
 {\bf Exports:}\\
@@ -18278,13 +18311,13 @@ These are directly exported but not implemented:
 
 These are implemented by this category:
 \begin{verbatim}
- differentiate : (%,List S) -> %
- differentiate : (%,S,NonNegativeInteger) -> %
- differentiate : (%,List S,List NonNegativeInteger) -> %
  D : (%,S) -> %
  D : (%,List S) -> %                  
  D : (%,S,NonNegativeInteger) -> %
  D : (%,List S,List NonNegativeInteger) -> %
+ differentiate : (%,List S) -> %
+ differentiate : (%,S,NonNegativeInteger) -> %
+ differentiate : (%,List S,List NonNegativeInteger) -> %
 \end{verbatim}
 
 These exports come from \refto{Ring}():
@@ -18657,6 +18690,7 @@ digraph pic {
 \pagepic{ps/v102finiteabelianmonoidring.ps}{FAMR}{0.40}
 
 {\bf See:}\\
+\pageto{PolynomialCategory}{POLYCAT}
 \pagefrom{AbelianMonoidRing}{AMR}
 \pagefrom{FullyRetractableTo}{FRETRCT}
 
@@ -18935,6 +18969,11 @@ FiniteAbelianMonoidRing(R:Ring, E:OrderedAbelianMonoid): Category ==
 "FiniteAbelianMonoidRing(a:Ring,b:OrderedAbelianMonoid)" ->
     "FullyRetractableTo(a:Ring)"
 
+"FiniteAbelianMonoidRing(a:Ring,b:OrderedAbelianMonoidSup)" 
+ [color=seagreen,href="bookvol10.2.pdf#nameddest=FAMR"];
+"FiniteAbelianMonoidRing(a:Ring,b:OrderedAbelianMonoidSup)" ->
+    "FiniteAbelianMonoidRing(a:Ring,b:OrderedAbelianMonoid)"
+
 @
 <<FAMR.dotpic>>=
 digraph pic {
@@ -19007,6 +19046,7 @@ digraph pic {
 \pagepic{ps/v102fullylinearlyexplicitringover.ps}{FLINEXP}{1.00}
 
 {\bf See:}\\
+\pageto{PolynomialCategory}{POLYCAT}
 \pagefrom{LinearlyExplicitRingOver}{LINEXP}
 
 {\bf Exports:}\\
@@ -21646,6 +21686,7 @@ digraph pic {
 \pagepic{ps/v102gcddomain.ps}{GCDDOM}{0.65}
 
 {\bf See:}\\
+\pageto{PolynomialCategory}{POLYCAT}
 \pageto{PrincipalIdealDomain}{PID}
 \pageto{UniqueFactorizationDomain}{UFD}
 \pagefrom{IntegralDomain}{INTDOM}
@@ -21698,23 +21739,23 @@ These are implemented by this category:
 
 These exports come from \refto{IntegralDomain}():
 \begin{verbatim}
- associates? : (%,%) -> Boolean
- exquo : (%,%) -> Union(%,"failed")
- unit? : % -> Boolean                 
- unitCanonical : % -> %
- unitNormal : % -> Record(unit: %,canonical: %,associate: %)
  0 : () -> %
  1 : () -> %                          
+ associates? : (%,%) -> Boolean
  characteristic : () -> NonNegativeInteger
  coerce : % -> %                      
  coerce : Integer -> %
  coerce : % -> OutputForm             
+ exquo : (%,%) -> Union(%,"failed")
  hash : % -> SingleInteger
  latex : % -> String                  
  one? : % -> Boolean
  recip : % -> Union(%,"failed")       
  sample : () -> %
  subtractIfCan : (%,%) -> Union(%,"failed")
+ unit? : % -> Boolean                 
+ unitCanonical : % -> %
+ unitNormal : % -> Record(unit: %,canonical: %,associate: %)
  zero? : % -> Boolean                 
  ?+? : (%,%) -> %                     
  ?=? : (%,%) -> Boolean
@@ -22700,6 +22741,7 @@ digraph pic {
 \pagepic{ps/v102polynomialfactorizationexplicit.ps}{PFECAT}{0.75}
 
 {\bf See:}\\
+\pageto{PolynomialCategory}{POLYCAT}
 \pagefrom{UniqueFactorizationDomain}{UFD}
 
 {\bf Exports:}\\
@@ -23180,6 +23222,946 @@ digraph pic {
 }
 
 @
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\pagehead{PolynomialCategory}{POLYCAT}
+\pagepic{ps/v102polynomialcategory.ps}{POLYCAT}{1.00}
+
+{\bf See:}\\
+\pagefrom{CommutativeRing}{COMRING}
+\pagefrom{ConvertibleTo}{KONVERT}
+\pagefrom{Evalable}{EVALAB}
+\pagefrom{FiniteAbelianMonoidRing}{FAMR}
+\pagefrom{FullyLinearlyExplicitRingOver}{FLINEXP}
+\pagefrom{GcdDomain}{GCDDOM}
+\pagefrom{InnerEvalable}{IEVALAB}
+\pagefrom{OrderedSet}{ORDSET}
+\pagefrom{PartialDifferentialRing}{PDRING}
+\pagefrom{PatternMatchable}{PATMAB}
+\pagefrom{PolynomialFactorizationExplicit}{PFECAT}
+\pagefrom{RetractableTo}{RETRACT}
+
+{\bf Exports:}\\
+\begin{tabular}{lll}
+\cross{POLYCAT}{0} &
+\cross{POLYCAT}{1} &
+\cross{POLYCAT}{associates?} \\
+\cross{POLYCAT}{binomThmExpt} &
+\cross{POLYCAT}{characteristic} &
+\cross{POLYCAT}{charthRoot} \\
+\cross{POLYCAT}{coefficient} &
+\cross{POLYCAT}{coefficients} &
+\cross{POLYCAT}{coerce} \\
+\cross{POLYCAT}{conditionP} &
+\cross{POLYCAT}{content} &
+\cross{POLYCAT}{convert} \\
+\cross{POLYCAT}{D} &
+\cross{POLYCAT}{degree} &
+\cross{POLYCAT}{differentiate} \\
+\cross{POLYCAT}{discriminant} &
+\cross{POLYCAT}{eval} &
+\cross{POLYCAT}{exquo} \\
+\cross{POLYCAT}{factor} &
+\cross{POLYCAT}{factorPolynomial} &
+\cross{POLYCAT}{factorSquareFreePolynomial} \\
+\cross{POLYCAT}{gcd} &
+\cross{POLYCAT}{gcdPolynomial} &
+\cross{POLYCAT}{ground} \\
+\cross{POLYCAT}{ground?} &
+\cross{POLYCAT}{hash} &
+\cross{POLYCAT}{isExpt} \\
+\cross{POLYCAT}{isPlus} &
+\cross{POLYCAT}{isTimes} &
+\cross{POLYCAT}{latex} \\
+\cross{POLYCAT}{lcm} &
+\cross{POLYCAT}{leadingCoefficient} &
+\cross{POLYCAT}{leadingMonomial} \\
+\cross{POLYCAT}{mainVariable} &
+\cross{POLYCAT}{map} &
+\cross{POLYCAT}{mapExponents} \\
+\cross{POLYCAT}{max} &
+\cross{POLYCAT}{min} &
+\cross{POLYCAT}{minimumDegree} \\
+\cross{POLYCAT}{monicDivide} &
+\cross{POLYCAT}{monomial} &
+\cross{POLYCAT}{monomial?} \\
+\cross{POLYCAT}{monomials} &
+\cross{POLYCAT}{multivariate} &
+\cross{POLYCAT}{numberOfMonomials} \\
+\cross{POLYCAT}{one?} &
+\cross{POLYCAT}{patternMatch} &
+\cross{POLYCAT}{pomopo!} \\
+\cross{POLYCAT}{prime?} &
+\cross{POLYCAT}{primitiveMonomials} &
+\cross{POLYCAT}{primitivePart} \\
+\cross{POLYCAT}{recip} &
+\cross{POLYCAT}{reducedSystem} &
+\cross{POLYCAT}{reductum} \\
+\cross{POLYCAT}{resultant} &
+\cross{POLYCAT}{retract} &
+\cross{POLYCAT}{retractIfCan} \\
+\cross{POLYCAT}{sample} &
+\cross{POLYCAT}{solveLinearPolynomialEquation} &
+\cross{POLYCAT}{squareFree} \\
+\cross{POLYCAT}{squareFreePart} &
+\cross{POLYCAT}{squareFreePolynomial} &
+\cross{POLYCAT}{subtractIfCan} \\
+\cross{POLYCAT}{totalDegree} &
+\cross{POLYCAT}{unit?} &
+\cross{POLYCAT}{unitCanonical} \\
+\cross{POLYCAT}{unitNormal} &
+\cross{POLYCAT}{univariate} &
+\cross{POLYCAT}{variables} \\
+\cross{POLYCAT}{zero?} &
+\cross{POLYCAT}{?*?} &
+\cross{POLYCAT}{?**?} \\
+\cross{POLYCAT}{?+?} &
+\cross{POLYCAT}{?-?} &
+\cross{POLYCAT}{-?} \\
+\cross{POLYCAT}{?=?} &
+\cross{POLYCAT}{?\^{}?} &
+\cross{POLYCAT}{?\~{}=?} \\
+\cross{POLYCAT}{?/?} &
+\cross{POLYCAT}{?$<$?} &
+\cross{POLYCAT}{?$<=$?} \\
+\cross{POLYCAT}{?$>$?} &
+\cross{POLYCAT}{?$>=$?} &
+\end{tabular}
+
+{\bf Attributes exported:}
+\begin{itemize}
+\item if R has canonicalUnitNormal then canonicalUnitNormal where
+{\bf \cross{POLYCAT}{canonicalUnitNormal}}
+is true if we can choose a canonical representative for each class 
+of associate elements, that is {\tt associates?(a,b)} returns true 
+if and only if {\tt unitCanonical(a) = unitCanonical(b)}.
+\end{itemize}
+
+These are directly exported but not implemented:
+\begin{verbatim}
+ degree : (%,VarSet) -> NonNegativeInteger
+ degree : (%,List VarSet) -> List NonNegativeInteger
+ mainVariable : % -> Union(VarSet,"failed")
+ minimumDegree : (%,List VarSet) -> List NonNegativeInteger
+ minimumDegree : (%,VarSet) -> NonNegativeInteger
+ monomial : (%,VarSet,NonNegativeInteger) -> %
+ multivariate : (SparseUnivariatePolynomial %,VarSet) -> %
+ multivariate : (SparseUnivariatePolynomial R,VarSet) -> %
+ univariate : (%,VarSet) -> SparseUnivariatePolynomial %
+ univariate : % -> SparseUnivariatePolynomial R
+ variables : % -> List VarSet
+\end{verbatim}
+
+These are implemented by this category:
+\begin{verbatim}
+ charthRoot : % -> Union(%,"failed") 
+  if 
+    and(has($,CharacteristicNonZero),
+        has(R,PolynomialFactorizationExplicit)) 
+    or R has CHARNZ
+ coefficient : (%,VarSet,NonNegativeInteger) -> %
+ coefficient : (%,List VarSet,List NonNegativeInteger) -> %
+ conditionP : Matrix % -> Union(Vector %,"failed") 
+  if 
+    and(has($,CharacteristicNonZero),
+        has(R,PolynomialFactorizationExplicit))
+ content : (%,VarSet) -> % if R has GCDDOM
+ convert : % -> Pattern Integer 
+     if VarSet has KONVERT PATTERN INT 
+     and R has KONVERT PATTERN INT
+ convert : % -> Pattern Float 
+     if VarSet has KONVERT PATTERN FLOAT 
+     and R has KONVERT PATTERN FLOAT
+ convert : % -> InputForm 
+     if VarSet has KONVERT INFORM 
+     and R has KONVERT INFORM
+ discriminant : (%,VarSet) -> % if R has COMRING
+ eval : (%,List Equation %) -> %      
+ factor : % -> Factored % if R has PFECAT
+ factorPolynomial :
+    SparseUnivariatePolynomial % ->
+       Factored SparseUnivariatePolynomial % 
+         if R has PFECAT
+ factorSquareFreePolynomial :
+    SparseUnivariatePolynomial % ->
+       Factored SparseUnivariatePolynomial % 
+         if R has PFECAT
+ gcdPolynomial : (SparseUnivariatePolynomial %,
+                  SparseUnivariatePolynomial %) ->
+                     SparseUnivariatePolynomial % 
+     if R has GCDDOM
+ isExpt : % ->
+   Union(Record(var: VarSet,exponent: NonNegativeInteger),"failed")
+ isPlus : % -> Union(List %,"failed")
+ isTimes : % -> Union(List %,"failed")
+ monicDivide : (%,%,VarSet) -> Record(quotient: %,remainder: %)
+ monomial : (%,List VarSet,List NonNegativeInteger) -> %
+ monomials : % -> List %              
+ patternMatch :
+   (%,Pattern Integer,PatternMatchResult(Integer,%)) ->
+     PatternMatchResult(Integer,%) 
+       if VarSet has PATMAB INT 
+       and R has PATMAB INT
+ patternMatch :
+    (%,Pattern Float,PatternMatchResult(Float,%)) ->
+      PatternMatchResult(Float,%) 
+        if VarSet has PATMAB FLOAT 
+        and R has PATMAB FLOAT
+ primitiveMonomials : % -> List %
+ primitivePart : % -> % if R has GCDDOM
+ primitivePart : (%,VarSet) -> % if R has GCDDOM
+ reducedSystem : Matrix % -> Matrix R
+ reducedSystem : (Matrix %,Vector %) ->
+    Record(mat: Matrix R,vec: Vector R)
+ resultant : (%,%,VarSet) -> % if R has COMRING
+ retract : % -> VarSet                
+ retractIfCan : % -> Union(VarSet,"failed")
+ solveLinearPolynomialEquation :
+    (List SparseUnivariatePolynomial %,
+     SparseUnivariatePolynomial %) ->
+        Union(List SparseUnivariatePolynomial %,"failed") 
+          if R has PFECAT
+ squareFree : % -> Factored % if R has GCDDOM
+ squareFreePart : % -> % if R has GCDDOM
+ totalDegree : % -> NonNegativeInteger
+ totalDegree : (%,List VarSet) -> NonNegativeInteger
+ ?<? : (%,%) -> Boolean if R has ORDSET
+\end{verbatim}
+
+These exports come from \refto{PartialDifferentialRing}(VarSet)\\
+where VarSet:OrderedSet:
+\begin{verbatim}
+ 0 : () -> %
+ 1 : () -> %                          
+ characteristic : () -> NonNegativeInteger
+ coerce : Integer -> %
+ coerce : % -> OutputForm             
+ D : (%,List VarSet) -> %             
+ D : (%,VarSet) -> %
+ D : (%,List VarSet,List NonNegativeInteger) -> %
+ D : (%,VarSet,NonNegativeInteger) -> %
+ differentiate : (%,VarSet) -> %      
+ differentiate : (%,List VarSet,List NonNegativeInteger) -> %
+ differentiate : (%,VarSet,NonNegativeInteger) -> %
+ differentiate : (%,List VarSet) -> %
+ hash : % -> SingleInteger
+ latex : % -> String                  
+ one? : % -> Boolean
+ recip : % -> Union(%,"failed")       
+ sample : () -> %                     
+ subtractIfCan : (%,%) -> Union(%,"failed")
+ zero? : % -> Boolean                 
+ ?+? : (%,%) -> %                     
+ ?=? : (%,%) -> Boolean
+ ?~=? : (%,%) -> Boolean
+ ?*? : (%,%) -> %                     
+ ?*? : (Integer,%) -> %
+ ?*? : (PositiveInteger,%) -> %       
+ ?*? : (NonNegativeInteger,%) -> %
+ ?-? : (%,%) -> %
+ -? : % -> %                          
+ ?^? : (%,PositiveInteger) -> %       
+ ?^? : (%,NonNegativeInteger) -> %
+ ?**? : (%,NonNegativeInteger) -> %
+ ?**? : (%,PositiveInteger) -> %
+\end{verbatim}
+
+These exports come from \refto{FiniteAbelianMonoidRing}(R,E)\\
+where R:Ring and E:OrderedAbelianMonoidSup:
+\begin{verbatim}
+ associates? : (%,%) -> Boolean if R has INTDOM
+ binomThmExpt : (%,%,NonNegativeInteger) -> % 
+     if R has COMRING
+ coefficient : (%,E) -> R
+ coefficients : % -> List R           
+ coerce : R -> %                      
+ coerce : Fraction Integer -> % 
+     if R has RETRACT FRAC INT 
+     or R has ALGEBRA FRAC INT
+ coerce : % -> % if R has INTDOM
+ content : % -> R if R has GCDDOM
+ degree : % -> E
+ exquo : (%,R) -> Union(%,"failed") if R has INTDOM
+ exquo : (%,%) -> Union(%,"failed") if R has INTDOM
+ ground : % -> R
+ ground? : % -> Boolean               
+ leadingCoefficient : % -> R
+ leadingMonomial : % -> %             
+ map : ((R -> R),%) -> %
+ mapExponents : ((E -> E),%) -> %     
+ minimumDegree : % -> E
+ monomial : (R,E) -> %                
+ monomial? : % -> Boolean
+ numberOfMonomials : % -> NonNegativeInteger
+ pomopo! : (%,R,E,%) -> %             
+ reductum : % -> %
+ retract : % -> Integer if R has RETRACT INT
+ retract : % -> Fraction Integer 
+     if R has RETRACT FRAC INT
+ retractIfCan : % -> Union(Integer,"failed") 
+     if R has RETRACT INT
+ retractIfCan : % -> Union(Fraction Integer,"failed") 
+     if R has RETRACT FRAC INT
+ unit? : % -> Boolean if R has INTDOM
+ unitCanonical : % -> % if R has INTDOM
+ unitNormal : % -> Record(unit: %,canonical: %,associate: %) 
+     if R has INTDOM
+ ?*? : (%,R) -> %                     
+ ?*? : (R,%) -> %
+ ?*? : (Fraction Integer,%) -> % 
+     if R has ALGEBRA FRAC INT
+ ?*? : (%,Fraction Integer) -> % 
+     if R has ALGEBRA FRAC INT
+ ?/? : (%,R) -> % if R has FIELD
+\end{verbatim}
+
+These exports come from \refto{Evalable}(PolynomialCategory(...)):
+\begin{verbatim}
+ eval : (%,Equation %) -> %
+ eval : (%,List %,List %) -> %
+ eval : (%,%,%) -> %                  
+\end{verbatim}
+
+These exports come from \refto{InnerEvalable}(VarSet,R)\\
+where VarSet:OrderedSet and R:Ring
+\begin{verbatim}
+ eval : (%,VarSet,R) -> %             
+ eval : (%,List VarSet,List R) -> %
+\end{verbatim}
+
+These exports come from \refto{InnerEvalable}(VarSet,R)\\
+where VarSet:OrderedSet and R:PolynomialCategory(...):
+\begin{verbatim}
+ eval : (%,VarSet,%) -> %
+ eval : (%,List VarSet,List %) -> %
+\end{verbatim}
+
+These exports come from \refto{RetractableTo}(VarSet)\\
+where VarSet:OrderedSet:
+\begin{verbatim}
+ coerce : VarSet -> %
+ retract : % -> R
+ retractIfCan : % -> Union(R,"failed")
+\end{verbatim}
+
+These exports come from \refto{FullyLinearlyExplicitRingOver}(R)\\
+where R:Ring:
+\begin{verbatim}
+ reducedSystem : (Matrix %,Vector %) ->
+    Record(mat: Matrix Integer,vec: Vector Integer) 
+       if R has LINEXP INT
+ reducedSystem : Matrix % -> Matrix Integer 
+       if R has LINEXP INT
+\end{verbatim}
+
+These exports come from \refto{OrderedSet}():
+\begin{verbatim}
+ max : (%,%) -> % if R has ORDSET
+ min : (%,%) -> % if R has ORDSET
+ ?<=? : (%,%) -> Boolean if R has ORDSET
+ ?>? : (%,%) -> Boolean if R has ORDSET
+ ?>=? : (%,%) -> Boolean if R has ORDSET
+\end{verbatim}
+
+These exports come from \refto{GcdDomain}():
+\begin{verbatim}
+ gcd : (%,%) -> % if R has GCDDOM
+ gcd : List % -> % if R has GCDDOM
+ lcm : (%,%) -> % if R has GCDDOM
+ lcm : List % -> % if R has GCDDOM
+\end{verbatim}
+
+These exports come from \refto{PolynomialFactorizationExplicit}():
+\begin{verbatim}
+ prime? : % -> Boolean if R has PFECAT
+ squareFreePolynomial : SparseUnivariatePolynomial % ->
+    Factored SparseUnivariatePolynomial % 
+      if R has PFECAT
+\end{verbatim}
+
+These exports come from \refto{ConvertibleTo}(InputForm):
+\begin{verbatim}
+\end{verbatim}
+
+These exports come from \refto{ConvertibleTo}(Pattern(Integer)):
+\begin{verbatim}
+\end{verbatim}
+
+These exports come from \refto{ConvertibleTo}(Pattern(Float)):
+\begin{verbatim}
+\end{verbatim}
+
+These exports come from \refto{PatternMatchable}(Pattern(Integer)):
+\begin{verbatim}
+\end{verbatim}
+
+These exports come from \refto{PatternMatchable}(Pattern(Float)):
+\begin{verbatim}
+\end{verbatim}
+
+These exports come from \refto{CommutativeRing}():
+\begin{verbatim}
+\end{verbatim}
+
+<<category POLYCAT PolynomialCategory>>=
+)abbrev category POLYCAT PolynomialCategory
+++ Author:
+++ Date Created:
+++ Date Last Updated:
+++ Basic Functions: Ring, monomial, coefficient, differentiate, eval
+++ Related Constructors: Polynomial, DistributedMultivariatePolynomial
+++ Also See: UnivariatePolynomialCategory
+++ AMS Classifications:
+++ Keywords:
+++ References:
+++ Description:
+++ The category for general multi-variate polynomials over a ring
+++ R, in variables from VarSet, with exponents from the
+++ \spadtype{OrderedAbelianMonoidSup}.
+
+PolynomialCategory(R:Ring, E:OrderedAbelianMonoidSup, VarSet:OrderedSet):
+        Category ==
+  Join(PartialDifferentialRing VarSet, FiniteAbelianMonoidRing(R, E),
+       Evalable %, InnerEvalable(VarSet, R),
+       InnerEvalable(VarSet, %), RetractableTo VarSet,
+       FullyLinearlyExplicitRingOver R) with
+    degree : (%,VarSet) -> NonNegativeInteger
+      ++ degree(p,v) gives the degree of polynomial p with respect 
+      ++ to the variable v.
+    degree : (%,List(VarSet)) -> List(NonNegativeInteger)
+      ++ degree(p,lv) gives the list of degrees of polynomial p
+      ++ with respect to each of the variables in the list lv.
+    coefficient: (%,VarSet,NonNegativeInteger) -> %
+      ++ coefficient(p,v,n) views the polynomial p as a univariate
+      ++ polynomial in v and returns the coefficient of the \spad{v**n} term.
+    coefficient: (%,List VarSet,List NonNegativeInteger) -> %
+      ++ coefficient(p, lv, ln) views the polynomial p as a polynomial
+      ++ in the variables of lv and returns the coefficient of the term
+      ++ \spad{lv**ln}, i.e. \spad{prod(lv_i ** ln_i)}.
+    monomials: % -> List %
+      ++ monomials(p) returns the list of non-zero monomials of 
+      ++ polynomial p, i.e.
+      ++ \spad{monomials(sum(a_(i) X^(i))) = [a_(1) X^(1),...,a_(n) X^(n)]}.
+    univariate   : (%,VarSet) -> SparseUnivariatePolynomial(%)
+      ++ univariate(p,v) converts the multivariate polynomial p
+      ++ into a univariate polynomial in v, whose coefficients are still
+      ++ multivariate polynomials (in all the other variables).
+    univariate   : % -> SparseUnivariatePolynomial(R)
+      ++ univariate(p) converts the multivariate polynomial p,
+      ++ which should actually involve only one variable,
+      ++ into a univariate polynomial
+      ++ in that variable, whose coefficients are in the ground ring.
+      ++ Error: if polynomial is genuinely multivariate
+    mainVariable  : % -> Union(VarSet,"failed")
+      ++ mainVariable(p) returns the biggest variable which actually
+      ++ occurs in the polynomial p, or "failed" if no variables are
+      ++ present.
+      ++ fails precisely if polynomial satisfies ground?
+    minimumDegree : (%,VarSet) -> NonNegativeInteger
+      ++ minimumDegree(p,v) gives the minimum degree of polynomial p
+      ++ with respect to v, i.e. viewed a univariate polynomial in v
+    minimumDegree : (%,List(VarSet)) -> List(NonNegativeInteger)
+      ++ minimumDegree(p, lv) gives the list of minimum degrees of the
+      ++ polynomial p with respect to each of the variables in the list lv
+    monicDivide : (%,%,VarSet) -> Record(quotient:%,remainder:%)
+      ++ monicDivide(a,b,v) divides the polynomial a by the polynomial b,
+      ++ with each viewed as a univariate polynomial in v returning
+      ++ both the quotient and remainder.
+      ++ Error: if b is not monic with respect to v.
+    monomial : (%,VarSet,NonNegativeInteger) -> %
+      ++ monomial(a,x,n) creates the monomial \spad{a*x**n} where \spad{a} is
+      ++ a polynomial, x is a variable and n is a nonnegative integer.
+    monomial : (%,List VarSet,List NonNegativeInteger) -> %
+      ++ monomial(a,[v1..vn],[e1..en]) returns \spad{a*prod(vi**ei)}.
+    multivariate : (SparseUnivariatePolynomial(R),VarSet) -> %
+      ++ multivariate(sup,v) converts an anonymous univariable
+      ++ polynomial sup to a polynomial in the variable v.
+    multivariate : (SparseUnivariatePolynomial(%),VarSet) -> %
+      ++ multivariate(sup,v) converts an anonymous univariable
+      ++ polynomial sup to a polynomial in the variable v.
+    isPlus: % -> Union(List %, "failed")
+      ++ isPlus(p) returns \spad{[m1,...,mn]} if polynomial 
+      ++ \spad{p = m1 + ... + mn} and
+      ++ \spad{n >= 2} and each mi is a nonzero monomial.
+    isTimes: % -> Union(List %, "failed")
+      ++ isTimes(p) returns \spad{[a1,...,an]} if polynomial 
+      ++ \spad{p = a1 ... an} and \spad{n >= 2}, and, for each i, 
+      ++ ai is either a nontrivial constant in R or else of the
+      ++ form \spad{x**e}, where \spad{e > 0} is an integer 
+      ++ and x in a member of VarSet.
+    isExpt: % -> Union(Record(var:VarSet, exponent:NonNegativeInteger),_
+                       "failed")
+      ++ isExpt(p) returns \spad{[x, n]} if polynomial p has the 
+      ++ form \spad{x**n} and \spad{n > 0}.
+    totalDegree : % -> NonNegativeInteger
+      ++ totalDegree(p) returns the largest sum over all monomials
+      ++ of all exponents of a monomial.
+    totalDegree : (%,List VarSet) -> NonNegativeInteger
+      ++ totalDegree(p, lv) returns the maximum sum (over all monomials 
+      ++ of polynomial p) of the variables in the list lv.
+    variables : % -> List(VarSet)
+      ++ variables(p) returns the list of those variables actually
+      ++ appearing in the polynomial p.
+    primitiveMonomials: % -> List %
+      ++ primitiveMonomials(p) gives the list of monomials of the
+      ++ polynomial p with their coefficients removed. Note:
+      ++ \spad{primitiveMonomials(sum(a_(i) X^(i))) = [X^(1),...,X^(n)]}.
+    if R has OrderedSet  then OrderedSet
+    -- OrderedRing view removed to allow EXPR to define abs
+    --if R has OrderedRing then OrderedRing
+    if (R has ConvertibleTo InputForm) and
+       (VarSet has ConvertibleTo InputForm) then
+         ConvertibleTo InputForm
+    if (R has ConvertibleTo Pattern Integer) and
+       (VarSet has ConvertibleTo Pattern Integer) then
+         ConvertibleTo Pattern Integer
+    if (R has ConvertibleTo Pattern Float) and
+       (VarSet has ConvertibleTo Pattern Float) then
+         ConvertibleTo Pattern Float
+    if (R has PatternMatchable Integer) and
+       (VarSet has PatternMatchable Integer) then
+         PatternMatchable Integer
+    if (R has PatternMatchable Float) and
+       (VarSet has PatternMatchable Float) then
+         PatternMatchable Float
+    if R has CommutativeRing then
+      resultant : (%,%,VarSet) -> %
+         ++ resultant(p,q,v) returns the resultant of the polynomials
+         ++ p and q with respect to the variable v.
+      discriminant : (%,VarSet) -> %
+         ++ discriminant(p,v) returns the disriminant of the polynomial p
+         ++ with respect to the variable v.
+    if R has GcdDomain then
+      GcdDomain
+      content: (%,VarSet) -> %
+        ++ content(p,v) is the gcd of the coefficients of the polynomial p
+        ++ when p is viewed as a univariate polynomial with respect to the
+        ++ variable v.
+        ++ Thus, for polynomial 7*x**2*y + 14*x*y**2, the gcd of the
+        ++ coefficients with respect to x is 7*y.
+      primitivePart: % -> %
+        ++ primitivePart(p) returns the unitCanonical associate of the
+        ++ polynomial p with its content divided out.
+      primitivePart: (%,VarSet) -> %
+        ++ primitivePart(p,v) returns the unitCanonical associate of the
+        ++ polynomial p with its content with respect to the variable v
+        ++ divided out.
+      squareFree: % -> Factored %
+        ++ squareFree(p) returns the square free factorization of the
+        ++ polynomial p.
+      squareFreePart: % -> %
+        ++ squareFreePart(p) returns product of all the irreducible factors
+        ++ of polynomial p each taken with multiplicity one.
+
+    -- assertions
+    if R has canonicalUnitNormal then canonicalUnitNormal
+             ++ we can choose a unique representative for each
+             ++ associate class.
+             ++ This normalization is chosen to be normalization of
+             ++ leading coefficient (by default).
+    if R has PolynomialFactorizationExplicit then
+       PolynomialFactorizationExplicit
+ add
+    p:%
+    v:VarSet
+    ln:List NonNegativeInteger
+    lv:List VarSet
+    n:NonNegativeInteger
+    pp,qq:SparseUnivariatePolynomial %
+
+    eval(p:%, l:List Equation %) ==
+      empty? l => p
+      for e in l repeat
+        retractIfCan(lhs e)@Union(VarSet,"failed") case "failed" => 
+             error "cannot find a variable to evaluate"
+      lvar:=[retract(lhs e)@VarSet for e in l]
+      eval(p, lvar,[rhs e for e in l]$List(%))
+
+    monomials p ==
+--    zero? p => empty()
+--    concat(leadingMonomial p, monomials reductum p)
+--    replaced by sequential version for efficiency, by WMSIT, 7/30/90
+      ml:= empty$List(%)
+      while p ^= 0 repeat
+        ml:=concat(leadingMonomial p, ml)
+        p:= reductum p
+      reverse ml
+
+    isPlus p ==
+      empty? rest(l := monomials p) => "failed"
+      l
+
+    isTimes p ==
+      empty?(lv := variables p) or not monomial? p => "failed"
+      l := [monomial(1, v, degree(p, v)) for v in lv]
+--      one?(r := leadingCoefficient p) =>
+      ((r := leadingCoefficient p) = 1) =>
+        empty? rest lv => "failed"
+        l
+      concat(r::%, l)
+
+    isExpt p ==
+      (u := mainVariable p) case "failed" => "failed"
+      p = monomial(1, u::VarSet, d := degree(p, u::VarSet)) =>
+        [u::VarSet, d]
+      "failed"
+
+    coefficient(p,v,n) == coefficient(univariate(p,v),n)
+
+    coefficient(p,lv,ln) ==
+       empty? lv =>
+         empty? ln => p
+         error "mismatched lists in coefficient"
+       empty? ln  => error "mismatched lists in coefficient"
+       coefficient(coefficient(univariate(p,first lv),first ln),
+                   rest lv,rest ln)
+
+    monomial(p,lv,ln) ==
+       empty? lv =>
+         empty? ln => p
+         error "mismatched lists in monomial"
+       empty? ln  => error "mismatched lists in monomial"
+       monomial(monomial(p,first lv, first ln),rest lv, rest ln)
+
+    retract(p:%):VarSet ==
+      q := mainVariable(p)::VarSet
+      q::% = p => q
+      error "Polynomial is not a single variable"
+
+    retractIfCan(p:%):Union(VarSet, "failed") ==
+      ((q := mainVariable p) case VarSet) and (q::VarSet::% = p) => q
+      "failed"
+
+    mkPrim(p:%):% == monomial(1,degree p)
+
+    primitiveMonomials p == [mkPrim q for q in monomials p]
+
+    totalDegree p ==
+        ground? p => 0
+        u := univariate(p, mainVariable(p)::VarSet)
+        d: NonNegativeInteger := 0
+        while u ^= 0 repeat
+          d := max(d, degree u + totalDegree leadingCoefficient u)
+          u := reductum u
+        d
+
+    totalDegree(p,lv) ==
+        ground? p => 0
+        u := univariate(p, v:=(mainVariable(p)::VarSet))
+        d: NonNegativeInteger := 0
+        w: NonNegativeInteger := 0
+        if member?(v, lv) then w:=1
+        while u ^= 0 repeat
+          d := max(d, w*(degree u) + totalDegree(leadingCoefficient u,lv))
+          u := reductum u
+        d
+
+    if R has CommutativeRing then
+        resultant(p1,p2,mvar) ==
+          resultant(univariate(p1,mvar),univariate(p2,mvar))
+
+        discriminant(p,var) ==
+          discriminant(univariate(p,var))
+
+    if R has IntegralDomain then
+      allMonoms(l:List %):List(%) ==
+        removeDuplicates_! concat [primitiveMonomials p for p in l]
+
+      P2R(p:%, b:List E, n:NonNegativeInteger):Vector(R) ==
+        w := new(n, 0)$Vector(R)
+        for i in minIndex w .. maxIndex w for bj in b repeat
+          qsetelt_!(w, i, coefficient(p, bj))
+        w
+
+      eq2R(l:List %, b:List E):Matrix(R) ==
+        matrix [[coefficient(p, bj) for p in l] for bj in b]
+
+      reducedSystem(m:Matrix %):Matrix(R) ==
+        l := listOfLists m
+        b := removeDuplicates_!
+                           concat [allMonoms r for r in l]$List(List(%))
+        d := [degree bj for bj in b]
+        mm := eq2R(first l, d)
+        l := rest l
+        while not empty? l repeat
+          mm := vertConcat(mm, eq2R(first l, d))
+          l := rest l
+        mm
+
+      reducedSystem(m:Matrix %, v:Vector %):
+       Record(mat:Matrix R, vec:Vector R) ==
+        l := listOfLists m
+        r := entries v
+        b : List % := removeDuplicates_! concat(allMonoms r,
+                          concat [allMonoms s for s in l]$List(List(%)))
+        d := [degree bj for bj in b]
+        n := #d
+        mm := eq2R(first l, d)
+        w := P2R(first r, d, n)
+        l := rest l
+        r := rest r
+        while not empty? l repeat
+          mm := vertConcat(mm, eq2R(first l, d))
+          w := concat(w, P2R(first r, d, n))
+          l := rest l
+          r := rest r
+        [mm, w]
+
+    if R has PolynomialFactorizationExplicit then
+       -- we might be in trouble if its actually only
+       -- a univariate polynomial category - have to remember to
+       -- over-ride these in UnivariatePolynomialCategory
+
+       PFBR ==>PolynomialFactorizationByRecursion(R,E,VarSet,%)
+
+       gcdPolynomial(pp,qq) ==
+          gcdPolynomial(pp,qq)$GeneralPolynomialGcdPackage(E,VarSet,R,%)
+
+       solveLinearPolynomialEquation(lpp,pp) ==
+         solveLinearPolynomialEquationByRecursion(lpp,pp)$PFBR
+
+       factorPolynomial(pp) ==
+         factorByRecursion(pp)$PFBR
+
+       factorSquareFreePolynomial(pp) ==
+         factorSquareFreeByRecursion(pp)$PFBR
+
+       factor p ==
+         v:Union(VarSet,"failed"):=mainVariable p
+         v case "failed" =>
+           ansR:=factor leadingCoefficient p
+           makeFR(unit(ansR)::%,
+                  [[w.flg,w.fctr::%,w.xpnt] for w in factorList ansR])
+         up:SparseUnivariatePolynomial %:=univariate(p,v)
+         ansSUP:=factorByRecursion(up)$PFBR
+         makeFR(multivariate(unit(ansSUP),v),
+                [[ww.flg,multivariate(ww.fctr,v),ww.xpnt]
+                 for ww in factorList ansSUP])
+       if R has CharacteristicNonZero then
+          mat: Matrix %
+
+          conditionP mat ==
+            ll:=listOfLists transpose mat  --hence each list corresponds to a
+                                           --column, i.e. to one variable
+            llR:List List R := [ empty() for z in first ll]
+            monslist:List List % := empty()
+            ch:=characteristic()$%
+            for l in ll repeat
+                mons:= "setUnion"/[primitiveMonomials u for u in l]
+                redmons:List % :=[]
+                for m in mons repeat
+                    vars:=variables m
+                    degs:=degree(m,vars)
+                    deg1:List NonNegativeInteger
+                    deg1:=[ ((nd:=d:Integer exquo ch:Integer)
+                               case "failed" => return "failed" ;
+                                nd::Integer::NonNegativeInteger)
+                           for d in degs ]
+                    redmons:=[monomial(1,vars,deg1),:redmons]
+                    llR:=[[ground coefficient(u,vars,degs),:v]_
+                            for u in l for v in llR]
+                monslist:=[redmons,:monslist]
+            ans:=conditionP transpose matrix llR
+            ans case "failed" => "failed"
+            i:NonNegativeInteger:=0
+            [ +/[m*(ans.(i:=i+1))::% for m in mons ]
+              for mons in monslist]
+
+    if R has CharacteristicNonZero then
+          charthRootlv:(%,List VarSet,NonNegativeInteger) ->_
+                                                      Union(%,"failed")
+          charthRoot p ==
+            vars:= variables p
+            empty? vars =>
+              ans := charthRoot ground p
+              ans case "failed" => "failed"
+              ans::R::%
+            ch:=characteristic()$%
+            charthRootlv(p,vars,ch)
+
+          charthRootlv(p,vars,ch) ==
+            empty? vars =>
+              ans := charthRoot ground p
+              ans case "failed" => "failed"
+              ans::R::%
+            v:=first vars
+            vars:=rest vars
+            d:=degree(p,v)
+            ans:% := 0
+            while (d>0) repeat
+               (dd:=(d::Integer exquo ch::Integer)) case "failed" =>
+                      return "failed"
+               cp:=coefficient(p,v,d)
+               p:=p-monomial(cp,v,d)
+               ansx:=charthRootlv(cp,vars,ch)
+               ansx case "failed" => return "failed"
+               d:=degree(p,v)
+               ans:=ans+monomial(ansx,v,dd::Integer::NonNegativeInteger)
+            ansx:=charthRootlv(p,vars,ch)
+            ansx case "failed" => return "failed"
+            return ans+ansx
+
+    monicDivide(p1,p2,mvar) ==
+       result:=monicDivide(univariate(p1,mvar),univariate(p2,mvar))
+       [multivariate(result.quotient,mvar),
+        multivariate(result.remainder,mvar)]
+
+    if R has GcdDomain then
+      if R has EuclideanDomain and R has CharacteristicZero then
+       squareFree p == squareFree(p)$MultivariateSquareFree(E,VarSet,R,%)
+      else
+        squareFree p == squareFree(p)$PolynomialSquareFree(VarSet,E,R,%)
+
+      squareFreePart p ==
+        unit(s := squareFree p) * */[f.factor for f in factors s]
+
+      content(p,v) == content univariate(p,v)
+
+      primitivePart p ==
+        zero? p => p
+        unitNormal((p exquo content p) ::%).canonical
+
+      primitivePart(p,v) ==
+        zero? p => p
+        unitNormal((p exquo content(p,v)) ::%).canonical
+
+    if R has OrderedSet then
+      p:% < q:% ==
+        (dp:= degree p) < (dq := degree q) => (leadingCoefficient q) > 0
+        dq < dp => (leadingCoefficient p) < 0
+        leadingCoefficient(p - q) < 0
+
+      if (R has PatternMatchable Integer) and
+         (VarSet has PatternMatchable Integer) then
+           patternMatch(p:%, pat:Pattern Integer,
+            l:PatternMatchResult(Integer, %)) ==
+              patternMatch(p, pat,
+                l)$PatternMatchPolynomialCategory(Integer,E,VarSet,R,%)
+
+      if (R has PatternMatchable Float) and
+         (VarSet has PatternMatchable Float) then
+           patternMatch(p:%, pat:Pattern Float,
+            l:PatternMatchResult(Float, %)) ==
+              patternMatch(p, pat,
+                l)$PatternMatchPolynomialCategory(Float,E,VarSet,R,%)
+
+    if (R has ConvertibleTo Pattern Integer) and
+       (VarSet has ConvertibleTo Pattern Integer) then
+         convert(x:%):Pattern(Integer) ==
+           map(convert, convert,
+              x)$PolynomialCategoryLifting(E,VarSet,R,%,Pattern Integer)
+
+    if (R has ConvertibleTo Pattern Float) and
+       (VarSet has ConvertibleTo Pattern Float) then
+         convert(x:%):Pattern(Float) ==
+           map(convert, convert,
+            x)$PolynomialCategoryLifting(E, VarSet, R, %, Pattern Float)
+
+    if (R has ConvertibleTo InputForm) and
+       (VarSet has ConvertibleTo InputForm) then
+         convert(p:%):InputForm ==
+           map(convert, convert,
+                    p)$PolynomialCategoryLifting(E,VarSet,R,%,InputForm)
+
+@
+<<POLYCAT.dotabb>>=
+"POLYCAT"
+ [color=lightblue,href="bookvol10.2.pdf#nameddest=POLYCAT"];
+"POLYCAT" -> "PDRING"
+"POLYCAT" -> "FAMR"
+"POLYCAT" -> "EVALAB"
+"POLYCAT" -> "IEVALAB"
+"POLYCAT" -> "RETRACT"
+"POLYCAT" -> "FLINEXP"
+"POLYCAT" -> "ORDSET"
+"POLYCAT" -> "GCDDOM"
+"POLYCAT" -> "PFECAT"
+"POLYCAT" -> "KONVERT"
+"POLYCAT" -> "PATMAB"
+"POLYCAT" -> "COMRING"
+
+@
+<<POLYCAT.dotfull>>=
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+ [color=lightblue,href="bookvol10.2.pdf#nameddest=POLYCAT"];
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "PartialDifferentialRing(a:OrderedSet)"
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "FiniteAbelianMonoidRing(a:Ring,b:OrderedAbelianMonoidSup)"
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "Evalable(PolynomialCategory(...))"
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "InnerEvalable(a:OrderedSet,b:Ring)"
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "InnerEvalable(a:OrderedSet,b:PolynomialCategory(...))"
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "RetractableTo(a:OrderedSet)"
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "FullyLinearlyExplicitRingOver(a:Ring)"
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "OrderedSet()"
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "GcdDomain()"
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "PolynomialFactorizationExplicit()"
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "ConvertibleTo(InputForm)"
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "PatternMatchable(Pattern(Integer))"
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "PatternMatchable(Pattern(Float))"
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "CommutativeRing()"
+
+@
+<<POLYCAT.dotpic>>=
+digraph pic {
+ fontsize=10;
+ bgcolor="#FFFF66";
+ node [shape=box, color=white, style=filled];
+
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+ [color=lightblue,href="bookvol10.2.pdf#nameddest=POLYCAT"];
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "PDRING..."
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "FAMR..."
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "EVALAB..."
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "IEVALAB..."
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "RETRACT..."
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "FLINEXP..."
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "ORDSET..."
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "GCDDOM..."
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "PFECAT..."
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "KONVERT..."
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "PATMAB..."
+"PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)"
+  -> "COMRING..."
+
+"PDRING..." [color=lightblue];
+"FAMR..." [color=lightblue];
+"EVALAB..." [color=lightblue];
+"IEVALAB..." [color=lightblue];
+"RETRACT..." [color=lightblue];
+"FLINEXP..." [color=lightblue];
+"ORDSET..." [color=lightblue];
+"GCDDOM..." [color=lightblue];
+"PFECAT..." [color=lightblue];
+"KONVERT..." [color=lightblue];
+"PATMAB..." [color=lightblue];
+"COMRING..." [color=lightblue];
+
+}
+
+@
 \chapter{Category Layer 17}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \pagehead{FieldOfPrimeCharacteristic}{FPC}
@@ -31124,6 +32106,1668 @@ Note that this code is not included in the generated catdef.spad file.
                1 6 0 0 18 1 0 16 0 17 1 0 8 0 10 1 0 8 0 11 1 0 0 0 19))))))
    (QUOTE |lookupComplete|))) 
 @
+\section{POLYCAT.lsp BOOTSTRAP}
+{\bf POLYCAT} depends on itself. We need to break this cycle to build
+the algebra. So we keep a cached copy of the translated {\bf POLYCAT}
+category which we can write into the {\bf MID} directory. We compile 
+the lisp code and copy the {\bf POLYCAT.o} file to the {\bf OUT} directory.
+This is eventually forcibly replaced by a recompiled version. 
+
+Note that this code is not included in the generated catdef.spad file.
+
+<<POLYCAT.lsp BOOTSTRAP>>=
+
+(/VERSIONCHECK 2) 
+
+(SETQ |PolynomialCategory;CAT| (QUOTE NIL)) 
+
+(SETQ |PolynomialCategory;AL| (QUOTE NIL)) 
+
+(DEFUN |PolynomialCategory| (&REST #0=#:G1430 &AUX #1=#:G1428)
+ (DSETQ #1# #0#)
+ (LET (#2=#:G1429)
+  (COND
+   ((SETQ #2# (|assoc| (|devaluateList| #1#) |PolynomialCategory;AL|))
+     (CDR #2#))
+   (T
+     (SETQ |PolynomialCategory;AL|
+      (|cons5|
+       (CONS (|devaluateList| #1#)
+        (SETQ #2# (APPLY (FUNCTION |PolynomialCategory;|) #1#)))
+       |PolynomialCategory;AL|))
+     #2#)))) 
+
+(DEFUN |PolynomialCategory;| (|t#1| |t#2| |t#3|)
+ (PROG (#0=#:G1427)
+  (RETURN
+   (PROG1 
+    (LETT #0#
+     (|sublisV|
+      (PAIR (QUOTE (|t#1| |t#2| |t#3|)) (LIST (|devaluate| |t#1|) (|devaluate| |t#2|) (|devaluate| |t#3|)))
+      (COND
+       (|PolynomialCategory;CAT|)
+       ((QUOTE T)
+        (LETT |PolynomialCategory;CAT|
+         (|Join|
+          (|PartialDifferentialRing| (QUOTE |t#3|))
+          (|FiniteAbelianMonoidRing| (QUOTE |t#1|) (QUOTE |t#2|))
+          (|Evalable| (QUOTE $))
+          (|InnerEvalable| (QUOTE |t#3|) (QUOTE |t#1|))
+          (|InnerEvalable| (QUOTE |t#3|) (QUOTE $))
+          (|RetractableTo| (QUOTE |t#3|))
+          (|FullyLinearlyExplicitRingOver| (QUOTE |t#1|))
+          (|mkCategory| (QUOTE |domain|)
+           (QUOTE
+            (((|degree| ((|NonNegativeInteger|) $ |t#3|)) T)
+             ((|degree| ((|List| (|NonNegativeInteger|)) $ (|List| |t#3|))) T)
+             ((|coefficient| ($ $ |t#3| (|NonNegativeInteger|))) T)
+             ((|coefficient| ($ $ (|List| |t#3|)
+               (|List| (|NonNegativeInteger|)))) T)
+             ((|monomials| ((|List| $) $)) T)
+             ((|univariate| ((|SparseUnivariatePolynomial| $) $ |t#3|)) T)
+             ((|univariate| ((|SparseUnivariatePolynomial| |t#1|) $)) T)
+             ((|mainVariable| ((|Union| |t#3| "failed") $)) T)
+             ((|minimumDegree| ((|NonNegativeInteger|) $ |t#3|)) T)
+             ((|minimumDegree| ((|List| (|NonNegativeInteger|)) $
+               (|List| |t#3|))) T)
+             ((|monicDivide|
+               ((|Record| (|:| |quotient| $) (|:| |remainder| $)) $ $ |t#3|))
+               T)
+             ((|monomial| ($ $ |t#3| (|NonNegativeInteger|))) T)
+             ((|monomial| ($ $ (|List| |t#3|) (|List| (|NonNegativeInteger|))))
+               T)
+             ((|multivariate| ($ (|SparseUnivariatePolynomial| |t#1|) |t#3|))
+               T)
+             ((|multivariate| ($ (|SparseUnivariatePolynomial| $) |t#3|)) T)
+             ((|isPlus| ((|Union| (|List| $) "failed") $)) T)
+             ((|isTimes| ((|Union| (|List| $) "failed") $)) T)
+             ((|isExpt|
+               ((|Union| 
+                (|Record| (|:| |var| |t#3|) 
+                          (|:| |exponent| (|NonNegativeInteger|)))
+                "failed") $))
+               T)
+             ((|totalDegree| ((|NonNegativeInteger|) $)) T)
+             ((|totalDegree| ((|NonNegativeInteger|) $ (|List| |t#3|))) T)
+             ((|variables| ((|List| |t#3|) $)) T)
+             ((|primitiveMonomials| ((|List| $) $)) T)
+             ((|resultant| ($ $ $ |t#3|)) (|has| |t#1| (|CommutativeRing|)))
+             ((|discriminant| ($ $ |t#3|)) (|has| |t#1| (|CommutativeRing|)))
+             ((|content| ($ $ |t#3|)) (|has| |t#1| (|GcdDomain|)))
+             ((|primitivePart| ($ $)) (|has| |t#1| (|GcdDomain|)))
+             ((|primitivePart| ($ $ |t#3|)) (|has| |t#1| (|GcdDomain|)))
+             ((|squareFree| ((|Factored| $) $)) (|has| |t#1| (|GcdDomain|)))
+             ((|squareFreePart| ($ $)) (|has| |t#1| (|GcdDomain|)))))
+           (QUOTE
+            (((|OrderedSet|) (|has| |t#1| (|OrderedSet|)))
+             ((|ConvertibleTo| (|InputForm|))
+              (AND (|has| |t#3| (|ConvertibleTo| (|InputForm|)))
+                   (|has| |t#1| (|ConvertibleTo| (|InputForm|)))))
+             ((|ConvertibleTo| (|Pattern| (|Integer|)))
+              (AND (|has| |t#3| (|ConvertibleTo| (|Pattern| (|Integer|))))
+                   (|has| |t#1| (|ConvertibleTo| (|Pattern| (|Integer|))))))
+             ((|ConvertibleTo| (|Pattern| (|Float|)))
+              (AND (|has| |t#3| (|ConvertibleTo| (|Pattern| (|Float|))))
+                   (|has| |t#1| (|ConvertibleTo| (|Pattern| (|Float|))))))
+             ((|PatternMatchable| (|Integer|))
+              (AND
+               (|has| |t#3| (|PatternMatchable| (|Integer|)))
+               (|has| |t#1| (|PatternMatchable| (|Integer|)))))
+             ((|PatternMatchable| (|Float|))
+              (AND
+               (|has| |t#3| (|PatternMatchable| (|Float|)))
+               (|has| |t#1| (|PatternMatchable| (|Float|)))))
+             ((|GcdDomain|) (|has| |t#1| (|GcdDomain|)))
+             (|canonicalUnitNormal|
+               (|has| |t#1| (ATTRIBUTE |canonicalUnitNormal|)))
+             ((|PolynomialFactorizationExplicit|)
+               (|has| |t#1| (|PolynomialFactorizationExplicit|)))))
+           (QUOTE
+            ((|Factored| $)
+             (|List| $)
+             (|List| |t#3|)
+             (|NonNegativeInteger|)
+             (|SparseUnivariatePolynomial| $)
+             (|SparseUnivariatePolynomial| |t#1|)
+             (|List| (|NonNegativeInteger|))))
+            NIL))
+          . #1=(|PolynomialCategory|)))))
+      . #1#)
+    (SETELT #0# 0
+     (LIST (QUOTE |PolynomialCategory|)
+      (|devaluate| |t#1|) (|devaluate| |t#2|) (|devaluate| |t#3|))))))) 
+
+@
+\section{POLYCAT-.lsp BOOTSTRAP}
+{\bf POLYCAT-} depends on {\bf POLYCAT}. We need to break this cycle to build
+the algebra. So we keep a cached copy of the translated {\bf POLYCAT-}
+category which we can write into the {\bf MID} directory. We compile 
+the lisp code and copy the {\bf POLYCAT-.o} file to the {\bf OUT} directory.
+This is eventually forcibly replaced by a recompiled version. 
+
+Note that this code is not included in the generated catdef.spad file.
+
+<<POLYCAT-.lsp BOOTSTRAP>>=
+
+(|/VERSIONCHECK| 2) 
+
+
+(/VERSIONCHECK 2) 
+
+(DEFUN |POLYCAT-;eval;SLS;1| (|p| |l| $)
+ (PROG (#0=#:G1444 #1=#:G1438 #2=#:G1445 #3=#:G1446 |lvar| #4=#:G1447 
+        |e| #5=#:G1448)
+  (RETURN 
+   (SEQ
+    (COND
+     ((NULL |l|) |p|)
+     ((QUOTE T)
+      (SEQ
+       (SEQ
+        (EXIT
+         (SEQ
+          (LETT |e| NIL |POLYCAT-;eval;SLS;1|)
+          (LETT #0# |l| |POLYCAT-;eval;SLS;1|)
+          G190
+          (COND
+           ((OR (ATOM #0#)
+                (PROGN (LETT |e| (CAR #0#) |POLYCAT-;eval;SLS;1|) NIL))
+            (GO G191)))
+          (SEQ 
+           (EXIT
+            (COND
+             ((QEQCAR
+               (SPADCALL (SPADCALL |e| (QREFELT $ 11)) (QREFELT $ 13)) 1)
+              (PROGN
+               (LETT #1# 
+                (|error| "cannot find a variable to evaluate")
+                |POLYCAT-;eval;SLS;1|)
+               (GO #1#))))))
+          (LETT #0# (CDR #0#) |POLYCAT-;eval;SLS;1|)
+          (GO G190)
+          G191
+          (EXIT NIL)))
+        #1# (EXIT #1#))
+       (LETT |lvar|
+        (PROGN
+         (LETT #2# NIL |POLYCAT-;eval;SLS;1|)
+         (SEQ
+          (LETT |e| NIL |POLYCAT-;eval;SLS;1|)
+          (LETT #3# |l| |POLYCAT-;eval;SLS;1|)
+          G190
+          (COND
+           ((OR (ATOM #3#)
+                (PROGN (LETT |e| (CAR #3#) |POLYCAT-;eval;SLS;1|) NIL))
+            (GO G191)))
+          (SEQ
+           (EXIT
+            (LETT #2#
+             (CONS (SPADCALL (SPADCALL |e| (QREFELT $ 11)) (QREFELT $ 14))
+                   #2#)
+             |POLYCAT-;eval;SLS;1|)))
+          (LETT #3# (CDR #3#) |POLYCAT-;eval;SLS;1|)
+          (GO G190)
+          G191
+          (EXIT (NREVERSE0 #2#))))
+         |POLYCAT-;eval;SLS;1|)
+       (EXIT
+        (SPADCALL |p| |lvar|
+         (PROGN
+          (LETT #4# NIL |POLYCAT-;eval;SLS;1|)
+          (SEQ
+           (LETT |e| NIL |POLYCAT-;eval;SLS;1|)
+           (LETT #5# |l| |POLYCAT-;eval;SLS;1|)
+           G190
+           (COND 
+            ((OR (ATOM #5#)
+                 (PROGN (LETT |e| (CAR #5#) |POLYCAT-;eval;SLS;1|) NIL))
+              (GO G191)))
+           (SEQ 
+            (EXIT
+             (LETT #4# (CONS (SPADCALL |e| (QREFELT $ 15)) #4#)
+              |POLYCAT-;eval;SLS;1|)))
+           (LETT #5# (CDR #5#) |POLYCAT-;eval;SLS;1|)
+           (GO G190)
+           G191
+           (EXIT (NREVERSE0 #4#))))
+         (QREFELT $ 18)))))))))) 
+
+(DEFUN |POLYCAT-;monomials;SL;2| (|p| $)
+ (PROG (|ml|)
+  (RETURN
+   (SEQ
+    (LETT |ml| NIL |POLYCAT-;monomials;SL;2|)
+    (SEQ G190
+     (COND
+      ((NULL 
+        (COND
+         ((SPADCALL |p| (|spadConstant| $ 21) (QREFELT $ 24)) (QUOTE NIL))
+         ((QUOTE T) (QUOTE T))))
+       (GO G191)))
+     (SEQ
+      (LETT |ml|
+       (CONS (SPADCALL |p| (QREFELT $ 25)) |ml|)
+       |POLYCAT-;monomials;SL;2|)
+      (EXIT
+       (LETT |p| (SPADCALL |p| (QREFELT $ 26)) |POLYCAT-;monomials;SL;2|)))
+      NIL
+     (GO G190)
+     G191
+     (EXIT NIL))
+    (EXIT (REVERSE |ml|)))))) 
+
+(DEFUN |POLYCAT-;isPlus;SU;3| (|p| $)
+ (PROG (|l|)
+  (RETURN
+   (COND
+    ((NULL 
+       (CDR (LETT |l| (SPADCALL |p| (QREFELT $ 28)) |POLYCAT-;isPlus;SU;3|)))
+      (CONS 1 "failed"))
+    ((QUOTE T) (CONS 0 |l|)))))) 
+
+(DEFUN |POLYCAT-;isTimes;SU;4| (|p| $)
+ (PROG (|lv| #0=#:G1470 |v| #1=#:G1471 |l| |r|)
+  (RETURN
+   (SEQ
+    (COND
+     ((OR (NULL 
+           (LETT |lv| (SPADCALL |p| (QREFELT $ 31)) |POLYCAT-;isTimes;SU;4|))
+          (NULL (SPADCALL |p| (QREFELT $ 32))))
+       (CONS 1 "failed"))
+     ((QUOTE T)
+      (SEQ
+       (LETT |l|
+        (PROGN
+         (LETT #0# NIL |POLYCAT-;isTimes;SU;4|)
+         (SEQ
+          (LETT |v| NIL |POLYCAT-;isTimes;SU;4|)
+          (LETT #1# |lv| |POLYCAT-;isTimes;SU;4|)
+          G190
+          (COND
+           ((OR (ATOM #1#) 
+                (PROGN (LETT |v| (CAR #1#) |POLYCAT-;isTimes;SU;4|) NIL))
+            (GO G191)))
+          (SEQ 
+           (EXIT
+            (LETT #0#
+             (CONS
+              (SPADCALL (|spadConstant| $ 33) |v|
+               (SPADCALL |p| |v| (QREFELT $ 36)) (QREFELT $ 37))
+              #0#)
+              |POLYCAT-;isTimes;SU;4|)))
+          (LETT #1# (CDR #1#) |POLYCAT-;isTimes;SU;4|)
+          (GO G190)
+          G191
+         (EXIT (NREVERSE0 #0#))))
+        |POLYCAT-;isTimes;SU;4|)
+       (LETT |r| (SPADCALL |p| (QREFELT $ 38)) |POLYCAT-;isTimes;SU;4|)
+       (EXIT
+        (COND
+         ((SPADCALL |r| (|spadConstant| $ 34) (QREFELT $ 39))
+           (COND
+            ((NULL (CDR |lv|)) (CONS 1 "failed"))
+            ((QUOTE T) (CONS 0 |l|))))
+         ((QUOTE T)
+           (CONS 0 (CONS (SPADCALL |r| (QREFELT $ 40)) |l|)))))))))))) 
+
+(DEFUN |POLYCAT-;isExpt;SU;5| (|p| $)
+ (PROG (|u| |d|)
+  (RETURN
+   (SEQ
+    (LETT |u| (SPADCALL |p| (QREFELT $ 42)) |POLYCAT-;isExpt;SU;5|)
+    (EXIT 
+     (COND
+      ((OR (QEQCAR |u| 1)
+           (NULL
+            (SPADCALL |p|
+             (SPADCALL (|spadConstant| $ 33)
+              (QCDR |u|)
+              (LETT |d| (SPADCALL |p| (QCDR |u|) (QREFELT $ 36))
+               |POLYCAT-;isExpt;SU;5|)
+              (QREFELT $ 37))
+             (QREFELT $ 24))))
+       (CONS 1 "failed"))
+      ((QUOTE T) (CONS 0 (CONS (QCDR |u|) |d|))))))))) 
+
+(DEFUN |POLYCAT-;coefficient;SVarSetNniS;6| (|p| |v| |n| $)
+ (SPADCALL (SPADCALL |p| |v| (QREFELT $ 47)) |n| (QREFELT $ 49))) 
+
+(DEFUN |POLYCAT-;coefficient;SLLS;7| (|p| |lv| |ln| $)
+ (COND
+  ((NULL |lv|)
+   (COND
+    ((NULL |ln|) |p|)
+    ((QUOTE T) (|error| "mismatched lists in coefficient"))))
+  ((NULL |ln|) (|error| "mismatched lists in coefficient"))
+  ((QUOTE T)
+   (SPADCALL
+    (SPADCALL
+     (SPADCALL |p| (|SPADfirst| |lv|) (QREFELT $ 47))
+     (|SPADfirst| |ln|)
+     (QREFELT $ 49))
+    (CDR |lv|)
+    (CDR |ln|)
+    (QREFELT $ 52))))) 
+
+(DEFUN |POLYCAT-;monomial;SLLS;8| (|p| |lv| |ln| $)
+ (COND
+  ((NULL |lv|) 
+   (COND
+    ((NULL |ln|) |p|)
+    ((QUOTE T) (|error| "mismatched lists in monomial"))))
+  ((NULL |ln|) (|error| "mismatched lists in monomial"))
+  ((QUOTE T)
+   (SPADCALL 
+    (SPADCALL |p| (|SPADfirst| |lv|) (|SPADfirst| |ln|) (QREFELT $ 37))
+    (CDR |lv|)
+    (CDR |ln|)
+    (QREFELT $ 54))))) 
+
+(DEFUN |POLYCAT-;retract;SVarSet;9| (|p| $)
+ (PROG (#0=#:G1496 |q|)
+  (RETURN
+   (SEQ
+    (LETT |q|
+     (PROG2
+      (LETT #0# (SPADCALL |p| (QREFELT $ 42)) |POLYCAT-;retract;SVarSet;9|)
+      (QCDR #0#)
+      (|check-union| (QEQCAR #0# 0) (QREFELT $ 9) #0#))
+     |POLYCAT-;retract;SVarSet;9|)
+    (EXIT
+     (COND
+      ((SPADCALL (SPADCALL |q| (QREFELT $ 56)) |p| (QREFELT $ 24)) |q|)
+      ((QUOTE T) (|error| "Polynomial is not a single variable")))))))) 
+
+(DEFUN |POLYCAT-;retractIfCan;SU;10| (|p| $) 
+ (PROG (|q| #0=#:G1504) 
+  (RETURN 
+   (SEQ 
+    (EXIT
+     (SEQ
+      (SEQ
+       (LETT |q| (SPADCALL |p| (QREFELT $ 42)) |POLYCAT-;retractIfCan;SU;10|)
+       (EXIT
+        (COND
+         ((QEQCAR |q| 0)
+          (COND
+           ((SPADCALL (SPADCALL (QCDR |q|) (QREFELT $ 56)) |p| (QREFELT $ 24))
+             (PROGN
+              (LETT #0# |q| |POLYCAT-;retractIfCan;SU;10|)
+              (GO #0#))))))))
+      (EXIT (CONS 1 "failed"))))
+     #0#
+     (EXIT #0#))))) 
+
+(DEFUN |POLYCAT-;mkPrim| (|p| $)
+ (SPADCALL
+  (|spadConstant| $ 34)
+  (SPADCALL |p| (QREFELT $ 59))
+  (QREFELT $ 60))) 
+
+(DEFUN |POLYCAT-;primitiveMonomials;SL;12| (|p| $)
+ (PROG (#0=#:G1509 |q| #1=#:G1510)
+  (RETURN
+   (SEQ
+    (PROGN
+     (LETT #0# NIL |POLYCAT-;primitiveMonomials;SL;12|)
+     (SEQ
+      (LETT |q| NIL |POLYCAT-;primitiveMonomials;SL;12|)
+      (LETT #1# (SPADCALL |p| (QREFELT $ 28)) |POLYCAT-;primitiveMonomials;SL;12|)
+      G190
+      (COND
+       ((OR (ATOM #1#)
+            (PROGN
+             (LETT |q| (CAR #1#) |POLYCAT-;primitiveMonomials;SL;12|)
+             NIL))
+        (GO G191)))
+      (SEQ 
+       (EXIT
+        (LETT #0# (CONS (|POLYCAT-;mkPrim| |q| $) #0#)
+         |POLYCAT-;primitiveMonomials;SL;12|)))
+      (LETT #1# (CDR #1#) |POLYCAT-;primitiveMonomials;SL;12|)
+      (GO G190)
+      G191
+      (EXIT (NREVERSE0 #0#)))))))) 
+
+(DEFUN |POLYCAT-;totalDegree;SNni;13| (|p| $)
+ (PROG (#0=#:G1512 |d| |u|)
+  (RETURN
+   (SEQ
+    (COND
+     ((SPADCALL |p| (QREFELT $ 62)) 0)
+     ((QUOTE T)
+      (SEQ
+       (LETT |u|
+        (SPADCALL |p|
+         (PROG2
+          (LETT #0#
+           (SPADCALL |p| (QREFELT $ 42))
+           |POLYCAT-;totalDegree;SNni;13|)
+          (QCDR #0#)
+          (|check-union| (QEQCAR #0# 0) (QREFELT $ 9) #0#))
+         (QREFELT $ 47))
+        |POLYCAT-;totalDegree;SNni;13|)
+       (LETT |d| 0 |POLYCAT-;totalDegree;SNni;13|)
+       (SEQ G190 
+        (COND
+         ((NULL
+          (COND
+           ((SPADCALL |u| (|spadConstant| $ 63) (QREFELT $ 64)) (QUOTE NIL))
+           ((QUOTE T) (QUOTE T)))) (GO G191)))
+        (SEQ
+         (LETT |d|
+          (MAX |d| 
+           (+
+            (SPADCALL |u| (QREFELT $ 65))
+            (SPADCALL (SPADCALL |u| (QREFELT $ 66)) (QREFELT $ 67))))
+          |POLYCAT-;totalDegree;SNni;13|)
+         (EXIT
+          (LETT |u|
+           (SPADCALL |u| (QREFELT $ 68)) |POLYCAT-;totalDegree;SNni;13|)))
+        NIL
+        (GO G190)
+        G191
+        (EXIT NIL))
+       (EXIT |d|)))))))) 
+
+(DEFUN |POLYCAT-;totalDegree;SLNni;14| (|p| |lv| $)
+ (PROG (#0=#:G1520 |v| |w| |d| |u|)
+  (RETURN
+   (SEQ
+    (COND
+     ((SPADCALL |p| (QREFELT $ 62)) 0)
+     ((QUOTE T)
+      (SEQ
+       (LETT |u|
+        (SPADCALL |p|
+         (LETT |v|
+          (PROG2
+           (LETT #0# 
+            (SPADCALL |p| (QREFELT $ 42))
+            |POLYCAT-;totalDegree;SLNni;14|)
+           (QCDR #0#)
+           (|check-union| (QEQCAR #0# 0) (QREFELT $ 9) #0#))
+          |POLYCAT-;totalDegree;SLNni;14|)
+         (QREFELT $ 47))
+        |POLYCAT-;totalDegree;SLNni;14|)
+       (LETT |d| 0 |POLYCAT-;totalDegree;SLNni;14|)
+       (LETT |w| 0 |POLYCAT-;totalDegree;SLNni;14|)
+       (COND
+        ((SPADCALL |v| |lv| (QREFELT $ 70))
+          (LETT |w| 1 |POLYCAT-;totalDegree;SLNni;14|)))
+       (SEQ G190
+        (COND
+         ((NULL
+          (COND
+           ((SPADCALL |u| (|spadConstant| $ 63) (QREFELT $ 64)) (QUOTE NIL))
+           ((QUOTE T) (QUOTE T)))) (GO G191)))
+        (SEQ
+         (LETT |d|
+          (MAX |d| 
+           (+ 
+            (* |w| (SPADCALL |u| (QREFELT $ 65)))
+            (SPADCALL (SPADCALL |u| (QREFELT $ 66)) |lv| (QREFELT $ 71))))
+          |POLYCAT-;totalDegree;SLNni;14|)
+         (EXIT
+          (LETT |u|
+           (SPADCALL |u| (QREFELT $ 68))
+           |POLYCAT-;totalDegree;SLNni;14|)))
+         NIL 
+         (GO G190) 
+         G191 
+         (EXIT NIL))
+       (EXIT |d|)))))))) 
+
+(DEFUN |POLYCAT-;resultant;2SVarSetS;15| (|p1| |p2| |mvar| $)
+ (SPADCALL
+  (SPADCALL |p1| |mvar| (QREFELT $ 47))
+  (SPADCALL |p2| |mvar| (QREFELT $ 47))
+  (QREFELT $ 73))) 
+
+(DEFUN |POLYCAT-;discriminant;SVarSetS;16| (|p| |var| $)
+ (SPADCALL (SPADCALL |p| |var| (QREFELT $ 47)) (QREFELT $ 75))) 
+
+(DEFUN |POLYCAT-;allMonoms| (|l| $)
+ (PROG (#0=#:G1532 |p| #1=#:G1533)
+  (RETURN
+   (SEQ
+    (SPADCALL
+     (SPADCALL
+      (PROGN
+       (LETT #0# NIL |POLYCAT-;allMonoms|)
+       (SEQ
+        (LETT |p| NIL |POLYCAT-;allMonoms|)
+        (LETT #1# |l| |POLYCAT-;allMonoms|)
+        G190
+        (COND
+         ((OR (ATOM #1#) (PROGN (LETT |p| (CAR #1#) |POLYCAT-;allMonoms|) NIL))
+          (GO G191)))
+        (SEQ 
+         (EXIT 
+          (LETT #0#
+           (CONS (SPADCALL |p| (QREFELT $ 77)) #0#)
+           |POLYCAT-;allMonoms|)))
+        (LETT #1# (CDR #1#) |POLYCAT-;allMonoms|)
+        (GO G190)
+        G191
+        (EXIT (NREVERSE0 #0#))))
+      (QREFELT $ 79))
+     (QREFELT $ 80)))))) 
+
+(DEFUN |POLYCAT-;P2R| (|p| |b| |n| $)
+ (PROG (|w| |bj| #0=#:G1538 |i| #1=#:G1537)
+  (RETURN 
+   (SEQ
+    (LETT |w|
+     (SPADCALL |n| (|spadConstant| $ 22) (QREFELT $ 82))
+     |POLYCAT-;P2R|)
+    (SEQ
+     (LETT |bj| NIL |POLYCAT-;P2R|)
+     (LETT #0# |b| |POLYCAT-;P2R|)
+     (LETT |i| (SPADCALL |w| (QREFELT $ 84)) |POLYCAT-;P2R|)
+     (LETT #1# (QVSIZE |w|) |POLYCAT-;P2R|)
+     G190
+     (COND
+      ((OR (> |i| #1#)
+           (ATOM #0#)
+           (PROGN (LETT |bj| (CAR #0#) |POLYCAT-;P2R|) NIL))
+       (GO G191)))
+     (SEQ
+      (EXIT
+       (SPADCALL |w| |i| (SPADCALL |p| |bj| (QREFELT $ 85)) (QREFELT $ 86))))
+     (LETT |i|
+      (PROG1 (+ |i| 1) (LETT #0# (CDR #0#) |POLYCAT-;P2R|)) |POLYCAT-;P2R|)
+     (GO G190)
+     G191
+     (EXIT NIL))
+    (EXIT |w|))))) 
+
+(DEFUN |POLYCAT-;eq2R| (|l| |b| $)
+ (PROG (#0=#:G1542 |bj| #1=#:G1543 #2=#:G1544 |p| #3=#:G1545)
+  (RETURN
+   (SEQ
+    (SPADCALL
+     (PROGN
+      (LETT #0# NIL |POLYCAT-;eq2R|)
+      (SEQ
+       (LETT |bj| NIL |POLYCAT-;eq2R|)
+       (LETT #1# |b| |POLYCAT-;eq2R|)
+       G190
+       (COND
+        ((OR (ATOM #1#) 
+             (PROGN (LETT |bj| (CAR #1#) |POLYCAT-;eq2R|) NIL)) (GO G191)))
+       (SEQ 
+        (EXIT
+         (LETT #0#
+          (CONS
+           (PROGN
+            (LETT #2# NIL |POLYCAT-;eq2R|)
+            (SEQ
+             (LETT |p| NIL |POLYCAT-;eq2R|)
+             (LETT #3# |l| |POLYCAT-;eq2R|)
+             G190
+             (COND
+              ((OR (ATOM #3#) (PROGN (LETT |p| (CAR #3#) |POLYCAT-;eq2R|) NIL))
+               (GO G191)))
+             (SEQ 
+              (EXIT
+               (LETT #2# 
+                (CONS (SPADCALL |p| |bj| (QREFELT $ 85)) #2#)
+                |POLYCAT-;eq2R|)))
+             (LETT #3# (CDR #3#) |POLYCAT-;eq2R|)
+             (GO G190)
+             G191
+             (EXIT (NREVERSE0 #2#))))
+           #0#)
+          |POLYCAT-;eq2R|)))
+       (LETT #1# (CDR #1#) |POLYCAT-;eq2R|)
+       (GO G190)
+       G191
+       (EXIT (NREVERSE0 #0#))))
+     (QREFELT $ 89)))))) 
+
+(DEFUN |POLYCAT-;reducedSystem;MM;20| (|m| $)
+ (PROG (#0=#:G1555 |r| #1=#:G1556 |b| #2=#:G1557 |bj| #3=#:G1558 |d| |mm| |l|)
+  (RETURN
+   (SEQ
+    (LETT |l| (SPADCALL |m| (QREFELT $ 92)) |POLYCAT-;reducedSystem;MM;20|)
+    (LETT |b|
+     (SPADCALL
+      (SPADCALL
+       (PROGN
+        (LETT #0# NIL |POLYCAT-;reducedSystem;MM;20|)
+        (SEQ
+         (LETT |r| NIL |POLYCAT-;reducedSystem;MM;20|)
+         (LETT #1# |l| |POLYCAT-;reducedSystem;MM;20|)
+         G190
+        (COND
+         ((OR (ATOM #1#) 
+              (PROGN (LETT |r| (CAR #1#) |POLYCAT-;reducedSystem;MM;20|) NIL))
+          (GO G191)))
+        (SEQ 
+         (EXIT 
+          (LETT #0# 
+           (CONS (|POLYCAT-;allMonoms| |r| $) #0#)
+           |POLYCAT-;reducedSystem;MM;20|)))
+        (LETT #1# (CDR #1#) |POLYCAT-;reducedSystem;MM;20|)
+        (GO G190)
+        G191
+        (EXIT (NREVERSE0 #0#))))
+       (QREFELT $ 79))
+      (QREFELT $ 80))
+     |POLYCAT-;reducedSystem;MM;20|)
+    (LETT |d|
+     (PROGN
+      (LETT #2# NIL |POLYCAT-;reducedSystem;MM;20|)
+      (SEQ
+       (LETT |bj| NIL |POLYCAT-;reducedSystem;MM;20|)
+       (LETT #3# |b| |POLYCAT-;reducedSystem;MM;20|)
+       G190
+       (COND
+        ((OR (ATOM #3#) 
+             (PROGN (LETT |bj| (CAR #3#) |POLYCAT-;reducedSystem;MM;20|) NIL))
+         (GO G191)))
+       (SEQ 
+        (EXIT 
+         (LETT #2# 
+          (CONS (SPADCALL |bj| (QREFELT $ 59)) #2#)
+          |POLYCAT-;reducedSystem;MM;20|)))
+       (LETT #3# (CDR #3#) |POLYCAT-;reducedSystem;MM;20|)
+       (GO G190)
+       G191
+       (EXIT (NREVERSE0 #2#))))
+      |POLYCAT-;reducedSystem;MM;20|)
+    (LETT |mm|
+     (|POLYCAT-;eq2R| (|SPADfirst| |l|) |d| $) |POLYCAT-;reducedSystem;MM;20|)
+    (LETT |l| (CDR |l|) |POLYCAT-;reducedSystem;MM;20|)
+    (SEQ G190
+     (COND
+      ((NULL (COND ((NULL |l|) (QUOTE NIL)) ((QUOTE T) (QUOTE T)))) (GO G191)))
+     (SEQ
+      (LETT |mm| 
+       (SPADCALL |mm| (|POLYCAT-;eq2R| (|SPADfirst| |l|) |d| $) (QREFELT $ 93))
+       |POLYCAT-;reducedSystem;MM;20|)
+      (EXIT (LETT |l| (CDR |l|) |POLYCAT-;reducedSystem;MM;20|)))
+     NIL
+     (GO G190)
+     G191
+     (EXIT NIL))
+    (EXIT |mm|))))) 
+
+(DEFUN |POLYCAT-;reducedSystem;MVR;21| (|m| |v| $)
+ (PROG (#0=#:G1570 |s| #1=#:G1571 |b| #2=#:G1572 |bj| #3=#:G1573 |d| |n| 
+        |mm| |w| |l| |r|)
+  (RETURN
+   (SEQ
+    (LETT |l| (SPADCALL |m| (QREFELT $ 92)) |POLYCAT-;reducedSystem;MVR;21|)
+    (LETT |r| (SPADCALL |v| (QREFELT $ 97)) |POLYCAT-;reducedSystem;MVR;21|)
+    (LETT |b| 
+     (SPADCALL 
+      (SPADCALL 
+       (|POLYCAT-;allMonoms| |r| $)
+       (SPADCALL 
+        (PROGN 
+         (LETT #0# NIL |POLYCAT-;reducedSystem;MVR;21|)
+         (SEQ
+          (LETT |s| NIL |POLYCAT-;reducedSystem;MVR;21|)
+          (LETT #1# |l| |POLYCAT-;reducedSystem;MVR;21|)
+          G190
+          (COND
+           ((OR (ATOM #1#) 
+                (PROGN 
+                 (LETT |s| (CAR #1#) |POLYCAT-;reducedSystem;MVR;21|)
+                  NIL))
+            (GO G191)))
+          (SEQ 
+           (EXIT 
+            (LETT #0# 
+             (CONS (|POLYCAT-;allMonoms| |s| $) #0#) 
+             |POLYCAT-;reducedSystem;MVR;21|)))
+          (LETT #1# (CDR #1#) |POLYCAT-;reducedSystem;MVR;21|)
+          (GO G190)
+          G191
+          (EXIT (NREVERSE0 #0#))))
+        (QREFELT $ 79))
+       (QREFELT $ 98))
+      (QREFELT $ 80))
+     |POLYCAT-;reducedSystem;MVR;21|)
+    (LETT |d|
+     (PROGN
+      (LETT #2# NIL |POLYCAT-;reducedSystem;MVR;21|)
+      (SEQ
+       (LETT |bj| NIL |POLYCAT-;reducedSystem;MVR;21|)
+       (LETT #3# |b| |POLYCAT-;reducedSystem;MVR;21|)
+       G190
+       (COND
+        ((OR (ATOM #3#) 
+             (PROGN (LETT |bj| (CAR #3#) |POLYCAT-;reducedSystem;MVR;21|) NIL))
+         (GO G191)))
+       (SEQ 
+        (EXIT 
+         (LETT #2# 
+          (CONS (SPADCALL |bj| (QREFELT $ 59)) #2#)
+          |POLYCAT-;reducedSystem;MVR;21|)))
+       (LETT #3# (CDR #3#) |POLYCAT-;reducedSystem;MVR;21|)
+       (GO G190)
+       G191
+       (EXIT (NREVERSE0 #2#))))
+      |POLYCAT-;reducedSystem;MVR;21|)
+    (LETT |n| (LENGTH |d|) |POLYCAT-;reducedSystem;MVR;21|)
+    (LETT |mm| 
+     (|POLYCAT-;eq2R| (|SPADfirst| |l|) |d| $)
+     |POLYCAT-;reducedSystem;MVR;21|)
+    (LETT |w| 
+     (|POLYCAT-;P2R| (|SPADfirst| |r|) |d| |n| $)
+     |POLYCAT-;reducedSystem;MVR;21|)
+    (LETT |l| (CDR |l|) |POLYCAT-;reducedSystem;MVR;21|)
+    (LETT |r| (CDR |r|) |POLYCAT-;reducedSystem;MVR;21|)
+    (SEQ G190
+     (COND
+      ((NULL (COND ((NULL |l|) (QUOTE NIL)) ((QUOTE T) (QUOTE T))))
+       (GO G191)))
+     (SEQ
+      (LETT |mm| 
+       (SPADCALL |mm| (|POLYCAT-;eq2R| (|SPADfirst| |l|) |d| $) (QREFELT $ 93))
+       |POLYCAT-;reducedSystem;MVR;21|)
+      (LETT |w| 
+       (SPADCALL |w| 
+        (|POLYCAT-;P2R| (|SPADfirst| |r|) |d| |n| $)
+        (QREFELT $ 99))
+       |POLYCAT-;reducedSystem;MVR;21|)
+      (LETT |l| (CDR |l|) |POLYCAT-;reducedSystem;MVR;21|)
+      (EXIT (LETT |r| (CDR |r|) |POLYCAT-;reducedSystem;MVR;21|)))
+      NIL
+      (GO G190)
+      G191
+      (EXIT NIL))
+    (EXIT (CONS |mm| |w|)))))) 
+
+(DEFUN |POLYCAT-;gcdPolynomial;3Sup;22| (|pp| |qq| $)
+ (SPADCALL |pp| |qq| (QREFELT $ 104))) 
+
+(DEFUN |POLYCAT-;solveLinearPolynomialEquation;LSupU;23| (|lpp| |pp| $)
+ (SPADCALL |lpp| |pp| (QREFELT $ 109))) 
+
+(DEFUN |POLYCAT-;factorPolynomial;SupF;24| (|pp| $)
+ (SPADCALL |pp| (QREFELT $ 114))) 
+
+(DEFUN |POLYCAT-;factorSquareFreePolynomial;SupF;25| (|pp| $)
+ (SPADCALL |pp| (QREFELT $ 117))) 
+
+(DEFUN |POLYCAT-;factor;SF;26| (|p| $) 
+ (PROG (|v| |ansR| #0=#:G1615 |w| #1=#:G1616 |up| |ansSUP| #2=#:G1617 
+        |ww| #3=#:G1618) 
+  (RETURN
+   (SEQ
+    (LETT |v| (SPADCALL |p| (QREFELT $ 42)) |POLYCAT-;factor;SF;26|)
+    (EXIT
+     (COND
+      ((QEQCAR |v| 1)
+       (SEQ
+        (LETT |ansR| 
+         (SPADCALL (SPADCALL |p| (QREFELT $ 38)) (QREFELT $ 120))
+         |POLYCAT-;factor;SF;26|)
+        (EXIT 
+         (SPADCALL 
+          (SPADCALL (SPADCALL |ansR| (QREFELT $ 122)) (QREFELT $ 40))
+          (PROGN 
+           (LETT #0# NIL |POLYCAT-;factor;SF;26|)
+           (SEQ 
+            (LETT |w| NIL |POLYCAT-;factor;SF;26|)
+            (LETT #1#
+             (SPADCALL |ansR| (QREFELT $ 126))
+             |POLYCAT-;factor;SF;26|)
+            G190 
+            (COND
+             ((OR (ATOM #1#) 
+                  (PROGN (LETT |w| (CAR #1#) |POLYCAT-;factor;SF;26|) NIL))
+              (GO G191)))
+            (SEQ 
+             (EXIT 
+              (LETT #0# 
+               (CONS 
+                (VECTOR (QVELT |w| 0) 
+                  (SPADCALL (QVELT |w| 1) (QREFELT $ 40)) (QVELT |w| 2))
+                #0#)
+               |POLYCAT-;factor;SF;26|)))
+            (LETT #1# (CDR #1#) |POLYCAT-;factor;SF;26|)
+            (GO G190)
+            G191
+            (EXIT (NREVERSE0 #0#))))
+          (QREFELT $ 130)))))
+      ((QUOTE T)
+       (SEQ
+        (LETT |up|
+         (SPADCALL |p| (QCDR |v|) (QREFELT $ 47)) |POLYCAT-;factor;SF;26|)
+        (LETT |ansSUP| (SPADCALL |up| (QREFELT $ 114)) |POLYCAT-;factor;SF;26|)
+        (EXIT
+         (SPADCALL
+          (SPADCALL 
+           (SPADCALL |ansSUP| (QREFELT $ 131)) (QCDR |v|) (QREFELT $ 132))
+          (PROGN 
+           (LETT #2# NIL |POLYCAT-;factor;SF;26|)
+           (SEQ 
+            (LETT |ww| NIL |POLYCAT-;factor;SF;26|)
+            (LETT #3# 
+             (SPADCALL |ansSUP| (QREFELT $ 135))
+             |POLYCAT-;factor;SF;26|)
+            G190
+            (COND
+             ((OR (ATOM #3#)
+                  (PROGN (LETT |ww| (CAR #3#) |POLYCAT-;factor;SF;26|) NIL))
+              (GO G191)))
+            (SEQ 
+             (EXIT 
+              (LETT #2# 
+               (CONS 
+                (VECTOR (QVELT |ww| 0) (SPADCALL (QVELT |ww| 1) (QCDR |v|) 
+                        (QREFELT $ 132)) (QVELT |ww| 2))
+                #2#) 
+               |POLYCAT-;factor;SF;26|)))
+            (LETT #3# (CDR #3#) |POLYCAT-;factor;SF;26|)
+            (GO G190)
+            G191
+            (EXIT (NREVERSE0 #2#))))
+          (QREFELT $ 130))))))))))) 
+
+(DEFUN |POLYCAT-;conditionP;MU;27| (|mat| $)
+ (PROG (|ll| #0=#:G1653 |z| #1=#:G1654 |ch| |l| #2=#:G1655 #3=#:G1656 
+        #4=#:G1625 #5=#:G1623 #6=#:G1624 #7=#:G1657 |vars| |degs| 
+        #8=#:G1658 |d| #9=#:G1659 |nd| #10=#:G1652 #11=#:G1632 |deg1| 
+        |redmons| #12=#:G1660 |v| #13=#:G1662 |u| #14=#:G1661 |llR| 
+        |monslist| |ans| #15=#:G1663 #16=#:G1664 |mons| #17=#:G1665 |m| 
+        #18=#:G1666 |i| #19=#:G1648 #20=#:G1646 #21=#:G1647)
+  (RETURN
+   (SEQ
+    (EXIT
+     (SEQ
+      (LETT |ll|
+       (SPADCALL (SPADCALL |mat| (QREFELT $ 137)) (QREFELT $ 92))
+       |POLYCAT-;conditionP;MU;27|)
+      (LETT |llR|
+       (PROGN
+        (LETT #0# NIL |POLYCAT-;conditionP;MU;27|)
+        (SEQ
+         (LETT |z| NIL |POLYCAT-;conditionP;MU;27|)
+         (LETT #1# (|SPADfirst| |ll|) |POLYCAT-;conditionP;MU;27|)
+         G190
+         (COND
+          ((OR (ATOM #1#) 
+               (PROGN (LETT |z| (CAR #1#) |POLYCAT-;conditionP;MU;27|) NIL))
+           (GO G191)))
+         (SEQ (EXIT (LETT #0# (CONS NIL #0#) |POLYCAT-;conditionP;MU;27|)))
+         (LETT #1# (CDR #1#) |POLYCAT-;conditionP;MU;27|)
+         (GO G190)
+         G191
+         (EXIT (NREVERSE0 #0#))))
+       |POLYCAT-;conditionP;MU;27|)
+      (LETT |monslist| NIL |POLYCAT-;conditionP;MU;27|)
+      (LETT |ch| (SPADCALL (QREFELT $ 138)) |POLYCAT-;conditionP;MU;27|)
+      (SEQ
+       (LETT |l| NIL |POLYCAT-;conditionP;MU;27|)
+       (LETT #2# |ll| |POLYCAT-;conditionP;MU;27|)
+       G190
+       (COND
+        ((OR (ATOM #2#) 
+             (PROGN (LETT |l| (CAR #2#) |POLYCAT-;conditionP;MU;27|) NIL))
+         (GO G191)))
+       (SEQ
+        (LETT |mons|
+         (PROGN
+          (LETT #6# NIL |POLYCAT-;conditionP;MU;27|)
+          (SEQ
+           (LETT |u| NIL |POLYCAT-;conditionP;MU;27|)
+           (LETT #3# |l| |POLYCAT-;conditionP;MU;27|)
+           G190
+           (COND
+            ((OR (ATOM #3#) 
+                 (PROGN (LETT |u| (CAR #3#) |POLYCAT-;conditionP;MU;27|) NIL))
+             (GO G191)))
+           (SEQ
+            (EXIT
+             (PROGN
+              (LETT #4# 
+               (SPADCALL |u| (QREFELT $ 77))
+               |POLYCAT-;conditionP;MU;27|)
+              (COND
+               (#6# 
+                (LETT #5# 
+                 (SPADCALL #5# #4# (QREFELT $ 139))
+                 |POLYCAT-;conditionP;MU;27|))
+               ((QUOTE T)
+                (PROGN 
+                 (LETT #5# #4# |POLYCAT-;conditionP;MU;27|)
+                 (LETT #6# (QUOTE T) |POLYCAT-;conditionP;MU;27|)))))))
+           (LETT #3# (CDR #3#) |POLYCAT-;conditionP;MU;27|)
+           (GO G190)
+           G191
+           (EXIT NIL))
+          (COND (#6# #5#) ((QUOTE T) (|IdentityError| (QUOTE |setUnion|)))))
+         |POLYCAT-;conditionP;MU;27|)
+        (LETT |redmons| NIL |POLYCAT-;conditionP;MU;27|)
+        (SEQ
+         (LETT |m| NIL |POLYCAT-;conditionP;MU;27|)
+         (LETT #7# |mons| |POLYCAT-;conditionP;MU;27|)
+         G190
+         (COND
+          ((OR (ATOM #7#) 
+               (PROGN (LETT |m| (CAR #7#) |POLYCAT-;conditionP;MU;27|) NIL)) 
+            (GO G191)))
+         (SEQ 
+          (LETT |vars|
+           (SPADCALL |m| (QREFELT $ 31))
+           |POLYCAT-;conditionP;MU;27|)
+          (LETT |degs|
+           (SPADCALL |m| |vars| (QREFELT $ 140))
+           |POLYCAT-;conditionP;MU;27|)
+          (LETT |deg1|
+           (PROGN
+            (LETT #8# NIL |POLYCAT-;conditionP;MU;27|)
+            (SEQ
+             (LETT |d| NIL |POLYCAT-;conditionP;MU;27|)
+             (LETT #9# |degs| |POLYCAT-;conditionP;MU;27|)
+             G190
+             (COND
+              ((OR (ATOM #9#) 
+                   (PROGN
+                    (LETT |d| (CAR #9#) |POLYCAT-;conditionP;MU;27|)
+                    NIL))
+               (GO G191)))
+             (SEQ 
+              (EXIT
+               (LETT #8# 
+                (CONS 
+                 (SEQ
+                  (LETT |nd|
+                   (SPADCALL |d| |ch| (QREFELT $ 142))
+                   |POLYCAT-;conditionP;MU;27|)
+                  (EXIT
+                   (COND
+                    ((QEQCAR |nd| 1)
+                      (PROGN
+                        (LETT #10# 
+                         (CONS 1 "failed") |POLYCAT-;conditionP;MU;27|)
+                        (GO #10#)))
+                    ((QUOTE T) 
+                      (PROG1 
+                       (LETT #11# (QCDR |nd|) |POLYCAT-;conditionP;MU;27|)
+                       (|check-subtype| 
+                        (>= #11# 0) (QUOTE (|NonNegativeInteger|)) #11#))))))
+                 #8#)
+                |POLYCAT-;conditionP;MU;27|)))
+            (LETT #9# (CDR #9#) |POLYCAT-;conditionP;MU;27|)
+            (GO G190)
+            G191
+            (EXIT (NREVERSE0 #8#))))
+           |POLYCAT-;conditionP;MU;27|)
+          (LETT |redmons| 
+           (CONS 
+            (SPADCALL (|spadConstant| $ 33) |vars| |deg1| (QREFELT $ 54))
+            |redmons|)
+           |POLYCAT-;conditionP;MU;27|)
+          (EXIT
+           (LETT |llR|
+            (PROGN
+             (LETT #12# NIL |POLYCAT-;conditionP;MU;27|)
+             (SEQ
+              (LETT |v| NIL |POLYCAT-;conditionP;MU;27|)
+              (LETT #13# |llR| |POLYCAT-;conditionP;MU;27|)
+              (LETT |u| NIL |POLYCAT-;conditionP;MU;27|)
+              (LETT #14# |l| |POLYCAT-;conditionP;MU;27|)
+              G190
+              (COND
+               ((OR (ATOM #14#)
+                 (PROGN
+                  (LETT |u| (CAR #14#) |POLYCAT-;conditionP;MU;27|)
+                   NIL) 
+                 (ATOM #13#)
+                 (PROGN (LETT |v| (CAR #13#) |POLYCAT-;conditionP;MU;27|) NIL))
+                (GO G191)))
+              (SEQ 
+               (EXIT 
+                (LETT #12#
+                 (CONS
+                  (CONS
+                   (SPADCALL
+                    (SPADCALL |u| |vars| |degs| (QREFELT $ 52))
+                    (QREFELT $ 143))
+                   |v|)
+                  #12#)
+                 |POLYCAT-;conditionP;MU;27|)))
+              (LETT #14#
+               (PROG1
+                (CDR #14#)
+                (LETT #13# (CDR #13#) |POLYCAT-;conditionP;MU;27|))
+               |POLYCAT-;conditionP;MU;27|)
+              (GO G190)
+              G191
+              (EXIT (NREVERSE0 #12#))))
+            |POLYCAT-;conditionP;MU;27|)))
+         (LETT #7# (CDR #7#) |POLYCAT-;conditionP;MU;27|)
+         (GO G190)
+         G191
+         (EXIT NIL))
+        (EXIT
+         (LETT |monslist| 
+          (CONS |redmons| |monslist|)
+          |POLYCAT-;conditionP;MU;27|)))
+       (LETT #2# (CDR #2#) |POLYCAT-;conditionP;MU;27|)
+       (GO G190)
+       G191
+       (EXIT NIL))
+      (LETT |ans|
+       (SPADCALL (SPADCALL (SPADCALL |llR| (QREFELT $ 89)) (QREFELT $ 144))
+                 (QREFELT $ 146))
+       |POLYCAT-;conditionP;MU;27|)
+      (EXIT
+       (COND 
+        ((QEQCAR |ans| 1) (CONS 1 "failed"))
+        ((QUOTE T)
+         (SEQ
+          (LETT |i| 0 |POLYCAT-;conditionP;MU;27|)
+          (EXIT
+           (CONS 0
+            (PRIMVEC2ARR
+             (PROGN
+              (LETT #15# (GETREFV (SIZE |monslist|)) 
+               |POLYCAT-;conditionP;MU;27|)
+              (SEQ
+               (LETT #16# 0 |POLYCAT-;conditionP;MU;27|)
+               (LETT |mons| NIL |POLYCAT-;conditionP;MU;27|)
+               (LETT #17# |monslist| |POLYCAT-;conditionP;MU;27|)
+               G190
+               (COND 
+                ((OR (ATOM #17#) 
+                     (PROGN 
+                      (LETT |mons| (CAR #17#) |POLYCAT-;conditionP;MU;27|)
+                      NIL))
+                 (GO G191)))
+               (SEQ 
+                (EXIT
+                 (SETELT #15# #16# 
+                  (PROGN
+                   (LETT #21# NIL |POLYCAT-;conditionP;MU;27|)
+                   (SEQ
+                    (LETT |m| NIL |POLYCAT-;conditionP;MU;27|)
+                    (LETT #18# |mons| |POLYCAT-;conditionP;MU;27|)
+                    G190
+                    (COND
+                     ((OR (ATOM #18#)
+                       (PROGN 
+                        (LETT |m| (CAR #18#) |POLYCAT-;conditionP;MU;27|)
+                         NIL))
+                      (GO G191)))
+                    (SEQ
+                     (EXIT
+                      (PROGN
+                       (LETT #19#
+                        (SPADCALL |m| 
+                         (SPADCALL 
+                          (SPADCALL 
+                           (QCDR |ans|)
+                           (LETT |i| (+ |i| 1) |POLYCAT-;conditionP;MU;27|)
+                           (QREFELT $ 147))
+                          (QREFELT $ 40))
+                         (QREFELT $ 148))
+                        |POLYCAT-;conditionP;MU;27|)
+                       (COND
+                        (#21#
+                         (LETT #20# 
+                          (SPADCALL #20# #19# (QREFELT $ 149))
+                          |POLYCAT-;conditionP;MU;27|))
+                        ((QUOTE T)
+                          (PROGN
+                           (LETT #20# #19# |POLYCAT-;conditionP;MU;27|)
+                           (LETT #21# 
+                            (QUOTE T)
+                            |POLYCAT-;conditionP;MU;27|)))))))
+                    (LETT #18# (CDR #18#) |POLYCAT-;conditionP;MU;27|)
+                    (GO G190)
+                    G191
+                    (EXIT NIL))
+                   (COND (#21# #20#) ((QUOTE T) (|spadConstant| $ 21)))))))
+               (LETT #17# 
+                (PROG1 
+                 (CDR #17#)
+                 (LETT #16# (QSADD1 #16#) |POLYCAT-;conditionP;MU;27|))
+                |POLYCAT-;conditionP;MU;27|)
+               (GO G190)
+               G191
+               (EXIT NIL))
+              #15#))))))))))
+   #10#
+   (EXIT #10#))))) 
+
+(DEFUN |POLYCAT-;charthRoot;SU;28| (|p| $)
+ (PROG (|vars| |ans| |ch|)
+  (RETURN
+   (SEQ
+    (LETT |vars| (SPADCALL |p| (QREFELT $ 31)) |POLYCAT-;charthRoot;SU;28|)
+    (EXIT
+     (COND
+      ((NULL |vars|)
+        (SEQ
+         (LETT |ans|
+          (SPADCALL (SPADCALL |p| (QREFELT $ 143)) (QREFELT $ 151))
+          |POLYCAT-;charthRoot;SU;28|)
+         (EXIT
+          (COND
+           ((QEQCAR |ans| 1) (CONS 1 "failed"))
+           ((QUOTE T) (CONS 0 (SPADCALL (QCDR |ans|) (QREFELT $ 40))))))))
+      ((QUOTE T)
+       (SEQ
+        (LETT |ch| (SPADCALL (QREFELT $ 138)) |POLYCAT-;charthRoot;SU;28|)
+        (EXIT (|POLYCAT-;charthRootlv| |p| |vars| |ch| $)))))))))) 
+
+(DEFUN |POLYCAT-;charthRootlv| (|p| |vars| |ch| $)
+ (PROG (|v| |dd| |cp| |d| #0=#:G1687 |ans| |ansx| #1=#:G1694)
+  (RETURN
+   (SEQ
+    (EXIT 
+     (COND
+      ((NULL |vars|)
+       (SEQ
+        (LETT |ans| 
+         (SPADCALL (SPADCALL |p| (QREFELT $ 143)) (QREFELT $ 151))
+         |POLYCAT-;charthRootlv|)
+        (EXIT
+         (COND
+          ((QEQCAR |ans| 1) (CONS 1 "failed"))
+          ((QUOTE T) (CONS 0 (SPADCALL (QCDR |ans|) (QREFELT $ 40))))))))
+      ((QUOTE T)
+       (SEQ
+        (LETT |v| (|SPADfirst| |vars|) |POLYCAT-;charthRootlv|)
+        (LETT |vars| (CDR |vars|) |POLYCAT-;charthRootlv|)
+        (LETT |d| (SPADCALL |p| |v| (QREFELT $ 36)) |POLYCAT-;charthRootlv|)
+        (LETT |ans| (|spadConstant| $ 21) |POLYCAT-;charthRootlv|)
+        (SEQ G190
+         (COND ((NULL (< 0 |d|)) (GO G191)))
+         (SEQ
+          (LETT |dd|
+           (SPADCALL |d| |ch| (QREFELT $ 142))
+           |POLYCAT-;charthRootlv|)
+          (EXIT
+           (COND
+            ((QEQCAR |dd| 1)
+              (PROGN
+               (LETT #1# (CONS 1 "failed") |POLYCAT-;charthRootlv|)
+               (GO #1#)))
+            ((QUOTE T)
+             (SEQ
+              (LETT |cp|
+               (SPADCALL |p| |v| |d| (QREFELT $ 154))
+               |POLYCAT-;charthRootlv|)
+              (LETT |p|
+               (SPADCALL |p|
+                (SPADCALL |cp| |v| |d| (QREFELT $ 37))
+                (QREFELT $ 155))
+               |POLYCAT-;charthRootlv|)
+              (LETT |ansx|
+               (|POLYCAT-;charthRootlv| |cp| |vars| |ch| $)
+               |POLYCAT-;charthRootlv|)
+              (EXIT
+               (COND
+                ((QEQCAR |ansx| 1)
+                  (PROGN 
+                   (LETT #1# (CONS 1 "failed") |POLYCAT-;charthRootlv|)
+                   (GO #1#)))
+                ((QUOTE T) 
+                 (SEQ
+                  (LETT |d|
+                   (SPADCALL |p| |v| (QREFELT $ 36))
+                   |POLYCAT-;charthRootlv|)
+                  (EXIT
+                   (LETT |ans|
+                    (SPADCALL |ans|
+                     (SPADCALL (QCDR |ansx|) |v| 
+                      (PROG1 
+                       (LETT #0# (QCDR |dd|) |POLYCAT-;charthRootlv|)
+                       (|check-subtype| (>= #0# 0) 
+                        (QUOTE (|NonNegativeInteger|)) #0#))
+                      (QREFELT $ 37))
+                     (QREFELT $ 149))
+                    |POLYCAT-;charthRootlv|)))))))))))
+         NIL 
+         (GO G190) 
+         G191 
+         (EXIT NIL))
+        (LETT |ansx|
+         (|POLYCAT-;charthRootlv| |p| |vars| |ch| $)
+         |POLYCAT-;charthRootlv|)
+        (EXIT
+         (COND
+          ((QEQCAR |ansx| 1)
+           (PROGN
+            (LETT #1# (CONS 1 "failed") |POLYCAT-;charthRootlv|)
+            (GO #1#)))
+          ((QUOTE T)
+           (PROGN
+            (LETT #1#
+             (CONS 0 (SPADCALL |ans| (QCDR |ansx|) (QREFELT $ 149)))
+             |POLYCAT-;charthRootlv|)
+            (GO #1#)))))))))
+    #1# 
+    (EXIT #1#))))) 
+
+(DEFUN |POLYCAT-;monicDivide;2SVarSetR;30| (|p1| |p2| |mvar| $) 
+ (PROG (|result|) 
+  (RETURN
+   (SEQ
+    (LETT |result|
+     (SPADCALL
+      (SPADCALL |p1| |mvar| (QREFELT $ 47))
+      (SPADCALL |p2| |mvar| (QREFELT $ 47))
+      (QREFELT $ 157))
+     |POLYCAT-;monicDivide;2SVarSetR;30|)
+    (EXIT
+     (CONS
+      (SPADCALL (QCAR |result|) |mvar| (QREFELT $ 132))
+      (SPADCALL (QCDR |result|) |mvar| (QREFELT $ 132)))))))) 
+
+(DEFUN |POLYCAT-;squareFree;SF;31| (|p| $)
+ (SPADCALL |p| (QREFELT $ 160))) 
+
+(DEFUN |POLYCAT-;squareFree;SF;32| (|p| $)
+ (SPADCALL |p| (QREFELT $ 163))) 
+
+(DEFUN |POLYCAT-;squareFree;SF;33| (|p| $)
+ (SPADCALL |p| (QREFELT $ 163))) 
+
+(DEFUN |POLYCAT-;squareFreePart;2S;34| (|p| $)
+ (PROG (|s| |f| #0=#:G1710 #1=#:G1708 #2=#:G1706 #3=#:G1707)
+  (RETURN
+   (SEQ
+    (SPADCALL
+     (SPADCALL 
+      (LETT |s| (SPADCALL |p| (QREFELT $ 164)) |POLYCAT-;squareFreePart;2S;34|)
+      (QREFELT $ 165))
+     (PROGN
+      (LETT #3# NIL |POLYCAT-;squareFreePart;2S;34|)
+      (SEQ
+       (LETT |f| NIL |POLYCAT-;squareFreePart;2S;34|)
+       (LETT #0# (SPADCALL |s| (QREFELT $ 168)) |POLYCAT-;squareFreePart;2S;34|)
+       G190
+       (COND
+        ((OR (ATOM #0#) 
+             (PROGN (LETT |f| (CAR #0#) |POLYCAT-;squareFreePart;2S;34|) NIL))
+         (GO G191)))
+       (SEQ 
+        (EXIT
+         (PROGN
+          (LETT #1# (QCAR |f|) |POLYCAT-;squareFreePart;2S;34|)
+          (COND
+           (#3#
+            (LETT #2#
+             (SPADCALL #2# #1# (QREFELT $ 148))
+             |POLYCAT-;squareFreePart;2S;34|))
+           ((QUOTE T)
+            (PROGN
+             (LETT #2# #1# |POLYCAT-;squareFreePart;2S;34|)
+             (LETT #3# (QUOTE T) |POLYCAT-;squareFreePart;2S;34|)))))))
+       (LETT #0# (CDR #0#) |POLYCAT-;squareFreePart;2S;34|)
+       (GO G190)
+       G191
+       (EXIT NIL))
+      (COND (#3# #2#) ((QUOTE T) (|spadConstant| $ 33))))
+     (QREFELT $ 148)))))) 
+
+(DEFUN |POLYCAT-;content;SVarSetS;35| (|p| |v| $)
+ (SPADCALL (SPADCALL |p| |v| (QREFELT $ 47)) (QREFELT $ 170))) 
+
+(DEFUN |POLYCAT-;primitivePart;2S;36| (|p| $)
+ (PROG (#0=#:G1713)
+  (RETURN
+   (COND
+    ((SPADCALL |p| (QREFELT $ 172)) |p|)
+    ((QUOTE T)
+     (QVELT
+      (SPADCALL
+       (PROG2
+        (LETT #0# 
+         (SPADCALL |p| (SPADCALL |p| (QREFELT $ 173)) (QREFELT $ 174))
+         |POLYCAT-;primitivePart;2S;36|)
+        (QCDR #0#)
+        (|check-union| (QEQCAR #0# 0) (QREFELT $ 6) #0#))
+       (QREFELT $ 176))
+      1)))))) 
+
+(DEFUN |POLYCAT-;primitivePart;SVarSetS;37| (|p| |v| $)
+ (PROG (#0=#:G1720)
+  (RETURN 
+   (COND 
+    ((SPADCALL |p| (QREFELT $ 172)) |p|)
+    ((QUOTE T) 
+     (QVELT 
+      (SPADCALL
+       (PROG2
+        (LETT #0#
+         (SPADCALL |p| (SPADCALL |p| |v| (QREFELT $ 178)) (QREFELT $ 179))
+         |POLYCAT-;primitivePart;SVarSetS;37|)
+        (QCDR #0#)
+        (|check-union| (QEQCAR #0# 0) (QREFELT $ 6) #0#))
+       (QREFELT $ 176))
+      1)))))) 
+
+(DEFUN |POLYCAT-;<;2SB;38| (|p| |q| $)
+ (PROG (|dp| |dq|)
+  (RETURN
+   (SEQ
+    (LETT |dp| (SPADCALL |p| (QREFELT $ 59)) |POLYCAT-;<;2SB;38|)
+    (LETT |dq| (SPADCALL |q| (QREFELT $ 59)) |POLYCAT-;<;2SB;38|)
+    (EXIT
+     (COND
+      ((SPADCALL |dp| |dq| (QREFELT $ 181))
+        (SPADCALL
+         (|spadConstant| $ 22)
+         (SPADCALL |q| (QREFELT $ 38))
+         (QREFELT $ 182)))
+      ((SPADCALL |dq| |dp| (QREFELT $ 181))
+        (SPADCALL
+         (SPADCALL |p| (QREFELT $ 38))
+         (|spadConstant| $ 22)
+         (QREFELT $ 182)))
+      ((QUOTE T)
+       (SPADCALL
+        (SPADCALL (SPADCALL |p| |q| (QREFELT $ 155)) (QREFELT $ 38))
+        (|spadConstant| $ 22)
+        (QREFELT $ 182))))))))) 
+
+(DEFUN |POLYCAT-;patternMatch;SP2Pmr;39| (|p| |pat| |l| $)
+ (SPADCALL |p| |pat| |l| (QREFELT $ 187))) 
+
+(DEFUN |POLYCAT-;patternMatch;SP2Pmr;40| (|p| |pat| |l| $)
+ (SPADCALL |p| |pat| |l| (QREFELT $ 193))) 
+
+(DEFUN |POLYCAT-;convert;SP;41| (|x| $)
+ (SPADCALL (ELT $ 196) (ELT $ 197) |x| (QREFELT $ 201))) 
+
+(DEFUN |POLYCAT-;convert;SP;42| (|x| $) 
+ (SPADCALL (ELT $ 203) (ELT $ 204) |x| (QREFELT $ 208))) 
+
+(DEFUN |POLYCAT-;convert;SIf;43| (|p| $)
+ (SPADCALL (ELT $ 211) (ELT $ 212) |p| (QREFELT $ 216))) 
+
+(DEFUN |PolynomialCategory&| (|#1| |#2| |#3| |#4|)
+ (PROG (DV$1 DV$2 DV$3 DV$4 |dv$| $ |pv$|)
+  (RETURN
+   (PROGN
+    (LETT DV$1 (|devaluate| |#1|) . #0=(|PolynomialCategory&|))
+    (LETT DV$2 (|devaluate| |#2|) . #0#)
+    (LETT DV$3 (|devaluate| |#3|) . #0#)
+    (LETT DV$4 (|devaluate| |#4|) . #0#)
+    (LETT |dv$| (LIST (QUOTE |PolynomialCategory&|) DV$1 DV$2 DV$3 DV$4) . #0#)
+    (LETT $ (GETREFV 226) . #0#)
+    (QSETREFV $ 0 |dv$|)
+    (QSETREFV $ 3
+     (LETT |pv$| 
+      (|buildPredVector| 0 0 
+       (LIST 
+        (|HasCategory| |#2| (QUOTE (|PolynomialFactorizationExplicit|)))
+        (|HasAttribute| |#2| (QUOTE |canonicalUnitNormal|))
+        (|HasCategory| |#2| (QUOTE (|GcdDomain|)))
+        (|HasCategory| |#2| (QUOTE (|CommutativeRing|)))
+        (|HasCategory| |#4| (QUOTE (|PatternMatchable| (|Float|))))
+        (|HasCategory| |#2| (QUOTE (|PatternMatchable| (|Float|))))
+        (|HasCategory| |#4| (QUOTE (|PatternMatchable| (|Integer|))))
+        (|HasCategory| |#2| (QUOTE (|PatternMatchable| (|Integer|))))
+        (|HasCategory| |#4| (QUOTE (|ConvertibleTo| (|Pattern| (|Float|)))))
+        (|HasCategory| |#2| (QUOTE (|ConvertibleTo| (|Pattern| (|Float|)))))
+        (|HasCategory| |#4| (QUOTE (|ConvertibleTo| (|Pattern| (|Integer|)))))
+        (|HasCategory| |#2| (QUOTE (|ConvertibleTo| (|Pattern| (|Integer|)))))
+        (|HasCategory| |#4| (QUOTE (|ConvertibleTo| (|InputForm|))))
+        (|HasCategory| |#2| (QUOTE (|ConvertibleTo| (|InputForm|))))
+        (|HasCategory| |#2| (QUOTE (|OrderedSet|)))))
+     . #0#))
+    (|stuffDomainSlots| $)
+    (QSETREFV $ 6 |#1|)
+    (QSETREFV $ 7 |#2|)
+    (QSETREFV $ 8 |#3|)
+    (QSETREFV $ 9 |#4|)
+    (COND 
+     ((|testBitVector| |pv$| 4)
+      (PROGN 
+       (QSETREFV $ 74 
+        (CONS (|dispatchFunction| |POLYCAT-;resultant;2SVarSetS;15|) $))
+       (QSETREFV $ 76 
+        (CONS (|dispatchFunction| |POLYCAT-;discriminant;SVarSetS;16|) $)))))
+    (COND 
+     ((|HasCategory| |#2| (QUOTE (|IntegralDomain|)))
+      (PROGN
+       (QSETREFV $ 95 
+        (CONS (|dispatchFunction| |POLYCAT-;reducedSystem;MM;20|) $))
+       (QSETREFV $ 102 
+        (CONS (|dispatchFunction| |POLYCAT-;reducedSystem;MVR;21|) $)))))
+    (COND 
+     ((|testBitVector| |pv$| 1)
+      (PROGN 
+       (QSETREFV $ 105
+        (CONS (|dispatchFunction| |POLYCAT-;gcdPolynomial;3Sup;22|) $))
+       (QSETREFV $ 112
+        (CONS 
+         (|dispatchFunction| 
+           |POLYCAT-;solveLinearPolynomialEquation;LSupU;23|) 
+         $))
+       (QSETREFV $ 116 
+        (CONS (|dispatchFunction| |POLYCAT-;factorPolynomial;SupF;24|) $))
+       (QSETREFV $ 118 
+        (CONS 
+         (|dispatchFunction| |POLYCAT-;factorSquareFreePolynomial;SupF;25|)
+         $))
+       (QSETREFV $ 136 (CONS (|dispatchFunction| |POLYCAT-;factor;SF;26|) $))
+       (COND
+        ((|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|)))
+         (PROGN 
+          (QSETREFV $ 150 
+           (CONS (|dispatchFunction| |POLYCAT-;conditionP;MU;27|) $))))))))
+    (COND 
+     ((|HasCategory| |#2| (QUOTE (|CharacteristicNonZero|)))
+      (PROGN 
+       (QSETREFV $ 152 
+        (CONS (|dispatchFunction| |POLYCAT-;charthRoot;SU;28|) $)))))
+    (COND 
+     ((|testBitVector| |pv$| 3)
+      (PROGN 
+       (COND 
+        ((|HasCategory| |#2| (QUOTE (|EuclideanDomain|)))
+         (COND 
+          ((|HasCategory| |#2| (QUOTE (|CharacteristicZero|)))
+           (QSETREFV $ 161 
+            (CONS (|dispatchFunction| |POLYCAT-;squareFree;SF;31|) $)))
+          ((QUOTE T) 
+           (QSETREFV $ 161 
+            (CONS (|dispatchFunction| |POLYCAT-;squareFree;SF;32|) $)))))
+        ((QUOTE T) 
+         (QSETREFV $ 161 
+          (CONS (|dispatchFunction| |POLYCAT-;squareFree;SF;33|) $))))
+      (QSETREFV $ 169  
+       (CONS (|dispatchFunction| |POLYCAT-;squareFreePart;2S;34|) $))
+      (QSETREFV $ 171 
+       (CONS (|dispatchFunction| |POLYCAT-;content;SVarSetS;35|) $))
+      (QSETREFV $ 177 
+       (CONS (|dispatchFunction| |POLYCAT-;primitivePart;2S;36|) $))
+      (QSETREFV $ 180 
+       (CONS (|dispatchFunction| |POLYCAT-;primitivePart;SVarSetS;37|) $)))))
+    (COND 
+     ((|testBitVector| |pv$| 15)
+      (PROGN 
+       (QSETREFV $ 183 (CONS (|dispatchFunction| |POLYCAT-;<;2SB;38|) $))
+       (COND 
+        ((|testBitVector| |pv$| 8)
+         (COND 
+          ((|testBitVector| |pv$| 7)
+           (QSETREFV $ 189 
+            (CONS 
+             (|dispatchFunction| |POLYCAT-;patternMatch;SP2Pmr;39|)
+             $))))))
+       (COND
+        ((|testBitVector| |pv$| 6)
+         (COND 
+         ((|testBitVector| |pv$| 5)
+          (QSETREFV $ 195 
+           (CONS 
+            (|dispatchFunction| |POLYCAT-;patternMatch;SP2Pmr;40|)
+            $)))))))))
+    (COND 
+     ((|testBitVector| |pv$| 12)
+      (COND 
+       ((|testBitVector| |pv$| 11)
+        (QSETREFV $ 202 
+         (CONS (|dispatchFunction| |POLYCAT-;convert;SP;41|) $))))))
+    (COND 
+     ((|testBitVector| |pv$| 10)
+      (COND 
+       ((|testBitVector| |pv$| 9)
+        (QSETREFV $ 209 
+         (CONS (|dispatchFunction| |POLYCAT-;convert;SP;42|) $))))))
+    (COND
+     ((|testBitVector| |pv$| 14)
+      (COND 
+       ((|testBitVector| |pv$| 13)
+         (QSETREFV $ 217
+          (CONS (|dispatchFunction| |POLYCAT-;convert;SIf;43|) $))))))
+    $)))) 
+
+(MAKEPROP
+ (QUOTE |PolynomialCategory&|)
+ (QUOTE |infovec|)
+ (LIST (QUOTE
+  #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) (|local| |#3|)
+    (|local| |#4|) (|Equation| 6) (0 . |lhs|) (|Union| 9 (QUOTE "failed"))
+    (5 . |retractIfCan|) (10 . |retract|) (15 . |rhs|) (|List| 9) (|List| $)
+    (20 . |eval|) (|List| 221) |POLYCAT-;eval;SLS;1| (27 . |Zero|)
+    (31 . |Zero|) (|Boolean|) (35 . =) (41 . |leadingMonomial|)
+    (46 . |reductum|) |POLYCAT-;monomials;SL;2| (51 . |monomials|)
+    (|Union| 17 (QUOTE "failed")) |POLYCAT-;isPlus;SU;3| (56 . |variables|)
+    (61 . |monomial?|) (66 . |One|) (70 . |One|) (|NonNegativeInteger|)
+    (74 . |degree|) (80 . |monomial|) (87 . |leadingCoefficient|) (92 . =)
+    (98 . |coerce|) |POLYCAT-;isTimes;SU;4| (103 . |mainVariable|)
+    (|Record| (|:| |var| 9) (|:| |exponent| 35))
+    (|Union| 43 (QUOTE "failed")) |POLYCAT-;isExpt;SU;5|
+    (|SparseUnivariatePolynomial| $) (108 . |univariate|)
+    (|SparseUnivariatePolynomial| 6) (114 . |coefficient|)
+    |POLYCAT-;coefficient;SVarSetNniS;6| (|List| 35) (120 . |coefficient|)
+    |POLYCAT-;coefficient;SLLS;7| (127 . |monomial|)
+    |POLYCAT-;monomial;SLLS;8| (134 . |coerce|)
+    |POLYCAT-;retract;SVarSet;9| |POLYCAT-;retractIfCan;SU;10|
+    (139 . |degree|) (144 . |monomial|) |POLYCAT-;primitiveMonomials;SL;12| 
+    (150 . |ground?|) (155 . |Zero|) (159 . =) (165 . |degree|) 
+    (170 . |leadingCoefficient|) (175 . |totalDegree|) (180 . |reductum|)
+    |POLYCAT-;totalDegree;SNni;13| (185 . |member?|) (191 . |totalDegree|) 
+    |POLYCAT-;totalDegree;SLNni;14| (197 . |resultant|) (203 . |resultant|)
+    (210 . |discriminant|) (215 . |discriminant|) (221 . |primitiveMonomials|)
+    (|List| 6) (226 . |concat|) (231 . |removeDuplicates!|) (|Vector| 7)
+    (236 . |new|) (|Integer|) (242 . |minIndex|) (247 . |coefficient|)
+    (253 . |qsetelt!|) (|List| 220) (|Matrix| 7) (260 . |matrix|)
+    (|List| 78) (|Matrix| 6) (265 . |listOfLists|) (270 . |vertConcat|)
+    (|Matrix| $) (276 . |reducedSystem|) (|Vector| 6) (281 . |entries|)
+    (286 . |concat|) (292 . |concat|) 
+    (|Record| (|:| |mat| 88) (|:| |vec| 81)) (|Vector| $)
+    (298 . |reducedSystem|) (|GeneralPolynomialGcdPackage| 8 9 7 6)
+    (304 . |gcdPolynomial|) (310 . |gcdPolynomial|)
+    (|Union| 107 (QUOTE "failed")) (|List| 48)
+    (|PolynomialFactorizationByRecursion| 7 8 9 6) 
+    (316 . |solveLinearPolynomialEquationByRecursion|)
+    (|Union| 111 (QUOTE "failed")) (|List| 46)
+    (322 . |solveLinearPolynomialEquation|) (|Factored| 48)
+    (328 . |factorByRecursion|) (|Factored| 46) (333 . |factorPolynomial|)
+    (338 . |factorSquareFreeByRecursion|)
+    (343 . |factorSquareFreePolynomial|) (|Factored| $) (348 . |factor|)
+    (|Factored| 7) (353 . |unit|) 
+    (|Union| (QUOTE "nil") (QUOTE "sqfr") (QUOTE "irred") (QUOTE "prime"))
+    (|Record| (|:| |flg| 123) (|:| |fctr| 7) (|:| |xpnt| 83))
+    (|List| 124) (358 . |factorList|)
+    (|Record| (|:| |flg| 123) (|:| |fctr| 6) (|:| |xpnt| 83))
+    (|List| 127) (|Factored| 6) (363 . |makeFR|) (369 . |unit|)
+    (374 . |multivariate|) 
+    (|Record| (|:| |flg| 123) (|:| |fctr| 48) (|:| |xpnt| 83))
+    (|List| 133) (380 . |factorList|) (385 . |factor|) (390 . |transpose|)
+    (395 . |characteristic|) (399 . |setUnion|) (405 . |degree|)
+    (|Union| $ (QUOTE "failed")) (411 . |exquo|) (417 . |ground|)
+    (422 . |transpose|) (|Union| 101 (QUOTE "failed")) (427 . |conditionP|)
+    (432 . |elt|) (438 . *) (444 . +) (450 . |conditionP|)
+    (455 . |charthRoot|) (460 . |charthRoot|) (465 . |Zero|)
+    (469 . |coefficient|) (476 . -) 
+    (|Record| (|:| |quotient| $) (|:| |remainder| $))
+    (482 . |monicDivide|) |POLYCAT-;monicDivide;2SVarSetR;30|
+    (|MultivariateSquareFree| 8 9 7 6) (488 . |squareFree|)
+    (493 . |squareFree|) (|PolynomialSquareFree| 9 8 7 6)
+    (498 . |squareFree|) (503 . |squareFree|) (508 . |unit|)
+    (|Record| (|:| |factor| 6) (|:| |exponent| 83)) (|List| 166)
+    (513 . |factors|) (518 . |squareFreePart|) (523 . |content|)
+    (528 . |content|) (534 . |zero?|) (539 . |content|) (544 . |exquo|)
+    (|Record| (|:| |unit| $) (|:| |canonical| $) (|:| |associate| $))
+    (550 . |unitNormal|) (555 . |primitivePart|) (560 . |content|)
+    (566 . |exquo|) (572 . |primitivePart|) (578 . <) (584 . <) (590 . <)
+    (|PatternMatchResult| 83 6) (|Pattern| 83)
+    (|PatternMatchPolynomialCategory| 83 8 9 7 6) (596 . |patternMatch|)
+    (|PatternMatchResult| 83 $) (603 . |patternMatch|)
+    (|PatternMatchResult| (|Float|) 6) (|Pattern| (|Float|))
+    (|PatternMatchPolynomialCategory| (|Float|) 8 9 7 6) 
+    (610 . |patternMatch|) (|PatternMatchResult| (|Float|) $)
+    (617 . |patternMatch|) (624 . |convert|) (629 . |convert|)
+    (|Mapping| 185 9) (|Mapping| 185 7)
+    (|PolynomialCategoryLifting| 8 9 7 6 185) (634 . |map|)
+    (641 . |convert|) (646 . |convert|) (651 . |convert|) (|Mapping| 191 9)
+    (|Mapping| 191 7) (|PolynomialCategoryLifting| 8 9 7 6 191)
+    (656 . |map|) (663 . |convert|) (|InputForm|) (668 . |convert|)
+    (673 . |convert|) (|Mapping| 210 9) (|Mapping| 210 7)
+    (|PolynomialCategoryLifting| 8 9 7 6 210) (678 . |map|)
+    (685 . |convert|) (|Record| (|:| |mat| 219) (|:| |vec| (|Vector| 83)))
+    (|Matrix| 83) (|List| 7) (|Equation| $) (|Union| 83 (QUOTE "failed"))
+    (|Union| 224 (QUOTE "failed")) (|Fraction| 83)
+    (|Union| 7 (QUOTE "failed"))))
+  (QUOTE #(|totalDegree| 690 |squareFreePart| 701 |squareFree| 706 
+   |solveLinearPolynomialEquation| 711 |retractIfCan| 717 |retract| 722 
+   |resultant| 727 |reducedSystem| 734 |primitivePart| 745 
+   |primitiveMonomials| 756 |patternMatch| 761 |monomials| 775 
+   |monomial| 780 |monicDivide| 787 |isTimes| 794 |isPlus| 799 
+   |isExpt| 804 |gcdPolynomial| 809 |factorSquareFreePolynomial| 815 
+   |factorPolynomial| 820 |factor| 825 |eval| 830 |discriminant| 836 
+   |convert| 842 |content| 857 |conditionP| 863 |coefficient| 868 
+   |charthRoot| 882 < 887))
+  (QUOTE NIL)
+  (CONS (|makeByteWordVec2| 1 (QUOTE NIL))
+   (CONS (QUOTE #())
+    (CONS (QUOTE #())
+     (|makeByteWordVec2| 217 (QUOTE
+      (1 10 6 0 11 1 6 12 0 13 1 6 9 0 14 1 10 6 0 15 3 6 0 0 16 17 18 0 6 0
+       21 0 7 0 22 2 6 23 0 0 24 1 6 0 0 25 1 6 0 0 26 1 6 17 0 28 1 6 16 0
+       31 1 6 23 0 32 0 6 0 33 0 7 0 34 2 6 35 0 9 36 3 6 0 0 9 35 37 1 6 7
+       0 38 2 7 23 0 0 39 1 6 0 7 40 1 6 12 0 42 2 6 46 0 9 47 2 48 6 0 35
+       49 3 6 0 0 16 51 52 3 6 0 0 16 51 54 1 6 0 9 56 1 6 8 0 59 2 6 0 7 8
+       60 1 6 23 0 62 0 48 0 63 2 48 23 0 0 64 1 48 35 0 65 1 48 6 0 66 1 6
+       35 0 67 1 48 0 0 68 2 16 23 9 0 70 2 6 35 0 16 71 2 48 6 0 0 73 3 0
+       0 0 0 9 74 1 48 6 0 75 2 0 0 0 9 76 1 6 17 0 77 1 78 0 17 79 1 78 0
+       0 80 2 81 0 35 7 82 1 81 83 0 84 2 6 7 0 8 85 3 81 7 0 83 7 86 1 88
+       0 87 89 1 91 90 0 92 2 88 0 0 0 93 1 0 88 94 95 1 96 78 0 97 2 78 0
+       0 0 98 2 81 0 0 0 99 2 0 100 94 101 102 2 103 48 48 48 104 2 0 46 46
+       46 105 2 108 106 107 48 109 2 0 110 111 46 112 1 108 113 48 114 1 0
+       115 46 116 1 108 113 48 117 1 0 115 46 118 1 7 119 0 120 1 121 7 0
+       122 1 121 125 0 126 2 129 0 6 128 130 1 113 48 0 131 2 6 0 46 9 132
+       1 113 134 0 135 1 0 119 0 136 1 91 0 0 137 0 6 35 138 2 78 0 0 0 139
+       2 6 51 0 16 140 2 83 141 0 0 142 1 6 7 0 143 1 88 0 0 144 1 7 145 94
+       146 2 81 7 0 83 147 2 6 0 0 0 148 2 6 0 0 0 149 1 0 145 94 150 1 7
+       141 0 151 1 0 141 0 152 0 8 0 153 3 6 0 0 9 35 154 2 6 0 0 0 155 2
+       48 156 0 0 157 1 159 129 6 160 1 0 119 0 161 1 162 129 6 163 1 6 119
+       0 164 1 129 6 0 165 1 129 167 0 168 1 0 0 0 169 1 48 6 0 170 2 0 0 0
+       9 171 1 6 23 0 172 1 6 7 0 173 2 6 141 0 7 174 1 6 175 0 176 1 0 0 0
+       177 2 6 0 0 9 178 2 6 141 0 0 179 2 0 0 0 9 180 2 8 23 0 0 181 2 7 23
+       0 0 182 2 0 23 0 0 183 3 186 184 6 185 184 187 3 0 188 0 185 188 189
+       3 192 190 6 191 190 193 3 0 194 0 191 194 195 1 9 185 0 196 1 7 185
+       0 197 3 200 185 198 199 6 201 1 0 185 0 202 1 9 191 0 203 1 7 191 0
+       204 3 207 191 205 206 6 208 1 0 191 0 209 1 9 210 0 211 1 7 210 0
+       212 3 215 210 213 214 6 216 1 0 210 0 217 2 0 35 0 16 72 1 0 35 0 69
+       1 0 0 0 169 1 0 119 0 161 2 0 110 111 46 112 1 0 12 0 58 1 0 9 0 57
+       3 0 0 0 0 9 74 1 0 88 94 95 2 0 100 94 101 102 2 0 0 0 9 180 1 0 0 0
+       177 1 0 17 0 61 3 0 188 0 185 188 189 3 0 194 0 191 194 195 1 0 17 0
+       27 3 0 0 0 16 51 55 3 0 156 0 0 9 158 1 0 29 0 41 1 0 29 0 30 1 0 44
+       0 45 2 0 46 46 46 105 1 0 115 46 118 1 0 115 46 116 1 0 119 0 136 2
+       0 0 0 19 20 2 0 0 0 9 76 1 0 210 0 217 1 0 185 0 202 1 0 191 0 209 2
+       0 0 0 9 171 1 0 145 94 150 3 0 0 0 16 51 53 3 0 0 0 9 35 50 1 0 141
+       0 152 2 0 23 0 0 183))))))
+  (QUOTE |lookupComplete|))) 
+
+@
 \section{RCAGG.lsp BOOTSTRAP}
 {\bf RCAGG} depends on a chain of files. We need to break this cycle to build
 the algebra. So we keep a cached copy of the translated {\bf RCAGG}
@@ -33070,6 +35714,7 @@ Note that this code is not included in the generated catdef.spad file.
 <<category PDRING PartialDifferentialRing>>
 <<category PFECAT PolynomialFactorizationExplicit>>
 <<category PID PrincipalIdealDomain>>
+<<category POLYCAT PolynomialCategory>>
 <<category PRIMCAT PrimitiveFunctionCategory>>
 <<category PRQAGG PriorityQueueAggregate>>
 <<category QUAGG QueueAggregate>>
@@ -33200,6 +35845,7 @@ digraph dotabb {
 <<PDRING.dotabb>>
 <<PFECAT.dotabb>>
 <<PID.dotabb>>
+<<POLYCAT.dotabb>>
 <<PRIMCAT.dotabb>>
 <<PRQAGG.dotabb>>
 <<QUAGG.dotabb>>
@@ -33333,6 +35979,7 @@ digraph dotfull {
 <<PDRING.dotfull>>
 <<PFECAT.dotfull>>
 <<PID.dotfull>>
+<<POLYCAT.dotfull>>
 <<PRIMCAT.dotfull>>
 <<PRQAGG.dotfull>>
 <<QUAGG.dotfull>>
diff --git a/books/ps/v102fullypatternmatchable.ps b/books/ps/v102fullypatternmatchable.ps
new file mode 100644
index 0000000..68f2efc
--- /dev/null
+++ b/books/ps/v102fullypatternmatchable.ps
@@ -0,0 +1,335 @@
+%!PS-Adobe-2.0
+%%Creator: dot version 2.8 (Thu Sep 14 20:34:11 UTC 2006)
+%%For: (root) root
+%%Title: pic
+%%Pages: (atend)
+%%BoundingBox: 36 36 234 224
+%%EndComments
+save
+%%BeginProlog
+/DotDict 200 dict def
+DotDict begin
+
+/setupLatin1 {
+mark
+/EncodingVector 256 array def
+ EncodingVector 0
+
+ISOLatin1Encoding 0 255 getinterval putinterval
+EncodingVector 45 /hyphen put
+
+% Set up ISO Latin 1 character encoding
+/starnetISO {
+        dup dup findfont dup length dict begin
+        { 1 index /FID ne { def }{ pop pop } ifelse
+        } forall
+        /Encoding EncodingVector def
+        currentdict end definefont
+} def
+/Times-Roman starnetISO def
+/Times-Italic starnetISO def
+/Times-Bold starnetISO def
+/Times-BoldItalic starnetISO def
+/Helvetica starnetISO def
+/Helvetica-Oblique starnetISO def
+/Helvetica-Bold starnetISO def
+/Helvetica-BoldOblique starnetISO def
+/Courier starnetISO def
+/Courier-Oblique starnetISO def
+/Courier-Bold starnetISO def
+/Courier-BoldOblique starnetISO def
+cleartomark
+} bind def
+
+%%BeginResource: procset graphviz 0 0
+/coord-font-family /Times-Roman def
+/default-font-family /Times-Roman def
+/coordfont coord-font-family findfont 8 scalefont def
+
+/InvScaleFactor 1.0 def
+/set_scale {
+	dup 1 exch div /InvScaleFactor exch def
+	dup scale
+} bind def
+
+% styles
+/solid { [] 0 setdash } bind def
+/dashed { [9 InvScaleFactor mul dup ] 0 setdash } bind def
+/dotted { [1 InvScaleFactor mul 6 InvScaleFactor mul] 0 setdash } bind def
+/invis {/fill {newpath} def /stroke {newpath} def /show {pop newpath} def} bind def
+/bold { 2 setlinewidth } bind def
+/filled { } bind def
+/unfilled { } bind def
+/rounded { } bind def
+/diagonals { } bind def
+
+% hooks for setting color 
+/nodecolor { sethsbcolor } bind def
+/edgecolor { sethsbcolor } bind def
+/graphcolor { sethsbcolor } bind def
+/nopcolor {pop pop pop} bind def
+
+/beginpage {	% i j npages
+	/npages exch def
+	/j exch def
+	/i exch def
+	/str 10 string def
+	npages 1 gt {
+		gsave
+			coordfont setfont
+			0 0 moveto
+			(\() show i str cvs show (,) show j str cvs show (\)) show
+		grestore
+	} if
+} bind def
+
+/set_font {
+	findfont exch
+	scalefont setfont
+} def
+
+% draw aligned label in bounding box aligned to current point
+/alignedtext {			% width adj text
+	/text exch def
+	/adj exch def
+	/width exch def
+	gsave
+		width 0 gt {
+			text stringwidth pop adj mul 0 rmoveto
+		} if
+		[] 0 setdash
+		text show
+	grestore
+} def
+
+/boxprim {				% xcorner ycorner xsize ysize
+		4 2 roll
+		moveto
+		2 copy
+		exch 0 rlineto
+		0 exch rlineto
+		pop neg 0 rlineto
+		closepath
+} bind def
+
+/ellipse_path {
+	/ry exch def
+	/rx exch def
+	/y exch def
+	/x exch def
+	matrix currentmatrix
+	newpath
+	x y translate
+	rx ry scale
+	0 0 1 0 360 arc
+	setmatrix
+} bind def
+
+/endpage { showpage } bind def
+/showpage { } def
+
+/layercolorseq
+	[	% layer color sequence - darkest to lightest
+		[0 0 0]
+		[.2 .8 .8]
+		[.4 .8 .8]
+		[.6 .8 .8]
+		[.8 .8 .8]
+	]
+def
+
+/layerlen layercolorseq length def
+
+/setlayer {/maxlayer exch def /curlayer exch def
+	layercolorseq curlayer 1 sub layerlen mod get
+	aload pop sethsbcolor
+	/nodecolor {nopcolor} def
+	/edgecolor {nopcolor} def
+	/graphcolor {nopcolor} def
+} bind def
+
+/onlayer { curlayer ne {invis} if } def
+
+/onlayers {
+	/myupper exch def
+	/mylower exch def
+	curlayer mylower lt
+	curlayer myupper gt
+	or
+	{invis} if
+} def
+
+/curlayer 0 def
+
+%%EndResource
+%%EndProlog
+%%BeginSetup
+14 default-font-family set_font
+1 setmiterlimit
+% /arrowlength 10 def
+% /arrowwidth 5 def
+
+% make sure pdfmark is harmless for PS-interpreters other than Distiller
+/pdfmark where {pop} {userdict /pdfmark /cleartomark load put} ifelse
+% make '<<' and '>>' safe on PS Level 1 devices
+/languagelevel where {pop languagelevel}{1} ifelse
+2 lt {
+    userdict (<<) cvn ([) cvn load put
+    userdict (>>) cvn ([) cvn load put
+} if
+
+%%EndSetup
+%%Page: 1 1
+%%PageBoundingBox: 36 36 234 224
+%%PageOrientation: Portrait
+gsave
+36 36 198 188 boxprim clip newpath
+36 36 translate
+0 0 1 beginpage
+1.0000 set_scale
+4 4 translate 0 rotate
+0.167 0.600 1.000 graphcolor
+0.167 0.600 1.000 graphcolor
+newpath -6 -6 moveto
+-6 186 lineto
+196 186 lineto
+196 -6 lineto
+closepath
+fill
+0.167 0.600 1.000 graphcolor
+newpath -6 -6 moveto
+-6 186 lineto
+196 186 lineto
+196 -6 lineto
+closepath
+stroke
+0.000 0.000 0.000 graphcolor
+14.00 /Times-Roman set_font
+% FullyPatternMatchable(a:Type)
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 190 180 moveto
+0 180 lineto
+0 144 lineto
+190 144 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 190 180 moveto
+0 180 lineto
+0 144 lineto
+190 144 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+8 157 moveto
+(FullyPatternMatchable\(a:Type\))
+[7.44 6.96 3.84 3.6 6.96 7.44 6.24 3.84 3.84 6.24 5.04 6.96 12.48 6.24 3.84 6 6.96 6.24 6.96 3.84 6.24 4.56 6.24 3.84 7.2 6.96 6.96 6.24 4.56]
+xshow
+end grestore
+end grestore
+% Type()
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 122 108 moveto
+68 108 lineto
+68 72 lineto
+122 72 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 122 108 moveto
+68 108 lineto
+68 72 lineto
+122 72 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+76 85 moveto
+(Type\(\))
+[7.2 6.96 6.96 6.24 4.56 4.56]
+xshow
+end grestore
+end grestore
+% FullyPatternMatchable(a:Type)->Type()
+newpath 95 144 moveto
+95 136 95 127 95 118 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 99 118 moveto
+95 108 lineto
+92 118 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 99 118 moveto
+95 108 lineto
+92 118 lineto
+closepath
+stroke
+end grestore
+% Category
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 129 36 moveto
+61 36 lineto
+61 0 lineto
+129 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 129 36 moveto
+61 36 lineto
+61 0 lineto
+129 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+69 13 moveto
+(Category)
+[9.36 6.24 3.84 6.24 6.96 6.96 5.04 6.96]
+xshow
+end grestore
+end grestore
+% Type()->Category
+newpath 95 72 moveto
+95 64 95 55 95 46 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 99 46 moveto
+95 36 lineto
+92 46 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 99 46 moveto
+95 36 lineto
+92 46 lineto
+closepath
+stroke
+end grestore
+endpage
+showpage
+grestore
+%%PageTrailer
+%%EndPage: 1
+%%Trailer
+%%Pages: 1
+end
+restore
+%%EOF
diff --git a/books/ps/v102polynomialcategory.ps b/books/ps/v102polynomialcategory.ps
new file mode 100644
index 0000000..305de5f
--- /dev/null
+++ b/books/ps/v102polynomialcategory.ps
@@ -0,0 +1,800 @@
+%!PS-Adobe-2.0
+%%Creator: dot version 2.8 (Thu Sep 14 20:34:11 UTC 2006)
+%%For: (root) root
+%%Title: pic
+%%Pages: (atend)
+%%BoundingBox: 36 36 1246 152
+%%EndComments
+save
+%%BeginProlog
+/DotDict 200 dict def
+DotDict begin
+
+/setupLatin1 {
+mark
+/EncodingVector 256 array def
+ EncodingVector 0
+
+ISOLatin1Encoding 0 255 getinterval putinterval
+EncodingVector 45 /hyphen put
+
+% Set up ISO Latin 1 character encoding
+/starnetISO {
+        dup dup findfont dup length dict begin
+        { 1 index /FID ne { def }{ pop pop } ifelse
+        } forall
+        /Encoding EncodingVector def
+        currentdict end definefont
+} def
+/Times-Roman starnetISO def
+/Times-Italic starnetISO def
+/Times-Bold starnetISO def
+/Times-BoldItalic starnetISO def
+/Helvetica starnetISO def
+/Helvetica-Oblique starnetISO def
+/Helvetica-Bold starnetISO def
+/Helvetica-BoldOblique starnetISO def
+/Courier starnetISO def
+/Courier-Oblique starnetISO def
+/Courier-Bold starnetISO def
+/Courier-BoldOblique starnetISO def
+cleartomark
+} bind def
+
+%%BeginResource: procset graphviz 0 0
+/coord-font-family /Times-Roman def
+/default-font-family /Times-Roman def
+/coordfont coord-font-family findfont 8 scalefont def
+
+/InvScaleFactor 1.0 def
+/set_scale {
+	dup 1 exch div /InvScaleFactor exch def
+	dup scale
+} bind def
+
+% styles
+/solid { [] 0 setdash } bind def
+/dashed { [9 InvScaleFactor mul dup ] 0 setdash } bind def
+/dotted { [1 InvScaleFactor mul 6 InvScaleFactor mul] 0 setdash } bind def
+/invis {/fill {newpath} def /stroke {newpath} def /show {pop newpath} def} bind def
+/bold { 2 setlinewidth } bind def
+/filled { } bind def
+/unfilled { } bind def
+/rounded { } bind def
+/diagonals { } bind def
+
+% hooks for setting color 
+/nodecolor { sethsbcolor } bind def
+/edgecolor { sethsbcolor } bind def
+/graphcolor { sethsbcolor } bind def
+/nopcolor {pop pop pop} bind def
+
+/beginpage {	% i j npages
+	/npages exch def
+	/j exch def
+	/i exch def
+	/str 10 string def
+	npages 1 gt {
+		gsave
+			coordfont setfont
+			0 0 moveto
+			(\() show i str cvs show (,) show j str cvs show (\)) show
+		grestore
+	} if
+} bind def
+
+/set_font {
+	findfont exch
+	scalefont setfont
+} def
+
+% draw aligned label in bounding box aligned to current point
+/alignedtext {			% width adj text
+	/text exch def
+	/adj exch def
+	/width exch def
+	gsave
+		width 0 gt {
+			text stringwidth pop adj mul 0 rmoveto
+		} if
+		[] 0 setdash
+		text show
+	grestore
+} def
+
+/boxprim {				% xcorner ycorner xsize ysize
+		4 2 roll
+		moveto
+		2 copy
+		exch 0 rlineto
+		0 exch rlineto
+		pop neg 0 rlineto
+		closepath
+} bind def
+
+/ellipse_path {
+	/ry exch def
+	/rx exch def
+	/y exch def
+	/x exch def
+	matrix currentmatrix
+	newpath
+	x y translate
+	rx ry scale
+	0 0 1 0 360 arc
+	setmatrix
+} bind def
+
+/endpage { showpage } bind def
+/showpage { } def
+
+/layercolorseq
+	[	% layer color sequence - darkest to lightest
+		[0 0 0]
+		[.2 .8 .8]
+		[.4 .8 .8]
+		[.6 .8 .8]
+		[.8 .8 .8]
+	]
+def
+
+/layerlen layercolorseq length def
+
+/setlayer {/maxlayer exch def /curlayer exch def
+	layercolorseq curlayer 1 sub layerlen mod get
+	aload pop sethsbcolor
+	/nodecolor {nopcolor} def
+	/edgecolor {nopcolor} def
+	/graphcolor {nopcolor} def
+} bind def
+
+/onlayer { curlayer ne {invis} if } def
+
+/onlayers {
+	/myupper exch def
+	/mylower exch def
+	curlayer mylower lt
+	curlayer myupper gt
+	or
+	{invis} if
+} def
+
+/curlayer 0 def
+
+%%EndResource
+%%EndProlog
+%%BeginSetup
+14 default-font-family set_font
+1 setmiterlimit
+% /arrowlength 10 def
+% /arrowwidth 5 def
+
+% make sure pdfmark is harmless for PS-interpreters other than Distiller
+/pdfmark where {pop} {userdict /pdfmark /cleartomark load put} ifelse
+% make '<<' and '>>' safe on PS Level 1 devices
+/languagelevel where {pop languagelevel}{1} ifelse
+2 lt {
+    userdict (<<) cvn ([) cvn load put
+    userdict (>>) cvn ([) cvn load put
+} if
+
+%%EndSetup
+%%Page: 1 1
+%%PageBoundingBox: 36 36 1246 152
+%%PageOrientation: Portrait
+gsave
+36 36 1210 116 boxprim clip newpath
+36 36 translate
+0 0 1 beginpage
+1.0000 set_scale
+4 4 translate 0 rotate
+0.167 0.600 1.000 graphcolor
+0.167 0.600 1.000 graphcolor
+newpath -6 -6 moveto
+-6 114 lineto
+1208 114 lineto
+1208 -6 lineto
+closepath
+fill
+0.167 0.600 1.000 graphcolor
+newpath -6 -6 moveto
+-6 114 lineto
+1208 114 lineto
+1208 -6 lineto
+closepath
+stroke
+0.000 0.000 0.000 graphcolor
+14.00 /Times-Roman set_font
+% PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)
+[ /Rect [ 373 72 799 108 ]
+  /Border [ 0 0 0 ]
+  /Action << /Subtype /URI /URI (bookvol10.2.pdf#nameddest=POLYCAT) >>
+  /Subtype /Link
+/ANN pdfmark
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 799 108 moveto
+373 108 lineto
+373 72 lineto
+799 72 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 799 108 moveto
+373 108 lineto
+373 72 lineto
+799 72 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+381 85 moveto
+(PolynomialCategory\(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet\))
+[7.44 6.96 3.6 6.96 6.96 6.96 10.8 3.84 6.24 3.84 9.36 6.24 3.84 6.24 6.96 6.96 5.04 6.96 4.56 6.24 3.84 9.36 3.84 6.96 6.96 3.6 6.96 3.84 10.08 4.56 6.96 6.24 4.8 6.24 6.96 9.84 6.96 6.24 3.84 3.84 6.24 6.96 12.48 6.96 6.96 6.96 3.84 6.96 7.68 6.96 6.96 3.6 6.24 3.84 10.08 4.56 6.96 6.24 4.8 6.24 6.96 7.68 6 3.84 4.56]
+xshow
+end grestore
+end grestore
+% PDRING...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 80 36 moveto
+0 36 lineto
+0 0 lineto
+80 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 80 36 moveto
+0 36 lineto
+0 0 lineto
+80 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+8 13 moveto
+(PDRING...)
+[7.68 10.08 9.36 4.56 9.84 10.08 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)->PDRING...
+newpath 373 78 moveto
+287 70 188 58 90 35 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 90 32 moveto
+80 33 lineto
+89 38 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 90 32 moveto
+80 33 lineto
+89 38 lineto
+closepath
+stroke
+end grestore
+% FAMR...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 164 36 moveto
+98 36 lineto
+98 0 lineto
+164 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 164 36 moveto
+98 36 lineto
+98 0 lineto
+164 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+106 13 moveto
+(FAMR...)
+[6.72 10.08 12.48 9.36 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)->FAMR...
+newpath 373 73 moveto
+311 65 243 54 174 36 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 175 33 moveto
+164 33 lineto
+173 39 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 175 33 moveto
+164 33 lineto
+173 39 lineto
+closepath
+stroke
+end grestore
+% EVALAB...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 264 36 moveto
+182 36 lineto
+182 0 lineto
+264 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 264 36 moveto
+182 36 lineto
+182 0 lineto
+264 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+189 13 moveto
+(EVALAB...)
+[8.64 8.4 10.08 8.64 10.08 9.36 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)->EVALAB...
+newpath 451 72 moveto
+399 63 337 52 274 36 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 275 33 moveto
+264 33 lineto
+273 39 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 275 33 moveto
+264 33 lineto
+273 39 lineto
+closepath
+stroke
+end grestore
+% IEVALAB...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 370 36 moveto
+282 36 lineto
+282 0 lineto
+370 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 370 36 moveto
+282 36 lineto
+282 0 lineto
+370 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+290 13 moveto
+(IEVALAB...)
+[4.56 8.64 8.4 10.08 8.64 10.08 9.36 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)->IEVALAB...
+newpath 512 72 moveto
+475 63 429 51 380 36 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 381 33 moveto
+370 33 lineto
+379 39 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 381 33 moveto
+370 33 lineto
+379 39 lineto
+closepath
+stroke
+end grestore
+% RETRACT...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 478 36 moveto
+388 36 lineto
+388 0 lineto
+478 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 478 36 moveto
+388 36 lineto
+388 0 lineto
+478 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+396 13 moveto
+(RETRACT...)
+[9.36 8.64 8.64 9.36 9.36 9.36 7.44 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)->RETRACT...
+newpath 547 72 moveto
+527 62 502 51 480 40 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 482 37 moveto
+471 36 lineto
+479 43 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 482 37 moveto
+471 36 lineto
+479 43 lineto
+closepath
+stroke
+end grestore
+% FLINEXP...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 578 36 moveto
+496 36 lineto
+496 0 lineto
+578 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 578 36 moveto
+496 36 lineto
+496 0 lineto
+578 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+503 13 moveto
+(FLINEXP...)
+[7.68 8.64 4.56 10.08 8.64 10.08 6.24 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)->FLINEXP...
+newpath 574 72 moveto
+568 64 561 54 555 44 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 558 42 moveto
+549 36 lineto
+552 46 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 558 42 moveto
+549 36 lineto
+552 46 lineto
+closepath
+stroke
+end grestore
+% ORDSET...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 676 36 moveto
+596 36 lineto
+596 0 lineto
+676 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 676 36 moveto
+596 36 lineto
+596 0 lineto
+676 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+603 13 moveto
+(ORDSET...)
+[10.08 9.36 10.08 7.68 8.64 7.44 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)->ORDSET...
+newpath 599 72 moveto
+604 64 611 54 617 44 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 620 46 moveto
+623 36 lineto
+614 42 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 620 46 moveto
+623 36 lineto
+614 42 lineto
+closepath
+stroke
+end grestore
+% GCDDOM...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 784 36 moveto
+694 36 lineto
+694 0 lineto
+784 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 784 36 moveto
+694 36 lineto
+694 0 lineto
+784 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+702 13 moveto
+(GCDDOM...)
+[10.08 9.36 10.08 10.08 10.08 12.48 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)->GCDDOM...
+newpath 625 72 moveto
+645 62 670 51 692 40 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 693 43 moveto
+701 36 lineto
+690 37 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 693 43 moveto
+701 36 lineto
+690 37 lineto
+closepath
+stroke
+end grestore
+% PFECAT...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 880 36 moveto
+802 36 lineto
+802 0 lineto
+880 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 880 36 moveto
+802 36 lineto
+802 0 lineto
+880 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+810 13 moveto
+(PFECAT...)
+[7.68 7.68 8.64 9.12 9.36 7.44 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)->PFECAT...
+newpath 662 72 moveto
+699 63 744 51 792 36 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 793 39 moveto
+802 33 lineto
+791 33 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 793 39 moveto
+802 33 lineto
+791 33 lineto
+closepath
+stroke
+end grestore
+% KONVERT...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 990 36 moveto
+898 36 lineto
+898 0 lineto
+990 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 990 36 moveto
+898 36 lineto
+898 0 lineto
+990 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+905 13 moveto
+(KONVERT...)
+[9.12 10.08 10.08 10.08 8.64 8.88 7.44 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)->KONVERT...
+newpath 709 72 moveto
+761 63 824 52 888 36 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 889 39 moveto
+898 33 lineto
+887 33 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 889 39 moveto
+898 33 lineto
+887 33 lineto
+closepath
+stroke
+end grestore
+% PATMAB...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 1092 36 moveto
+1008 36 lineto
+1008 0 lineto
+1092 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 1092 36 moveto
+1008 36 lineto
+1008 0 lineto
+1092 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+1015 13 moveto
+(PATMAB...)
+[6.48 9.36 8.64 12.48 10.08 9.36 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)->PATMAB...
+newpath 789 72 moveto
+853 64 925 53 998 36 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 999 39 moveto
+1008 34 lineto
+998 33 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 999 39 moveto
+1008 34 lineto
+998 33 lineto
+closepath
+stroke
+end grestore
+% COMRING...
+gsave 10 dict begin
+filled
+0.537 0.247 0.902 nodecolor
+0.537 0.247 0.902 nodecolor
+newpath 1202 36 moveto
+1110 36 lineto
+1110 0 lineto
+1202 0 lineto
+closepath
+fill
+0.537 0.247 0.902 nodecolor
+newpath 1202 36 moveto
+1110 36 lineto
+1110 0 lineto
+1202 0 lineto
+closepath
+stroke
+gsave 10 dict begin
+0.000 0.000 0.000 nodecolor
+1117 13 moveto
+(COMRING...)
+[9.12 10.08 12.48 9.36 4.56 9.84 10.08 3.6 3.6 3.6]
+xshow
+end grestore
+end grestore
+% PolynomialCategory(a:Ring,b:OrderedAbelianMonoidSup,c:OrderedSet)->COMRING...
+newpath 799 78 moveto
+889 70 996 58 1100 36 curveto
+stroke
+gsave 10 dict begin
+solid
+1 setlinewidth
+0.000 0.000 0.000 edgecolor
+newpath 1101 39 moveto
+1110 34 lineto
+1100 33 lineto
+closepath
+fill
+0.000 0.000 0.000 edgecolor
+newpath 1101 39 moveto
+1110 34 lineto
+1100 33 lineto
+closepath
+stroke
+end grestore
+endpage
+showpage
+grestore
+%%PageTrailer
+%%EndPage: 1
+%%Trailer
+%%Pages: 1
+end
+restore
+%%EOF




From MAILER-DAEMON Sun Oct 05 14:08:02 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KmY1S-0006yW-01
	for mharc-axiom-developer@gnu.org; Sun, 05 Oct 2008 14:08:02 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KmY1Q-0006yB-5I
	for axiom-developer@nongnu.org; Sun, 05 Oct 2008 14:08:00 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KmY1P-0006xy-1K
	for axiom-developer@nongnu.org; Sun, 05 Oct 2008 14:07:59 -0400
Received: from [199.232.76.173] (port=52479 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KmY1O-0006xv-Ue
	for axiom-developer@nongnu.org; Sun, 05 Oct 2008 14:07:58 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:39279
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KmY1O-0005LP-Eq
	for axiom-developer@nongnu.org; Sun, 05 Oct 2008 14:07:58 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m95I7or3005104;
	Sun, 5 Oct 2008 13:07:50 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m95I7oPG005101;
	Sun, 5 Oct 2008 13:07:50 -0500
Date: Sun, 5 Oct 2008 13:07:50 -0500
Message-Id: <200810051807.m95I7oPG005101@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20081004.01.tpd.patch (bookvol10.2 add UPOLYC,
	update attributes)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sun, 05 Oct 2008 18:08:00 -0000

UPOLYC was moved from polycat.spad.

Attribute decorations were added to all categories which show the
attributes exported and the attributes used.

<http://axiom-developer.org/axiom-website/patches.html#latest>



From MAILER-DAEMON Mon Oct 06 01:50:38 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KmizO-0001Z9-8U
	for mharc-axiom-developer@gnu.org; Mon, 06 Oct 2008 01:50:38 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KmizM-0001YF-Ap
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 01:50:36 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KmizJ-0001Xe-4N
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 01:50:35 -0400
Received: from [199.232.76.173] (port=32788 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KmizJ-0001Xa-0t
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 01:50:33 -0400
Received: from mx-7.zoominternet.net ([24.154.1.26]:55907
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KmizI-0001rt-Eb
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 01:50:32 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=scqaGIT91dsA:10 a=r9D4ewcIpNkA:10
	a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=QXw9akGHyYZAdcdilj8A:9 a=ZcbLqquUhyeYCkX7O38A:7
	a=ZxBexbzkmoucDsDN0ID7P1T2tL4A:4 a=ufO146cb3fEA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.45] ([24.154.1.45:40166] helo=pop-2.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 0D/A3-18577-217A9E84; Mon, 06 Oct 2008 01:50:10 -0400
Received: (qmail 9172 invoked from network); 6 Oct 2008 05:50:13 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-2.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 6 Oct 2008 05:50:13 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id m965nta13755;
	Mon, 6 Oct 2008 01:49:55 -0400
Date: Mon, 6 Oct 2008 01:49:55 -0400
Message-Id: <200810060549.m965nta13755@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: wilsons@start.ca
In-reply-to: <87prmml4h8.fsf@lattice.localdomain> (message from Stephen Wilson
	on Mon, 29 Sep 2008 23:03:47 -0400)
References: <873ajlmh9x.fsf@lattice.localdomain>
	<87prmml4h8.fsf@lattice.localdomain>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
Subject: [Axiom-developer] Re: Some code, if you are interested.
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 06 Oct 2008 05:50:36 -0000

Stephen,

I'm finally free of the constraints for a bit. I will look at what
you sent in detail.

Have you looked at clojure? I was very skeptical of this lisp-on-jvm
but he makes some very good points about scaling on multiple processors.
I think this topic will become important in future CAS systems and he
seems to have spent a good deal of time on that subject. I strongly
recommend reviewing the clojure for lisp videos by Bill Hickey. I think
he has some fundamentally useful ideas for exploiting parallelism which
could be reflected into Axiom.

Tim



From MAILER-DAEMON Mon Oct 06 02:04:05 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KmjCP-00062j-61
	for mharc-axiom-developer@gnu.org; Mon, 06 Oct 2008 02:04:05 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KmjCN-00062C-EL
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 02:04:03 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KmjCM-00061z-Co
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 02:04:02 -0400
Received: from [199.232.76.173] (port=54203 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KmjCM-00061w-7t
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 02:04:02 -0400
Received: from fg-out-1718.google.com ([72.14.220.154]:55423)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <ted.kosan@gmail.com>) id 1KmjCL-000698-HF
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 02:04:01 -0400
Received: by fg-out-1718.google.com with SMTP id l26so3482471fgb.8
	for <axiom-developer@nongnu.org>; Sun, 05 Oct 2008 23:04:00 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=gamma;
	h=domainkey-signature:received:received:message-id:date:from:to
	:subject:in-reply-to:mime-version:content-type
	:content-transfer-encoding:content-disposition:references;
	bh=5ghl57YhgpnSenaxugKl3wnmKTc7ZYrFhlpCZhcHa8w=;
	b=RGEHAN4y69WwwZgCcZkZUWhHvRmZd95tLcWHiPJqrwWRNsmGymnIFcaolp+INKLg5P
	piDp/fdqQdFQDFJbYiNgEp5hTUTmoOZAK95Fn8arkoEqXmXI/KZQW8w+bkem4cVHjfny
	ddES283Gp7yCvoxBAyaNeda4CL3iIL4yl6WBg=
DomainKey-Signature: a=rsa-sha1; c=nofws; d=gmail.com; s=gamma;
	h=message-id:date:from:to:subject:in-reply-to:mime-version
	:content-type:content-transfer-encoding:content-disposition
	:references;
	b=Pkt6CvaGrnR00utaR1m9o72Mv2XVIkwXF1gEIy4NvnYzQTXRTBzRmLDjIQeA2Hn6jl
	XeMYkJ0a/Ql5THRbVSkcVQYnaxlNVi6gC4vczGVa1G9ZqN3R6GaobU/DzhcGfIjuOPwq
	N1CKxwGHJ+UfPkvd2nQmgIn0T0tiOg04Xg478=
Received: by 10.187.227.5 with SMTP id e5mr922055far.63.1223273040222;
	Sun, 05 Oct 2008 23:04:00 -0700 (PDT)
Received: by 10.187.204.5 with HTTP; Sun, 5 Oct 2008 23:04:00 -0700 (PDT)
Message-ID: <9d9ff120810052304t23c4fa78y55606e3a0848c2ec@mail.gmail.com>
Date: Mon, 6 Oct 2008 02:04:00 -0400
From: "Ted Kosan" <ted.kosan@gmail.com>
To: axiom-developer@nongnu.org
Subject: Re: [Axiom-developer] Re: Some code, if you are interested.
In-Reply-To: <200810060549.m965nta13755@localhost.localdomain>
MIME-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline
References: <873ajlmh9x.fsf@lattice.localdomain>
	<87prmml4h8.fsf@lattice.localdomain>
	<200810060549.m965nta13755@localhost.localdomain>
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6 (newer, 2)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 06 Oct 2008 06:04:03 -0000

Tim wrote:

> Have you looked at clojure? I was very skeptical of this lisp-on-jvm
> but he makes some very good points about scaling on multiple processors.
> I think this topic will become important in future CAS systems and he
> seems to have spent a good deal of time on that subject. I strongly
> recommend reviewing the clojure for lisp videos by Bill Hickey. I think
> he has some fundamentally useful ideas for exploiting parallelism which
> could be reflected into Axiom.

I remember reading in the Axiom literature somewhere that Axiom was
designed so it could be ported to different Lisp implementations with
a reasonable amount of effort.  What are your thoughts on the
possibility of enabling Axiom to run on Clojure?

Ted



From MAILER-DAEMON Mon Oct 06 02:44:46 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Kmjpm-0002Wp-1d
	for mharc-axiom-developer@gnu.org; Mon, 06 Oct 2008 02:44:46 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Kmjpk-0002Wk-Hl
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 02:44:44 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Kmjph-0002UF-VM
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 02:44:43 -0400
Received: from [199.232.76.173] (port=41216 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Kmjph-0002U2-Rv
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 02:44:41 -0400
Received: from mx-8.zoominternet.net ([24.154.1.27]:46354
	helo=cm-2.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Kmjph-0001aK-I0
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 02:44:41 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=rGYLs91JmmUA:10 a=EWcQ9U467JkA:10
	a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=libPhnQhDKwI5vy_MagA:9 a=T35D7siFMtZG1g_BfGUA:7
	a=LkC2a-45HMx7TuLz-dTnb8H1TMYA:4 a=WcGY3-TIXCwA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.46] ([24.154.1.46:51759] helo=pop-3.zoominternet.net)
	by mx-8.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id E3/6D-29996-4C3B9E84; Mon, 06 Oct 2008 02:44:20 -0400
Received: (qmail 27881 invoked from network); 6 Oct 2008 06:44:21 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-3.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <axiom-developer@nongnu.org>; 6 Oct 2008 06:44:21 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id m966i7B13795;
	Mon, 6 Oct 2008 02:44:07 -0400
Date: Mon, 6 Oct 2008 02:44:07 -0400
Message-Id: <200810060644.m966i7B13795@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: ted.kosan@gmail.com
In-reply-to: <9d9ff120810052304t23c4fa78y55606e3a0848c2ec@mail.gmail.com>
	(ted.kosan@gmail.com)
Subject: Re: [Axiom-developer] Re: Some code, if you are interested.
References: <873ajlmh9x.fsf@lattice.localdomain>
	<87prmml4h8.fsf@lattice.localdomain>
	<200810060549.m965nta13755@localhost.localdomain>
	<9d9ff120810052304t23c4fa78y55606e3a0848c2ec@mail.gmail.com>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 06 Oct 2008 06:44:45 -0000

>> Have you looked at clojure? I was very skeptical of this lisp-on-jvm
>> but he makes some very good points about scaling on multiple processors.
>> I think this topic will become important in future CAS systems and he
>> seems to have spent a good deal of time on that subject. I strongly
>> recommend reviewing the clojure for lisp videos by Bill Hickey. I think
>> he has some fundamentally useful ideas for exploiting parallelism which
>> could be reflected into Axiom.
>
>I remember reading in the Axiom literature somewhere that Axiom was
>designed so it could be ported to different Lisp implementations with
>a reasonable amount of effort.  What are your thoughts on the
>possibility of enabling Axiom to run on Clojure?

I spent a few hours watching Hickey's videos and some time exploring
his immutable data structures. I have downloaded but not yet run clojure.

The key interesting idea of Clojure is that the system scales well
when given multiple cores. I feel this is important in the long term
for Axiom.

I can see several possible paths of interest. 

First, some areas of future planned coverage for Axiom include 
areas where algorithms do not exist, only procedures which are not
guaranteed to terminate. This occurs in my other project (Magnus)
which involves the area of infinite group theory. In that project
the user interface allows several procedures to compete for CPU
time and, if one succeeds, to poison the others. This scales well
for multicore machines. Moving those procedures into Axiom is
blocked on the multi-thread issue so far.

Second, there are "embarassingly parallel" tasks such as matrix
multiplication that can give scaling within algorithms.

Third, there are multi-branch algorithms in an area called Provisos
where I've done a lot of research. The basic idea is that you decorate
each intermediate expression with "such that" conditions, which I term
"provisos". For instance 1/x provided x != 0. At each step of the
computation additional provisos might get added. My research approach
to this uses symbolic intervals so that
   1/x provided x != 0
becomes
   1/x for x in [-oo..0)
   1/x for x in [0..0]
   1/x for x in (0..+oo]
which then becomes 3 independent computations. Each new intervaled
proviso continues to fork into independent computations. As answers
are reached the proviso forks are rejoined based on their intervals
of validity. In general, this leads to natural parallelism. Since
Clojure has immutable data structures the intermediate results can
be naturally shared.

Probabilistic algorithms is another area where parallelism can be
exploited.

Finally, within Axiom, in the 30 year horizon plan is the crystal
interface which presents multiple, connected facets that are 
dependent views of the same problem (one facet has documentation;
another source code; a third, the running state; a fourth, the
related internet papers, etc.) Each facet is maintained on a separate
process/processor working off a common knowledge network data structure.



Given those thoughts I'm interested in Clojure. While I'm very skeptical
of "another lisp" in general it seems that Hickey has tried to stay close
to the common lisp language where practical.

Clojure raises a few questions. What is the expected Lisp API that
Axiom requires? I know Axiom uses tail recursion which Clojure does
not yet have but there is some promise that something is "in the pipe".
And Clojure provides the recur mechanism.

How would the parallel nature be exported from the lisp upward into Spad?

Is the performance hit for normal programs too great relative to the
performance gain on parallel work?

Can I just implement Hickey's immutable structures and get the same
benefit?




As you can see I'm in the process of writing down the details of the
system internals, including some rewrites of the compiler/interpreter
code into common lisp. I hope to find time to play with Clojure enough
to be able to architect the ideas cleanly into the reorganization.

Tim



From MAILER-DAEMON Mon Oct 06 03:22:09 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KmkPx-0005w2-R2
	for mharc-axiom-developer@gnu.org; Mon, 06 Oct 2008 03:22:09 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KmkPw-0005vr-3d
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 03:22:08 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KmkPu-0005vY-OA
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 03:22:07 -0400
Received: from [199.232.76.173] (port=33914 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KmkPu-0005vV-JG
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 03:22:06 -0400
Received: from mx20.gnu.org ([199.232.41.8]:5212)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <daly@axiom-developer.org>)
	id 1KmkPu-0000nh-8r
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 03:22:06 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]
	helo=axiom-developer.org) by mx20.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KmkPt-0004Xb-JX
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 03:22:05 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m967Lxr3008801;
	Mon, 6 Oct 2008 02:21:59 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m967LxWV008798;
	Mon, 6 Oct 2008 02:21:59 -0500
Date: Mon, 6 Oct 2008 02:21:59 -0500
Message-Id: <200810060721.m967LxWV008798@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by mx20.gnu.org: Linux 2.6? (barebone, rare!)
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6,
	seldom 2.4 (older, 4)
Cc: 
Subject: [Axiom-developer] 20081005.01.tpd.patch (bookvol10.2 add categories)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 06 Oct 2008 07:22:08 -0000

Addded categories:
  SegmentCategory
  FullyEvalableOver
  SegmentExpansionCategory
  SExpressionCategory
  ThreeSpaceCategory
  BinaryTreeCategory
  LazyStreamAggregate

See:
<http://axiom-developer.org/axiom-website/patches.html#latest>

Tim




From MAILER-DAEMON Mon Oct 06 14:39:08 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Kmuz6-00088j-Ga
	for mharc-axiom-developer@gnu.org; Mon, 06 Oct 2008 14:39:08 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Kmuz3-000885-Vt
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 14:39:06 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Kmuz3-00087g-2p
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 14:39:05 -0400
Received: from [199.232.76.173] (port=39610 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Kmuz2-00087X-SE
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 14:39:04 -0400
Received: from matrix.start.ca ([204.101.248.1]:37799)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <wilsons@start.ca>) id 1Kmuz2-00068l-4p
	for axiom-developer@nongnu.org; Mon, 06 Oct 2008 14:39:04 -0400
Received: from lattice.localdomain (pool7-086.adsl.user.start.ca
	[207.236.142.86])
	by matrix.start.ca (8.13.6/8.12.11) with ESMTP id m96Ictlc004309;
	Mon, 6 Oct 2008 14:38:55 -0400
To: daly@axiom-developer.org
Subject: Re: [Axiom-developer] Re: Some code, if you are interested.
References: <873ajlmh9x.fsf@lattice.localdomain>
	<87prmml4h8.fsf@lattice.localdomain>
	<200810060549.m965nta13755@localhost.localdomain>
From: Stephen Wilson <wilsons@start.ca>
Date: Mon, 06 Oct 2008 14:38:59 -0400
In-Reply-To: <200810060549.m965nta13755@localhost.localdomain> (root's message
	of "Mon\, 6 Oct 2008 01\:49\:55 -0400")
Message-ID: <871vytpnzw.fsf@lattice.localdomain>
User-Agent: Gnus/5.11 (Gnus v5.11) Emacs/22.2 (gnu/linux)
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.4-2.6
Cc: axiom-developer@nongnu.org
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 06 Oct 2008 18:39:06 -0000

root <daly@axiom-developer.org> writes:
> I'm finally free of the constraints for a bit. I will look at what
> you sent in detail.

Looking forward to your thoughts!  

I submitted a project proposal to the Savannah folks but it may take time to
process.  Main effort at the moment is to get a general overview/tutorial
written.  The code needs to be cleaned up a lot, and documentation merged as the
basic structure is starting to settle down.

> Have you looked at clojure? I was very skeptical of this lisp-on-jvm but he
> makes some very good points about scaling on multiple processors.  I think
> this topic will become important in future CAS systems and he seems to have
> spent a good deal of time on that subject.  I strongly recommend reviewing the
> clojure for lisp videos by Bill Hickey. I think he has some fundamentally
> useful ideas for exploiting parallelism which

No, I have not looked at the system in any detail.  From what I recall it is
based on software transactional memory. 

But never have I used systems like this for any real work, and cannot claim any
deep understanding.  There seems to be a lot of work going on in this area.

I was going to write down a few more thoughts but should probably wait until I
am more informed on STM.  My initial feeling is that both traditional threads
(locks, condition variables) and STM could/should be made available.

Steve








From MAILER-DAEMON Tue Oct 07 13:20:44 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KnGEm-00018K-3B
	for mharc-axiom-developer@gnu.org; Tue, 07 Oct 2008 13:20:44 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KnGEk-00017i-Iv
	for axiom-developer@nongnu.org; Tue, 07 Oct 2008 13:20:42 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KnGEi-00016o-Iy
	for axiom-developer@nongnu.org; Tue, 07 Oct 2008 13:20:41 -0400
Received: from [199.232.76.173] (port=52652 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KnGEi-00016a-C5
	for axiom-developer@nongnu.org; Tue, 07 Oct 2008 13:20:40 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:59452
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KnGEh-0008WL-Vc
	for axiom-developer@nongnu.org; Tue, 07 Oct 2008 13:20:40 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m97HKbr3003380;
	Tue, 7 Oct 2008 12:20:37 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m97HKb4U003377;
	Tue, 7 Oct 2008 12:20:37 -0500
Date: Tue, 7 Oct 2008 12:20:37 -0500
Message-Id: <200810071720.m97HKb4U003377@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20081006.01.tpd.patch (bookvol10.2 add categories)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 07 Oct 2008 17:20:42 -0000

Added to bookvol10.2:
   FortranProgramCategory
   FortranFunctionCategory
   FortranMatrixCategory
   FortranMatrixFunctionCategory
   FortranVectorCategory
   FortranVectorFunctionCategory
   FortranMachineTypeCategory
   LeftAlgebra

See:
<http://axiom-developer.org/axiom-website/patches.html#latest>




From MAILER-DAEMON Wed Oct 08 14:59:39 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KneG3-0006PG-9w
	for mharc-axiom-developer@gnu.org; Wed, 08 Oct 2008 14:59:39 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KneG0-0006Nm-Hr
	for axiom-developer@nongnu.org; Wed, 08 Oct 2008 14:59:36 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KneFz-0006NC-BU
	for axiom-developer@nongnu.org; Wed, 08 Oct 2008 14:59:35 -0400
Received: from [199.232.76.173] (port=49647 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KneFz-0006N5-5R
	for axiom-developer@nongnu.org; Wed, 08 Oct 2008 14:59:35 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:38409
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KneFy-00082T-N4
	for axiom-developer@nongnu.org; Wed, 08 Oct 2008 14:59:34 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m98IxUr3009100;
	Wed, 8 Oct 2008 13:59:30 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m98IxURs009097;
	Wed, 8 Oct 2008 13:59:30 -0500
Date: Wed, 8 Oct 2008 13:59:30 -0500
Message-Id: <200810081859.m98IxURs009097@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 
	20081007.01.tpd.patch (bookvol10.2 add categories, update ATTREG)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 08 Oct 2008 18:59:37 -0000

Add categories to bookvol10.2, update ATTREG 
  RadicalCategory
  RealConstant
  CachableSet
  FreeModuleCat
  XAlgebra
  XFreeAlgebra
  LieAlgebra
  XPolynomialsCat
  FreeLieAlgebra
  RealNumberSystem
  FloatingPointSystem

See:
<http://axiom-developer.org/axiom-website/patches.html>



From MAILER-DAEMON Thu Oct 09 02:13:33 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KnomD-0004HX-9R
	for mharc-axiom-developer@gnu.org; Thu, 09 Oct 2008 02:13:33 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KnomB-0004F7-UW
	for axiom-developer@nongnu.org; Thu, 09 Oct 2008 02:13:31 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Knom8-0004EY-RG
	for axiom-developer@nongnu.org; Thu, 09 Oct 2008 02:13:31 -0400
Received: from [199.232.76.173] (port=45266 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Knom8-0004EV-M1
	for axiom-developer@nongnu.org; Thu, 09 Oct 2008 02:13:28 -0400
Received: from matrix.start.ca ([204.101.248.1]:54355)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <wilsons@start.ca>) id 1Knom7-00053D-Sx
	for axiom-developer@nongnu.org; Thu, 09 Oct 2008 02:13:28 -0400
Received: from lattice.localdomain (pool3-012.adsl.user.start.ca
	[207.61.212.12])
	by matrix.start.ca (8.13.6/8.12.11) with ESMTP id m996DMl0022165;
	Thu, 9 Oct 2008 02:13:22 -0400
To: daly@axiom-developer.org
Subject: Re: [Axiom-developer] Re: Some code, if you are interested.
References: <873ajlmh9x.fsf@lattice.localdomain>
	<87prmml4h8.fsf@lattice.localdomain>
	<200810060549.m965nta13755@localhost.localdomain>
From: Stephen Wilson <wilsons@start.ca>
Date: Thu, 09 Oct 2008 02:13:18 -0400
In-Reply-To: <200810060549.m965nta13755@localhost.localdomain> (root's message
	of "Mon\, 6 Oct 2008 01\:49\:55 -0400")
Message-ID: <87vdw2i9dt.fsf@lattice.localdomain>
User-Agent: Gnus/5.11 (Gnus v5.11) Emacs/22.2 (gnu/linux)
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.4-2.6
Cc: axiom-developer@nongnu.org
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Thu, 09 Oct 2008 06:13:32 -0000

root <daly@axiom-developer.org> writes:
> I strongly recommend reviewing the clojure for lisp videos by Bill Hickey. I
> think he has some fundamentally useful ideas for exploiting parallelism which
> could be reflected into Axiom.

Just finished watching the videos.  Great talker, great ideas.

Of course now I need to sit down with Clojure and experiment.


A thread or concurrent domain could be written using any number of primitives
various lisps offer (posix thread model on SBCL, fork/waitpid model in GCL,
etc).

In many ways using the fork/waitpid model smooths away some of the headaches
having mutable data can bring since the child always gets a copy of the heap and
stack.


Sometime soon I should find the time to implement a simple thread domain using
my little compiler to see what happens.  I kept concurrency in mind when I was
writing the thing so the system should (I hope) work in a mutithreaded world --
there are only a few points of possible contention as far as the runtime is
concerned.

We could implement a traditional mutex/condition-var model and see how it
"feels" (probably just the same as it does everywhere else).  And since, at this
time, the system has no library and only one destructive primitive (which could
be trivially removed) we could implement Hickey's functional datatypes and
explore the methods needed to get STM.

I would not go so far to say the above would be easy, but it might be a
comparatively expedient way to help understand concurrency in the context of a
spad-like language and to grow familiar with the implementation details.

Steve



From MAILER-DAEMON Thu Oct 09 03:15:58 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Knpkc-0007pS-Ay
	for mharc-axiom-developer@gnu.org; Thu, 09 Oct 2008 03:15:58 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Knpka-0007p4-Bg
	for axiom-developer@nongnu.org; Thu, 09 Oct 2008 03:15:56 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KnpkY-0007ok-KW
	for axiom-developer@nongnu.org; Thu, 09 Oct 2008 03:15:55 -0400
Received: from [199.232.76.173] (port=44523 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KnpkY-0007oh-Eu
	for axiom-developer@nongnu.org; Thu, 09 Oct 2008 03:15:54 -0400
Received: from mx20.gnu.org ([199.232.41.8]:20888)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <daly@axiom-developer.org>)
	id 1KnpkY-0005rZ-1h
	for axiom-developer@nongnu.org; Thu, 09 Oct 2008 03:15:54 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]
	helo=axiom-developer.org) by mx20.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KnpkX-0005Tc-Bs
	for axiom-developer@nongnu.org; Thu, 09 Oct 2008 03:15:53 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m997Fnr3025139;
	Thu, 9 Oct 2008 02:15:49 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m997Fnxn025136;
	Thu, 9 Oct 2008 02:15:49 -0500
Date: Thu, 9 Oct 2008 02:15:49 -0500
Message-Id: <200810090715.m997Fnxn025136@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by mx20.gnu.org: Linux 2.6? (barebone, rare!)
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6,
	seldom 2.4 (older, 4)
Cc: 
Subject: [Axiom-developer] 20081008.01.tpd.patch (bookvol10.2 add ACF,
	fix MONOGEN, FFCAT)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Thu, 09 Oct 2008 07:15:56 -0000

MONOGEN and FFCAT now have all the required supporting categories.
ACF has been added.

See
<http://axiom-developer.org/axiom-website/patches.html#latest>



From MAILER-DAEMON Thu Oct 09 03:17:36 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KnpmC-00089D-3U
	for mharc-axiom-developer@gnu.org; Thu, 09 Oct 2008 03:17:36 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Knpm9-00088M-Vr
	for axiom-developer@nongnu.org; Thu, 09 Oct 2008 03:17:34 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Knpm9-000883-FJ
	for axiom-developer@nongnu.org; Thu, 09 Oct 2008 03:17:33 -0400
Received: from [199.232.76.173] (port=44537 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Knpm9-00087x-AE
	for axiom-developer@nongnu.org; Thu, 09 Oct 2008 03:17:33 -0400
Received: from mx20.gnu.org ([199.232.41.8]:21000)
	by monty-python.gnu.org with esmtps (TLS-1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.60) (envelope-from <daly@axiom-developer.org>)
	id 1Knpm8-00061e-W6
	for axiom-developer@nongnu.org; Thu, 09 Oct 2008 03:17:33 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]
	helo=axiom-developer.org) by mx20.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Knpm8-0005c0-Bo
	for axiom-developer@nongnu.org; Thu, 09 Oct 2008 03:17:32 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m997HTr3025320;
	Thu, 9 Oct 2008 02:17:29 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m997HT9C025317;
	Thu, 9 Oct 2008 02:17:29 -0500
Date: Thu, 9 Oct 2008 02:17:29 -0500
Message-Id: <200810090717.m997HT9C025317@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-kernel: by mx20.gnu.org: Linux 2.6? (barebone, rare!)
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: 
Subject: [Axiom-developer] status
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Thu, 09 Oct 2008 07:17:34 -0000

I will be on the road until tuesday 10/14 with uncertain net access.
Rumor has it that git allows disconnected development so we will see.

Tim



From MAILER-DAEMON Mon Oct 13 09:09:59 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KpNBO-0004Af-Ua
	for mharc-axiom-developer@gnu.org; Mon, 13 Oct 2008 09:09:58 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KpNBM-00046z-Qz
	for axiom-developer@nongnu.org; Mon, 13 Oct 2008 09:09:56 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KpNBL-00043p-0m
	for axiom-developer@nongnu.org; Mon, 13 Oct 2008 09:09:55 -0400
Received: from [199.232.76.173] (port=49446 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KpNBK-00043O-OO
	for axiom-developer@nongnu.org; Mon, 13 Oct 2008 09:09:54 -0400
Received: from ns.fbk.eu ([217.77.80.3]:56813 helo=lancelot.fbk.eu)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <brunelli@fbk.eu>) id 1KpNBK-0008SO-D4
	for axiom-developer@nongnu.org; Mon, 13 Oct 2008 09:09:54 -0400
X-AuditID: d94d5003-aaa14bb000000668-06-48f3489fae95
Message-ID: <48F3489D.1010101@fbk.eu>
Date: Mon, 13 Oct 2008 15:09:49 +0200
From: Roberto Brunelli <brunelli@fbk.eu>
User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US;
	rv:1.8.0.7) Gecko/20060910 SeaMonkey/1.0.5
MIME-Version: 1.0
To: axiom-developer@nongnu.org
Content-Type: text/plain; charset="ISO-8859-1"; format=flowed
Content-Transfer-Encoding: 7bit
X-Brightmail-Tracker: AAAAAA==
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Subject: [Axiom-developer] Slackware building of axiom-sept2008-src.tgz
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 13 Oct 2008 13:09:57 -0000

Dear you all,

I'm trying to build from sources (using a generic linux selector for system in the 
building process) on a Slackware12 box (dual core 2 machine). I reach the regression
stage but I get many FAILED results.

Any hint on what I am doing wrong?

Thanks a lot,

-- 
	<r/>
| Roberto Brunelli - [scientist at  Fondazione Bruno Kessler]
|         'Home can be anywhere, for it is a part of one's self'





From MAILER-DAEMON Tue Oct 14 11:55:14 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KpmEr-0003p3-W9
	for mharc-axiom-developer@gnu.org; Tue, 14 Oct 2008 11:55:14 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KpmEp-0003oR-Rl
	for axiom-developer@nongnu.org; Tue, 14 Oct 2008 11:55:11 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KpmEj-0003lQ-KM
	for axiom-developer@nongnu.org; Tue, 14 Oct 2008 11:55:10 -0400
Received: from [199.232.76.173] (port=59561 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KpmEj-0003lF-Fs
	for axiom-developer@nongnu.org; Tue, 14 Oct 2008 11:55:05 -0400
Received: from mx-7.zoominternet.net ([24.154.1.26]:51598
	helo=cm-1.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KpmEj-0006dn-3L
	for axiom-developer@nongnu.org; Tue, 14 Oct 2008 11:55:05 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=c3h-_OtzWfUA:10 a=ymN5Jxk3sjEA:10
	a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=6H8EXPRMKkYLXOvvCV8A:9 a=Nnzth1xDl1ZRwUVePBTix5scxeAA:4
	a=Dqp-bWOt5EsA:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.44] ([24.154.1.44:38733] helo=pop-1.zoominternet.net)
	by mx-7.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id DE/00-30003-AB0C4F84; Tue, 14 Oct 2008 11:54:34 -0400
Received: (qmail 3163 invoked from network); 14 Oct 2008 15:54:39 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-1.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <axiom-developer@nongnu.org>; 14 Oct 2008 15:54:39 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id m9EFtDQ26622;
	Tue, 14 Oct 2008 11:55:13 -0400
Date: Tue, 14 Oct 2008 11:55:13 -0400
Message-Id: <200810141555.m9EFtDQ26622@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: brunelli@fbk.eu
In-reply-to: <48F3489D.1010101@fbk.eu> (message from Roberto Brunelli on Mon, 
	13 Oct 2008 15:09:49 +0200)
Subject: Re: [Axiom-developer] Slackware building of axiom-sept2008-src.tgz
References: <48F3489D.1010101@fbk.eu>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 14 Oct 2008 15:55:12 -0000

Roberto,

Sorry, just got back online and saw your email.

What exactly is the failure you see?

Can you tell me where you got your slackware distro?
What version is it? I'll set up a virtual machine and do a build.

Tim



From MAILER-DAEMON Wed Oct 15 09:03:44 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Kq62S-0006yd-6R
	for mharc-axiom-developer@gnu.org; Wed, 15 Oct 2008 09:03:44 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Kq62P-0006y8-86
	for axiom-developer@nongnu.org; Wed, 15 Oct 2008 09:03:41 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Kq62O-0006xr-5R
	for axiom-developer@nongnu.org; Wed, 15 Oct 2008 09:03:40 -0400
Received: from [199.232.76.173] (port=34137 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Kq62O-0006xo-26
	for axiom-developer@nongnu.org; Wed, 15 Oct 2008 09:03:40 -0400
Received: from ns.fbk.eu ([217.77.80.3]:41069 helo=lancelot.fbk.eu)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <brunelli@fbk.eu>) id 1Kq62M-0005Qq-Jd
	for axiom-developer@nongnu.org; Wed, 15 Oct 2008 09:03:39 -0400
X-AuditID: d94d5003-abe16bb000000668-95-48f5ea272542
Message-ID: <48F5EA26.8090002@fbk.eu>
Date: Wed, 15 Oct 2008 15:03:34 +0200
From: Roberto Brunelli <brunelli@fbk.eu>
User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US;
	rv:1.8.0.7) Gecko/20060910 SeaMonkey/1.0.5
MIME-Version: 1.0
To: "daly@axiom-developer.org" <daly@axiom-developer.org>
Subject: Re: [Axiom-developer] Slackware building of axiom-sept2008-src.tgz
References: <48F3489D.1010101@fbk.eu>
	<200810141555.m9EFtDQ26622@localhost.localdomain>
In-Reply-To: <200810141555.m9EFtDQ26622@localhost.localdomain>
Content-Type: text/plain; charset="ISO-8859-1"; format=flowed
Content-Transfer-Encoding: 7bit
X-Brightmail-Tracker: AAAAAA==
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: "axiom-developer@nongnu.org" <axiom-developer@nongnu.org>
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 15 Oct 2008 13:03:41 -0000

Tim,

root wrote:
> Roberto,
> 
> Sorry, just got back online and saw your email.
> 
> What exactly is the failure you see?
> 
I append  some system info, the names of the regression files containing
MISMATCHes and some sample lines from DoubleFloat and gamma.

> Can you tell me where you got your slackware distro?

It's a Slackware 12 distribution (I do not remember the site I downloaded it from).
I recompiled the kernel and it uses gcc 4.1.2 (should be the distro default)

> What version is it? I'll set up a virtual machine and do a build.
> 
> Tim
> 

Linux pariah 2.6.21.5-rb-smp #1 SMP PREEMPT Sat Dec 1 16:01:33 CET 2007
i686 Intel(R) Core(TM)2 Duo CPU     T7500  @ 2.20GHz GenuineIntel GNU/Linux

Slackware 12

gcc (GCC) 4.1.2

Files reporting MISMATCH

DoubleFloat.regress
FileName.regress
TextFile.regress
constant.regress
dfloat.regress
e1.regress
easter.regress
ei.regress
elemnum.regress
en.regress
fname.regress
fname1.regress
gamma.regress
grpthry.regress
ico.regress
is.regress
kamke3.regress
r20bugs.regress
repa6.regress
textfile.regress

Examples:

From_DoubleFloat____________________________________________________
(1) -> testing DoubleFloat
passed DoubleFloat  1 of 10
passed DoubleFloat  2 of 10
MISMATCH
expected:"   (3)  2.71828"
      got:"   (3)  2.7182799999999996"
FAILED DoubleFloat  3 of 10
MISMATCH
expected:"   (4)  2.71828"
      got:"   (4)  2.7182799999999996"
FAILED DoubleFloat  4 of 10
passed DoubleFloat  5 of 10
passed DoubleFloat  6 of 10
passed DoubleFloat  7 of 10
passed DoubleFloat  8 of 10
passed DoubleFloat  9 of 10
passed DoubleFloat  10 of 10
regression result FAILED 2 of 10 stanzas file DoubleFloat
Value = NIL
(1) ->

From__gamma___________________________________________________________

MISMATCH
expected:"   (12)"
      got:"      - 8.1977805654074309E-3 - 5.7322940416723464E-2 %i,"
MISMATCH
expected:""
      got:"      - 8.1977805649999999E-3 - 5.7322940417E-2 %i,"
MISMATCH
expected:"      DoubleFloat "
      got:"     [1. + 9.9999999999999992E-2 %i,"
MISMATCH
expected:"   Compiling function lng2 with type Complex DoubleFloat -> Complex "
      got:""
MISMATCH
expected:" "
      got:"   [[1.,0.,0.,0.],"
FAILED gamma  12 of 12
regression result FAILED 4 of 12 stanzas file gamma
Value = NIL

-- 
	<r/>
| Roberto Brunelli - [scientist at  Fondazione Bruno Kessler]
|         'Home can be anywhere, for it is a part of one's self'





From MAILER-DAEMON Wed Oct 15 12:52:44 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Kq9c4-0001oQ-N6
	for mharc-axiom-developer@gnu.org; Wed, 15 Oct 2008 12:52:44 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Kq9c3-0001nb-QO
	for axiom-developer@nongnu.org; Wed, 15 Oct 2008 12:52:43 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Kq9c1-0001nO-8P
	for axiom-developer@nongnu.org; Wed, 15 Oct 2008 12:52:42 -0400
Received: from [199.232.76.173] (port=50094 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Kq9c1-0001nL-5b
	for axiom-developer@nongnu.org; Wed, 15 Oct 2008 12:52:41 -0400
Received: from mx-8.zoominternet.net ([24.154.1.27]:50728
	helo=cm-2.zoominternet.net)
	by monty-python.gnu.org with esmtp (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Kq9c0-0004Ly-Qf
	for axiom-developer@nongnu.org; Wed, 15 Oct 2008 12:52:40 -0400
X-SpamGroup: 2000
X-CM-Cat: Undefined:Undefined
X-CNFS-Analysis: v=1.0 c=1 a=c3h-_OtzWfUA:10 a=ymN5Jxk3sjEA:10
	a=E8rTNAPPKTgA:10 a=9x1qJYSYWOoMgoVr+WVG7Q==:17
	a=pRNi4hHtJW3D6aZJc7UA:9 a=9hvb4g9GtLToPUM-QERr4FoIYZ8A:4
	a=XF7b4UCPwd8A:10
X-CM-Score: 0
X-Scanned-by: Cloudmark Authority Engine
Received: from [24.154.1.47] ([24.154.1.47:53918] helo=pop-4.zoominternet.net)
	by mx-8.zoominternet.net (envelope-from <daly@axiom-developer.org>)
	(ecelerity 2.2.2.30 r(24168)) with ESMTP
	id 43/C2-28305-CBF16F84; Wed, 15 Oct 2008 12:52:12 -0400
Received: (qmail 4703 invoked from network); 15 Oct 2008 16:52:16 -0000
Received: from unknown (HELO localhost.localdomain) ([72.23.19.139])
	(envelope-sender <daly@axiom-developer.org>)
	by pop-4.zoominternet.net (qmail-ldap-1.03) with SMTP
	for <daly@axiom-developer.org>; 15 Oct 2008 16:52:16 -0000
Received: (from root@localhost)
	by localhost.localdomain (8.11.6/8.11.6) id m9FGooV27350;
	Wed, 15 Oct 2008 12:50:50 -0400
Date: Wed, 15 Oct 2008 12:50:50 -0400
Message-Id: <200810151650.m9FGooV27350@localhost.localdomain>
From: root <daly@axiom-developer.org>
To: brunelli@fbk.eu
In-reply-to: <48F5EA26.8090002@fbk.eu> (message from Roberto Brunelli on Wed, 
	15 Oct 2008 15:03:34 +0200)
Subject: Re: [Axiom-developer] Slackware building of axiom-sept2008-src.tgz
References: <48F3489D.1010101@fbk.eu>
	<200810141555.m9EFtDQ26622@localhost.localdomain>
	<48F5EA26.8090002@fbk.eu>
X-detected-operating-system: by monty-python.gnu.org: Genre and OS details not
	recognized.
Cc: axiom-developer@nongnu.org
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
Reply-To: daly@axiom-developer.org
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 15 Oct 2008 16:52:44 -0000

The most likely cause of the mismatches are due to the precision
used in the system numeric libraries. Are any of the failures 
caused by things other than numeric output? The test cases use
a pure string compare so 3.14159 and 3.1415 will be considered
different.

If any of the failures are not caused by numbers please send me
the failing .output file so I can see what went wrong.

Tim



From MAILER-DAEMON Sat Oct 25 12:29:46 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Ktm1K-00027g-7L
	for mharc-axiom-developer@gnu.org; Sat, 25 Oct 2008 12:29:46 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Ktm1I-00027H-D9
	for axiom-developer@nongnu.org; Sat, 25 Oct 2008 12:29:44 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Ktm1F-000275-S0
	for axiom-developer@nongnu.org; Sat, 25 Oct 2008 12:29:42 -0400
Received: from [199.232.76.173] (port=58005 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Ktm1F-000272-Mh
	for axiom-developer@nongnu.org; Sat, 25 Oct 2008 12:29:41 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:38639
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Ktm1F-0002u0-JW
	for axiom-developer@nongnu.org; Sat, 25 Oct 2008 12:29:41 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m9PGTcr3029676;
	Sat, 25 Oct 2008 11:29:38 -0500
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m9PGTcGS029673;
	Sat, 25 Oct 2008 11:29:38 -0500
Date: Sat, 25 Oct 2008 11:29:38 -0500
Message-Id: <200810251629.m9PGTcGS029673@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20081023.01.tpd.patch (bookvol10.2 add categories)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Sat, 25 Oct 2008 16:29:44 -0000

Add these categories to bookvol10.2:
  CombinatorialOpsCategory
  DifferentialVariableCategory
  ExpressionSpace
  FiniteDivisorCategory
  DifferentialPolynomialCategory
  QuotientFieldCategory

See:
<http://axiom-developer.org/axiom-website/patches.html#latest>

Tim



From MAILER-DAEMON Mon Oct 27 10:46:41 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KuTMf-00084J-A3
	for mharc-axiom-developer@gnu.org; Mon, 27 Oct 2008 10:46:41 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KuTMd-00083x-CH
	for axiom-developer@nongnu.org; Mon, 27 Oct 2008 10:46:39 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KuTMa-00083Z-3L
	for axiom-developer@nongnu.org; Mon, 27 Oct 2008 10:46:38 -0400
Received: from [199.232.76.173] (port=38546 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KuTMZ-00083W-UM
	for axiom-developer@nongnu.org; Mon, 27 Oct 2008 10:46:35 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:46984
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KuTMZ-0006xc-OQ
	for axiom-developer@nongnu.org; Mon, 27 Oct 2008 10:46:35 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m9REkWr3013437;
	Mon, 27 Oct 2008 08:46:33 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m9REkWFY013434;
	Mon, 27 Oct 2008 08:46:32 -0600
Date: Mon, 27 Oct 2008 08:46:32 -0600
Message-Id: <200810271446.m9REkWFY013434@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20081026.01.tpd.patch (bookvol10.2 add categories)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Mon, 27 Oct 2008 14:46:39 -0000

Add
  IndexedDirectProductCategory
  FreeAbelianMonoidCategory
  IntervalCategory
  FunctionSpace
to bookvol10.2

See <http://axiom-developer.org/axiom-website/20081026.01.tpd.patch>

Tim



From MAILER-DAEMON Tue Oct 28 16:58:35 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Kuve6-0000kZ-Pq
	for mharc-axiom-developer@gnu.org; Tue, 28 Oct 2008 16:58:34 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Kuve4-0000i8-F4
	for axiom-developer@nongnu.org; Tue, 28 Oct 2008 16:58:32 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Kuve2-0000fg-GX
	for axiom-developer@nongnu.org; Tue, 28 Oct 2008 16:58:31 -0400
Received: from [199.232.76.173] (port=44554 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Kuve2-0000f5-7H
	for axiom-developer@nongnu.org; Tue, 28 Oct 2008 16:58:30 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:51097
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Kuve1-0007yk-UH
	for axiom-developer@nongnu.org; Tue, 28 Oct 2008 16:58:30 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m9SKwMr3005786;
	Tue, 28 Oct 2008 14:58:22 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m9SKwMJg005783;
	Tue, 28 Oct 2008 14:58:22 -0600
Date: Tue, 28 Oct 2008 14:58:22 -0600
Message-Id: <200810282058.m9SKwMJg005783@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20081027.01.tpd.patch (add sae.input regression
	test)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Tue, 28 Oct 2008 20:58:32 -0000

Add SAE regression test from example by Waldek Hebisch
===================================================================
diff --git a/changelog b/changelog
index 56e625a..08229c9 100644
--- a/changelog
+++ b/changelog
@@ -1,3 +1,5 @@
+20081027 tpd src/input/Makefile add SAE example
+20081027 tpd src/input/sae.input add SAE example
 20081026 tpd books/bookvol10.2 add categories	
 20081026 tpd books/ps/v102functionspace.ps added
 20081026 tpd ps/v102intervalcategory.ps added
diff --git a/src/input/Makefile.pamphlet b/src/input/Makefile.pamphlet
index 93c2ee7..8f1549b 100644
--- a/src/input/Makefile.pamphlet
+++ b/src/input/Makefile.pamphlet
@@ -350,6 +350,7 @@ REGRES= algaggr.regress algbrbf.regress  algfacob.regress alist.regress  \
     realclos.regress  reclos.regress   regset.regress \
     repa6.regress     robidoux.regress \
     roman.regress     roots.regress    ruleset.regress  rules.regress \
+    sae.regress \
     schaum1.regress   schaum2.regress  schaum3.regress  schaum4.regress \
     schaum5.regress   schaum6.regress  schaum7.regress  schaum8.regress \
     schaum9.regress   schaum10.regress schaum11.regress schaum12.regress \
@@ -637,7 +638,8 @@ FILES= ${OUT}/algaggr.input  ${OUT}/algbrbf.input    ${OUT}/algfacob.input \
        ${OUT}/radff.input    ${OUT}/radix.input      ${OUT}/realclos.input \
        ${OUT}/reclos.input   ${OUT}/regset.input     \
        ${OUT}/robidoux.input ${OUT}/roman.input      ${OUT}/roots.input \
-       ${OUT}/ruleset.input  ${OUT}/rules.input      ${OUT}/schaum1.input \
+       ${OUT}/ruleset.input  ${OUT}/rules.input      ${OUT}/sae.input \
+       ${OUT}/schaum1.input \
        ${OUT}/schaum2.input  ${OUT}/schaum3.input    ${OUT}/schaum4.input \
        ${OUT}/schaum5.input  ${OUT}/schaum6.input    ${OUT}/schaum7.input \
        ${OUT}/schaum8.input  ${OUT}/schaum9.input    ${OUT}/schaum10.input \
@@ -956,6 +958,7 @@ DOCFILES= \
   ${DOC}/robidoux.input.dvi    ${DOC}/roman.input.dvi      \
   ${DOC}/romnum.as.dvi         ${DOC}/roots.input.dvi      \
   ${DOC}/ruleset.input.dvi     ${DOC}/rules.input.dvi      \
+  ${DOC}/sae.input.dvi \
   ${DOC}/schaum1.input.dvi     ${DOC}/schaum2.input.dvi \
   ${DOC}/schaum3.input.dvi     ${DOC}/schaum4.input.dvi \
   ${DOC}/schaum5.input.dvi     ${DOC}/schaum6.input.dvi \
diff --git a/src/input/sae.input.pamphlet b/src/input/sae.input.pamphlet
new file mode 100644
index 0000000..b720cce
--- /dev/null
+++ b/src/input/sae.input.pamphlet
@@ -0,0 +1,84 @@
+\documentclass{article}
+\usepackage{axiom}
+\begin{document}
+\title{\$SPAD/src/input sae.input}
+\author{Waldek Hebisch}
+\maketitle
+\begin{abstract}
+\end{abstract}
+\eject
+\tableofcontents
+\eject
+<<*>>=
+)spool sae.output
+)set message test on
+)set message auto off
+)clear all
+ 
+--S 1 of 6
+pol1:=x^2+1
+--R
+--R         2
+--R   (1)  x  + 1
+--R                                                     Type: Polynomial Integer
+--E 1
+
+--S 2 of 6
+pol2:=z^3-2
+--R
+--R         3
+--R   (2)  z  - 2
+--R                                                     Type: Polynomial Integer
+--E 2
+
+--S 3 of 6
+primrec:=primitiveElement([pol1,pol2],[x,z])$PrimitiveElement(FRAC(INT))
+--R
+--R   (3)
+--R   [coef= [- 3,- 1],
+--R
+--R     poly =
+--R            2   5     1   4    20  3    13   2   2431      91
+--R       [- ---- ?  - ---- ?  - --- ?  - ---- ?  - ---- ? + ---,
+--R          1293      7758      431      1293      3879     862
+--R         2   5     1   4    60  3    13  2   1138     273
+--R        --- ?  + ---- ?  + --- ?  + --- ?  + ---- ? - ---]
+--R        431      2586      431      431      1293     862
+--R     ,
+--R           6      4     3       2
+--R    prim= ?  + 27?  + 4?  + 243?  - 108? + 733]
+--RType: Record(coef: List Integer,poly: List SparseUnivariatePolynomial Fraction Integer,prim: SparseUnivariatePolynomial Fraction Integer)
+--E 3
+
+--S 4 of 6
+Ae:=SAE(FRAC(INT),SparseUnivariatePolynomial(FRAC(INT)),primrec.prim)
+--R
+--R   (4)
+--R  SimpleAlgebraicExtension(Fraction Integer,SparseUnivariatePolynomial Fraction
+--R   Integer,?**6+27*?**4+4*?**3+243*?*?+(-108*?)+733)
+--R                                                                 Type: Domain
+--E 4
+
+--S 5 of 6
+(primrec.poly.1::Ae)^2
+--R
+--R   (5)  - 1
+--RType: SimpleAlgebraicExtension(Fraction Integer,SparseUnivariatePolynomial Fraction Integer,?**6+27*?**4+4*?**3+243*?*?+(-108*?)+733)
+--E 5
+
+--S 6 of 6
+(primrec.poly.2::Ae)^3
+--R
+--R   (6)  2
+--RType: SimpleAlgebraicExtension(Fraction Integer,SparseUnivariatePolynomial Fraction Integer,?**6+27*?**4+4*?**3+243*?*?+(-108*?)+733)
+--E 6
+
+)spool 
+)lisp (bye)
+ 
+@
+\eject
+\begin{thebibliography}{99}
+\bibitem{1} nothing
+\end{thebibliography}
+\end{document}



From MAILER-DAEMON Wed Oct 29 04:32:00 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1Kv6T9-0004vZ-Lb
	for mharc-axiom-developer@gnu.org; Wed, 29 Oct 2008 04:31:59 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1Kv6T7-0004vI-MJ
	for axiom-developer@nongnu.org; Wed, 29 Oct 2008 04:31:57 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1Kv6T5-0004uu-41
	for axiom-developer@nongnu.org; Wed, 29 Oct 2008 04:31:56 -0400
Received: from [199.232.76.173] (port=54488 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1Kv6T4-0004ug-T0
	for axiom-developer@nongnu.org; Wed, 29 Oct 2008 04:31:54 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:58202
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1Kv6T3-000663-VP
	for axiom-developer@nongnu.org; Wed, 29 Oct 2008 04:31:54 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m9T8Vnr3024607;
	Wed, 29 Oct 2008 02:31:49 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m9T8Vlb4024594;
	Wed, 29 Oct 2008 02:31:47 -0600
Date: Wed, 29 Oct 2008 02:31:47 -0600
Message-Id: <200810290831.m9T8Vlb4024594@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] Axiom on a thumb drive
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 29 Oct 2008 08:31:58 -0000

Axiom runs from a thumb drive. This is really trivial. 
It took about 1/2 hour from start to finish and now I have
a complete copy of Axiom, runnable on most machines, in my pocket.

Eventually I'll figure out how to build thumb images directly
so Axiom is native and these steps are not needed.

0) plug in a USB stick with sufficient space (see footnote 0)
1) visit https://fedorahosted.org/liveusb-creator
2) download liveusb-creator-2.7.zip (see footnote 1)
3) unzip liveusb-creator-2.7.zip 
4) cd liveusb-creator-2.7
5) liveusb-creator-2.7.exe
6) set up about 500M (I used 1G) of "persistant overlay"
7) hit enter
8) when the process completes "safely remove the USB stick"

You need to follow this process once:

0) boot your computer and hit the PF key
1) boot fedora 9
------  (get axiom image) -----
2) start firefox
3) visit http://axiom-developer.org/axiom-website/download.html
4) download the fedora9 binary (see footnote 2)
5) cd /home/fedora/Download
6) tar -zxf axiom-fedora9-sept2008-bin.tgz

The thumb drive remembers Axiom but not the fedora breakage.
You'll need to do this each time, unfortunately.
You could put these steps in a shell script

------ (fix fedora breakage as root) ------
0) start an xterm
1) su -
2) echo 0 >/proc/sys/kernel/exec-shield
3) echo 0 >/proc/sys/kernel/randomize_va_space
4) exit
------ (set up axiom) ------
5) cd axiom
6) export AXIOM=`pwd`/mnt/fedora9
7) export PATH=$AXIOM/bin:$PATH
------ (run axiom) ------
8) axiom



footnote 0: you don't need to erase your files. they will not be harmed.
    I used an 8 Gig stick and made a 1G "overlay area" but you can use
    much less. Axiom uses about 230 Megs and can be made smaller by 
    deleting pdfs, etc.

footnote 1: if you have wget you can do:
    wget https://fedorahosted.org/releases/l/i/liveusb-creator/liveusb-creator-2.7.zip 

footnote 2: by default the fedora install puts the firefox downloads into
 /home/fedora/Download



From MAILER-DAEMON Wed Oct 29 18:23:41 2008
Received: from mailman by lists.gnu.org with archive (Exim 4.43)
	id 1KvJS1-0002Tp-4u
	for mharc-axiom-developer@gnu.org; Wed, 29 Oct 2008 18:23:41 -0400
Received: from mailman by lists.gnu.org with tmda-scanned (Exim 4.43)
	id 1KvJRy-0002SS-0e
	for axiom-developer@nongnu.org; Wed, 29 Oct 2008 18:23:38 -0400
Received: from exim by lists.gnu.org with spam-scanned (Exim 4.43)
	id 1KvJRw-0002R0-Og
	for axiom-developer@nongnu.org; Wed, 29 Oct 2008 18:23:37 -0400
Received: from [199.232.76.173] (port=54495 helo=monty-python.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.43) id 1KvJRw-0002Qq-JK
	for axiom-developer@nongnu.org; Wed, 29 Oct 2008 18:23:36 -0400
Received: from vs338.rosehosting.com ([209.135.140.38]:59665
	helo=axiom-developer.org) by monty-python.gnu.org with esmtps
	(TLS-1.0:DHE_RSA_AES_256_CBC_SHA1:32) (Exim 4.60)
	(envelope-from <daly@axiom-developer.org>) id 1KvJRw-00051s-70
	for axiom-developer@nongnu.org; Wed, 29 Oct 2008 18:23:36 -0400
Received: from axiom-developer.org (lincoln.rosehosting.com [127.0.0.1])
	by axiom-developer.org (8.12.8/8.12.8) with ESMTP id m9TMNWr3020695;
	Wed, 29 Oct 2008 16:23:32 -0600
From: daly@axiom-developer.org
Received: (from daly@localhost)
	by axiom-developer.org (8.12.8/8.12.8/Submit) id m9TMNURC020686;
	Wed, 29 Oct 2008 16:23:30 -0600
Date: Wed, 29 Oct 2008 16:23:30 -0600
Message-Id: <200810292223.m9TMNURC020686@axiom-developer.org>
To: axiom-developer@nongnu.org
X-detected-operating-system: by monty-python.gnu.org: GNU/Linux 2.6? (barebone, rare!)
Cc: 
Subject: [Axiom-developer] 20081028.01.tpd.patch (bookvol10.2 add pscat.spad
	categories)
X-BeenThere: axiom-developer@nongnu.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: Axiom Developers <axiom-developer.nongnu.org>
List-Unsubscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>, 
	<mailto:axiom-developer-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.gnu.org/pipermail/axiom-developer>
List-Post: <mailto:axiom-developer@nongnu.org>
List-Help: <mailto:axiom-developer-request@nongnu.org?subject=help>
List-Subscribe: <http://lists.nongnu.org/mailman/listinfo/axiom-developer>,
	<mailto:axiom-developer-request@nongnu.org?subject=subscribe>
X-List-Received-Date: Wed, 29 Oct 2008 22:23:38 -0000

Add these categories from pscat.spad to bookvol10.2
  PowerSeriesCategory
  MultivariateTaylorSeriesCategory
  UnivariatePowerSeriesCategory
  UnivariateTaylorSeriesCategory
  UnivariateLaurentSeriesCategory
  UnivariatePuiseuxSeriesCategory

See <http://axiom-developer.org/axiom-website/patches.html#latest>



